"""
Backlot API Endpoints
Handles AI co-pilot chat, call sheet distribution, and other Backlot-specific functionality
"""
from fastapi import APIRouter, HTTPException, Depends, Header, File, UploadFile, Form, Body, Query, Request
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any, Literal
from datetime import datetime, timezone, timedelta
from app.services.ai_service import get_ai_response
from app.services.email_service import (
    EmailService,
    generate_call_sheet_email_html,
    generate_call_sheet_text
)
from app.services.pdf_service import generate_call_sheet_pdf as create_call_sheet_pdf
from app.services.deal_memo_pdf_service import generate_deal_memo_pdf, generate_signed_deal_memo_pdf

from app.services.breakdown_pdf_service import (
    generate_breakdown_pdf,
    generate_project_breakdown_pdf,
)

# Excel export is optional - only available if openpyxl is installed
try:
    from app.services.excel_service import generate_call_sheet_excel
    EXCEL_EXPORT_AVAILABLE = True
except ImportError:
    EXCEL_EXPORT_AVAILABLE = False
    generate_call_sheet_excel = None
from fastapi.responses import Response
import uuid
import re
import os
import json
import tempfile
import requests
import secrets
import hashlib
from pypdf import PdfReader
from app.core.database import get_client, execute_single, execute_query, execute_insert
from app.core.config import settings
from app.core.storage import upload_file, get_signed_url, generate_unique_filename, BACKLOT_FILES_BUCKET, download_from_s3_uri
from app.core.quota_enforcement import (
    enforce_storage_limit,
    enforce_bandwidth_limit,
    record_bandwidth_usage,
)
from app.socketio_app import get_user_from_token

router = APIRouter()


def generate_signed_url(s3_uri: str, expires_in: int = 86400) -> str:
    """
    Generate a signed URL from an S3 URI.

    Args:
        s3_uri: S3 URI in format s3://bucket/key
        expires_in: URL expiration time in seconds (default 24 hours)

    Returns:
        Signed URL string, or empty string if URI is invalid
    """
    if not s3_uri:
        return ""

    if s3_uri.startswith("s3://"):
        parts = s3_uri[5:].split("/", 1)
        if len(parts) == 2:
            bucket, key = parts
            return get_signed_url(bucket, key, expires_in)

    # If it's already a regular URL or invalid format, return as-is
    return s3_uri


def _get_org_id_for_project(project_id: str) -> Optional[str]:
    """Get organization_id for a project. Returns None if project has no org."""
    row = execute_single(
        "SELECT organization_id FROM backlot_projects WHERE id = :pid",
        {"pid": project_id}
    )
    return str(row["organization_id"]) if row and row.get("organization_id") else None


def _enforce_org_storage(project_id: str, file_size: int = 0):
    """Enforce org-level storage limit for a project. No-op if project has no org."""
    org_id = _get_org_id_for_project(project_id)
    if org_id:
        enforce_storage_limit(org_id, file_size, "active")


def _enforce_org_bandwidth_and_record(
    project_id: str,
    file_size: int,
    user_id: Optional[str] = None,
    event_type: str = "file_download",
    resource_type: Optional[str] = None,
    resource_id: Optional[str] = None,
):
    """Enforce bandwidth limit and record usage. No-op if project has no org."""
    org_id = _get_org_id_for_project(project_id)
    if org_id:
        enforce_bandwidth_limit(org_id, file_size)
        record_bandwidth_usage(
            org_id=org_id,
            bytes_transferred=file_size,
            event_type=event_type,
            project_id=project_id,
            user_id=user_id,
            resource_type=resource_type,
            resource_id=resource_id,
        )


class ChatMessage(BaseModel):
    role: str  # 'user' or 'assistant'
    content: str


class CopilotRequest(BaseModel):
    messages: List[ChatMessage]
    project_context: Optional[Dict[str, Any]] = None


class CopilotResponse(BaseModel):
    response: str
    success: bool = True


@router.post("/copilot/chat", response_model=CopilotResponse)
async def copilot_chat(request: CopilotRequest):
    """
    Send a message to the Backlot AI co-pilot

    Args:
        request: Chat messages and optional project context

    Returns:
        AI response
    """
    try:
        # Convert messages to the format expected by AI service
        messages = [{"role": m.role, "content": m.content} for m in request.messages]

        # Get AI response
        response = await get_ai_response(
            messages=messages,
            project_context=request.project_context
        )

        return CopilotResponse(response=response, success=True)

    except Exception as e:
        print(f"Copilot error: {e}")
        raise HTTPException(
            status_code=500,
            detail="Failed to get AI response. Please try again."
        )


@router.get("/copilot/health")
async def copilot_health():
    """Check if the AI copilot is available"""
    from app.core.config import settings

    has_anthropic = bool(settings.ANTHROPIC_API_KEY)
    has_openai = bool(settings.OPENAI_API_KEY)

    return {
        "available": has_anthropic or has_openai,
        "providers": {
            "anthropic": has_anthropic,
            "openai": has_openai
        },
        "fallback_mode": not (has_anthropic or has_openai)
    }


# =====================================================
# Project CRUD Endpoints
# =====================================================

class ProjectCreateInput(BaseModel):
    """Input for creating a new project"""
    title: str
    logline: Optional[str] = None
    description: Optional[str] = None
    project_type: Optional[str] = None
    genre: Optional[str] = None
    format: Optional[str] = None
    runtime_minutes: Optional[int] = None
    status: Optional[str] = "pre_production"
    visibility: Optional[str] = "private"
    target_start_date: Optional[str] = None
    target_end_date: Optional[str] = None
    cover_image_url: Optional[str] = None
    thumbnail_url: Optional[str] = None


class ProjectUpdateInput(BaseModel):
    """Input for updating a project"""
    title: Optional[str] = None
    logline: Optional[str] = None
    description: Optional[str] = None
    project_type: Optional[str] = None
    genre: Optional[str] = None
    format: Optional[str] = None
    runtime_minutes: Optional[int] = None
    status: Optional[str] = None
    visibility: Optional[str] = None
    target_start_date: Optional[str] = None
    target_end_date: Optional[str] = None
    cover_image_url: Optional[str] = None
    thumbnail_url: Optional[str] = None


class ProjectResponse(BaseModel):
    """Project response with owner info"""
    id: str
    owner_id: str
    title: str
    slug: Optional[str] = None
    logline: Optional[str] = None
    description: Optional[str] = None
    project_type: Optional[str] = None
    genre: Optional[str] = None
    format: Optional[str] = None
    runtime_minutes: Optional[int] = None
    status: Optional[str] = None
    visibility: Optional[str] = None
    target_start_date: Optional[str] = None
    target_end_date: Optional[str] = None
    cover_image_url: Optional[str] = None
    thumbnail_url: Optional[str] = None
    logo_url: Optional[str] = None
    created_at: Optional[str] = None
    updated_at: Optional[str] = None
    owner: Optional[Dict[str, Any]] = None

    class Config:
        extra = "allow"


def get_profile_id_from_cognito_id(cognito_user_id: str) -> str:
    """
    Look up the profile ID from a Cognito user ID.
    Returns the profile ID or raises an exception if not found.
    """
    # Convert to string to ensure proper comparison
    if not cognito_user_id:
        return None
    uid_str = str(cognito_user_id)
    # First try to find by cognito_user_id (preferred)
    profile_row = execute_single(
        "SELECT id FROM profiles WHERE cognito_user_id = :cuid LIMIT 1",
        {"cuid": uid_str}
    )
    if profile_row:
        return str(profile_row["id"])
    # Fallback: check if it's already a profile ID
    profile_row = execute_single(
        "SELECT id FROM profiles WHERE id::text = :uid LIMIT 1",
        {"uid": uid_str}
    )
    if not profile_row:
        return None
    return str(profile_row["id"])


def serialize_project(project: dict) -> dict:
    """
    Convert project data to JSON-serializable format.
    Converts UUIDs and datetimes to strings.
    """
    if not project:
        return project

    result = dict(project)

    # Convert UUID fields to strings
    for field in ["id", "owner_id"]:
        if field in result and result[field] is not None:
            result[field] = str(result[field])

    # Convert datetime fields to ISO strings
    for field in ["created_at", "updated_at", "target_start_date", "target_end_date"]:
        if field in result and result[field] is not None:
            if hasattr(result[field], 'isoformat'):
                result[field] = result[field].isoformat()

    # Serialize owner if present
    if "owner" in result and result["owner"]:
        owner = dict(result["owner"])
        if "id" in owner and owner["id"] is not None:
            owner["id"] = str(owner["id"])
        result["owner"] = owner

    return result


@router.get("/projects", response_model=List[ProjectResponse])
async def list_my_projects(
    status: Optional[str] = None,
    visibility: Optional[str] = None,
    search: Optional[str] = None,
    ownership: Optional[str] = None,  # 'owner', 'member', or 'all' (default)
    limit: int = 50,
    authorization: str = Header(None)
):
    """
    List projects for the current user (owned or member of).

    ownership param:
    - 'owner': Only projects created by the user
    - 'member': Only projects where user is a team member (not owner)
    - 'all' or None: Both owned and member projects
    """
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    try:
        # Look up the profile ID from cognito_user_id
        profile_id = get_profile_id_from_cognito_id(cognito_user_id)

        if not profile_id:
            return []  # No profile = no projects

        # Get projects where user is a member (not owner)
        member_result = client.table("backlot_project_members").select(
            "project_id"
        ).eq("user_id", profile_id).execute()

        member_project_ids = [m["project_id"] for m in (member_result.data or [])]

        # Build query for projects - use raw SQL for OR condition
        conditions = []
        params = {"profile_id": profile_id, "limit": limit}

        # Apply ownership filter
        if ownership == "owner":
            # Only projects the user owns
            conditions.append("owner_id = :profile_id")
        elif ownership == "member":
            # Only projects where user is a member (not owner)
            if not member_project_ids:
                return []  # No memberships = no results for this filter
            placeholders = ",".join([f":id_{i}" for i in range(len(member_project_ids))])
            for i, pid in enumerate(member_project_ids):
                params[f"id_{i}"] = pid
            conditions.append(f"(id IN ({placeholders}) AND owner_id != :profile_id)")
        else:
            # Default: all projects user has access to (owned OR member)
            if member_project_ids:
                placeholders = ",".join([f":id_{i}" for i in range(len(member_project_ids))])
                for i, pid in enumerate(member_project_ids):
                    params[f"id_{i}"] = pid
                conditions.append(f"(owner_id = :profile_id OR id IN ({placeholders}))")
            else:
                conditions.append("owner_id = :profile_id")

        # Apply optional filters
        if status and status != "all":
            conditions.append("status = :status")
            params["status"] = status

        if visibility and visibility != "all":
            conditions.append("visibility = :visibility")
            params["visibility"] = visibility

        if search:
            conditions.append("title ILIKE :search")
            params["search"] = f"%{search}%"

        where_clause = " AND ".join(conditions)
        projects = execute_query(
            f"SELECT * FROM backlot_projects WHERE {where_clause} ORDER BY updated_at DESC LIMIT :limit",
            params
        )

        if not projects:
            return []

        # Fetch owner profiles
        owner_ids = list(set(p["owner_id"] for p in projects))
        profiles_result = client.table("profiles").select(
            "id, username, full_name, display_name, avatar_url, role, is_order_member"
        ).in_("id", owner_ids).execute()

        profile_map = {p["id"]: p for p in (profiles_result.data or [])}

        # Attach owner info and serialize
        for project in projects:
            project["owner"] = profile_map.get(project["owner_id"])

        return [serialize_project(p) for p in projects]

    except Exception as e:
        print(f"Error listing projects: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# PUBLIC PROJECTS ENDPOINT (must come before /projects/{project_id})
# =====================================================

@router.get("/projects/public")
async def list_public_projects(
    status: Optional[str] = None,
    search: Optional[str] = None,
    limit: int = 50,
    authorization: str = Header(None)
):
    """
    List ALL public visibility projects in the system.
    Returns has_access flag indicating if current user is owner/member.
    Auth is optional - anonymous users see all public projects without has_access info.
    """
    client = get_client()

    # Try to get current user (optional auth)
    profile_id = None
    member_project_ids = []

    if authorization and authorization.startswith("Bearer "):
        try:
            token = authorization.replace("Bearer ", "")
            from app.core.cognito import CognitoAuth
            user = CognitoAuth.verify_token(token)
            if user:
                cognito_user_id = user.get("id")
                profile_id = get_profile_id_from_cognito_id(cognito_user_id)

                if profile_id:
                    # Get projects where user is a member
                    member_result = client.table("backlot_project_members").select(
                        "project_id"
                    ).eq("user_id", profile_id).execute()
                    member_project_ids = [m["project_id"] for m in (member_result.data or [])]
        except Exception:
            pass  # Anonymous access is fine

    try:
        # Build query for public projects
        conditions = ["visibility = 'public'"]
        params = {"limit": limit}

        if status and status != "all":
            conditions.append("status = :status")
            params["status"] = status

        if search:
            conditions.append("title ILIKE :search")
            params["search"] = f"%{search}%"

        where_clause = " AND ".join(conditions)
        projects = execute_query(
            f"SELECT * FROM backlot_projects WHERE {where_clause} ORDER BY updated_at DESC LIMIT :limit",
            params
        )

        if not projects:
            return {"projects": []}

        # Fetch owner profiles
        owner_ids = list(set(p["owner_id"] for p in projects))
        profiles_result = client.table("profiles").select(
            "id, username, full_name, display_name, avatar_url, role, is_order_member"
        ).in_("id", owner_ids).execute()

        profile_map = {p["id"]: p for p in (profiles_result.data or [])}

        # Build response with has_access flag
        result = []
        for project in projects:
            project_data = serialize_project(project)
            project_data["owner"] = profile_map.get(project["owner_id"])

            # Determine if current user has access
            if profile_id:
                is_owner = project["owner_id"] == profile_id
                is_member = project["id"] in member_project_ids
                project_data["has_access"] = is_owner or is_member
            else:
                project_data["has_access"] = False

            result.append(project_data)

        return {"projects": result}

    except Exception as e:
        print(f"Error listing public projects: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# DONATION ENDPOINTS (must come before /projects/{project_id})
# =====================================================

# Platform fee for donations (5% by default)
DONATION_PLATFORM_FEE_PERCENT = float(os.getenv("DONATION_PLATFORM_FEE_PERCENT", "5"))


class DonationRequest(BaseModel):
    amount_cents: int
    message: Optional[str] = None
    is_anonymous: bool = False


@router.post("/projects/{project_id}/donate")
async def create_donation_checkout(
    project_id: str,
    request: DonationRequest,
    authorization: str = Header(None)
):
    """
    Create a Stripe checkout session for a one-time donation to a project.
    Returns a checkout URL that redirects the user to Stripe payment.
    """
    from app.core.config import settings
    import stripe

    if not settings.STRIPE_SECRET_KEY:
        raise HTTPException(status_code=500, detail="Stripe not configured")
    stripe.api_key = settings.STRIPE_SECRET_KEY

    # Validate amount
    if request.amount_cents < 100:  # Minimum $1
        raise HTTPException(status_code=400, detail="Minimum donation is $1.00")
    if request.amount_cents > 100000000:  # Maximum $1,000,000
        raise HTTPException(status_code=400, detail="Maximum donation is $1,000,000")

    client = get_client()

    # Get project and verify donations are enabled
    project_result = client.table("backlot_projects").select(
        "id, title, owner_id, visibility, donations_enabled"
    ).eq("id", project_id).single().execute()

    if not project_result.data:
        raise HTTPException(status_code=404, detail="Project not found")

    project = project_result.data

    # Check if donations are enabled for this project
    if not project.get("donations_enabled"):
        raise HTTPException(status_code=400, detail="Donations are not enabled for this project")

    # Get donor info (optional - can donate without logging in)
    donor_profile_id = None
    donor_email = None
    donor_name = None

    if authorization and authorization.startswith("Bearer "):
        try:
            user = await get_user_from_token(authorization)
            if user:
                cognito_user_id = user.get("id")
                donor_profile_id = get_profile_id_from_cognito_id(cognito_user_id)

                if donor_profile_id:
                    profile_result = client.table("profiles").select(
                        "id, email, full_name, display_name"
                    ).eq("id", donor_profile_id).single().execute()
                    if profile_result.data:
                        donor_email = profile_result.data.get("email")
                        donor_name = profile_result.data.get("display_name") or profile_result.data.get("full_name")
        except Exception:
            pass  # Anonymous donation is fine

    # Create the donation record in pending state
    donation_data = {
        "project_id": project_id,
        "donor_id": donor_profile_id,
        "amount_cents": request.amount_cents,
        "currency": "usd",
        "status": "pending",
        "message": request.message,
        "is_anonymous": request.is_anonymous,
        "donor_name": donor_name if not request.is_anonymous else None,
        "donor_email": donor_email,
    }

    donation_result = client.table("project_donations").insert(donation_data).execute()
    if not donation_result.data:
        raise HTTPException(status_code=500, detail="Failed to create donation record")

    donation = donation_result.data[0]
    donation_id = donation["id"]

    # Build URLs
    base_url = settings.FRONTEND_URL
    success_url = f"{base_url}/backlot/public?donation=success&project={project_id}"
    cancel_url = f"{base_url}/backlot/public?donation=cancelled&project={project_id}"

    # Create Stripe checkout session for one-time payment
    try:
        checkout_params = {
            "payment_method_types": ["card"],
            "line_items": [{
                "price_data": {
                    "currency": "usd",
                    "product_data": {
                        "name": f"Donation to {project['title']}",
                        "description": f"Support this project on Second Watch Network",
                    },
                    "unit_amount": request.amount_cents,
                },
                "quantity": 1,
            }],
            "mode": "payment",
            "success_url": success_url,
            "cancel_url": cancel_url,
            "metadata": {
                "donation_id": donation_id,
                "project_id": project_id,
                "type": "project_donation",
            },
        }

        # Add customer email if available
        if donor_email:
            checkout_params["customer_email"] = donor_email

        session = stripe.checkout.Session.create(**checkout_params)

        # Update donation record with checkout session ID
        client.table("project_donations").update({
            "stripe_checkout_session_id": session.id
        }).eq("id", donation_id).execute()

        return {"checkout_url": session.url, "donation_id": donation_id}

    except stripe.error.StripeError as e:
        # Delete the pending donation record on Stripe error
        client.table("project_donations").delete().eq("id", donation_id).execute()
        raise HTTPException(status_code=500, detail=f"Stripe error: {str(e)}")


@router.get("/projects/{project_id}/donations/summary")
async def get_donation_summary(
    project_id: str,
    authorization: str = Header(None)
):
    """
    Get donation summary for a project.
    Public endpoint - anyone can see how much has been raised.
    """
    client = get_client()

    # Verify project exists and is public or user has access
    project_result = client.table("backlot_projects").select(
        "id, title, visibility, donations_enabled, donation_goal_cents, donation_message, owner_id"
    ).eq("id", project_id).single().execute()

    if not project_result.data:
        raise HTTPException(status_code=404, detail="Project not found")

    project = project_result.data

    # Only allow access to public projects or projects user has access to
    if project["visibility"] != "public":
        if not authorization:
            raise HTTPException(status_code=403, detail="Access denied")
        try:
            user = await get_user_from_token(authorization)
            cognito_user_id = user.get("id")
            profile_id = get_profile_id_from_cognito_id(cognito_user_id)

            is_owner = project["owner_id"] == profile_id
            if not is_owner:
                # Check if member
                member_result = client.table("backlot_project_members").select(
                    "id"
                ).eq("project_id", project_id).eq("user_id", profile_id).execute()
                if not member_result.data:
                    raise HTTPException(status_code=403, detail="Access denied")
        except HTTPException:
            raise
        except Exception:
            raise HTTPException(status_code=403, detail="Access denied")

    # Get donation stats - only succeeded donations count
    stats = execute_single("""
        SELECT
            COALESCE(SUM(net_amount_cents), 0) as total_raised_cents,
            COUNT(DISTINCT donor_id) as unique_donor_count,
            COUNT(*) as donation_count
        FROM project_donations
        WHERE project_id = :project_id AND status = 'succeeded'
    """, {"project_id": project_id})

    total_raised = stats["total_raised_cents"] if stats else 0
    donor_count = stats["unique_donor_count"] if stats else 0
    donation_count = stats["donation_count"] if stats else 0

    # Get recent donors (non-anonymous only, last 5)
    recent_donors_result = client.table("project_donations").select(
        "id, donor_name, amount_cents, created_at, is_anonymous"
    ).eq("project_id", project_id).eq(
        "status", "succeeded"
    ).eq("is_anonymous", False).order(
        "created_at", desc=True
    ).limit(5).execute()

    recent_donors = []
    for d in (recent_donors_result.data or []):
        if d.get("donor_name"):
            recent_donors.append({
                "name": d["donor_name"],
                "amount_cents": d["amount_cents"],
                "created_at": d["created_at"],
            })

    # Calculate goal progress if goal is set
    goal_cents = project.get("donation_goal_cents")
    percent_of_goal = None
    if goal_cents and goal_cents > 0:
        percent_of_goal = min(100, round(total_raised / goal_cents * 100, 1))

    return {
        "donations_enabled": project.get("donations_enabled", False),
        "donation_message": project.get("donation_message"),
        "total_raised_cents": total_raised,
        "donor_count": donor_count,
        "donation_count": donation_count,
        "goal_cents": goal_cents,
        "percent_of_goal": percent_of_goal,
        "recent_donors": recent_donors,
    }


@router.get("/projects/{project_id}/donations")
async def list_project_donations(
    project_id: str,
    limit: int = 50,
    authorization: str = Header(None)
):
    """
    List all donations for a project.
    Owner-only endpoint - includes donor info for non-anonymous donations.
    """
    user = await get_user_from_token(authorization)
    cognito_user_id = user.get("id")
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)

    if not profile_id:
        raise HTTPException(status_code=403, detail="Profile not found")

    client = get_client()

    # Verify user is project owner
    project_result = client.table("backlot_projects").select(
        "id, owner_id"
    ).eq("id", project_id).single().execute()

    if not project_result.data:
        raise HTTPException(status_code=404, detail="Project not found")

    if project_result.data["owner_id"] != profile_id:
        raise HTTPException(status_code=403, detail="Only project owner can view donations")

    # Get all donations for this project
    donations_result = client.table("project_donations").select(
        "id, amount_cents, net_amount_cents, platform_fee_cents, currency, status, message, is_anonymous, donor_name, donor_email, created_at, donor_id"
    ).eq("project_id", project_id).order(
        "created_at", desc=True
    ).limit(limit).execute()

    donations = []
    for d in (donations_result.data or []):
        donation_data = {
            "id": d["id"],
            "amount_cents": d["amount_cents"],
            "net_amount_cents": d.get("net_amount_cents"),
            "platform_fee_cents": d.get("platform_fee_cents"),
            "currency": d["currency"],
            "status": d["status"],
            "message": d.get("message"),
            "is_anonymous": d["is_anonymous"],
            "created_at": d["created_at"],
        }

        # Include donor info if not anonymous
        if not d["is_anonymous"]:
            donation_data["donor"] = {
                "id": d.get("donor_id"),
                "name": d.get("donor_name"),
                "email": d.get("donor_email"),
            }

        donations.append(donation_data)

    return {"donations": donations}


@router.patch("/projects/{project_id}/donation-settings")
async def update_donation_settings(
    project_id: str,
    donations_enabled: Optional[bool] = None,
    donation_goal_cents: Optional[int] = None,
    donation_message: Optional[str] = None,
    authorization: str = Header(None)
):
    """
    Update donation settings for a project.
    Owner-only endpoint.
    """
    user = await get_user_from_token(authorization)
    cognito_user_id = user.get("id")
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)

    if not profile_id:
        raise HTTPException(status_code=403, detail="Profile not found")

    client = get_client()

    # Verify user is project owner
    project_result = client.table("backlot_projects").select(
        "id, owner_id"
    ).eq("id", project_id).single().execute()

    if not project_result.data:
        raise HTTPException(status_code=404, detail="Project not found")

    if project_result.data["owner_id"] != profile_id:
        raise HTTPException(status_code=403, detail="Only project owner can update donation settings")

    # Build update data
    update_data = {}
    if donations_enabled is not None:
        update_data["donations_enabled"] = donations_enabled
    if donation_goal_cents is not None:
        if donation_goal_cents < 0:
            raise HTTPException(status_code=400, detail="Goal cannot be negative")
        update_data["donation_goal_cents"] = donation_goal_cents if donation_goal_cents > 0 else None
    if donation_message is not None:
        update_data["donation_message"] = donation_message if donation_message.strip() else None

    if not update_data:
        raise HTTPException(status_code=400, detail="No settings to update")

    # Update project
    result = client.table("backlot_projects").update(update_data).eq("id", project_id).execute()

    if not result.data:
        raise HTTPException(status_code=500, detail="Failed to update settings")

    return {
        "donations_enabled": result.data[0].get("donations_enabled"),
        "donation_goal_cents": result.data[0].get("donation_goal_cents"),
        "donation_message": result.data[0].get("donation_message"),
    }


@router.patch("/projects/{project_id}/settings")
async def update_project_settings(
    project_id: str,
    allow_original_playback: Optional[bool] = None,
    authorization: str = Header(None)
):
    """
    Update project settings (owner-only).

    Settings:
    - allow_original_playback: Allow users to access original quality files (default: false)
    """
    user = await get_user_from_token(authorization)
    cognito_user_id = user.get("id")
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)

    if not profile_id:
        raise HTTPException(status_code=403, detail="Profile not found")

    client = get_client()

    # Verify user is project owner
    project_result = client.table("backlot_projects").select(
        "id, owner_id, settings"
    ).eq("id", project_id).single().execute()

    if not project_result.data:
        raise HTTPException(status_code=404, detail="Project not found")

    if project_result.data["owner_id"] != profile_id:
        raise HTTPException(status_code=403, detail="Only project owner can update project settings")

    # Get current settings
    current_settings = project_result.data.get("settings") or {}

    # Build updated settings
    updated_settings = dict(current_settings)
    if allow_original_playback is not None:
        updated_settings["allow_original_playback"] = allow_original_playback

    # Update project
    result = client.table("backlot_projects").update({
        "settings": updated_settings
    }).eq("id", project_id).execute()

    if not result.data:
        raise HTTPException(status_code=500, detail="Failed to update settings")

    return {
        "settings": result.data[0].get("settings", {}),
    }


@router.get("/projects/{project_id}/settings")
async def get_project_settings(
    project_id: str,
    authorization: str = Header(None)
):
    """
    Get project settings.
    """
    user = await get_user_from_token(authorization)
    cognito_user_id = user.get("id")
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)

    if not profile_id:
        raise HTTPException(status_code=403, detail="Profile not found")

    client = get_client()

    # Get project settings
    project_result = client.table("backlot_projects").select(
        "id, settings"
    ).eq("id", project_id).single().execute()

    if not project_result.data:
        raise HTTPException(status_code=404, detail="Project not found")

    settings = project_result.data.get("settings") or {}

    return {
        "settings": settings,
        "allow_original_playback": settings.get("allow_original_playback", False),
    }


# =====================================================
# COLLAB FORM SEARCH ENDPOINTS (must come before /projects/{project_id})
# =====================================================

@router.get("/projects/search/for-collab")
async def search_projects_for_collab(
    q: Optional[str] = Query(None, description="Search query"),
    limit: int = Query(20, ge=1, le=50),
    authorization: str = Header(None)
):
    """
    Search backlot projects for collab form production selector.

    - No query: Returns only PUBLIC projects (alphabetically)
    - With query: Returns user's OWN projects (any visibility) + PUBLIC projects matching query
    """
    client = get_client()

    try:
        # Get user profile if authenticated
        profile_id = None
        if authorization and authorization.startswith("Bearer "):
            try:
                user = await get_current_user_from_token(authorization)
                cognito_user_id = user["id"]
                profile_id = get_profile_id_from_cognito_id(cognito_user_id)
            except:
                pass  # Continue without auth for public-only results

        if not q or not q.strip():
            # No query: Return only PUBLIC projects, alphabetically
            result = client.table("backlot_projects").select(
                "id, title, project_type, visibility, thumbnail_url, owner_id"
            ).eq("visibility", "public").order("title").limit(limit).execute()

            projects = result.data or []
        else:
            # With query: User's own projects + public projects matching
            search_term = f"%{q.strip()}%"

            if profile_id:
                # Authenticated: Get user's projects (any visibility) + public matching
                projects = execute_query(
                    """
                    SELECT DISTINCT id, title, project_type, visibility, thumbnail_url, owner_id
                    FROM backlot_projects
                    WHERE (owner_id = :profile_id OR visibility = 'public')
                      AND title ILIKE :search
                    ORDER BY
                        CASE WHEN owner_id = :profile_id THEN 0 ELSE 1 END,
                        title
                    LIMIT :limit
                    """,
                    {"profile_id": profile_id, "search": search_term, "limit": limit}
                )
            else:
                # Not authenticated: Only public projects
                result = client.table("backlot_projects").select(
                    "id, title, project_type, visibility, thumbnail_url, owner_id"
                ).eq("visibility", "public").ilike("title", search_term).order("title").limit(limit).execute()

                projects = result.data or []

        # Map title -> name for SearchableCombobox compatibility
        return [
            {
                "id": str(p["id"]),
                "name": p["title"],
                "project_type": p.get("project_type"),
                "visibility": p.get("visibility"),
                "thumbnail_url": p.get("thumbnail_url"),
            }
            for p in projects
        ]

    except Exception as e:
        print(f"Error searching projects for collab: {e}")
        raise HTTPException(status_code=500, detail=str(e))


class QuickCreateInput(BaseModel):
    title: str = Field(..., min_length=1, max_length=200)


@router.post("/projects/quick-create")
async def quick_create_project(
    input: QuickCreateInput,
    authorization: str = Header(...)
):
    """
    Quickly create an unlisted backlot project.
    Used when adding new production from collab form.
    Creates with visibility='unlisted' and status='pre_production'.
    """
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    try:
        profile_id = get_profile_id_from_cognito_id(cognito_user_id)

        if not profile_id:
            raise HTTPException(status_code=404, detail="Profile not found")

        # Generate slug from title
        slug_base = re.sub(r'[^a-z0-9]+', '-', input.title.lower()).strip('-')
        slug = f"{slug_base}-{str(uuid.uuid4())[:8]}"

        # Create minimal project with unlisted visibility
        project_data = {
            "owner_id": profile_id,
            "title": input.title.strip(),
            "slug": slug,
            "status": "pre_production",
            "visibility": "unlisted",
        }

        result = client.table("backlot_projects").insert(project_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create project")

        project = result.data[0]

        # Also add owner as admin member
        client.table("backlot_project_members").insert({
            "project_id": project["id"],
            "user_id": profile_id,
            "role": "admin",
        }).execute()

        # Return in SearchableCombobox format
        return {
            "id": str(project["id"]),
            "name": project["title"],
            "project_type": project.get("project_type"),
            "visibility": project.get("visibility"),
            "thumbnail_url": project.get("thumbnail_url"),
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error quick creating project: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects", response_model=ProjectResponse)
async def create_project(
    project_input: ProjectCreateInput,
    authorization: str = Header(None)
):
    """
    Create a new Backlot project.
    """
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    try:
        # Look up the profile ID from cognito_user_id (FK constraint requires profiles.id)
        profile_id = get_profile_id_from_cognito_id(cognito_user_id)

        if not profile_id:
            raise HTTPException(status_code=404, detail="Profile not found")

        # Generate slug from title
        import re
        slug_base = re.sub(r'[^a-z0-9]+', '-', project_input.title.lower()).strip('-')
        slug = f"{slug_base}-{str(uuid.uuid4())[:8]}"

        # Create project
        project_data = {
            "owner_id": profile_id,
            "title": project_input.title,
            "slug": slug,
            "logline": project_input.logline,
            "description": project_input.description,
            "project_type": project_input.project_type,
            "genre": project_input.genre,
            "format": project_input.format,
            "runtime_minutes": project_input.runtime_minutes,
            "status": project_input.status or "pre_production",
            "visibility": project_input.visibility or "private",
            "target_start_date": project_input.target_start_date,
            "target_end_date": project_input.target_end_date,
            "cover_image_url": project_input.cover_image_url,
            "thumbnail_url": project_input.thumbnail_url,
        }

        result = client.table("backlot_projects").insert(project_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create project")

        project = result.data[0]

        # Add owner as admin member
        try:
            client.table("backlot_project_members").insert({
                "project_id": project["id"],
                "user_id": profile_id,
                "role": "admin",
            }).execute()
        except Exception as e:
            print(f"Failed to add owner as member: {e}")

        # Assign showrunner role
        try:
            client.table("backlot_project_roles").insert({
                "project_id": project["id"],
                "user_id": profile_id,
                "backlot_role": "showrunner",
                "is_primary": True,
            }).execute()
        except Exception as e:
            print(f"Failed to assign showrunner role: {e}")

        # Fetch owner profile
        owner_profile = client.table("profiles").select(
            "id, username, full_name, display_name, avatar_url, role, is_order_member"
        ).eq("id", profile_id).execute()

        project["owner"] = owner_profile.data[0] if owner_profile.data else None

        return serialize_project(project)

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating project: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}", response_model=ProjectResponse)
async def get_project(
    project_id: str,
    authorization: str = Header(None)
):
    """
    Get a single project by ID.
    """
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    try:
        # Look up the profile ID from cognito_user_id
        profile_id = get_profile_id_from_cognito_id(cognito_user_id) or cognito_user_id

        # Verify access
        project = await verify_project_access(client, project_id, profile_id)

        # Fetch owner profile
        profile_result = client.table("profiles").select(
            "id, username, full_name, display_name, avatar_url, role, is_order_member"
        ).eq("id", project["owner_id"]).execute()

        project["owner"] = profile_result.data[0] if profile_result.data else None

        return serialize_project(project)

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting project: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/workspace-init")
async def get_workspace_init(
    project_id: str,
    authorization: str = Header(None)
):
    """
    Combined endpoint for workspace initialization.
    Returns project, permission, view-config, can-manage-roles, my-roles, and production-days
    in a single request to reduce concurrent Lambda invocations.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        user_id = str(user["id"])
        cognito_user_id = user.get("user_id") or user.get("id")
        profile_id = get_profile_id_from_cognito_id(cognito_user_id) or cognito_user_id

        # --- Project ---
        project_response = client.table("backlot_projects").select("*").eq("id", project_id).execute()
        if not project_response.data:
            raise HTTPException(status_code=404, detail="Project not found")
        project = project_response.data[0]

        # Fetch owner profile
        owner_result = client.table("profiles").select(
            "id, username, full_name, display_name, avatar_url, role, is_order_member"
        ).eq("id", project["owner_id"]).execute()
        project["owner"] = owner_result.data[0] if owner_result.data else None

        is_owner = str(project["owner_id"]) == str(profile_id)

        # --- Permission (my-role) ---
        if is_owner:
            permission = {
                "role": "owner", "is_owner": True, "can_edit": True,
                "can_view": True, "is_admin": True
            }
        else:
            member_response = client.table("backlot_project_members").select(
                "role, production_role"
            ).eq("project_id", project_id).eq("user_id", profile_id).execute()

            if member_response.data:
                member = member_response.data[0]
                role = member.get("role", "viewer")
                permission = {
                    "role": role,
                    "production_role": member.get("production_role"),
                    "is_owner": False,
                    "can_edit": role in ["owner", "admin", "editor"],
                    "can_view": True,
                    "is_admin": role in ["owner", "admin"]
                }
            elif project.get("visibility") == "public":
                permission = {
                    "role": "public_viewer", "is_owner": False,
                    "can_edit": False, "can_view": True, "is_admin": False
                }
            else:
                raise HTTPException(status_code=403, detail="Access denied - not a project member")

        # --- Profile role (needed for view-config and can-manage-roles) ---
        profile_result = client.table("profiles").select("role, is_admin, is_superadmin").eq("id", user_id).execute()
        profile = profile_result.data[0] if profile_result.data else {}
        profile_role = profile.get("role")
        is_site_admin = profile_role in ["admin", "superadmin"] or profile.get("is_admin") or profile.get("is_superadmin")

        # --- Backlot roles (my-roles) ---
        roles_result = client.table("backlot_project_roles").select("*").eq(
            "project_id", project_id
        ).eq("user_id", user_id).execute()
        my_roles = []
        for r in (roles_result.data or []):
            rd = dict(r)
            rd["id"] = str(rd["id"])
            rd["project_id"] = str(rd["project_id"])
            rd["user_id"] = str(rd["user_id"]) if rd.get("user_id") else None
            my_roles.append(rd)

        # --- View config ---
        default_configs = {
            "showrunner": {
                "tabs": {
                    "overview": True, "script": True, "shot-lists": True, "coverage": True,
                    "schedule": True, "call-sheets": True, "casting": True, "locations": True,
                    "gear": True, "dailies": True, "review": True, "assets": True,
                    "budget": True, "daily-budget": True, "receipts": True, "analytics": True,
                    "tasks": True, "updates": True, "contacts": True,
                    "clearances": True, "credits": True, "roles": True, "settings": True,
                },
                "sections": {"budget_numbers": True, "admin_tools": True},
            },
            "crew": {
                "tabs": {
                    "overview": True, "script": True, "shot-lists": False, "coverage": False,
                    "schedule": True, "call-sheets": True, "casting": False, "locations": False,
                    "gear": False, "dailies": False, "review": False, "assets": False,
                    "budget": False, "daily-budget": False, "receipts": False, "analytics": False,
                    "tasks": True, "updates": True, "contacts": False,
                    "clearances": False, "credits": False, "roles": False, "settings": False,
                },
                "sections": {"budget_numbers": False, "admin_tools": False},
            },
        }

        if is_owner or is_site_admin:
            view_config = {"role": "owner" if is_owner else "admin", **default_configs["showrunner"]}
        else:
            primary_role_data = next((r for r in my_roles if r.get("is_primary")), my_roles[0] if my_roles else None)
            primary_role = primary_role_data["backlot_role"] if primary_role_data else "crew"

            view_result = client.table("backlot_project_view_profiles").select("config").eq(
                "project_id", project_id
            ).eq("backlot_role", primary_role).eq("is_default", True).execute()

            if view_result.data and view_result.data[0].get("config"):
                view_config = {"role": primary_role, "config": view_result.data[0]["config"]}
            else:
                config = default_configs.get(primary_role, default_configs["crew"])
                view_config = {"role": primary_role, **config}

        # --- Can manage roles ---
        can_manage_roles = False
        if is_site_admin or is_owner:
            can_manage_roles = True
        else:
            showrunner_result = client.table("backlot_project_roles").select("backlot_role").eq(
                "project_id", project_id
            ).eq("user_id", user_id).eq("backlot_role", "showrunner").execute()
            can_manage_roles = len(showrunner_result.data or []) > 0

        # --- Production days ---
        days_result = client.table("backlot_production_days").select("*").eq(
            "project_id", project_id
        ).order("day_number").execute()

        return {
            "project": serialize_project(project),
            "permission": permission,
            "view_config": view_config,
            "can_manage_roles": can_manage_roles,
            "my_roles": my_roles,
            "production_days": days_result.data or [],
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error in workspace-init: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/my-role")
async def get_my_project_role(
    project_id: str,
    authorization: str = Header(None)
):
    """
    Get the current user's role in a project.
    Returns role info including whether user can edit.
    """
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    try:
        # Look up the profile ID from cognito_user_id
        profile_id = get_profile_id_from_cognito_id(cognito_user_id) or cognito_user_id

        # Get project to check ownership
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        if not project_response.data:
            raise HTTPException(status_code=404, detail="Project not found")

        project = project_response.data[0]
        is_owner = project["owner_id"] == profile_id

        if is_owner:
            return {
                "role": "owner",
                "is_owner": True,
                "can_edit": True,
                "can_view": True,
                "is_admin": True
            }

        # Check membership
        member_response = client.table("backlot_project_members").select(
            "role, production_role"
        ).eq("project_id", project_id).eq("user_id", profile_id).execute()

        if not member_response.data:
            # Not a member - check if project is public
            project_full = client.table("backlot_projects").select("visibility").eq("id", project_id).execute()
            if project_full.data and project_full.data[0].get("visibility") == "public":
                return {
                    "role": "public_viewer",
                    "is_owner": False,
                    "can_edit": False,
                    "can_view": True,
                    "is_admin": False
                }
            raise HTTPException(status_code=403, detail="Access denied - not a project member")

        member = member_response.data[0]
        role = member.get("role", "viewer")
        can_edit = role in ["owner", "admin", "editor"]
        is_admin = role in ["owner", "admin"]

        return {
            "role": role,
            "production_role": member.get("production_role"),
            "is_owner": False,
            "can_edit": can_edit,
            "can_view": True,
            "is_admin": is_admin
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting user role: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/projects/{project_id}", response_model=ProjectResponse)
async def update_project(
    project_id: str,
    project_input: ProjectUpdateInput,
    authorization: str = Header(None)
):
    """
    Update a project.
    """
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    try:
        # Look up the profile ID from cognito_user_id
        profile_id = get_profile_id_from_cognito_id(cognito_user_id) or cognito_user_id

        # Verify edit access
        await verify_project_access(client, project_id, profile_id, require_edit=True)

        # Build update data (only include non-None fields)
        update_data = {}
        for field, value in project_input.dict().items():
            if value is not None:
                update_data[field] = value

        if not update_data:
            raise HTTPException(status_code=400, detail="No fields to update")

        # Capture old status before update for archive storage shift
        old_status = None
        if "status" in update_data:
            old_proj = client.table("backlot_projects").select("status").eq("id", project_id).single().execute()
            old_status = old_proj.data.get("status") if old_proj.data else None

        result = client.table("backlot_projects").update(update_data).eq("id", project_id).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to update project")

        project = result.data[0]

        # Shift storage between active/archive if status changed
        new_status = update_data.get("status")
        if new_status and old_status != new_status:
            if new_status == "archived" and old_status != "archived":
                execute_single(
                    "SELECT shift_project_storage(:pid, 'to_archive')",
                    {"pid": project_id}
                )
            elif old_status == "archived" and new_status != "archived":
                execute_single(
                    "SELECT shift_project_storage(:pid, 'to_active')",
                    {"pid": project_id}
                )

        # Fetch owner profile
        profile_result = client.table("profiles").select(
            "id, username, full_name, display_name, avatar_url, role, is_order_member"
        ).eq("id", project["owner_id"]).execute()

        project["owner"] = profile_result.data[0] if profile_result.data else None

        return serialize_project(project)

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating project: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/projects/{project_id}")
async def delete_project(
    project_id: str,
    authorization: str = Header(None)
):
    """
    Delete a project (owner only).
    """
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    try:
        # Look up the profile ID from cognito_user_id
        profile_id = get_profile_id_from_cognito_id(cognito_user_id) or cognito_user_id

        # Get project and verify ownership
        project_result = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()

        if not project_result.data:
            raise HTTPException(status_code=404, detail="Project not found")

        if project_result.data[0]["owner_id"] != profile_id:
            raise HTTPException(status_code=403, detail="Only the owner can delete this project")

        # Delete project (cascade should handle related records)
        client.table("backlot_projects").delete().eq("id", project_id).execute()

        return {"success": True, "message": "Project deleted"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting project: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Call Sheet Send Models
# =====================================================

class CallSheetSendRequest(BaseModel):
    """Request to send a call sheet"""
    channel: Literal["email", "notification", "email_and_notification"] = "email_and_notification"
    recipient_mode: Literal["all_project_members", "call_sheet_people", "custom"] = "all_project_members"
    recipient_user_ids: Optional[List[str]] = None
    extra_emails: Optional[List[str]] = None
    message: Optional[str] = None


class CallSheetSendResponse(BaseModel):
    """Response from sending a call sheet"""
    success: bool
    send_id: Optional[str] = None
    emails_sent: int = 0
    notifications_sent: int = 0
    total_recipients: int = 0
    message: str = ""


class CallSheetSendHistory(BaseModel):
    """Record of a call sheet send"""
    id: str
    sent_at: datetime
    sent_by_name: Optional[str] = None
    channel: str
    recipient_count: int
    emails_sent: int
    notifications_sent: int
    message: Optional[str] = None


# =====================================================
# Helper Functions
# =====================================================

async def get_current_user_from_token(authorization: str = Header(None)) -> Dict[str, Any]:
    """Extract and validate user from Bearer token using AWS Cognito.
    Returns the profile ID (not Cognito ID) for database lookups.
    """
    if not authorization or not authorization.startswith("Bearer "):
        print("[AUTH] Missing or invalid authorization header")
        raise HTTPException(status_code=401, detail="Missing or invalid authorization header")

    token = authorization.replace("Bearer ", "")

    try:
        from app.core.cognito import CognitoAuth
        user = CognitoAuth.verify_token(token)
        if not user:
            print("[AUTH] Token verification returned None")
            raise HTTPException(status_code=401, detail="Invalid token")

        # Try 'user_id', 'sub', and 'id' as Cognito might return any of these
        cognito_id = user.get("user_id") or user.get("sub") or user.get("id")
        email = user.get("email")

        if not cognito_id:
            print(f"[AUTH] No cognito_id found in user object: {list(user.keys())}")
            raise HTTPException(status_code=401, detail="No user ID in token")

        # Convert Cognito ID to profile ID for database lookups
        profile_id = get_profile_id_from_cognito_id(cognito_id)
        if not profile_id:
            print(f"[AUTH] No profile found for cognito_id: {cognito_id}")
            raise HTTPException(status_code=401, detail="User profile not found")

        # Return both 'id' and 'user_id' to handle both access patterns
        return {"id": profile_id, "user_id": profile_id, "cognito_id": cognito_id, "email": email}
    except HTTPException:
        raise
    except Exception as e:
        print(f"[AUTH] Authentication exception: {type(e).__name__}: {str(e)}")
        raise HTTPException(status_code=401, detail=f"Authentication failed: {str(e)}")


async def check_storage_quota(user_id: str, file_size: int = 0) -> Dict[str, Any]:
    """Check if user has available storage quota for upload.

    Args:
        user_id: The user's profile ID
        file_size: Size of file to upload in bytes (optional, 0 for pre-check)

    Returns:
        Dict with quota info: can_upload, bytes_used, quota_bytes, bytes_remaining

    Raises:
        HTTPException 403 if quota would be exceeded
    """
    # Default quota values - allow uploads if quota check fails
    default_quota = 10737418240  # 10GB default
    default_result = {
        "can_upload": True,
        "bytes_used": 0,
        "quota_bytes": default_quota,
        "bytes_remaining": default_quota,
        "percentage_used": 0
    }

    try:
        client = get_client()

        # Get current usage - don't use single() to avoid error on missing records
        try:
            usage_result = client.table("user_storage_usage").select(
                "total_bytes_used, custom_quota_bytes"
            ).eq("user_id", user_id).execute()
        except Exception as e:
            print(f"Warning: Could not query user_storage_usage: {e}")
            return default_result

        current_usage = 0
        custom_quota = None

        # Get first result if any exist
        if usage_result.data and len(usage_result.data) > 0:
            current_usage = usage_result.data[0].get("total_bytes_used") or 0
            custom_quota = usage_result.data[0].get("custom_quota_bytes")

        # Get effective quota
        if custom_quota:
            effective_quota = custom_quota
        else:
            # Get max quota from user's roles - wrap in try-catch
            try:
                roles_result = client.table("user_roles").select(
                    "custom_roles(storage_quota_bytes)"
                ).eq("user_id", user_id).execute()

                max_quota = default_quota
                for role in (roles_result.data or []):
                    role_quota = (role.get("custom_roles") or {}).get("storage_quota_bytes") or 0
                    if role_quota > max_quota:
                        max_quota = role_quota
                effective_quota = max_quota
            except Exception as e:
                print(f"Warning: Could not query user_roles: {e}")
                effective_quota = default_quota

        bytes_remaining = effective_quota - current_usage
        can_upload = (current_usage + file_size) <= effective_quota

        result = {
            "can_upload": can_upload,
            "bytes_used": current_usage,
            "quota_bytes": effective_quota,
            "bytes_remaining": bytes_remaining,
            "percentage_used": round((current_usage / effective_quota) * 100, 1) if effective_quota > 0 else 0
        }

        if not can_upload and file_size > 0:
            raise HTTPException(
                status_code=403,
                detail={
                    "message": "Storage quota exceeded",
                    "bytes_used": current_usage,
                    "quota_bytes": effective_quota,
                    "file_size": file_size,
                    "bytes_remaining": bytes_remaining
                }
            )

        return result

    except HTTPException:
        raise
    except Exception as e:
        print(f"Warning: Storage quota check failed: {e}")
        return default_result


async def verify_project_access(
    client,
    project_id: str,
    user_id: str,
    require_edit: bool = False
) -> Dict[str, Any]:
    """Verify user has access to project and return project data.

    user_id can be either a Cognito user ID or a profile ID - both are handled.
    """
    # Convert cognito user ID to profile ID if needed
    profile_id = get_profile_id_from_cognito_id(user_id)
    if not profile_id:
        # user_id might already be a profile ID
        profile_id = user_id

    # Get project
    project_response = client.table("backlot_projects").select("*").eq("id", project_id).execute()

    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    project = project_response.data[0]

    # Check if owner (compare as strings to handle UUID objects)
    if str(project["owner_id"]) == str(profile_id):
        return project

    # Check membership
    member_response = client.table("backlot_project_members").select("*").eq("project_id", project_id).eq("user_id", profile_id).execute()

    if not member_response.data:
        raise HTTPException(status_code=403, detail="You don't have access to this project")

    member = member_response.data[0]

    if require_edit and member["role"] not in ["owner", "admin", "editor"]:
        raise HTTPException(status_code=403, detail="You don't have permission to edit this project")

    return project


# =====================================================
# Script Scene Sync Helper
# =====================================================

async def sync_scenes_from_script(client, project_id: str, script_id: str, parsed_scenes: list):
    """
    Sync scenes from parsed script content to the database.
    Updates existing scenes or creates new ones based on scene_number.
    """
    from app.utils.script_parser import ParsedScene

    try:
        # Get existing scenes for this project
        existing_scenes = client.table("backlot_scenes").select(
            "id, scene_number, slugline"
        ).eq("project_id", project_id).execute()

        existing_by_number = {s["scene_number"]: s for s in (existing_scenes.data or [])}

        for parsed_scene in parsed_scenes:
            scene_number = parsed_scene.scene_number

            # Prepare scene data
            scene_data = {
                "project_id": project_id,
                "script_id": script_id,
                "scene_number": scene_number,
                "slugline": parsed_scene.slugline,
                "set_name": parsed_scene.location_hint,
                "int_ext": parsed_scene.int_ext,
                "time_of_day": parsed_scene.time_of_day.lower() if parsed_scene.time_of_day else None,
                "sequence": parsed_scene.sequence,
                "page_start": parsed_scene.page_start,
            }

            if scene_number in existing_by_number:
                # Update existing scene
                existing_id = existing_by_number[scene_number]["id"]
                client.table("backlot_scenes").update(scene_data).eq("id", existing_id).execute()
            else:
                # Create new scene
                client.table("backlot_scenes").insert(scene_data).execute()

        # Optionally: Mark scenes that are no longer in the script as omitted
        parsed_scene_numbers = {s.scene_number for s in parsed_scenes}
        for existing_number, existing_scene in existing_by_number.items():
            if existing_number not in parsed_scene_numbers:
                # Mark as omitted rather than deleting to preserve any breakdown data
                client.table("backlot_scenes").update({
                    "is_omitted": True
                }).eq("id", existing_scene["id"]).execute()

    except Exception as e:
        print(f"Error syncing scenes from script: {e}")
        # Don't fail the main operation if scene sync fails
        pass


# =====================================================
# Call Sheet Send Endpoints
# =====================================================

@router.post("/call-sheets/{call_sheet_id}/send", response_model=CallSheetSendResponse)
async def send_call_sheet(
    call_sheet_id: str,
    request: CallSheetSendRequest,
    authorization: str = Header(None)
):
    """
    Send a call sheet to selected recipients via email and/or notification

    Args:
        call_sheet_id: ID of the call sheet to send
        request: Send configuration (channel, recipients, message)

    Returns:
        Send result with counts
    """
    # Authenticate user
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()  # Use admin client for full access

    # Get call sheet
    sheet_response = client.table("backlot_call_sheets").select("*").eq("id", call_sheet_id).execute()

    if not sheet_response.data:
        raise HTTPException(status_code=404, detail="Call sheet not found")

    call_sheet = sheet_response.data[0]
    project_id = call_sheet["project_id"]

    # Verify access
    project = await verify_project_access(client, project_id, user_id, require_edit=True)

    # Get call sheet people
    people_response = client.table("backlot_call_sheet_people").select("*").eq("call_sheet_id", call_sheet_id).order("sort_order").execute()
    call_sheet_people = people_response.data or []

    # Determine recipients based on mode
    recipients = []

    if request.recipient_mode == "all_project_members":
        # Get all project members
        members_response = client.table("backlot_project_members").select("*, profiles(id, email, full_name, display_name)").eq("project_id", project_id).execute()

        for member in members_response.data or []:
            profile = member.get("profiles")
            if profile:
                email = member.get("email") or profile.get("email")
                if email:
                    recipients.append({
                        "user_id": member["user_id"],
                        "email": email,
                        "name": profile.get("display_name") or profile.get("full_name") or email
                    })

        # Also add the project owner
        owner_response = client.table("profiles").select("id, email, full_name, display_name").eq("id", project["owner_id"]).execute()
        if owner_response.data:
            owner = owner_response.data[0]
            owner_email = owner.get("email")
            if owner_email and not any(r["email"] == owner_email for r in recipients):
                recipients.append({
                    "user_id": project["owner_id"],
                    "email": owner_email,
                    "name": owner.get("display_name") or owner.get("full_name") or owner_email
                })

    elif request.recipient_mode == "call_sheet_people":
        # Get people from call sheet with emails
        for person in call_sheet_people:
            email = person.get("email")
            if email:
                recipients.append({
                    "user_id": person.get("member_id"),  # May be null for external people
                    "email": email,
                    "name": person.get("name", email)
                })

    elif request.recipient_mode == "custom":
        # Use provided user IDs
        if request.recipient_user_ids:
            for uid in request.recipient_user_ids:
                # Get user profile
                profile_response = client.table("profiles").select("id, email, full_name, display_name").eq("id", uid).execute()
                if profile_response.data:
                    profile = profile_response.data[0]
                    if profile.get("email"):
                        recipients.append({
                            "user_id": uid,
                            "email": profile["email"],
                            "name": profile.get("display_name") or profile.get("full_name") or profile["email"]
                        })

    # Add extra emails (external guests)
    if request.extra_emails:
        for email in request.extra_emails:
            email = email.strip()
            if email and not any(r["email"] == email for r in recipients):
                recipients.append({
                    "user_id": None,
                    "email": email,
                    "name": email
                })

    if not recipients:
        raise HTTPException(status_code=400, detail="No recipients found for this send configuration")

    # Get sender info
    sender_response = client.table("profiles").select("full_name, display_name").eq("id", user_id).execute()
    sender_name = ""
    if sender_response.data:
        sender = sender_response.data[0]
        sender_name = sender.get("display_name") or sender.get("full_name") or "Production Team"

    # Format call sheet data for email
    from datetime import datetime as dt
    call_date_str = call_sheet.get("date", "")
    try:
        call_date = dt.strptime(call_date_str, "%Y-%m-%d")
        call_date_formatted = call_date.strftime("%A, %B %d, %Y")
    except:
        call_date_formatted = call_date_str

    # Generate view URL
    view_url = f"{settings.FRONTEND_URL}/backlot/projects/{project_id}?view=call-sheets&sheet={call_sheet_id}"

    # Generate email HTML
    email_html = generate_call_sheet_email_html(
        project_title=project.get("title", ""),
        call_sheet_title=call_sheet.get("title", "Call Sheet"),
        call_date=call_date_formatted,
        call_time=call_sheet.get("general_call_time", ""),
        location_name=call_sheet.get("location_name", ""),
        location_address=call_sheet.get("location_address", ""),
        schedule_blocks=call_sheet.get("schedule_blocks", []),
        people=call_sheet_people,
        special_instructions=call_sheet.get("special_instructions"),
        weather_info=call_sheet.get("weather_info"),
        safety_notes=call_sheet.get("safety_notes"),
        hospital_name=call_sheet.get("hospital_name"),
        hospital_address=call_sheet.get("hospital_address"),
        hospital_phone=call_sheet.get("hospital_phone"),
        sender_name=sender_name,
        sender_message=request.message,
        view_url=view_url
    )

    # Generate text version
    email_text = generate_call_sheet_text(
        project_title=project.get("title", ""),
        call_sheet_title=call_sheet.get("title", "Call Sheet"),
        call_date=call_date_formatted,
        call_time=call_sheet.get("general_call_time", ""),
        location_name=call_sheet.get("location_name", ""),
        location_address=call_sheet.get("location_address", ""),
        schedule_blocks=call_sheet.get("schedule_blocks", []),
        people=call_sheet_people,
        special_instructions=call_sheet.get("special_instructions"),
        sender_message=request.message
    )

    emails_sent = 0
    notifications_sent = 0

    # Send emails if requested
    if request.channel in ["email", "email_and_notification"]:
        email_addresses = [r["email"] for r in recipients if r.get("email")]
        if email_addresses:
            subject = f"Call Sheet: {call_sheet.get('title', 'Production Update')} - {project.get('title', '')}"
            result = await EmailService.send_email(
                to_emails=email_addresses,
                subject=subject,
                html_content=email_html,
                text_content=email_text
            )
            if result.get("success"):
                emails_sent = len(email_addresses)

    # Send notifications if requested
    if request.channel in ["notification", "email_and_notification"]:
        for recipient in recipients:
            if recipient.get("user_id"):
                try:
                    notification_data = {
                        "user_id": recipient["user_id"],
                        "title": f"Call Sheet: {call_sheet.get('title', '')}",
                        "body": f"{project.get('title', '')} - {call_date_formatted}",
                        "type": "call_sheet",
                        "related_id": call_sheet_id,
                        "payload": {
                            "project_id": project_id,
                            "call_sheet_id": call_sheet_id,
                            "call_date": call_sheet.get("date"),
                            "message": request.message
                        },
                        "status": "unread"
                    }
                    client.table("notifications").insert(notification_data).execute()
                    notifications_sent += 1
                except Exception as e:
                    print(f"Failed to create notification for {recipient['user_id']}: {e}")

    # Log the send
    send_log = {
        "call_sheet_id": call_sheet_id,
        "project_id": project_id,
        "sent_by_user_id": user_id,
        "recipients": recipients,
        "channel": request.channel,
        "message": request.message,
        "recipient_count": len(recipients),
        "emails_sent": emails_sent,
        "notifications_sent": notifications_sent
    }

    log_response = client.table("backlot_call_sheet_send_history").insert(send_log).execute()
    send_id = log_response.data[0]["id"] if log_response.data else None

    # Auto-publish if not already published
    if not call_sheet.get("is_published"):
        client.table("backlot_call_sheets").update({
            "is_published": True,
            "published_at": datetime.utcnow().isoformat()
        }).eq("id", call_sheet_id).execute()

    return CallSheetSendResponse(
        success=True,
        send_id=send_id,
        emails_sent=emails_sent,
        notifications_sent=notifications_sent,
        total_recipients=len(recipients),
        message=f"Call sheet sent to {len(recipients)} recipient(s)"
    )


@router.get("/call-sheets/{call_sheet_id}/send-history", response_model=List[CallSheetSendHistory])
async def get_call_sheet_send_history(
    call_sheet_id: str,
    authorization: str = Header(None)
):
    """Get send history for a call sheet"""
    # Authenticate user
    current_user = await get_current_user_from_token(authorization)
    cognito_user_id = current_user["id"]

    # Resolve profile ID
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    if not profile_id:
        raise HTTPException(status_code=404, detail="Profile not found")

    # Get call sheet to verify access
    sheet_result = execute_single(
        "SELECT project_id FROM backlot_call_sheets WHERE id = :call_sheet_id",
        {"call_sheet_id": call_sheet_id}
    )

    if not sheet_result:
        raise HTTPException(status_code=404, detail="Call sheet not found")

    project_id = sheet_result["project_id"]

    # Verify access - check if owner or member
    project_result = execute_single(
        "SELECT owner_id FROM backlot_projects WHERE id = :project_id",
        {"project_id": str(project_id)}
    )
    if not project_result:
        raise HTTPException(status_code=404, detail="Project not found")

    is_owner = str(project_result.get("owner_id")) == profile_id
    if not is_owner:
        member_result = execute_single(
            "SELECT role FROM backlot_project_members WHERE project_id = :project_id AND user_id = :user_id",
            {"project_id": str(project_id), "user_id": profile_id}
        )
        if not member_result:
            raise HTTPException(status_code=403, detail="Access denied")

    # Get send history with sender name using SQLAlchemy
    history = execute_query(
        """
        SELECT h.*, p.full_name, p.display_name
        FROM backlot_call_sheet_send_history h
        LEFT JOIN profiles p ON h.sent_by_user_id = p.id
        WHERE h.call_sheet_id = :call_sheet_id
        ORDER BY h.sent_at DESC
        """,
        {"call_sheet_id": call_sheet_id}
    )

    result = []
    for record in history or []:
        sent_by_name = record.get("display_name") or record.get("full_name")

        result.append(CallSheetSendHistory(
            id=str(record["id"]),
            sent_at=str(record["sent_at"]) if record.get("sent_at") else None,
            sent_by_name=sent_by_name,
            channel=record.get("channel", "email"),
            recipient_count=record.get("recipient_count", 0),
            emails_sent=record.get("emails_sent", 0),
            notifications_sent=record.get("notifications_sent", 0),
            message=record.get("message")
        ))

    return result


@router.get("/projects/{project_id}/members-for-send")
async def get_project_members_for_send(
    project_id: str,
    authorization: str = Header(None)
):
    """Get project members for recipient selection in send modal"""
    # Authenticate user
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Verify access
    project = await verify_project_access(client, project_id, user_id)

    # Get all project members
    members_response = client.table("backlot_project_members").select("*").eq("project_id", project_id).execute()

    # Get user profiles for all members
    user_ids = [m["user_id"] for m in (members_response.data or []) if m.get("user_id")]
    user_ids.append(str(project["owner_id"]))  # Include owner
    user_ids = list(set(user_ids))  # Deduplicate

    profiles_map = {}
    if user_ids:
        profiles_response = client.table("profiles").select("id, email, full_name, display_name, avatar_url").in_("id", user_ids).execute()
        for p in (profiles_response.data or []):
            profiles_map[str(p["id"])] = p

    result = []

    # Add owner
    owner_id = str(project["owner_id"])
    owner = profiles_map.get(owner_id)
    if owner:
        result.append({
            "user_id": owner["id"],
            "name": owner.get("display_name") or owner.get("full_name") or owner.get("email"),
            "email": owner.get("email"),
            "avatar_url": owner.get("avatar_url"),
            "role": "owner",
            "production_role": "Owner"
        })

    # Add members
    for member in members_response.data or []:
        member_user_id = str(member.get("user_id", ""))
        profile = profiles_map.get(member_user_id)
        if profile and member_user_id != owner_id:
            result.append({
                "user_id": profile["id"],
                "name": profile.get("display_name") or profile.get("full_name") or profile.get("email"),
                "email": member.get("email") or profile.get("email"),
                "avatar_url": profile.get("avatar_url"),
                "role": member.get("role"),
                "production_role": member.get("production_role")
            })

    return result


# =====================================================
# Project Credits Models
# =====================================================

class ProjectCreditInput(BaseModel):
    """Input for creating/updating a project credit"""
    department: Optional[str] = None
    credit_role: str
    name: str
    user_id: Optional[str] = None
    is_primary: bool = False
    is_public: bool = True
    order_index: int = 0
    endorsement_note: Optional[str] = None
    imdb_id: Optional[str] = None


class ProjectCreditResponse(BaseModel):
    """Project credit response"""
    id: str
    project_id: str
    department: Optional[str] = None
    credit_role: str
    name: str
    user_id: Optional[str] = None
    is_primary: bool = False
    is_public: bool = True
    order_index: int = 0
    endorsement_note: Optional[str] = None
    imdb_id: Optional[str] = None
    created_by: Optional[str] = None
    created_at: Optional[str] = None
    linked_user: Optional[Dict[str, Any]] = None

    class Config:
        extra = "allow"


# =====================================================
# Project Updates (Announcements) Models
# =====================================================

class ProjectAnnouncementInput(BaseModel):
    """Input for creating/updating a project update/announcement"""
    title: str
    content: str
    type: str = "general"  # general, milestone, deadline, urgent
    is_public: bool = False
    attachments: Optional[List[Dict[str, Any]]] = None
    visible_to_roles: Optional[List[str]] = None


class ProjectAnnouncementResponse(BaseModel):
    """Project update/announcement response"""
    id: str
    project_id: str
    title: str
    content: str
    type: str = "general"
    is_public: bool = False
    attachments: Optional[List[Dict[str, Any]]] = None
    visible_to_roles: Optional[List[str]] = None
    created_by: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None
    author: Optional[Dict[str, Any]] = None
    has_read: bool = False

    class Config:
        extra = "allow"


# =====================================================
# Call Sheet Scene Models
# =====================================================

class CallSheetSceneInput(BaseModel):
    """Input for creating/updating a call sheet scene"""
    scene_number: Optional[str] = None
    segment_label: Optional[str] = None
    page_count: Optional[str] = None
    set_name: str
    int_ext: Optional[str] = None
    time_of_day: Optional[str] = None
    description: Optional[str] = None
    cast_ids: Optional[str] = None
    cast_names: Optional[str] = None
    location_id: Optional[str] = None
    sort_order: Optional[int] = 0


class CallSheetScene(BaseModel):
    """Call sheet scene/segment"""
    id: str
    call_sheet_id: str
    scene_number: Optional[str] = None
    segment_label: Optional[str] = None
    page_count: Optional[str] = None
    set_name: str
    int_ext: Optional[str] = None
    time_of_day: Optional[str] = None
    description: Optional[str] = None
    cast_ids: Optional[str] = None
    cast_names: Optional[str] = None
    location_id: Optional[str] = None
    sort_order: int = 0
    created_at: datetime
    updated_at: datetime


# =====================================================
# Call Sheet Location Models (Multiple Locations Support)
# =====================================================

class CallSheetLocationInput(BaseModel):
    """Input for a call sheet location entry"""
    location_number: int = 1
    location_id: Optional[str] = None
    name: str
    address: Optional[str] = None
    parking_instructions: Optional[str] = None
    basecamp_location: Optional[str] = None
    call_time: Optional[str] = None
    notes: Optional[str] = None
    sort_order: Optional[int] = 0


class CallSheetLocation(BaseModel):
    """A call sheet location entry"""
    id: str
    call_sheet_id: str
    location_number: int = 1
    location_id: Optional[str] = None
    name: str
    address: Optional[str] = None
    parking_instructions: Optional[str] = None
    basecamp_location: Optional[str] = None
    call_time: Optional[str] = None
    notes: Optional[str] = None
    sort_order: int = 0
    created_at: datetime
    updated_at: datetime


class BulkDepartmentTimeUpdate(BaseModel):
    """Request body for bulk updating times for a department"""
    department: str
    call_time: Optional[str] = None
    makeup_time: Optional[str] = None  # For cast
    pickup_time: Optional[str] = None  # For cast
    on_set_time: Optional[str] = None  # For cast
    apply_to: str = "all"  # "all" or "empty_only"


class CallSheetCloneInput(BaseModel):
    """Request body for cloning a call sheet"""
    new_date: str  # ISO date string for the new call sheet
    new_day_number: Optional[int] = None  # Optional new day number
    new_title: Optional[str] = None  # Optional new title
    keep_people: bool = True  # Clone cast & crew
    keep_scenes: bool = True  # Clone scene list
    keep_locations: bool = True  # Clone locations
    keep_schedule_blocks: bool = True  # Clone schedule blocks
    keep_department_notes: bool = True  # Clone department notes


class CallSheetCommentInput(BaseModel):
    """Request body for creating/updating a comment"""
    content: str
    parent_comment_id: Optional[str] = None
    field_reference: Optional[str] = None


class CallSheetCommentResponse(BaseModel):
    """Response for a comment"""
    id: str
    call_sheet_id: str
    parent_comment_id: Optional[str] = None
    user_id: str
    content: str
    field_reference: Optional[str] = None
    is_resolved: bool = False
    resolved_by: Optional[str] = None
    resolved_at: Optional[str] = None
    created_at: str
    updated_at: str
    # Joined user data
    user_name: Optional[str] = None
    user_avatar_url: Optional[str] = None
    replies: Optional[List["CallSheetCommentResponse"]] = None

    class Config:
        from_attributes = True


class CallSheetShareInput(BaseModel):
    """Request body for creating a share link"""
    name: Optional[str] = None
    expires_in_days: int = 7
    password: Optional[str] = None
    allowed_actions: List[str] = ["view"]


class CallSheetShareResponse(BaseModel):
    """Response for a share link"""
    id: str
    call_sheet_id: str
    share_token: str
    share_url: str
    name: Optional[str] = None
    expires_at: str
    is_active: bool = True
    has_password: bool = False
    view_count: int = 0
    last_viewed_at: Optional[str] = None
    allowed_actions: List[str] = ["view"]
    created_at: str
    created_by_name: Optional[str] = None


# =====================================================
# Call Sheet Comment Endpoints
# =====================================================

@router.get("/call-sheets/{call_sheet_id}/comments")
async def get_call_sheet_comments(
    call_sheet_id: str,
    authorization: str = Header(None)
):
    """Get all comments for a call sheet with user info and nested replies"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify access to call sheet
        cs = client.table("backlot_call_sheets").select("project_id").eq("id", call_sheet_id).execute()
        if not cs.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        await verify_project_access(client, cs.data[0]["project_id"], user["id"])

        # Get all comments
        comments_result = client.table("backlot_call_sheet_comments").select("*").eq("call_sheet_id", call_sheet_id).order("created_at").execute()

        comments = comments_result.data or []

        # Get user profiles for all comment authors
        user_ids = list(set(c["user_id"] for c in comments if c.get("user_id")))
        profiles_map = {}
        if user_ids:
            profiles_result = client.table("profiles").select("id, full_name, display_name, avatar_url").in_("id", user_ids).execute()
            for p in (profiles_result.data or []):
                profiles_map[str(p["id"])] = p

        # Organize into tree structure (top-level and replies)
        comment_map = {}
        top_level = []

        for comment in comments:
            profile = profiles_map.get(str(comment.get("user_id")), {})
            comment_data = {
                **comment,
                "user_name": profile.get("display_name") or profile.get("full_name") or "Unknown",
                "user_avatar_url": profile.get("avatar_url"),
                "replies": []
            }
            comment_map[comment["id"]] = comment_data

        for comment_id, comment in comment_map.items():
            if comment.get("parent_comment_id"):
                parent = comment_map.get(comment["parent_comment_id"])
                if parent:
                    parent["replies"].append(comment)
            else:
                top_level.append(comment)

        # Count unresolved
        unresolved_count = sum(1 for c in comments if not c.get("is_resolved") and not c.get("parent_comment_id"))

        return {
            "comments": top_level,
            "total": len(comments),
            "unresolved_count": unresolved_count
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching comments: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/call-sheets/{call_sheet_id}/comments")
async def create_call_sheet_comment(
    call_sheet_id: str,
    comment_input: CallSheetCommentInput,
    authorization: str = Header(None)
):
    """Create a new comment on a call sheet"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify access
        cs = client.table("backlot_call_sheets").select("project_id").eq("id", call_sheet_id).execute()
        if not cs.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        await verify_project_access(client, cs.data[0]["project_id"], user["id"])

        # Get profile ID
        profile_id = get_profile_id_from_cognito_id(user["id"])
        if not profile_id:
            raise HTTPException(status_code=404, detail="Profile not found")

        # Create comment
        comment_data = {
            "call_sheet_id": call_sheet_id,
            "user_id": profile_id,
            "content": comment_input.content,
            "parent_comment_id": comment_input.parent_comment_id,
            "field_reference": comment_input.field_reference,
        }

        result = client.table("backlot_call_sheet_comments").insert(comment_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create comment")

        # Get user info
        profile = client.table("profiles").select("full_name, display_name, avatar_url").eq("id", profile_id).single().execute()

        comment = result.data[0]
        comment["user_name"] = profile.data.get("display_name") or profile.data.get("full_name") or "Unknown"
        comment["user_avatar_url"] = profile.data.get("avatar_url")
        comment["replies"] = []

        return {"comment": comment}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating comment: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/call-sheets/{call_sheet_id}/comments/{comment_id}")
async def update_call_sheet_comment(
    call_sheet_id: str,
    comment_id: str,
    comment_input: CallSheetCommentInput,
    authorization: str = Header(None)
):
    """Update an existing comment (only the author can update)"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get comment and verify ownership
        comment = client.table("backlot_call_sheet_comments").select("*").eq("id", comment_id).single().execute()
        if not comment.data:
            raise HTTPException(status_code=404, detail="Comment not found")

        profile_id = get_profile_id_from_cognito_id(user["id"])
        if str(comment.data["user_id"]) != str(profile_id):
            raise HTTPException(status_code=403, detail="You can only edit your own comments")

        # Update
        result = client.table("backlot_call_sheet_comments").update({
            "content": comment_input.content,
            "updated_at": datetime.utcnow().isoformat()
        }).eq("id", comment_id).execute()

        return {"comment": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating comment: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/call-sheets/{call_sheet_id}/comments/{comment_id}")
async def delete_call_sheet_comment(
    call_sheet_id: str,
    comment_id: str,
    authorization: str = Header(None)
):
    """Delete a comment (author or project admin can delete)"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get comment
        comment = client.table("backlot_call_sheet_comments").select("*, backlot_call_sheets!call_sheet_id(project_id)").eq("id", comment_id).single().execute()
        if not comment.data:
            raise HTTPException(status_code=404, detail="Comment not found")

        profile_id = get_profile_id_from_cognito_id(user["id"])
        is_author = str(comment.data["user_id"]) == str(profile_id)

        # Check if admin/owner
        project_id = comment.data.get("backlot_call_sheets", {}).get("project_id")
        is_admin = False
        if project_id:
            project = client.table("backlot_projects").select("owner_id").eq("id", project_id).single().execute()
            if project.data and str(project.data["owner_id"]) == str(profile_id):
                is_admin = True
            else:
                member = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id).single().execute()
                if member.data and member.data.get("role") in ["owner", "admin"]:
                    is_admin = True

        if not is_author and not is_admin:
            raise HTTPException(status_code=403, detail="You don't have permission to delete this comment")

        # Delete comment (will cascade to replies)
        client.table("backlot_call_sheet_comments").delete().eq("id", comment_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting comment: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/call-sheets/{call_sheet_id}/comments/{comment_id}/resolve")
async def resolve_call_sheet_comment(
    call_sheet_id: str,
    comment_id: str,
    authorization: str = Header(None)
):
    """Mark a comment as resolved (any editor can resolve)"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get comment and call sheet
        comment = client.table("backlot_call_sheet_comments").select("*").eq("id", comment_id).single().execute()
        if not comment.data:
            raise HTTPException(status_code=404, detail="Comment not found")

        cs = client.table("backlot_call_sheets").select("project_id").eq("id", call_sheet_id).single().execute()
        if not cs.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        # Verify edit access
        await verify_project_access(client, cs.data["project_id"], user["id"], require_edit=True)

        profile_id = get_profile_id_from_cognito_id(user["id"])

        # Toggle resolved status
        new_resolved = not comment.data.get("is_resolved", False)

        update_data = {
            "is_resolved": new_resolved,
            "resolved_by": profile_id if new_resolved else None,
            "resolved_at": datetime.utcnow().isoformat() if new_resolved else None,
            "updated_at": datetime.utcnow().isoformat()
        }

        result = client.table("backlot_call_sheet_comments").update(update_data).eq("id", comment_id).execute()

        return {"comment": result.data[0] if result.data else None, "is_resolved": new_resolved}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error resolving comment: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Call Sheet Version History Endpoints
# =====================================================

@router.get("/call-sheets/{call_sheet_id}/versions")
async def get_call_sheet_versions(
    call_sheet_id: str,
    limit: int = Query(50, ge=1, le=100),
    authorization: str = Header(None)
):
    """Get version history for a call sheet"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify access
        cs = client.table("backlot_call_sheets").select("project_id, current_version").eq("id", call_sheet_id).execute()
        if not cs.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        await verify_project_access(client, cs.data[0]["project_id"], user["id"])

        # Get versions
        versions_result = client.table("backlot_call_sheet_versions").select(
            "id, version_number, changed_fields, change_summary, created_at, created_by_user_id"
        ).eq("call_sheet_id", call_sheet_id).order("version_number", desc=True).limit(limit).execute()

        # Get creator profiles
        user_ids = list(set(v["created_by_user_id"] for v in (versions_result.data or []) if v.get("created_by_user_id")))
        profiles_map = {}
        if user_ids:
            profiles_result = client.table("profiles").select("id, full_name, display_name, avatar_url").in_("id", user_ids).execute()
            for p in (profiles_result.data or []):
                profiles_map[str(p["id"])] = p

        versions = []
        for v in versions_result.data or []:
            profile = profiles_map.get(str(v.get("created_by_user_id")), {})
            versions.append({
                "id": v["id"],
                "version_number": v["version_number"],
                "changed_fields": v.get("changed_fields") or [],
                "change_summary": v.get("change_summary"),
                "created_at": v["created_at"],
                "created_by_name": profile.get("display_name") or profile.get("full_name") or "Unknown",
                "created_by_avatar_url": profile.get("avatar_url"),
            })

        return {
            "versions": versions,
            "current_version": cs.data[0].get("current_version", 1)
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching versions: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/call-sheets/{call_sheet_id}/versions/{version_number}")
async def get_call_sheet_version(
    call_sheet_id: str,
    version_number: int,
    authorization: str = Header(None)
):
    """Get a specific version snapshot"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify access
        cs = client.table("backlot_call_sheets").select("project_id").eq("id", call_sheet_id).execute()
        if not cs.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        await verify_project_access(client, cs.data[0]["project_id"], user["id"])

        # Get specific version
        version = client.table("backlot_call_sheet_versions").select("*").eq("call_sheet_id", call_sheet_id).eq("version_number", version_number).single().execute()

        if not version.data:
            raise HTTPException(status_code=404, detail=f"Version {version_number} not found")

        return {"version": version.data}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching version: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/call-sheets/{call_sheet_id}/revert/{version_number}")
async def revert_call_sheet_to_version(
    call_sheet_id: str,
    version_number: int,
    authorization: str = Header(None)
):
    """Revert a call sheet to a previous version"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify access (require edit)
        cs = client.table("backlot_call_sheets").select("project_id, current_version").eq("id", call_sheet_id).execute()
        if not cs.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        await verify_project_access(client, cs.data[0]["project_id"], user["id"], require_edit=True)

        # Get the version to revert to
        version = client.table("backlot_call_sheet_versions").select("snapshot").eq("call_sheet_id", call_sheet_id).eq("version_number", version_number).single().execute()

        if not version.data:
            raise HTTPException(status_code=404, detail=f"Version {version_number} not found")

        snapshot = version.data.get("snapshot", {})
        if not snapshot:
            raise HTTPException(status_code=400, detail="Version snapshot is empty")

        # Get profile ID for tracking
        profile_id = get_profile_id_from_cognito_id(user["id"])

        # Create a new version with current state before reverting
        current_cs = client.table("backlot_call_sheets").select("*").eq("id", call_sheet_id).single().execute()
        current_version = cs.data[0].get("current_version", 1)

        # Save current state as new version
        client.table("backlot_call_sheet_versions").insert({
            "call_sheet_id": call_sheet_id,
            "version_number": current_version + 1,
            "snapshot": current_cs.data,
            "changed_fields": ["reverted"],
            "change_summary": f"Reverted to version {version_number}",
            "created_by_user_id": profile_id,
        }).execute()

        # Apply the snapshot (filter out non-updatable fields)
        update_fields = {k: v for k, v in snapshot.items() if k not in ["id", "created_at", "project_id"]}
        update_fields["current_version"] = current_version + 2
        update_fields["last_modified_by"] = profile_id
        update_fields["updated_at"] = datetime.utcnow().isoformat()

        result = client.table("backlot_call_sheets").update(update_fields).eq("id", call_sheet_id).execute()

        # Create another version after revert
        client.table("backlot_call_sheet_versions").insert({
            "call_sheet_id": call_sheet_id,
            "version_number": current_version + 2,
            "snapshot": result.data[0] if result.data else {},
            "changed_fields": list(update_fields.keys()),
            "change_summary": f"State after reverting to version {version_number}",
            "created_by_user_id": profile_id,
        }).execute()

        return {
            "success": True,
            "reverted_to": version_number,
            "new_version": current_version + 2,
            "call_sheet": result.data[0] if result.data else None
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error reverting version: {e}")
        raise HTTPException(status_code=500, detail=str(e))


async def create_call_sheet_version(client, call_sheet_id: str, call_sheet_data: dict, profile_id: str, changed_fields: list = None, summary: str = None):
    """Helper function to create a new version snapshot"""
    try:
        # Get current version number
        cs = client.table("backlot_call_sheets").select("current_version").eq("id", call_sheet_id).single().execute()
        current_version = (cs.data.get("current_version") or 0) if cs.data else 0

        # Create version snapshot
        client.table("backlot_call_sheet_versions").insert({
            "call_sheet_id": call_sheet_id,
            "version_number": current_version + 1,
            "snapshot": call_sheet_data,
            "changed_fields": changed_fields or [],
            "change_summary": summary or "Updated call sheet",
            "created_by_user_id": profile_id,
        }).execute()

        # Update version number on call sheet
        client.table("backlot_call_sheets").update({
            "current_version": current_version + 1,
            "last_modified_by": profile_id,
        }).eq("id", call_sheet_id).execute()

        return current_version + 1
    except Exception as e:
        print(f"Error creating version: {e}")
        # Don't fail the main operation if versioning fails
        return None


# =====================================================
# Call Sheet Share Link Endpoints
# =====================================================

def generate_share_token():
    """Generate a secure random token for share links"""
    return secrets.token_urlsafe(32)


def hash_password(password: str) -> str:
    """Hash a password for share link protection"""
    return hashlib.sha256(password.encode()).hexdigest()


def verify_share_password(password: str, password_hash: str) -> bool:
    """Verify a password against its hash"""
    return hash_password(password) == password_hash


@router.post("/call-sheets/{call_sheet_id}/shares")
async def create_call_sheet_share(
    call_sheet_id: str,
    share_input: CallSheetShareInput,
    authorization: str = Header(None)
):
    """Create a share link for a call sheet"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify access (require edit permission to share)
        cs = client.table("backlot_call_sheets").select("project_id, title").eq("id", call_sheet_id).execute()
        if not cs.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        await verify_project_access(client, cs.data[0]["project_id"], user["id"], require_edit=True)

        # Get profile ID
        profile_id = get_profile_id_from_cognito_id(user["id"])
        if not profile_id:
            raise HTTPException(status_code=400, detail="User profile not found")

        # Generate token
        share_token = generate_share_token()

        # Calculate expiration
        from datetime import timedelta
        expires_at = datetime.utcnow() + timedelta(days=share_input.expires_in_days)

        # Hash password if provided
        password_hash = hash_password(share_input.password) if share_input.password else None

        # Create share record
        share_data = {
            "call_sheet_id": call_sheet_id,
            "share_token": share_token,
            "created_by": profile_id,
            "expires_at": expires_at.isoformat(),
            "is_active": True,
            "password_hash": password_hash,
            "allowed_actions": share_input.allowed_actions,
            "name": share_input.name or f"Share - {cs.data[0].get('title', 'Call Sheet')}",
        }

        result = client.table("backlot_call_sheet_shares").insert(share_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create share link")

        share = result.data[0]

        # Get creator name
        creator = client.table("profiles").select("full_name").eq("id", profile_id).single().execute()
        creator_name = creator.data.get("full_name") if creator.data else None

        # Build share URL (frontend URL)
        share_url = f"{settings.FRONTEND_URL}/share/{share_token}"

        return {
            "id": share["id"],
            "call_sheet_id": share["call_sheet_id"],
            "share_token": share["share_token"],
            "share_url": share_url,
            "name": share["name"],
            "expires_at": share["expires_at"],
            "is_active": share["is_active"],
            "has_password": password_hash is not None,
            "view_count": 0,
            "last_viewed_at": None,
            "allowed_actions": share["allowed_actions"],
            "created_at": share["created_at"],
            "created_by_name": creator_name,
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating share link: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/call-sheets/{call_sheet_id}/shares")
async def get_call_sheet_shares(
    call_sheet_id: str,
    authorization: str = Header(None)
):
    """Get all share links for a call sheet"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify access
        cs = client.table("backlot_call_sheets").select("project_id").eq("id", call_sheet_id).execute()
        if not cs.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        await verify_project_access(client, cs.data[0]["project_id"], user["id"])

        # Get shares
        shares = client.table("backlot_call_sheet_shares").select("*").eq("call_sheet_id", call_sheet_id).order("created_at", desc=True).execute()

        # Get creator profiles
        creator_ids = list(set(s["created_by"] for s in (shares.data or []) if s.get("created_by")))
        profiles_map = {}
        if creator_ids:
            profiles_result = client.table("profiles").select("id, full_name").in_("id", creator_ids).execute()
            for p in (profiles_result.data or []):
                profiles_map[str(p["id"])] = p

        result = []
        for share in (shares.data or []):
            share_url = f"{settings.FRONTEND_URL}/share/{share['share_token']}"
            profile_data = profiles_map.get(str(share.get("created_by")), {})
            result.append({
                "id": share["id"],
                "call_sheet_id": share["call_sheet_id"],
                "share_token": share["share_token"],
                "share_url": share_url,
                "name": share["name"],
                "expires_at": share["expires_at"],
                "is_active": share["is_active"],
                "has_password": share["password_hash"] is not None,
                "view_count": share["view_count"],
                "last_viewed_at": share["last_viewed_at"],
                "allowed_actions": share["allowed_actions"],
                "created_at": share["created_at"],
                "created_by_name": profile_data.get("full_name"),
            })

        return {"shares": result}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching shares: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/shares/{share_id}")
async def revoke_share_link(
    share_id: str,
    authorization: str = Header(None)
):
    """Revoke (deactivate) a share link"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get share and verify access
        share = client.table("backlot_call_sheet_shares").select("call_sheet_id").eq("id", share_id).single().execute()
        if not share.data:
            raise HTTPException(status_code=404, detail="Share link not found")

        cs = client.table("backlot_call_sheets").select("project_id").eq("id", share.data["call_sheet_id"]).execute()
        if not cs.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        await verify_project_access(client, cs.data[0]["project_id"], user["id"], require_edit=True)

        # Deactivate share
        client.table("backlot_call_sheet_shares").update({"is_active": False}).eq("id", share_id).execute()

        return {"success": True, "message": "Share link revoked"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error revoking share: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/shares/{share_id}/permanent")
async def delete_share_link(
    share_id: str,
    authorization: str = Header(None)
):
    """Permanently delete a share link"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get share and verify access
        share = client.table("backlot_call_sheet_shares").select("call_sheet_id").eq("id", share_id).single().execute()
        if not share.data:
            raise HTTPException(status_code=404, detail="Share link not found")

        cs = client.table("backlot_call_sheets").select("project_id").eq("id", share.data["call_sheet_id"]).execute()
        if not cs.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        await verify_project_access(client, cs.data[0]["project_id"], user["id"], require_edit=True)

        # Delete share
        client.table("backlot_call_sheet_shares").delete().eq("id", share_id).execute()

        return {"success": True, "message": "Share link deleted"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting share: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Public Share Endpoints (No Auth Required)
# =====================================================

@router.get("/public/call-sheet/{share_token}")
async def get_public_call_sheet(
    share_token: str,
    password: Optional[str] = Query(None)
):
    """Get a call sheet via share token (public, no auth required)"""
    client = get_client()

    try:
        # Find share by token
        share = client.table("backlot_call_sheet_shares").select("*").eq("share_token", share_token).single().execute()

        if not share.data:
            raise HTTPException(status_code=404, detail="Share link not found or expired")

        # Check if active
        if not share.data.get("is_active"):
            raise HTTPException(status_code=410, detail="This share link has been revoked")

        # Check expiration
        expires_at_raw = share.data["expires_at"]
        if isinstance(expires_at_raw, str):
            expires_at = datetime.fromisoformat(expires_at_raw.replace("Z", "+00:00"))
        else:
            expires_at = expires_at_raw
        if expires_at.tzinfo is None:
            expires_at = expires_at.replace(tzinfo=timezone.utc)
        if expires_at < datetime.now(timezone.utc):
            raise HTTPException(status_code=410, detail="This share link has expired")

        # Check password if required
        if share.data.get("password_hash"):
            if not password:
                raise HTTPException(status_code=401, detail="Password required", headers={"X-Requires-Password": "true"})
            if not verify_share_password(password, share.data["password_hash"]):
                raise HTTPException(status_code=401, detail="Invalid password")

        call_sheet_id = str(share.data["call_sheet_id"])

        # Get call sheet data
        call_sheet = client.table("backlot_call_sheets").select("*").eq("id", call_sheet_id).single().execute()
        if not call_sheet.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        # Get related data
        people = client.table("backlot_call_sheet_people").select("*").eq("call_sheet_id", call_sheet_id).order("sort_order").execute()
        scenes = client.table("backlot_call_sheet_scenes").select("*").eq("call_sheet_id", call_sheet_id).order("sort_order").execute()
        locations = client.table("backlot_call_sheet_locations").select("*").eq("call_sheet_id", call_sheet_id).order("sort_order").execute()

        # Get project info
        project = client.table("backlot_projects").select("title, logo_url").eq("id", str(call_sheet.data["project_id"])).single().execute()

        # Update view count
        view_count = share.data.get("view_count")
        new_count = (int(view_count) if view_count is not None else 0) + 1
        client.table("backlot_call_sheet_shares").update({
            "view_count": new_count,
            "last_viewed_at": datetime.utcnow().isoformat()
        }).eq("id", str(share.data["id"])).execute()

        # Log view
        client.table("backlot_call_sheet_share_views").insert({
            "share_id": str(share.data["id"]),
        }).execute()

        return {
            "call_sheet": call_sheet.data,
            "people": people.data,
            "scenes": scenes.data,
            "locations": locations.data,
            "project": project.data if project.data else {},
            "allowed_actions": share.data.get("allowed_actions", ["view"]),
        }

    except HTTPException:
        raise
    except Exception as e:
        import traceback
        print(f"Error fetching public call sheet: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/public/call-sheet/{share_token}/pdf")
async def get_public_call_sheet_pdf(
    share_token: str,
    password: Optional[str] = Query(None)
):
    """Download PDF of a call sheet via share token (public, no auth required)"""
    client = get_client()

    try:
        # Find share by token
        share = client.table("backlot_call_sheet_shares").select("*").eq("share_token", share_token).single().execute()

        if not share.data:
            raise HTTPException(status_code=404, detail="Share link not found or expired")

        # Check if active
        if not share.data.get("is_active"):
            raise HTTPException(status_code=410, detail="This share link has been revoked")

        # Check expiration
        expires_at = datetime.fromisoformat(share.data["expires_at"].replace("Z", "+00:00"))
        if expires_at < datetime.now(expires_at.tzinfo):
            raise HTTPException(status_code=410, detail="This share link has expired")

        # Check password if required
        if share.data.get("password_hash"):
            if not password:
                raise HTTPException(status_code=401, detail="Password required")
            if not verify_share_password(password, share.data["password_hash"]):
                raise HTTPException(status_code=401, detail="Invalid password")

        # Check if download is allowed
        allowed_actions = share.data.get("allowed_actions", ["view"])
        if "download" not in allowed_actions and "view" not in allowed_actions:
            raise HTTPException(status_code=403, detail="Download not allowed for this share link")

        call_sheet_id = share.data["call_sheet_id"]

        # Get call sheet data
        call_sheet = client.table("backlot_call_sheets").select("*").eq("id", call_sheet_id).single().execute()
        if not call_sheet.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        # Get related data
        people = client.table("backlot_call_sheet_people").select("*").eq("call_sheet_id", call_sheet_id).order("sort_order").execute()
        scenes = client.table("backlot_call_sheet_scenes").select("*").eq("call_sheet_id", call_sheet_id).order("sort_order").execute()
        locations = client.table("backlot_call_sheet_locations").select("*").eq("call_sheet_id", call_sheet_id).order("sort_order").execute()

        # Get project info
        project = client.table("backlot_projects").select("*").eq("id", call_sheet.data["project_id"]).single().execute()

        # Generate PDF
        pdf_bytes = await create_call_sheet_pdf(
            call_sheet=call_sheet.data,
            people=people.data,
            scenes=scenes.data,
            locations=locations.data,
            project=project.data if project.data else {}
        )

        # Create filename
        title = call_sheet.data.get("title", "call-sheet")
        date = call_sheet.data.get("shoot_date", "")
        filename = f"{title.replace(' ', '_')}_{date}.pdf" if date else f"{title.replace(' ', '_')}.pdf"

        return Response(
            content=pdf_bytes,
            media_type="application/pdf",
            headers={
                "Content-Disposition": f'attachment; filename="{filename}"'
            }
        )

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error generating public PDF: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Call Sheet Scene Endpoints
# =====================================================

@router.get("/call-sheets/{call_sheet_id}/scenes", response_model=List[CallSheetScene])
async def get_call_sheet_scenes(
    call_sheet_id: str,
    authorization: str = Header(None)
):
    """Get all scenes for a call sheet"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get call sheet to verify access
    sheet_response = client.table("backlot_call_sheets").select("project_id").eq("id", call_sheet_id).execute()
    if not sheet_response.data:
        raise HTTPException(status_code=404, detail="Call sheet not found")

    project_id = sheet_response.data[0]["project_id"]
    await verify_project_access(client, project_id, user_id)

    # Get scenes
    scenes_response = client.table("backlot_call_sheet_scenes").select("*").eq("call_sheet_id", call_sheet_id).order("sort_order").execute()

    return scenes_response.data or []


@router.post("/call-sheets/{call_sheet_id}/scenes", response_model=CallSheetScene)
async def create_call_sheet_scene(
    call_sheet_id: str,
    scene: CallSheetSceneInput,
    authorization: str = Header(None)
):
    """Create a new scene for a call sheet"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get call sheet to verify access
    sheet_response = client.table("backlot_call_sheets").select("project_id").eq("id", call_sheet_id).execute()
    if not sheet_response.data:
        raise HTTPException(status_code=404, detail="Call sheet not found")

    project_id = sheet_response.data[0]["project_id"]
    await verify_project_access(client, project_id, user_id, require_edit=True)

    # Get next sort order
    max_order_response = client.table("backlot_call_sheet_scenes").select("sort_order").eq("call_sheet_id", call_sheet_id).order("sort_order", desc=True).limit(1).execute()
    next_order = (max_order_response.data[0]["sort_order"] + 1) if max_order_response.data else 0

    # Create scene
    scene_data = scene.model_dump()
    scene_data["call_sheet_id"] = call_sheet_id
    if scene_data.get("sort_order") is None:
        scene_data["sort_order"] = next_order

    result = client.table("backlot_call_sheet_scenes").insert(scene_data).execute()

    if not result.data:
        raise HTTPException(status_code=500, detail="Failed to create scene")

    return result.data[0]


@router.put("/call-sheets/{call_sheet_id}/scenes/{scene_id}", response_model=CallSheetScene)
async def update_call_sheet_scene(
    call_sheet_id: str,
    scene_id: str,
    scene: CallSheetSceneInput,
    authorization: str = Header(None)
):
    """Update a call sheet scene"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get call sheet to verify access
    sheet_response = client.table("backlot_call_sheets").select("project_id").eq("id", call_sheet_id).execute()
    if not sheet_response.data:
        raise HTTPException(status_code=404, detail="Call sheet not found")

    project_id = sheet_response.data[0]["project_id"]
    await verify_project_access(client, project_id, user_id, require_edit=True)

    # Update scene
    scene_data = scene.model_dump(exclude_unset=True)
    scene_data["updated_at"] = datetime.utcnow().isoformat()

    result = client.table("backlot_call_sheet_scenes").update(scene_data).eq("id", scene_id).eq("call_sheet_id", call_sheet_id).execute()

    if not result.data:
        raise HTTPException(status_code=404, detail="Scene not found")

    return result.data[0]


@router.delete("/call-sheets/{call_sheet_id}/scenes/{scene_id}")
async def delete_call_sheet_scene(
    call_sheet_id: str,
    scene_id: str,
    authorization: str = Header(None)
):
    """Delete a call sheet scene"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get call sheet to verify access
    sheet_response = client.table("backlot_call_sheets").select("project_id").eq("id", call_sheet_id).execute()
    if not sheet_response.data:
        raise HTTPException(status_code=404, detail="Call sheet not found")

    project_id = sheet_response.data[0]["project_id"]
    await verify_project_access(client, project_id, user_id, require_edit=True)

    # Delete scene
    client.table("backlot_call_sheet_scenes").delete().eq("id", scene_id).eq("call_sheet_id", call_sheet_id).execute()

    return {"success": True, "message": "Scene deleted"}


@router.post("/call-sheets/{call_sheet_id}/scenes/reorder")
async def reorder_call_sheet_scenes(
    call_sheet_id: str,
    scene_ids: List[str],
    authorization: str = Header(None)
):
    """Reorder scenes in a call sheet"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get call sheet to verify access
    sheet_response = client.table("backlot_call_sheets").select("project_id").eq("id", call_sheet_id).execute()
    if not sheet_response.data:
        raise HTTPException(status_code=404, detail="Call sheet not found")

    project_id = sheet_response.data[0]["project_id"]
    await verify_project_access(client, project_id, user_id, require_edit=True)

    # Update sort orders
    for index, scene_id in enumerate(scene_ids):
        client.table("backlot_call_sheet_scenes").update({"sort_order": index}).eq("id", scene_id).eq("call_sheet_id", call_sheet_id).execute()

    return {"success": True, "message": "Scenes reordered"}


# =====================================================
# Call Sheet Locations Endpoints (Multiple Locations)
# =====================================================

@router.get("/call-sheets/{call_sheet_id}/locations", response_model=List[CallSheetLocation])
async def get_call_sheet_locations(
    call_sheet_id: str,
    authorization: str = Header(None)
):
    """Get all locations for a call sheet"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get call sheet to verify access
    sheet_response = client.table("backlot_call_sheets").select("project_id").eq("id", call_sheet_id).execute()
    if not sheet_response.data:
        raise HTTPException(status_code=404, detail="Call sheet not found")

    project_id = sheet_response.data[0]["project_id"]
    await verify_project_access(client, project_id, user_id)

    # Get locations
    locations_response = client.table("backlot_call_sheet_locations").select("*").eq("call_sheet_id", call_sheet_id).order("sort_order").execute()

    return locations_response.data or []


@router.post("/call-sheets/{call_sheet_id}/locations", response_model=CallSheetLocation)
async def create_call_sheet_location(
    call_sheet_id: str,
    location: CallSheetLocationInput,
    authorization: str = Header(None)
):
    """Add a new location to a call sheet"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get call sheet to verify access
    sheet_response = client.table("backlot_call_sheets").select("project_id").eq("id", call_sheet_id).execute()
    if not sheet_response.data:
        raise HTTPException(status_code=404, detail="Call sheet not found")

    project_id = sheet_response.data[0]["project_id"]
    await verify_project_access(client, project_id, user_id, require_edit=True)

    # Get next location number and sort order
    max_response = client.table("backlot_call_sheet_locations").select("location_number, sort_order").eq("call_sheet_id", call_sheet_id).order("location_number", desc=True).limit(1).execute()
    next_number = (max_response.data[0]["location_number"] + 1) if max_response.data else 1
    next_order = (max_response.data[0]["sort_order"] + 1) if max_response.data else 0

    # Create location
    location_data = location.model_dump()
    location_data["call_sheet_id"] = call_sheet_id
    if location_data.get("location_number") is None or location_data.get("location_number") == 1:
        location_data["location_number"] = next_number
    if location_data.get("sort_order") is None:
        location_data["sort_order"] = next_order

    result = client.table("backlot_call_sheet_locations").insert(location_data).execute()

    if not result.data:
        raise HTTPException(status_code=500, detail="Failed to create location")

    return result.data[0]


@router.put("/call-sheets/{call_sheet_id}/locations/{location_entry_id}", response_model=CallSheetLocation)
async def update_call_sheet_location(
    call_sheet_id: str,
    location_entry_id: str,
    location: CallSheetLocationInput,
    authorization: str = Header(None)
):
    """Update a call sheet location"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get call sheet to verify access
    sheet_response = client.table("backlot_call_sheets").select("project_id").eq("id", call_sheet_id).execute()
    if not sheet_response.data:
        raise HTTPException(status_code=404, detail="Call sheet not found")

    project_id = sheet_response.data[0]["project_id"]
    await verify_project_access(client, project_id, user_id, require_edit=True)

    # Update location
    location_data = location.model_dump(exclude_unset=True)
    location_data["updated_at"] = datetime.utcnow().isoformat()

    result = client.table("backlot_call_sheet_locations").update(location_data).eq("id", location_entry_id).eq("call_sheet_id", call_sheet_id).execute()

    if not result.data:
        raise HTTPException(status_code=404, detail="Location not found")

    return result.data[0]


@router.delete("/call-sheets/{call_sheet_id}/locations/{location_entry_id}")
async def delete_call_sheet_location(
    call_sheet_id: str,
    location_entry_id: str,
    authorization: str = Header(None)
):
    """Delete a call sheet location"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get call sheet to verify access
    sheet_response = client.table("backlot_call_sheets").select("project_id").eq("id", call_sheet_id).execute()
    if not sheet_response.data:
        raise HTTPException(status_code=404, detail="Call sheet not found")

    project_id = sheet_response.data[0]["project_id"]
    await verify_project_access(client, project_id, user_id, require_edit=True)

    # Delete location
    client.table("backlot_call_sheet_locations").delete().eq("id", location_entry_id).eq("call_sheet_id", call_sheet_id).execute()

    return {"success": True, "message": "Location deleted"}


# =====================================================
# PDF Generation Models & Endpoints
# =====================================================

class PdfGenerateRequest(BaseModel):
    """Request to generate a PDF"""
    regenerate: bool = False
    include_logo: bool = True


class PdfGenerateResponse(BaseModel):
    """Response from PDF generation"""
    success: bool
    pdf_url: str = ""
    generated_at: str = ""
    message: str = ""


@router.post("/call-sheets/{call_sheet_id}/generate-pdf", response_model=PdfGenerateResponse)
async def generate_call_sheet_pdf_endpoint(
    call_sheet_id: str,
    request: PdfGenerateRequest = PdfGenerateRequest(),
    authorization: str = Header(None)
):
    """
    Generate a PDF for a call sheet

    This endpoint generates a professional PDF from the call sheet data
    and stores it for download.
    """
    import io

    current_user = await get_current_user_from_token(authorization)
    cognito_user_id = current_user["id"]

    # Resolve profile ID
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    if not profile_id:
        raise HTTPException(status_code=404, detail="Profile not found")

    # Get call sheet using SQLAlchemy
    call_sheet_result = execute_single(
        "SELECT * FROM backlot_call_sheets WHERE id = :call_sheet_id",
        {"call_sheet_id": call_sheet_id}
    )
    if not call_sheet_result:
        raise HTTPException(status_code=404, detail="Call sheet not found")

    call_sheet = dict(call_sheet_result)
    project_id = call_sheet["project_id"]

    # Get project
    project_result = execute_single(
        "SELECT * FROM backlot_projects WHERE id = :project_id",
        {"project_id": str(project_id)}
    )
    if not project_result:
        raise HTTPException(status_code=404, detail="Project not found")

    project = dict(project_result)

    # Verify access - check if owner or member with edit access
    is_owner = str(project.get("owner_id")) == profile_id
    if not is_owner:
        member_result = execute_single(
            "SELECT role FROM backlot_project_members WHERE project_id = :project_id AND user_id = :user_id",
            {"project_id": str(project_id), "user_id": profile_id}
        )
        if not member_result:
            raise HTTPException(status_code=403, detail="Access denied")
        role = member_result["role"]
        if role not in ("admin", "editor", "owner"):
            raise HTTPException(status_code=403, detail="Edit access required")

    # Check if PDF already exists and regenerate not requested
    if call_sheet.get("pdf_url") and not request.regenerate:
        return PdfGenerateResponse(
            success=True,
            pdf_url=call_sheet["pdf_url"],
            generated_at=call_sheet.get("pdf_generated_at", ""),
            message="PDF already exists. Use regenerate=true to create a new one."
        )

    # Get related data using SQLAlchemy
    scenes = execute_query(
        "SELECT * FROM backlot_call_sheet_scenes WHERE call_sheet_id = :call_sheet_id ORDER BY sort_order ASC",
        {"call_sheet_id": call_sheet_id}
    )
    scenes = [dict(s) for s in scenes] if scenes else []

    people = execute_query(
        "SELECT * FROM backlot_call_sheet_people WHERE call_sheet_id = :call_sheet_id ORDER BY sort_order ASC",
        {"call_sheet_id": call_sheet_id}
    )
    people = [dict(p) for p in people] if people else []

    locations = execute_query(
        "SELECT * FROM backlot_call_sheet_locations WHERE call_sheet_id = :call_sheet_id ORDER BY sort_order ASC",
        {"call_sheet_id": call_sheet_id}
    )
    locations = [dict(loc) for loc in locations] if locations else []

    # Get logo if requested
    logo_url = None
    if request.include_logo:
        logo_url = call_sheet.get("header_logo_url") or project.get("header_logo_url")

    try:
        # Generate PDF using WeasyPrint
        pdf_bytes = await create_call_sheet_pdf(
            call_sheet=call_sheet,
            project=project,
            scenes=scenes,
            people=people,
            locations=locations,
            logo_url=logo_url,
        )

        # Generate a unique filename
        call_date = call_sheet.get("date", "").replace("-", "")
        safe_title = "".join(c if c.isalnum() else "_" for c in call_sheet.get("title", "callsheet"))
        filename = f"{safe_title}_{call_date}_{uuid.uuid4().hex[:8]}.pdf"

        # Upload to AWS S3
        storage_path = f"call-sheets/{project_id}/{filename}"

        # Upload the PDF to S3 storage
        upload_file(
            bucket="backlot-files",
            path=storage_path,
            file=io.BytesIO(pdf_bytes),
            content_type="application/pdf"
        )

        # Get the public URL from S3
        pdf_url = get_signed_url("backlot-files", storage_path, expires_in=86400)  # 24 hour expiry

        generated_at = datetime.utcnow().isoformat()

        # Update the call sheet with the PDF URL using SQLAlchemy
        execute_single(
            "UPDATE backlot_call_sheets SET pdf_url = :pdf_url, pdf_generated_at = :generated_at WHERE id = :call_sheet_id RETURNING id",
            {"pdf_url": pdf_url, "generated_at": generated_at, "call_sheet_id": call_sheet_id}
        )

        return PdfGenerateResponse(
            success=True,
            pdf_url=pdf_url,
            generated_at=generated_at,
            message="PDF generated successfully"
        )

    except ImportError as e:
        return PdfGenerateResponse(
            success=False,
            pdf_url="",
            generated_at=datetime.utcnow().isoformat(),
            message=f"PDF generation requires WeasyPrint. Error: {str(e)}"
        )
    except Exception as e:
        return PdfGenerateResponse(
            success=False,
            pdf_url="",
            generated_at=datetime.utcnow().isoformat(),
            message=f"PDF generation failed: {str(e)}"
        )


# =============================================================================
# WEATHER FORECAST ENDPOINT
# =============================================================================

class WeatherForecast(BaseModel):
    """Weather forecast data"""
    condition: str
    weather_code: int
    high_temp_f: Optional[float]
    low_temp_f: Optional[float]
    precipitation_chance: int
    humidity: Optional[int]
    wind_mph: Optional[float]
    wind_direction: str
    wind_degrees: float


class HourlyWeather(BaseModel):
    """Hourly weather data"""
    time: str
    temp_f: Optional[float]
    condition: str
    precipitation_chance: int


class WeatherResponse(BaseModel):
    """Weather API response"""
    timezone: str
    timezone_offset: str
    date: str
    sunrise: Optional[str]
    sunset: Optional[str]
    forecast: WeatherForecast
    hourly: Optional[List[HourlyWeather]] = None
    formatted_text: Optional[str] = None


@router.get("/weather", response_model=WeatherResponse)
async def get_weather_forecast(
    lat: float,
    lng: float,
    date: str,
    include_hourly: bool = True,
    authorization: str = Header(None)
):
    """
    Get weather forecast for a location and date.

    Uses Open-Meteo API (free, no key required).
    Also returns timezone information for the location.

    Args:
        lat: Latitude
        lng: Longitude
        date: Date in YYYY-MM-DD format
        include_hourly: Whether to include hourly forecast data
    """
    # Basic auth check
    if not authorization:
        raise HTTPException(status_code=401, detail="Not authenticated")

    await get_current_user_from_token(authorization)

    # Validate date format
    try:
        datetime.strptime(date, "%Y-%m-%d")
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid date format. Use YYYY-MM-DD")

    # Validate coordinates
    if not (-90 <= lat <= 90):
        raise HTTPException(status_code=400, detail="Latitude must be between -90 and 90")
    if not (-180 <= lng <= 180):
        raise HTTPException(status_code=400, detail="Longitude must be between -180 and 180")

    # Fetch weather
    from app.services.weather_service import fetch_weather_forecast, format_weather_forecast_text

    weather_data = await fetch_weather_forecast(lat, lng, date, include_hourly)

    if not weather_data:
        raise HTTPException(status_code=503, detail="Weather service unavailable")

    # Add formatted text
    weather_data["formatted_text"] = format_weather_forecast_text(weather_data)

    return weather_data


@router.get("/call-sheets/{call_sheet_id}/download-pdf")
async def download_call_sheet_pdf(
    call_sheet_id: str,
    authorization: str = Header(None)
):
    """
    Download a PDF for a call sheet (direct bytes response)

    This endpoint generates and returns a PDF immediately without storing it.
    Use this for quick downloads; use generate-pdf for persisted storage.
    """
    current_user = await get_current_user_from_token(authorization)
    cognito_user_id = current_user["id"]

    # Resolve profile ID
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    if not profile_id:
        raise HTTPException(status_code=404, detail="Profile not found")

    # Get call sheet using SQLAlchemy
    call_sheet_result = execute_single(
        "SELECT * FROM backlot_call_sheets WHERE id = :call_sheet_id",
        {"call_sheet_id": call_sheet_id}
    )
    if not call_sheet_result:
        raise HTTPException(status_code=404, detail="Call sheet not found")

    call_sheet = dict(call_sheet_result)
    project_id = call_sheet["project_id"]

    # Get project
    project_result = execute_single(
        "SELECT * FROM backlot_projects WHERE id = :project_id",
        {"project_id": str(project_id)}
    )
    if not project_result:
        raise HTTPException(status_code=404, detail="Project not found")

    project = dict(project_result)

    # Verify access - check if owner or member
    is_owner = str(project.get("owner_id")) == profile_id
    if not is_owner:
        member_result = execute_single(
            "SELECT role FROM backlot_project_members WHERE project_id = :project_id AND user_id = :user_id",
            {"project_id": str(project_id), "user_id": profile_id}
        )
        if not member_result:
            raise HTTPException(status_code=403, detail="Access denied")

    # Get related data using SQLAlchemy
    scenes = execute_query(
        "SELECT * FROM backlot_call_sheet_scenes WHERE call_sheet_id = :call_sheet_id ORDER BY sort_order ASC",
        {"call_sheet_id": call_sheet_id}
    )
    scenes = [dict(s) for s in scenes] if scenes else []

    people = execute_query(
        "SELECT * FROM backlot_call_sheet_people WHERE call_sheet_id = :call_sheet_id ORDER BY sort_order ASC",
        {"call_sheet_id": call_sheet_id}
    )
    people = [dict(p) for p in people] if people else []

    locations = execute_query(
        "SELECT * FROM backlot_call_sheet_locations WHERE call_sheet_id = :call_sheet_id ORDER BY sort_order ASC",
        {"call_sheet_id": call_sheet_id}
    )
    locations = [dict(loc) for loc in locations] if locations else []

    # Get logo
    logo_url = call_sheet.get("header_logo_url") or project.get("header_logo_url")

    try:
        # Convert date/time objects to strings for PDF generation
        call_sheet_for_pdf = {}
        for key, value in call_sheet.items():
            if hasattr(value, 'isoformat'):
                call_sheet_for_pdf[key] = str(value)
            else:
                call_sheet_for_pdf[key] = value

        # Generate PDF using the renamed import
        pdf_bytes = await create_call_sheet_pdf(
            call_sheet=call_sheet_for_pdf,
            project=project,
            scenes=scenes,
            people=people,
            locations=locations,
            logo_url=logo_url,
        )

        # Create filename - handle date as string or date object
        date_val = call_sheet.get("date", "")
        if hasattr(date_val, 'strftime'):
            call_date = date_val.strftime("%Y%m%d")
        else:
            call_date = str(date_val).replace("-", "") if date_val else ""
        safe_title = "".join(c if c.isalnum() else "_" for c in str(call_sheet.get("title", "callsheet")))
        filename = f"{safe_title}_{call_date}.pdf"

        return Response(
            content=pdf_bytes,
            media_type="application/pdf",
            headers={
                "Content-Disposition": f'attachment; filename="{filename}"'
            }
        )

    except Exception as e:
        import traceback
        print(f"PDF generation error: {e}")
        print(traceback.format_exc())
        raise HTTPException(status_code=500, detail=f"PDF generation failed: {str(e)}")


@router.get("/call-sheets/{call_sheet_id}/download-excel")
async def download_call_sheet_excel(
    call_sheet_id: str,
    authorization: str = Header(None)
):
    """
    Download an Excel file for a call sheet

    Returns a professionally formatted Excel workbook with multiple sheets:
    - Overview: Summary with call times and general info
    - Cast & Crew: All personnel with contact info
    - Scenes: Scene breakdown
    - Locations: Location details with contacts
    """
    # Check if Excel export is available
    if not EXCEL_EXPORT_AVAILABLE or generate_call_sheet_excel is None:
        raise HTTPException(
            status_code=501,
            detail="Excel export is not available. Please install openpyxl: pip install openpyxl"
        )

    current_user = await get_current_user_from_token(authorization)
    cognito_user_id = current_user["id"]

    # Resolve profile ID
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    if not profile_id:
        raise HTTPException(status_code=404, detail="Profile not found")

    # Get call sheet using SQLAlchemy
    call_sheet_result = execute_single(
        "SELECT * FROM backlot_call_sheets WHERE id = :call_sheet_id",
        {"call_sheet_id": call_sheet_id}
    )
    if not call_sheet_result:
        raise HTTPException(status_code=404, detail="Call sheet not found")

    call_sheet = dict(call_sheet_result)
    project_id = call_sheet["project_id"]

    # Get project
    project_result = execute_single(
        "SELECT * FROM backlot_projects WHERE id = :project_id",
        {"project_id": str(project_id)}
    )
    if not project_result:
        raise HTTPException(status_code=404, detail="Project not found")

    project = dict(project_result)

    # Verify access - check if owner or member
    is_owner = str(project.get("owner_id")) == profile_id
    if not is_owner:
        member_result = execute_single(
            "SELECT role FROM backlot_project_members WHERE project_id = :project_id AND user_id = :user_id",
            {"project_id": str(project_id), "user_id": profile_id}
        )
        if not member_result:
            raise HTTPException(status_code=403, detail="Access denied")

    # Get related data using SQLAlchemy
    scenes = execute_query(
        "SELECT * FROM backlot_call_sheet_scenes WHERE call_sheet_id = :call_sheet_id ORDER BY sort_order ASC",
        {"call_sheet_id": call_sheet_id}
    )
    scenes = [dict(s) for s in scenes] if scenes else []

    people = execute_query(
        "SELECT * FROM backlot_call_sheet_people WHERE call_sheet_id = :call_sheet_id ORDER BY sort_order ASC",
        {"call_sheet_id": call_sheet_id}
    )
    people = [dict(p) for p in people] if people else []

    locations = execute_query(
        "SELECT * FROM backlot_call_sheet_locations WHERE call_sheet_id = :call_sheet_id ORDER BY sort_order ASC",
        {"call_sheet_id": call_sheet_id}
    )
    locations = [dict(loc) for loc in locations] if locations else []

    try:
        # Convert date/time objects to strings for Excel generation
        call_sheet_for_excel = {}
        for key, value in call_sheet.items():
            if hasattr(value, 'isoformat'):
                call_sheet_for_excel[key] = str(value)
            else:
                call_sheet_for_excel[key] = value

        # Generate Excel
        excel_bytes = await generate_call_sheet_excel(
            call_sheet=call_sheet_for_excel,
            people=people,
            scenes=scenes,
            locations=locations,
            project=project,
        )

        # Create filename
        date_val = call_sheet.get("date", "")
        if hasattr(date_val, 'strftime'):
            call_date = date_val.strftime("%Y%m%d")
        else:
            call_date = str(date_val).replace("-", "") if date_val else ""
        safe_title = "".join(c if c.isalnum() else "_" for c in str(call_sheet.get("title", "callsheet")))
        filename = f"{safe_title}_{call_date}.xlsx"

        return Response(
            content=excel_bytes,
            media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            headers={
                "Content-Disposition": f'attachment; filename="{filename}"'
            }
        )

    except Exception as e:
        import traceback
        print(f"Excel generation error: {e}")
        print(traceback.format_exc())
        raise HTTPException(status_code=500, detail=f"Excel generation failed: {str(e)}")


# =====================================================
# Logo Upload Models & Endpoints
# =====================================================

class LogoUploadResponse(BaseModel):
    """Response from logo upload"""
    success: bool
    logo_url: str = ""
    message: str = ""


@router.post("/projects/{project_id}/upload-logo", response_model=LogoUploadResponse)
async def upload_project_logo(
    project_id: str,
    authorization: str = Header(None)
):
    """
    Upload a logo for project call sheets

    Note: This endpoint expects the file to be uploaded via multipart form data.
    For the current implementation, the frontend will upload directly to S3 Storage
    and then call this endpoint to update the project with the logo URL.
    """
    # This is a placeholder - actual file upload would need FastAPI's File/UploadFile
    # In the current architecture, we handle file uploads on the frontend via S3 Storage
    # and just update the database record here

    raise HTTPException(
        status_code=501,
        detail="Logo upload is handled directly via S3 Storage on the frontend. "
               "Use the /projects/{project_id}/set-logo endpoint to set the logo URL after uploading."
    )


class SetLogoRequest(BaseModel):
    """Request to set logo URL"""
    logo_url: str
    filename: Optional[str] = None


class ProjectLogo(BaseModel):
    """Project logo model"""
    id: str
    project_id: str
    logo_url: str
    filename: Optional[str] = None
    is_active: bool = False
    uploaded_by_user_id: Optional[str] = None
    created_at: Optional[str] = None
    updated_at: Optional[str] = None


@router.post("/projects/{project_id}/set-logo", response_model=LogoUploadResponse)
async def set_project_logo(
    project_id: str,
    request: SetLogoRequest,
    authorization: str = Header(None)
):
    """
    Set the logo URL for a project (after uploading to storage).
    Also saves to the logos table and marks it as active.
    """
    current_user = await get_current_user_from_token(authorization)
    cognito_user_id = current_user["id"]

    client = get_client()

    # Get profile ID
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    if not profile_id:
        raise HTTPException(status_code=404, detail="Profile not found")

    # Verify access
    await verify_project_access(client, project_id, profile_id, require_edit=True)

    # Deactivate all existing logos for this project
    client.table("backlot_project_logos").update({
        "is_active": False
    }).eq("project_id", project_id).execute()

    # Save the new logo to the logos table and mark as active
    logo_result = client.table("backlot_project_logos").insert({
        "project_id": project_id,
        "logo_url": request.logo_url,
        "filename": request.filename,
        "is_active": True,
        "uploaded_by_user_id": profile_id
    }).execute()

    # Update project with logo URL
    result = client.table("backlot_projects").update({
        "header_logo_url": request.logo_url
    }).eq("id", project_id).execute()

    if not result.data:
        raise HTTPException(status_code=500, detail="Failed to update project logo")

    return LogoUploadResponse(
        success=True,
        logo_url=request.logo_url,
        message="Project logo updated successfully"
    )


@router.get("/projects/{project_id}/logos")
async def get_project_logos(
    project_id: str,
    authorization: str = Header(None)
):
    """Get all logos uploaded for a project"""
    current_user = await get_current_user_from_token(authorization)
    cognito_user_id = current_user["id"]

    client = get_client()

    # Get profile ID
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    if not profile_id:
        raise HTTPException(status_code=404, detail="Profile not found")

    # Verify access
    await verify_project_access(client, project_id, profile_id)

    # Get all logos for this project, ordered by most recent first
    result = client.table("backlot_project_logos").select("*").eq(
        "project_id", project_id
    ).order("created_at", desc=True).execute()

    return {"logos": result.data or []}


@router.get("/projects/{project_id}/logos/active")
async def get_active_project_logo(
    project_id: str,
    authorization: str = Header(None)
):
    """Get the currently active logo for a project"""
    current_user = await get_current_user_from_token(authorization)
    cognito_user_id = current_user["id"]

    client = get_client()

    # Get profile ID
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    if not profile_id:
        raise HTTPException(status_code=404, detail="Profile not found")

    # Verify access
    await verify_project_access(client, project_id, profile_id)

    # Get active logo
    result = client.table("backlot_project_logos").select("*").eq(
        "project_id", project_id
    ).eq("is_active", True).execute()

    if result.data:
        return {"logo": result.data[0]}

    # If no active logo, return the most recent one
    result = client.table("backlot_project_logos").select("*").eq(
        "project_id", project_id
    ).order("created_at", desc=True).limit(1).execute()

    return {"logo": result.data[0] if result.data else None}


@router.put("/projects/{project_id}/logos/{logo_id}/activate")
async def activate_project_logo(
    project_id: str,
    logo_id: str,
    authorization: str = Header(None)
):
    """Set a specific logo as the active logo for call sheets"""
    current_user = await get_current_user_from_token(authorization)
    cognito_user_id = current_user["id"]

    client = get_client()

    # Get profile ID
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    if not profile_id:
        raise HTTPException(status_code=404, detail="Profile not found")

    # Verify access
    await verify_project_access(client, project_id, profile_id, require_edit=True)

    # Verify the logo belongs to this project
    logo_result = client.table("backlot_project_logos").select("*").eq(
        "id", logo_id
    ).eq("project_id", project_id).execute()

    if not logo_result.data:
        raise HTTPException(status_code=404, detail="Logo not found")

    logo = logo_result.data[0]

    # Deactivate all logos for this project
    client.table("backlot_project_logos").update({
        "is_active": False
    }).eq("project_id", project_id).execute()

    # Activate the selected logo
    client.table("backlot_project_logos").update({
        "is_active": True,
        "updated_at": datetime.utcnow().isoformat()
    }).eq("id", logo_id).execute()

    # Update the project header_logo_url
    client.table("backlot_projects").update({
        "header_logo_url": logo["logo_url"]
    }).eq("id", project_id).execute()

    return {"success": True, "logo": logo}


@router.delete("/projects/{project_id}/logos/{logo_id}")
async def delete_project_logo(
    project_id: str,
    logo_id: str,
    authorization: str = Header(None)
):
    """Delete a logo from the project's logo library"""
    current_user = await get_current_user_from_token(authorization)
    cognito_user_id = current_user["id"]

    client = get_client()

    # Get profile ID
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    if not profile_id:
        raise HTTPException(status_code=404, detail="Profile not found")

    # Verify access
    await verify_project_access(client, project_id, profile_id, require_edit=True)

    # Verify the logo belongs to this project
    logo_result = client.table("backlot_project_logos").select("*").eq(
        "id", logo_id
    ).eq("project_id", project_id).execute()

    if not logo_result.data:
        raise HTTPException(status_code=404, detail="Logo not found")

    was_active = logo_result.data[0].get("is_active", False)

    # Delete the logo
    client.table("backlot_project_logos").delete().eq("id", logo_id).execute()

    # If the deleted logo was active, make the most recent remaining logo active
    if was_active:
        remaining = client.table("backlot_project_logos").select("*").eq(
            "project_id", project_id
        ).order("created_at", desc=True).limit(1).execute()

        if remaining.data:
            new_active = remaining.data[0]
            client.table("backlot_project_logos").update({
                "is_active": True
            }).eq("id", new_active["id"]).execute()

            client.table("backlot_projects").update({
                "header_logo_url": new_active["logo_url"]
            }).eq("id", project_id).execute()
        else:
            # No logos left, clear the project's header_logo_url
            client.table("backlot_projects").update({
                "header_logo_url": None
            }).eq("id", project_id).execute()

    return {"success": True, "message": "Logo deleted"}


# =====================================================
# Sync Models & Endpoints
# =====================================================

class SyncRequest(BaseModel):
    """Request to sync call sheet data to other Backlot tools"""
    sync_production_day: bool = True
    sync_locations: bool = True
    sync_tasks: bool = True


class SyncResponse(BaseModel):
    """Response from sync operation"""
    success: bool
    production_day_synced: bool = False
    locations_created: int = 0
    tasks_created: int = 0
    message: str = ""


@router.post("/call-sheets/{call_sheet_id}/sync", response_model=SyncResponse)
async def sync_call_sheet_data(
    call_sheet_id: str,
    request: SyncRequest,
    authorization: str = Header(None)
):
    """
    Sync call sheet data to other Backlot tools

    This will:
    - Create/update a production day from the call sheet
    - Create locations from unique location entries
    - Create tasks for department prep items
    """
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get call sheet with all data
    sheet_response = client.table("backlot_call_sheets").select("*").eq("id", call_sheet_id).execute()
    if not sheet_response.data:
        raise HTTPException(status_code=404, detail="Call sheet not found")

    call_sheet = sheet_response.data[0]
    project_id = call_sheet["project_id"]

    # Verify access
    await verify_project_access(client, project_id, user_id, require_edit=True)

    production_day_synced = False
    locations_created = 0
    tasks_created = 0

    # Sync Production Day
    if request.sync_production_day:
        production_day_id = call_sheet.get("production_day_id")

        # Get primary location from call sheet locations table
        primary_location = client.table("backlot_call_sheet_locations").select("*").eq("call_sheet_id", call_sheet_id).eq("location_number", 1).execute()
        primary_loc = primary_location.data[0] if primary_location.data else None

        day_data = {
            "project_id": project_id,
            "date": call_sheet["date"],
            "title": call_sheet.get("title"),
            "general_call_time": call_sheet.get("general_call_time") or call_sheet.get("crew_call_time"),
            "wrap_time": call_sheet.get("estimated_wrap_time"),
            "location_name": primary_loc.get("name") if primary_loc else call_sheet.get("location_name"),
            "location_address": primary_loc.get("address") if primary_loc else call_sheet.get("location_address"),
            "weather_notes": call_sheet.get("weather_forecast") or call_sheet.get("weather_info"),
            "notes": call_sheet.get("general_notes"),
        }

        # Add day number if available
        if call_sheet.get("shoot_day_number"):
            day_data["day_number"] = call_sheet["shoot_day_number"]

        if production_day_id:
            # Update existing production day
            client.table("backlot_production_days").update(day_data).eq("id", production_day_id).execute()
            production_day_synced = True
        else:
            # Check if a production day exists for this date
            existing_day = client.table("backlot_production_days").select("id").eq("project_id", project_id).eq("date", call_sheet["date"]).execute()

            if existing_day.data:
                # Link and update existing day
                production_day_id = existing_day.data[0]["id"]
                client.table("backlot_production_days").update(day_data).eq("id", production_day_id).execute()
                client.table("backlot_call_sheets").update({"production_day_id": production_day_id}).eq("id", call_sheet_id).execute()
            else:
                # Get next day number
                if not day_data.get("day_number"):
                    max_day = client.table("backlot_production_days").select("day_number").eq("project_id", project_id).order("day_number", desc=True).limit(1).execute()
                    day_data["day_number"] = (max_day.data[0]["day_number"] + 1) if max_day.data else 1

                # Create new production day
                result = client.table("backlot_production_days").insert(day_data).execute()
                if result.data:
                    production_day_id = result.data[0]["id"]
                    client.table("backlot_call_sheets").update({"production_day_id": production_day_id}).eq("id", call_sheet_id).execute()

            production_day_synced = True

    # Sync Locations from call sheet locations and scenes
    if request.sync_locations:
        # Sync from call sheet locations table
        cs_locations = client.table("backlot_call_sheet_locations").select("*").eq("call_sheet_id", call_sheet_id).is_("location_id", "null").execute()

        for cs_loc in cs_locations.data or []:
            loc_name = cs_loc.get("name")
            if loc_name:
                # Check if location already exists
                existing = client.table("backlot_locations").select("id").eq("project_id", project_id).eq("name", loc_name).execute()

                if not existing.data:
                    # Create new location
                    location_data = {
                        "project_id": project_id,
                        "name": loc_name,
                        "address": cs_loc.get("address"),
                        "parking_notes": cs_loc.get("parking_instructions"),
                    }
                    result = client.table("backlot_locations").insert(location_data).execute()

                    if result.data:
                        # Link call sheet location to master location
                        client.table("backlot_call_sheet_locations").update({"location_id": result.data[0]["id"]}).eq("id", cs_loc["id"]).execute()
                        locations_created += 1
                else:
                    # Link to existing location
                    client.table("backlot_call_sheet_locations").update({"location_id": existing.data[0]["id"]}).eq("id", cs_loc["id"]).execute()

        # Sync from scenes
        scenes_response = client.table("backlot_call_sheet_scenes").select("*").eq("call_sheet_id", call_sheet_id).is_("location_id", "null").execute()

        for scene in scenes_response.data or []:
            set_name = scene.get("set_name")
            if set_name:
                # Check if location already exists
                existing = client.table("backlot_locations").select("id").eq("project_id", project_id).eq("name", set_name).execute()

                if not existing.data:
                    # Create new location
                    location_data = {
                        "project_id": project_id,
                        "name": set_name,
                        "scene_description": scene.get("description"),
                    }
                    result = client.table("backlot_locations").insert(location_data).execute()

                    if result.data:
                        # Link scene to location
                        client.table("backlot_call_sheet_scenes").update({"location_id": result.data[0]["id"]}).eq("id", scene["id"]).execute()
                        locations_created += 1
                else:
                    # Link scene to existing location
                    client.table("backlot_call_sheet_scenes").update({"location_id": existing.data[0]["id"]}).eq("id", scene["id"]).execute()

    # Sync Tasks from department notes
    if request.sync_tasks:
        department_notes = [
            ("camera_notes", "Camera Department"),
            ("sound_notes", "Sound Department"),
            ("grip_electric_notes", "Grip & Electric"),
            ("art_notes", "Art Department"),
            ("wardrobe_notes", "Wardrobe"),
            ("makeup_hair_notes", "Makeup & Hair"),
            ("stunts_notes", "Stunts"),
            ("vfx_notes", "VFX"),
            ("transport_notes", "Transportation"),
            ("catering_notes", "Catering"),
        ]

        production_day_id = call_sheet.get("production_day_id")

        for note_field, department in department_notes:
            note_content = call_sheet.get(note_field)
            if note_content and note_content.strip():
                # Check if task already exists from this call sheet for this department
                existing_task = client.table("backlot_tasks").select("id").eq("source_call_sheet_id", call_sheet_id).eq("department", department).execute()

                if not existing_task.data:
                    task_data = {
                        "project_id": project_id,
                        "title": f"{department} - {call_sheet.get('title', 'Call Sheet')}",
                        "description": note_content,
                        "department": department,
                        "due_date": call_sheet["date"],
                        "status": "todo",
                        "priority": "medium",
                        "production_day_id": production_day_id,
                        "source_type": "call_sheet",
                        "source_call_sheet_id": call_sheet_id,
                        "created_by": user_id,
                    }
                    result = client.table("backlot_tasks").insert(task_data).execute()
                    if result.data:
                        tasks_created += 1

    return SyncResponse(
        success=True,
        production_day_synced=production_day_synced,
        locations_created=locations_created,
        tasks_created=tasks_created,
        message=f"Synced call sheet data: {'production day updated, ' if production_day_synced else ''}{locations_created} locations, {tasks_created} tasks"
    )


# =====================================================
# BUDGET SYSTEM - Models
# =====================================================

class BudgetInput(BaseModel):
    """Input for creating/updating a budget"""
    name: Optional[str] = "Main Budget"
    description: Optional[str] = None
    currency: Optional[str] = "USD"
    status: Optional[str] = "draft"
    contingency_percent: Optional[float] = 10.0
    notes: Optional[str] = None
    # Professional budget fields
    project_type_template: Optional[str] = "feature"
    shoot_days: Optional[int] = None
    prep_days: Optional[int] = None
    wrap_days: Optional[int] = None
    post_days: Optional[int] = None
    episode_count: Optional[int] = None
    union_type: Optional[str] = "non_union"


class BudgetCategoryInput(BaseModel):
    """Input for creating/updating a budget category"""
    name: str
    code: Optional[str] = None
    description: Optional[str] = None
    sort_order: Optional[int] = 0
    color: Optional[str] = None
    icon: Optional[str] = None
    # Professional budget fields
    category_type: Optional[str] = "production"
    account_code_prefix: Optional[str] = None
    phase: Optional[str] = None
    is_above_the_line: Optional[bool] = False
    # Sales tax fields
    is_taxable: Optional[bool] = False
    tax_rate: Optional[float] = 0  # Stored as decimal (e.g., 0.0825 for 8.25%)


class BudgetLineItemInput(BaseModel):
    """Input for creating/updating a budget line item"""
    category_id: Optional[str] = None
    account_code: Optional[str] = None
    description: str
    rate_type: Optional[str] = "flat"
    rate_amount: Optional[float] = 0
    quantity: Optional[float] = 1
    units: Optional[str] = None
    actual_total: Optional[float] = None
    vendor_name: Optional[str] = None
    po_number: Optional[str] = None
    invoice_reference: Optional[str] = None
    notes: Optional[str] = None
    internal_notes: Optional[str] = None
    is_locked: Optional[bool] = False
    sort_order: Optional[int] = 0
    # Professional budget fields
    calc_mode: Optional[str] = "flat"
    days: Optional[float] = None
    weeks: Optional[float] = None
    episodes: Optional[int] = None
    union_code: Optional[str] = None
    is_fringe: Optional[bool] = False
    fringe_base_item_id: Optional[str] = None
    fringe_percent: Optional[float] = None
    source_type: Optional[str] = None
    source_id: Optional[str] = None
    sub_account_code: Optional[str] = None
    phase: Optional[str] = None
    department: Optional[str] = None
    manual_total_override: Optional[float] = None
    use_manual_total: Optional[bool] = False


# Professional Budget Input Models
class CreateBudgetFromTemplateInput(BaseModel):
    """Input for creating a budget from a project type template"""
    project_type: str = "feature"
    name: Optional[str] = "Main Budget"
    shoot_days: Optional[int] = 0
    prep_days: Optional[int] = 0
    wrap_days: Optional[int] = 0
    post_days: Optional[int] = 0
    episode_count: Optional[int] = 1
    union_type: Optional[str] = "non_union"
    include_common_only: Optional[bool] = True


class Budget(BaseModel):
    """Budget response model"""
    id: str
    project_id: str
    name: str
    description: Optional[str]
    currency: str
    status: str
    approved_by: Optional[str]
    approved_at: Optional[str]
    locked_at: Optional[str]
    estimated_total: float
    actual_total: float
    variance: float
    contingency_percent: float
    contingency_amount: float
    notes: Optional[str]
    version: int
    created_by: Optional[str]
    created_at: str
    updated_at: str
    # Professional budget fields
    project_type_template: Optional[str] = "feature"
    has_top_sheet: Optional[bool] = False
    pdf_url: Optional[str] = None
    last_pdf_generated_at: Optional[str] = None
    fringes_total: Optional[float] = 0
    grand_total: Optional[float] = 0
    shoot_days: Optional[int] = 0
    prep_days: Optional[int] = 0
    wrap_days: Optional[int] = 0
    post_days: Optional[int] = 0
    episode_count: Optional[int] = 1
    union_type: Optional[str] = "non_union"


class BudgetCategory(BaseModel):
    """Budget category response model"""
    id: str
    budget_id: str
    name: str
    code: Optional[str]
    description: Optional[str]
    estimated_subtotal: float
    actual_subtotal: float
    sort_order: int
    color: Optional[str]
    icon: Optional[str]
    created_at: str
    updated_at: str
    # Professional budget fields
    category_type: Optional[str] = "production"
    account_code_prefix: Optional[str] = None
    phase: Optional[str] = None
    is_above_the_line: Optional[bool] = False
    # Sales tax fields
    is_taxable: bool = False
    tax_rate: float = 0


class BudgetLineItem(BaseModel):
    """Budget line item response model"""
    id: str
    budget_id: str
    category_id: Optional[str]
    account_code: Optional[str]
    description: str
    rate_type: str
    rate_amount: float
    quantity: float
    units: Optional[str]
    estimated_total: float
    actual_total: float
    variance: float
    vendor_name: Optional[str]
    po_number: Optional[str]
    invoice_reference: Optional[str]
    notes: Optional[str]
    internal_notes: Optional[str]
    is_allocated_to_days: bool
    total_allocated: float
    is_locked: bool
    sort_order: int
    created_at: str
    updated_at: str
    # Professional budget fields
    calc_mode: Optional[str] = "flat"
    days: Optional[float] = None
    weeks: Optional[float] = None
    episodes: Optional[int] = None
    union_code: Optional[str] = None
    is_fringe: Optional[bool] = False
    fringe_base_item_id: Optional[str] = None
    fringe_percent: Optional[float] = None
    source_type: Optional[str] = None
    source_id: Optional[str] = None
    sub_account_code: Optional[str] = None
    phase: Optional[str] = None
    department: Optional[str] = None
    manual_total_override: Optional[float] = None
    use_manual_total: Optional[bool] = False
    # Tax line item fields
    is_tax_line_item: bool = False
    tax_source_category_id: Optional[str] = None


# Professional Budget Response Models
class TopSheetCategoryRow(BaseModel):
    """A single category row in a TopSheet section"""
    code: Optional[str]
    name: str
    estimated: float
    actual: float
    variance: float


class TopSheetSection(BaseModel):
    """A section of the TopSheet (e.g., Above the Line, Production, etc.)"""
    label: str
    total: float
    categories: List[TopSheetCategoryRow]


class TopSheetData(BaseModel):
    """Top Sheet summary data - structured for frontend display"""
    budget_id: str
    project_title: str
    project_type: str
    prepared_date: str
    # Category type breakdowns
    above_the_line: TopSheetSection
    production: TopSheetSection
    post: TopSheetSection
    other: TopSheetSection
    # Totals
    subtotal: float
    contingency_percent: float
    contingency_amount: float
    fringes_total: float
    grand_total: float
    # Metadata
    is_stale: bool
    last_computed: str


class BudgetAccountTemplate(BaseModel):
    """Budget account template from registry"""
    id: str
    project_type: str
    account_code: str
    sub_code: Optional[str]
    name: str
    description: Optional[str]
    category_type: str
    category_name: str
    department: Optional[str]
    phase: Optional[str]
    default_calc_mode: str
    default_units: Optional[str]
    sort_order: int
    is_common: bool
    aicp_code: Optional[str] = None
    dga_code: Optional[str] = None


class BudgetTemplatePreview(BaseModel):
    """Preview of what template will create"""
    project_type: str
    category_count: int
    line_item_count: int
    categories: List[dict]


# =============================================================================
# BUDGET BUNDLE MODELS (for intentional budget creation)
# =============================================================================

class BundleLineItemResponse(BaseModel):
    """A line item within a bundle category"""
    account_code: str
    description: str
    calc_mode: str = "flat"
    default_units: str = ""
    department: Optional[str] = None
    phase: Optional[str] = None
    is_essential: bool = False


class BundleCategoryResponse(BaseModel):
    """A category within a bundle"""
    name: str
    code: str
    account_code_prefix: str
    category_type: str  # above_the_line, production, post, other
    sort_order: int
    color: str = "#6b7280"
    line_items: List[BundleLineItemResponse] = []


class DepartmentBundleResponse(BaseModel):
    """A department bundle - a small set of common line items"""
    id: str
    name: str
    description: str
    category_type: str
    icon: str = ""
    categories: List[BundleCategoryResponse]
    total_line_items: int = 0
    is_recommended: bool = False


class BundleListResponse(BaseModel):
    """Response containing all available bundles"""
    bundles: List[DepartmentBundleResponse]
    project_types: List[str]
    category_types: List[str]


class RecommendedBundlesResponse(BaseModel):
    """Response with recommended bundles for a project type"""
    project_type: str
    recommended: List[DepartmentBundleResponse]
    core_essentials: List[DepartmentBundleResponse]
    all_available: List[DepartmentBundleResponse]


class CreateBudgetFromBundlesInput(BaseModel):
    """Input for creating a budget from selected bundles"""
    name: str = "Main Budget"
    project_type: str = "feature"
    currency: str = "USD"
    contingency_percent: float = 10.0
    shoot_days: int = 0
    prep_days: int = 0
    wrap_days: int = 0
    post_days: int = 0
    episode_count: int = 1
    union_type: str = "non_union"
    # Seeding options
    seed_mode: str = "bundles"  # "blank" | "categories_only" | "bundles" | "essentials"
    selected_bundle_ids: List[str] = []  # Bundle IDs to include
    # High-level category toggles (for "categories_only" mode)
    include_above_the_line: bool = True
    include_production: bool = True
    include_post: bool = True
    include_other: bool = True


class BudgetCreationResult(BaseModel):
    """Result of creating a budget from bundles"""
    budget: Budget
    categories_created: int
    line_items_created: int
    bundles_used: List[str]
    seed_mode: str


class BudgetSummary(BaseModel):
    """Budget summary response"""
    budget: Budget
    categories: List[BudgetCategory]
    total_line_items: int
    total_receipts: int
    unmapped_receipts: int
    daily_budgets_count: int


class BudgetStats(BaseModel):
    """Budget statistics"""
    estimated_total: float
    actual_total: float
    variance: float
    variance_percent: float
    receipt_total: float
    unmapped_receipt_total: float
    categories_over_budget: int
    categories_under_budget: int
    days_over_budget: int


# Helper function to verify budget access
async def verify_budget_access(client, project_id: str, user_id: str, require_edit: bool = False):
    """Verify user has access to project budgets (producers/admins only)"""
    # Check if project owner
    project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    project = project_response.data[0]
    if project["owner_id"] == user_id:
        return True

    # Check membership with producer/PM role
    member_response = client.table("backlot_project_members").select(
        "role, production_role"
    ).eq("project_id", project_id).eq("user_id", user_id).execute()

    if not member_response.data:
        raise HTTPException(status_code=403, detail="Access denied - not a project member")

    member = member_response.data[0]
    role = member.get("role", "")
    production_role = (member.get("production_role") or "").lower()

    # Admins and owners can access
    if role in ["owner", "admin"]:
        return True

    # Producers and production managers can access
    if any(r in production_role for r in ["producer", "production manager", "pm", "upm", "line producer"]):
        return True

    raise HTTPException(status_code=403, detail="Access denied - budget access requires producer/admin role")


# =====================================================
# BUDGET CRUD ENDPOINTS
# =====================================================

@router.get("/projects/{project_id}/budget", response_model=Budget)
async def get_project_budget(
    project_id: str,
    authorization: str = Header(None)
):
    """Get the main budget for a project"""
    from app.services.feature_gates import enforce_project_feature
    enforce_project_feature(project_id, "BUDGETING")

    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()
    await verify_budget_access(client, project_id, user_id)

    # Get budget
    response = client.table("backlot_budgets").select("*").eq("project_id", project_id).execute()

    if not response.data:
        raise HTTPException(status_code=404, detail="No budget found for this project")

    return response.data[0]


@router.get("/projects/{project_id}/budget/summary", response_model=BudgetSummary)
async def get_budget_summary(
    project_id: str,
    authorization: str = Header(None)
):
    """Get budget with categories and stats"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()
    await verify_budget_access(client, project_id, user_id)

    # Get budget
    budget_response = client.table("backlot_budgets").select("*").eq("project_id", project_id).execute()
    if not budget_response.data:
        raise HTTPException(status_code=404, detail="No budget found for this project")

    budget = budget_response.data[0]
    budget_id = budget["id"]

    # Get categories
    categories_response = client.table("backlot_budget_categories").select("*").eq("budget_id", budget_id).order("sort_order").execute()

    # Get line item count
    line_items_response = client.table("backlot_budget_line_items").select("id", count="exact").eq("budget_id", budget_id).execute()

    # Get receipt counts
    receipts_response = client.table("backlot_receipts").select("id, is_mapped", count="exact").eq("budget_id", budget_id).execute()
    total_receipts = receipts_response.count if hasattr(receipts_response, 'count') else len(receipts_response.data or [])
    unmapped_receipts = len([r for r in (receipts_response.data or []) if not r.get("is_mapped")])

    # Get daily budgets count
    daily_response = client.table("backlot_daily_budgets").select("id", count="exact").eq("budget_id", budget_id).execute()
    daily_count = daily_response.count if hasattr(daily_response, 'count') else len(daily_response.data or [])

    return BudgetSummary(
        budget=Budget(**budget),
        categories=[BudgetCategory(**c) for c in (categories_response.data or [])],
        total_line_items=line_items_response.count if hasattr(line_items_response, 'count') else len(line_items_response.data or []),
        total_receipts=total_receipts,
        unmapped_receipts=unmapped_receipts,
        daily_budgets_count=daily_count
    )


@router.post("/projects/{project_id}/budget", response_model=Budget)
async def create_budget(
    project_id: str,
    budget_input: BudgetInput = BudgetInput(),
    authorization: str = Header(None)
):
    """Create a budget for a project"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()
    await verify_budget_access(client, project_id, user_id)

    # Check if budget already exists
    existing = client.table("backlot_budgets").select("id").eq("project_id", project_id).eq("name", budget_input.name or "Main Budget").execute()
    if existing.data:
        raise HTTPException(status_code=400, detail="A budget with this name already exists for this project")

    # Create budget
    budget_data = budget_input.model_dump(exclude_unset=True)
    budget_data["project_id"] = project_id
    budget_data["created_by"] = user_id

    result = client.table("backlot_budgets").insert(budget_data).execute()
    if not result.data:
        raise HTTPException(status_code=500, detail="Failed to create budget")

    budget = result.data[0]

    # Create default categories
    default_categories = [
        {"name": "Pre-Production", "code": "A", "sort_order": 0, "icon": "clipboard"},
        {"name": "Cast", "code": "B", "sort_order": 1, "icon": "users"},
        {"name": "Crew", "code": "C", "sort_order": 2, "icon": "hard-hat"},
        {"name": "Equipment", "code": "D", "sort_order": 3, "icon": "camera"},
        {"name": "Locations", "code": "E", "sort_order": 4, "icon": "map-pin"},
        {"name": "Production", "code": "F", "sort_order": 5, "icon": "film"},
        {"name": "Post-Production", "code": "G", "sort_order": 6, "icon": "edit"},
        {"name": "Other", "code": "H", "sort_order": 7, "icon": "more-horizontal"},
    ]

    for cat in default_categories:
        cat["budget_id"] = budget["id"]
        client.table("backlot_budget_categories").insert(cat).execute()

    return budget


@router.put("/projects/{project_id}/budget", response_model=Budget)
async def update_budget(
    project_id: str,
    budget_input: BudgetInput,
    authorization: str = Header(None)
):
    """Update the project budget"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()
    await verify_budget_access(client, project_id, user_id)

    # Get existing budget
    existing = client.table("backlot_budgets").select("id, status").eq("project_id", project_id).execute()
    if not existing.data:
        raise HTTPException(status_code=404, detail="Budget not found")

    budget = existing.data[0]

    # Check if budget is locked
    if budget["status"] == "locked":
        raise HTTPException(status_code=400, detail="Cannot modify a locked budget")

    # Update budget
    update_data = budget_input.model_dump(exclude_unset=True)
    update_data["updated_at"] = datetime.utcnow().isoformat()

    result = client.table("backlot_budgets").update(update_data).eq("id", budget["id"]).execute()
    if not result.data:
        raise HTTPException(status_code=500, detail="Failed to update budget")

    return result.data[0]


@router.put("/budgets/{budget_id}", response_model=Budget)
async def update_budget_by_id(
    budget_id: str,
    budget_input: BudgetInput,
    authorization: str = Header(None)
):
    """Update a specific budget by ID"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get existing budget
    existing = client.table("backlot_budgets").select("id, project_id, status").eq("id", budget_id).execute()
    if not existing.data:
        raise HTTPException(status_code=404, detail="Budget not found")

    budget = existing.data[0]

    # Verify access to the project
    await verify_budget_access(client, budget["project_id"], user_id)

    # Check if budget is locked
    if budget["status"] == "locked":
        raise HTTPException(status_code=400, detail="Cannot modify a locked budget")

    # Update budget
    update_data = budget_input.model_dump(exclude_unset=True)
    update_data["updated_at"] = datetime.utcnow().isoformat()

    result = client.table("backlot_budgets").update(update_data).eq("id", budget_id).execute()
    if not result.data:
        raise HTTPException(status_code=500, detail="Failed to update budget")

    return result.data[0]


@router.post("/projects/{project_id}/budget/lock")
async def lock_budget(
    project_id: str,
    authorization: str = Header(None)
):
    """Lock the budget to prevent further modifications"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()
    await verify_budget_access(client, project_id, user_id)

    # Get budget
    existing = client.table("backlot_budgets").select("id").eq("project_id", project_id).execute()
    if not existing.data:
        raise HTTPException(status_code=404, detail="Budget not found")

    # Lock budget
    result = client.table("backlot_budgets").update({
        "status": "locked",
        "locked_at": datetime.utcnow().isoformat()
    }).eq("id", existing.data[0]["id"]).execute()

    return {"success": True, "message": "Budget locked successfully"}


@router.get("/projects/{project_id}/budgets", response_model=List[Budget])
async def get_project_budgets(
    project_id: str,
    authorization: str = Header(None)
):
    """Get ALL budgets for a project (supports multiple budgets per project)"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()
    await verify_budget_access(client, project_id, user_id)

    # Get all budgets for project
    response = client.table("backlot_budgets").select("*").eq("project_id", project_id).order("created_at", desc=True).execute()

    return response.data or []


@router.delete("/budgets/{budget_id}")
async def delete_budget(
    budget_id: str,
    authorization: str = Header(None)
):
    """Delete a budget and ALL associated data (categories, line items, daily budgets, receipts).
    This is a destructive operation that cannot be undone.
    """
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get budget to verify access
    budget_response = client.table("backlot_budgets").select("id, project_id, name, status").eq("id", budget_id).execute()
    if not budget_response.data:
        raise HTTPException(status_code=404, detail="Budget not found")

    budget = budget_response.data[0]

    # Verify user has access to the project
    await verify_budget_access(client, budget["project_id"], user_id)

    # Don't allow deletion of locked budgets
    if budget["status"] == "locked":
        raise HTTPException(status_code=400, detail="Cannot delete a locked budget. Unlock it first.")

    # Delete in correct order to respect foreign key constraints:
    # 1. Daily budget items
    daily_budgets = client.table("backlot_daily_budgets").select("id").eq("budget_id", budget_id).execute()
    for db in (daily_budgets.data or []):
        client.table("backlot_daily_budget_items").delete().eq("daily_budget_id", db["id"]).execute()

    # 2. Daily budgets
    client.table("backlot_daily_budgets").delete().eq("budget_id", budget_id).execute()

    # 3. Budget actuals - delete by budget_id first
    client.table("backlot_budget_actuals").delete().eq("budget_id", budget_id).execute()

    # 4. Get line items and categories to also delete any actuals referencing them (in case budget_id was null)
    line_items = client.table("backlot_budget_line_items").select("id").eq("budget_id", budget_id).execute()
    for li in (line_items.data or []):
        client.table("backlot_budget_actuals").delete().eq("budget_line_item_id", li["id"]).execute()

    categories = client.table("backlot_budget_categories").select("id").eq("budget_id", budget_id).execute()
    for cat in (categories.data or []):
        client.table("backlot_budget_actuals").delete().eq("budget_category_id", cat["id"]).execute()

    # 5. Receipts
    client.table("backlot_receipts").delete().eq("budget_id", budget_id).execute()

    # 6. Line items
    client.table("backlot_budget_line_items").delete().eq("budget_id", budget_id).execute()

    # 7. Categories
    client.table("backlot_budget_categories").delete().eq("budget_id", budget_id).execute()

    # 8. Finally, the budget itself
    client.table("backlot_budgets").delete().eq("id", budget_id).execute()

    return {"success": True, "message": f"Budget '{budget['name']}' and all associated data has been permanently deleted"}


@router.get("/projects/{project_id}/budget/stats", response_model=BudgetStats)
async def get_budget_stats(
    project_id: str,
    authorization: str = Header(None)
):
    """Get budget statistics"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()
    await verify_budget_access(client, project_id, user_id)

    # Get budget
    budget_response = client.table("backlot_budgets").select("*").eq("project_id", project_id).execute()
    if not budget_response.data:
        raise HTTPException(status_code=404, detail="Budget not found")

    budget = budget_response.data[0]
    budget_id = budget["id"]

    # Get categories for over/under budget counts
    categories = client.table("backlot_budget_categories").select("estimated_subtotal, actual_subtotal").eq("budget_id", budget_id).execute()
    categories_over = sum(1 for c in (categories.data or []) if c["actual_subtotal"] > c["estimated_subtotal"])
    categories_under = sum(1 for c in (categories.data or []) if c["actual_subtotal"] < c["estimated_subtotal"])

    # Get receipt totals
    receipts = client.table("backlot_receipts").select("amount, is_mapped").eq("budget_id", budget_id).execute()
    receipt_total = sum(r.get("amount", 0) or 0 for r in (receipts.data or []))
    unmapped_total = sum(r.get("amount", 0) or 0 for r in (receipts.data or []) if not r.get("is_mapped"))

    # Get daily budgets over budget
    daily = client.table("backlot_daily_budgets").select("estimated_total, actual_total").eq("budget_id", budget_id).execute()
    days_over = sum(1 for d in (daily.data or []) if d["actual_total"] > d["estimated_total"])

    estimated = budget["estimated_total"]
    actual = budget["actual_total"]
    variance = actual - estimated
    variance_percent = (variance / estimated * 100) if estimated > 0 else 0

    return BudgetStats(
        estimated_total=estimated,
        actual_total=actual,
        variance=variance,
        variance_percent=variance_percent,
        receipt_total=receipt_total,
        unmapped_receipt_total=unmapped_total,
        categories_over_budget=categories_over,
        categories_under_budget=categories_under,
        days_over_budget=days_over
    )


@router.get("/projects/{project_id}/budget/comparison")
async def get_budget_comparison(
    project_id: str,
    authorization: str = Header(None)
):
    """Get comprehensive budget comparison data for estimated vs actual analysis"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()
    await verify_budget_access(client, project_id, user_id)

    # Get budget
    budget_response = client.table("backlot_budgets").select("*").eq("project_id", project_id).execute()
    if not budget_response.data:
        raise HTTPException(status_code=404, detail="Budget not found")

    budget = budget_response.data[0]
    budget_id = budget["id"]

    # Get categories with line items
    categories_response = client.table("backlot_budget_categories").select("*").eq("budget_id", budget_id).order("sort_order").execute()
    categories = categories_response.data or []

    # Get line items
    line_items_response = client.table("backlot_budget_line_items").select("*").eq("budget_id", budget_id).order("sort_order").execute()
    line_items = line_items_response.data or []

    # Get receipts linked to budget
    receipts_response = client.table("backlot_receipts").select(
        "id, amount, vendor_name, budget_line_item_id, budget_category_id"
    ).eq("budget_id", budget_id).execute()
    receipts = receipts_response.data or []

    # Get mileage linked to budget
    mileage_response = client.table("backlot_mileage_entries").select(
        "id, miles, rate_per_mile, is_round_trip, budget_line_item_id, budget_category_id, status"
    ).eq("project_id", project_id).neq("budget_line_item_id", None).execute()
    mileage_entries = [m for m in (mileage_response.data or []) if m.get("status") == "approved"]

    # Get kit rentals linked to budget
    kit_rentals_response = client.table("backlot_kit_rentals").select(
        "id, total_amount, budget_line_item_id, budget_category_id, status"
    ).eq("project_id", project_id).neq("budget_line_item_id", None).execute()
    kit_rentals = [k for k in (kit_rentals_response.data or []) if k.get("status") == "approved"]

    # Get per diem linked to budget
    per_diem_response = client.table("backlot_per_diem").select(
        "id, amount, budget_line_item_id, budget_category_id, status"
    ).eq("project_id", project_id).neq("budget_line_item_id", None).execute()
    per_diem_entries = [p for p in (per_diem_response.data or []) if p.get("status") == "approved"]

    # Calculate totals by expense type
    receipt_total = sum(r.get("amount", 0) or 0 for r in receipts)
    mileage_total = sum(
        (m.get("miles", 0) * m.get("rate_per_mile", 0.67) * (2 if m.get("is_round_trip") else 1))
        for m in mileage_entries
    )
    kit_rental_total = sum(k.get("total_amount", 0) or 0 for k in kit_rentals)
    per_diem_total = sum(p.get("amount", 0) or 0 for p in per_diem_entries)

    # Group expenses by line item
    expenses_by_line_item = {}
    for r in receipts:
        line_id = r.get("budget_line_item_id")
        if line_id:
            if line_id not in expenses_by_line_item:
                expenses_by_line_item[line_id] = []
            expenses_by_line_item[line_id].append({
                "type": "receipt",
                "amount": r.get("amount", 0) or 0,
                "vendor": r.get("vendor_name")
            })

    for m in mileage_entries:
        line_id = m.get("budget_line_item_id")
        if line_id:
            if line_id not in expenses_by_line_item:
                expenses_by_line_item[line_id] = []
            amount = m.get("miles", 0) * m.get("rate_per_mile", 0.67) * (2 if m.get("is_round_trip") else 1)
            expenses_by_line_item[line_id].append({
                "type": "mileage",
                "amount": amount,
                "miles": m.get("miles", 0)
            })

    for k in kit_rentals:
        line_id = k.get("budget_line_item_id")
        if line_id:
            if line_id not in expenses_by_line_item:
                expenses_by_line_item[line_id] = []
            expenses_by_line_item[line_id].append({
                "type": "kit_rental",
                "amount": k.get("total_amount", 0) or 0
            })

    for p in per_diem_entries:
        line_id = p.get("budget_line_item_id")
        if line_id:
            if line_id not in expenses_by_line_item:
                expenses_by_line_item[line_id] = []
            expenses_by_line_item[line_id].append({
                "type": "per_diem",
                "amount": p.get("amount", 0) or 0
            })

    # Build line items with expenses
    line_items_map = {}
    for item in line_items:
        item_id = item["id"]
        expenses = expenses_by_line_item.get(item_id, [])
        actual_from_expenses = sum(e.get("amount", 0) for e in expenses)
        # Use stored actual_total or calculated from expenses
        actual = item.get("actual_total", 0) or actual_from_expenses
        estimated = item.get("estimated_total", 0) or 0
        line_items_map[item_id] = {
            "id": item_id,
            "description": item.get("description"),
            "account_code": item.get("account_code"),
            "estimated_total": estimated,
            "actual_total": actual,
            "variance": actual - estimated,
            "variance_percent": ((actual - estimated) / estimated * 100) if estimated > 0 else 0,
            "expenses": expenses,
            "category_id": item.get("category_id")
        }

    # Build categories with line items
    categories_with_items = []
    for cat in categories:
        cat_id = cat["id"]
        cat_line_items = [line_items_map[item["id"]] for item in line_items if item.get("category_id") == cat_id]
        estimated = cat.get("estimated_subtotal", 0) or 0
        actual = cat.get("actual_subtotal", 0) or 0
        categories_with_items.append({
            "id": cat_id,
            "name": cat.get("name"),
            "code": cat.get("code"),
            "account_code_prefix": cat.get("account_code_prefix"),
            "category_type": cat.get("category_type"),
            "estimated_subtotal": estimated,
            "actual_subtotal": actual,
            "variance": actual - estimated,
            "variance_percent": ((actual - estimated) / estimated * 100) if estimated > 0 else 0,
            "line_items": cat_line_items
        })

    # Group by category type
    category_types = ["above_the_line", "production", "post", "other"]
    type_labels = {
        "above_the_line": "Above the Line",
        "production": "Production",
        "post": "Post-Production",
        "other": "Other / Indirect"
    }

    by_category_type = []
    for cat_type in category_types:
        type_cats = [c for c in categories_with_items if c.get("category_type") == cat_type]
        type_estimated = sum(c.get("estimated_subtotal", 0) for c in type_cats)
        type_actual = sum(c.get("actual_subtotal", 0) for c in type_cats)
        by_category_type.append({
            "type": cat_type,
            "label": type_labels.get(cat_type, cat_type),
            "estimated": type_estimated,
            "actual": type_actual,
            "variance": type_actual - type_estimated,
            "variance_percent": ((type_actual - type_estimated) / type_estimated * 100) if type_estimated > 0 else 0,
            "categories": type_cats
        })

    # Overall summary
    estimated_total = budget.get("estimated_total", 0) or 0
    actual_total = budget.get("actual_total", 0) or 0
    contingency = budget.get("contingency_amount", 0) or 0
    fringes = budget.get("fringes_total", 0) or 0
    grand_total = budget.get("grand_total", 0) or estimated_total + contingency + fringes

    return {
        "budget": {
            "id": budget_id,
            "name": budget.get("name"),
            "status": budget.get("status"),
            "project_type": budget.get("project_type_template"),
            "contingency_percent": budget.get("contingency_percent"),
            "contingency_amount": contingency,
            "fringes_total": fringes,
            "grand_total": grand_total
        },
        "summary": {
            "estimated_total": estimated_total,
            "actual_total": actual_total,
            "variance": actual_total - estimated_total,
            "variance_percent": ((actual_total - estimated_total) / estimated_total * 100) if estimated_total > 0 else 0
        },
        "by_category_type": by_category_type,
        "categories": categories_with_items,
        "expense_breakdown": {
            "receipts": receipt_total,
            "mileage": mileage_total,
            "kit_rentals": kit_rental_total,
            "per_diem": per_diem_total,
            "total": receipt_total + mileage_total + kit_rental_total + per_diem_total
        }
    }


# =====================================================
# TAX CALCULATION HELPER
# =====================================================

def recalculate_category_tax(client, category_id: str, budget_id: str):
    """Recalculate and update the tax line item for a category.

    This function manages auto-generated tax line items:
    - Creates a tax line item if category is taxable and has a tax rate
    - Updates the tax line item when line items change
    - Deletes the tax line item if tax is disabled
    """
    # Get category tax settings
    cat = client.table("backlot_budget_categories").select("*").eq("id", category_id).single().execute()
    if not cat.data:
        return

    category = cat.data
    is_taxable = category.get("is_taxable", False)
    tax_rate = category.get("tax_rate", 0) or 0

    # Find existing tax line item for this category
    existing_tax = client.table("backlot_budget_line_items").select("id").eq("tax_source_category_id", category_id).eq("is_tax_line_item", True).execute()
    existing_tax_id = existing_tax.data[0]["id"] if existing_tax.data else None

    if not is_taxable or tax_rate <= 0:
        # Delete tax line item if exists and tax is disabled
        if existing_tax_id:
            client.table("backlot_budget_line_items").delete().eq("id", existing_tax_id).execute()
        return

    # Calculate taxable total (sum of non-tax line items in this category)
    taxable_items = client.table("backlot_budget_line_items").select("estimated_total").eq("category_id", category_id).eq("is_tax_line_item", False).execute()
    taxable_total = sum(item.get("estimated_total", 0) or 0 for item in (taxable_items.data or []))

    tax_amount = round(taxable_total * tax_rate, 2)
    tax_percent_display = f"{tax_rate * 100:.2f}%"

    if existing_tax_id:
        # Update existing tax line item (rate_amount * quantity = estimated_total via generated column)
        client.table("backlot_budget_line_items").update({
            "rate_amount": tax_amount,
            "description": f"Estimated Sales Tax ({tax_percent_display})",
            "updated_at": datetime.utcnow().isoformat()
        }).eq("id", existing_tax_id).execute()
    else:
        # Create new tax line item
        # Note: estimated_total, actual_total, variance are generated columns - don't insert them
        import uuid
        client.table("backlot_budget_line_items").insert({
            "id": str(uuid.uuid4()),
            "budget_id": budget_id,
            "category_id": category_id,
            "account_code": "TAX",
            "description": f"Estimated Sales Tax ({tax_percent_display})",
            "rate_type": "flat",
            "rate_amount": tax_amount,
            "quantity": 1,
            "is_tax_line_item": True,
            "tax_source_category_id": category_id,
            "is_locked": True,  # Prevent manual editing
            "sort_order": 99999,  # Always at end
            "created_at": datetime.utcnow().isoformat(),
            "updated_at": datetime.utcnow().isoformat()
        }).execute()


# =====================================================
# BUDGET CATEGORIES ENDPOINTS
# =====================================================

@router.get("/budgets/{budget_id}/categories", response_model=List[BudgetCategory])
async def get_budget_categories(
    budget_id: str,
    authorization: str = Header(None)
):
    """Get all categories for a budget"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get budget to verify access
    budget_response = client.table("backlot_budgets").select("project_id").eq("id", budget_id).execute()
    if not budget_response.data:
        raise HTTPException(status_code=404, detail="Budget not found")

    await verify_budget_access(client, budget_response.data[0]["project_id"], user_id)

    # Get categories
    response = client.table("backlot_budget_categories").select("*").eq("budget_id", budget_id).order("sort_order").execute()
    return response.data or []


@router.post("/budgets/{budget_id}/categories", response_model=BudgetCategory)
async def create_budget_category(
    budget_id: str,
    category: BudgetCategoryInput,
    authorization: str = Header(None)
):
    """Create a new budget category"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get budget to verify access
    budget_response = client.table("backlot_budgets").select("project_id, status").eq("id", budget_id).execute()
    if not budget_response.data:
        raise HTTPException(status_code=404, detail="Budget not found")

    budget = budget_response.data[0]
    if budget["status"] == "locked":
        raise HTTPException(status_code=400, detail="Cannot modify a locked budget")

    await verify_budget_access(client, budget["project_id"], user_id)

    # Create category
    try:
        import uuid
        from datetime import datetime

        category_data = category.model_dump()
        category_data["id"] = str(uuid.uuid4())
        category_data["budget_id"] = budget_id
        category_data["estimated_subtotal"] = 0
        category_data["actual_subtotal"] = 0
        category_data["created_at"] = datetime.utcnow().isoformat()
        category_data["updated_at"] = datetime.utcnow().isoformat()

        result = client.table("backlot_budget_categories").insert(category_data).execute()
        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create category - no data returned")

        return result.data[0]
    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating budget category: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Failed to create category: {str(e)}")


@router.put("/budgets/{budget_id}/categories/{category_id}", response_model=BudgetCategory)
async def update_budget_category(
    budget_id: str,
    category_id: str,
    category: BudgetCategoryInput,
    authorization: str = Header(None)
):
    """Update a budget category"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get budget to verify access
    budget_response = client.table("backlot_budgets").select("project_id, status").eq("id", budget_id).execute()
    if not budget_response.data:
        raise HTTPException(status_code=404, detail="Budget not found")

    budget = budget_response.data[0]
    if budget["status"] == "locked":
        raise HTTPException(status_code=400, detail="Cannot modify a locked budget")

    await verify_budget_access(client, budget["project_id"], user_id)

    # Update category
    category_data = category.model_dump(exclude_unset=True)
    category_data["updated_at"] = datetime.utcnow().isoformat()

    result = client.table("backlot_budget_categories").update(category_data).eq("id", category_id).eq("budget_id", budget_id).execute()
    if not result.data:
        raise HTTPException(status_code=404, detail="Category not found")

    # Recalculate tax if tax settings changed
    if "is_taxable" in category_data or "tax_rate" in category_data:
        recalculate_category_tax(client, category_id, budget_id)

    return result.data[0]


@router.delete("/budgets/{budget_id}/categories/{category_id}")
async def delete_budget_category(
    budget_id: str,
    category_id: str,
    authorization: str = Header(None)
):
    """Delete a budget category (moves line items to uncategorized)"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get budget to verify access
    budget_response = client.table("backlot_budgets").select("project_id, status").eq("id", budget_id).execute()
    if not budget_response.data:
        raise HTTPException(status_code=404, detail="Budget not found")

    budget = budget_response.data[0]
    if budget["status"] == "locked":
        raise HTTPException(status_code=400, detail="Cannot modify a locked budget")

    await verify_budget_access(client, budget["project_id"], user_id)

    # Unlink line items from this category
    client.table("backlot_budget_line_items").update({"category_id": None}).eq("category_id", category_id).execute()

    # Delete category
    client.table("backlot_budget_categories").delete().eq("id", category_id).eq("budget_id", budget_id).execute()

    return {"success": True, "message": "Category deleted"}


# =====================================================
# BUDGET LINE ITEMS ENDPOINTS
# =====================================================

@router.get("/budgets/{budget_id}/line-items", response_model=List[BudgetLineItem])
async def get_budget_line_items(
    budget_id: str,
    category_id: Optional[str] = None,
    authorization: str = Header(None)
):
    """Get all line items for a budget"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get budget to verify access
    budget_response = client.table("backlot_budgets").select("project_id").eq("id", budget_id).execute()
    if not budget_response.data:
        raise HTTPException(status_code=404, detail="Budget not found")

    await verify_budget_access(client, budget_response.data[0]["project_id"], user_id)

    # Build query
    query = client.table("backlot_budget_line_items").select("*").eq("budget_id", budget_id)
    if category_id:
        query = query.eq("category_id", category_id)

    response = query.order("category_id").order("sort_order").execute()
    return response.data or []


def generate_next_account_code(category_code: str, existing_codes: list) -> str:
    """Generate the next account code based on category code and existing line item codes.

    Format: [prefix]-[sequence]
    - prefix starts at category_code + 1 (e.g., category 100 -> first prefix is 101)
    - sequence is 01, 02, etc.
    - If user set a different prefix (e.g., 102-01), continue from there (102-02)
    """
    import re

    if not category_code:
        return ""

    # Parse category code as base number
    try:
        cat_num = int(re.sub(r'\D', '', category_code) or '0')
    except ValueError:
        cat_num = 0

    if cat_num == 0:
        return ""

    # Default starting prefix is category + 1
    default_prefix = cat_num + 1

    # Parse existing codes to find the highest prefix and its sequence
    highest_prefix = default_prefix
    sequences_by_prefix = {}

    for code in existing_codes:
        if not code:
            continue
        # Match pattern like "101-01" or "101-1" or just "101"
        match = re.match(r'^(\d+)(?:-(\d+))?$', str(code).strip())
        if match:
            prefix = int(match.group(1))
            seq = int(match.group(2)) if match.group(2) else 1

            if prefix not in sequences_by_prefix:
                sequences_by_prefix[prefix] = []
            sequences_by_prefix[prefix].append(seq)

            if prefix >= highest_prefix:
                highest_prefix = prefix

    # Find the next sequence for the highest prefix
    if highest_prefix in sequences_by_prefix:
        max_seq = max(sequences_by_prefix[highest_prefix])
        next_seq = max_seq + 1
    else:
        next_seq = 1

    return f"{highest_prefix}-{next_seq:02d}"


@router.post("/budgets/{budget_id}/line-items", response_model=BudgetLineItem)
async def create_budget_line_item(
    budget_id: str,
    line_item: BudgetLineItemInput,
    authorization: str = Header(None)
):
    """Create a new budget line item"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get budget to verify access
    budget_response = client.table("backlot_budgets").select("project_id, status").eq("id", budget_id).execute()
    if not budget_response.data:
        raise HTTPException(status_code=404, detail="Budget not found")

    budget = budget_response.data[0]
    if budget["status"] == "locked":
        raise HTTPException(status_code=400, detail="Cannot modify a locked budget")

    await verify_budget_access(client, budget["project_id"], user_id)

    # Create line item
    item_data = line_item.model_dump(exclude_unset=True)
    item_data["budget_id"] = budget_id

    # Auto-generate account code if not provided and category has a code
    if not item_data.get("account_code") and item_data.get("category_id"):
        category_id = item_data["category_id"]

        # Get category code
        cat_response = client.table("backlot_budget_categories").select("code, account_code_prefix").eq("id", category_id).execute()
        if cat_response.data:
            cat = cat_response.data[0]
            category_code = cat.get("account_code_prefix") or cat.get("code") or ""

            if category_code:
                # Get existing line item codes in this category
                existing_response = client.table("backlot_budget_line_items").select("account_code").eq("category_id", category_id).execute()
                existing_codes = [li.get("account_code") for li in (existing_response.data or [])]

                # Generate next code
                next_code = generate_next_account_code(category_code, existing_codes)
                if next_code:
                    item_data["account_code"] = next_code

    result = client.table("backlot_budget_line_items").insert(item_data).execute()
    if not result.data:
        raise HTTPException(status_code=500, detail="Failed to create line item")

    # Recalculate category tax if line item has a category
    if item_data.get("category_id"):
        recalculate_category_tax(client, item_data["category_id"], budget_id)

    return result.data[0]


@router.put("/budgets/{budget_id}/line-items/{line_item_id}", response_model=BudgetLineItem)
async def update_budget_line_item(
    budget_id: str,
    line_item_id: str,
    line_item: BudgetLineItemInput,
    authorization: str = Header(None)
):
    """Update a budget line item"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get budget to verify access
    budget_response = client.table("backlot_budgets").select("project_id, status").eq("id", budget_id).execute()
    if not budget_response.data:
        raise HTTPException(status_code=404, detail="Budget not found")

    budget = budget_response.data[0]
    if budget["status"] == "locked":
        raise HTTPException(status_code=400, detail="Cannot modify a locked budget")

    await verify_budget_access(client, budget["project_id"], user_id)

    # Check if line item is locked or is a tax line item
    existing = client.table("backlot_budget_line_items").select("is_locked, is_tax_line_item, category_id").eq("id", line_item_id).execute()
    if existing.data and existing.data[0].get("is_locked"):
        raise HTTPException(status_code=400, detail="Cannot modify a locked line item")
    if existing.data and existing.data[0].get("is_tax_line_item"):
        raise HTTPException(status_code=400, detail="Cannot modify a tax line item - it is system-managed")

    old_category_id = existing.data[0].get("category_id") if existing.data else None

    # Update line item
    item_data = line_item.model_dump(exclude_unset=True)
    item_data["updated_at"] = datetime.utcnow().isoformat()

    result = client.table("backlot_budget_line_items").update(item_data).eq("id", line_item_id).eq("budget_id", budget_id).execute()
    if not result.data:
        raise HTTPException(status_code=404, detail="Line item not found")

    # Recalculate tax for affected categories
    new_category_id = result.data[0].get("category_id")
    if old_category_id:
        recalculate_category_tax(client, old_category_id, budget_id)
    if new_category_id and new_category_id != old_category_id:
        recalculate_category_tax(client, new_category_id, budget_id)

    return result.data[0]


@router.delete("/budgets/{budget_id}/line-items/{line_item_id}")
async def delete_budget_line_item(
    budget_id: str,
    line_item_id: str,
    authorization: str = Header(None)
):
    """Delete a budget line item"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get budget to verify access
    budget_response = client.table("backlot_budgets").select("project_id, status").eq("id", budget_id).execute()
    if not budget_response.data:
        raise HTTPException(status_code=404, detail="Budget not found")

    budget = budget_response.data[0]
    if budget["status"] == "locked":
        raise HTTPException(status_code=400, detail="Cannot modify a locked budget")

    await verify_budget_access(client, budget["project_id"], user_id)

    # Check if line item is locked or is a tax line item
    existing = client.table("backlot_budget_line_items").select("is_locked, is_tax_line_item, category_id").eq("id", line_item_id).execute()
    if existing.data and existing.data[0].get("is_locked"):
        raise HTTPException(status_code=400, detail="Cannot delete a locked line item")
    if existing.data and existing.data[0].get("is_tax_line_item"):
        raise HTTPException(status_code=400, detail="Cannot delete a tax line item - it is system-managed")

    category_id = existing.data[0].get("category_id") if existing.data else None

    # Delete line item (cascades to day links)
    client.table("backlot_budget_line_items").delete().eq("id", line_item_id).eq("budget_id", budget_id).execute()

    # Recalculate tax for the category
    if category_id:
        recalculate_category_tax(client, category_id, budget_id)

    return {"success": True, "message": "Line item deleted"}


# =====================================================
# DAILY BUDGET SYSTEM - Models
# =====================================================

class DailyBudgetInput(BaseModel):
    """Input for creating/updating a daily budget"""
    date: Optional[str] = None
    notes: Optional[str] = None


class DailyBudgetItemInput(BaseModel):
    """Input for creating/updating a daily budget item"""
    budget_line_item_id: Optional[str] = None
    label: str
    category_name: Optional[str] = None
    estimated_amount: Optional[float] = 0
    actual_amount: Optional[float] = 0
    vendor_name: Optional[str] = None
    notes: Optional[str] = None
    is_ad_hoc: Optional[bool] = False
    sort_order: Optional[int] = 0


class DailyBudget(BaseModel):
    """Daily budget response model"""
    id: str
    project_id: str
    budget_id: str
    production_day_id: str
    date: str
    estimated_total: float
    actual_total: float
    variance: float
    variance_percent: float
    notes: Optional[str]
    created_at: str
    updated_at: str


class DailyBudgetItem(BaseModel):
    """Daily budget item response model"""
    id: str
    daily_budget_id: str
    budget_line_item_id: Optional[str]
    label: str
    category_name: Optional[str]
    estimated_amount: float
    actual_amount: float
    vendor_name: Optional[str]
    notes: Optional[str]
    is_ad_hoc: bool
    sort_order: int
    created_at: str
    updated_at: str


class DailyBudgetSummary(BaseModel):
    """Daily budget summary for list views"""
    id: str
    date: str
    production_day_number: int
    production_day_title: Optional[str]
    estimated_total: float
    actual_total: float
    variance: float
    variance_percent: float
    item_count: int
    receipt_count: int
    has_call_sheet: bool


class BudgetDayLinkInput(BaseModel):
    """Input for linking budget line items to production days"""
    budget_line_item_id: str
    production_day_id: str
    call_sheet_id: Optional[str] = None
    estimated_share: Optional[float] = 0
    actual_share: Optional[float] = 0
    notes: Optional[str] = None


class SuggestedLineItemForDay(BaseModel):
    """Suggested line item for a production day"""
    line_item_id: str
    line_item_description: str
    category_name: Optional[str]
    match_reason: str
    suggested_share: float


# =====================================================
# DAILY BUDGET ENDPOINTS
# =====================================================

@router.get("/projects/{project_id}/daily-budgets", response_model=List[DailyBudgetSummary])
async def get_project_daily_budgets(
    project_id: str,
    authorization: str = Header(None)
):
    """Get all daily budgets for a project"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()
    await verify_budget_access(client, project_id, user_id)

    # Get budget
    budget_response = client.table("backlot_budgets").select("id").eq("project_id", project_id).execute()
    if not budget_response.data:
        return []  # No budget yet, no daily budgets

    budget_id = budget_response.data[0]["id"]

    # Get daily budgets with production day info
    daily_response = client.table("backlot_daily_budgets").select("*").eq("budget_id", budget_id).order("shoot_date").execute()

    summaries = []
    for db in daily_response.data or []:
        # Get production day info
        prod_day = client.table("backlot_production_days").select("day_number, title").eq("id", db["production_day_id"]).execute()
        prod_day_data = prod_day.data[0] if prod_day.data else {}

        # Count items
        items_count = client.table("backlot_daily_budget_items").select("id", count="exact").eq("daily_budget_id", db["id"]).execute()

        # Count receipts
        receipts_count = client.table("backlot_receipts").select("id", count="exact").eq("daily_budget_id", db["id"]).execute()

        # Check for call sheet
        call_sheet = client.table("backlot_call_sheets").select("id").eq("production_day_id", db["production_day_id"]).limit(1).execute()

        summaries.append(DailyBudgetSummary(
            id=db["id"],
            date=db["date"],
            production_day_number=prod_day_data.get("day_number", 0),
            production_day_title=prod_day_data.get("title"),
            estimated_total=db["estimated_total"],
            actual_total=db["actual_total"],
            variance=db["variance"],
            variance_percent=db["variance_percent"],
            item_count=items_count.count if hasattr(items_count, 'count') else len(items_count.data or []),
            receipt_count=receipts_count.count if hasattr(receipts_count, 'count') else len(receipts_count.data or []),
            has_call_sheet=bool(call_sheet.data)
        ))

    return summaries


@router.get("/daily-budgets/{daily_budget_id}", response_model=DailyBudget)
async def get_daily_budget(
    daily_budget_id: str,
    authorization: str = Header(None)
):
    """Get a daily budget by ID"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get daily budget
    response = client.table("backlot_daily_budgets").select("*").eq("id", daily_budget_id).execute()
    if not response.data:
        raise HTTPException(status_code=404, detail="Daily budget not found")

    db = response.data[0]
    await verify_budget_access(client, db["project_id"], user_id)

    return db


@router.get("/production-days/{production_day_id}/daily-budget", response_model=DailyBudget)
async def get_daily_budget_for_day(
    production_day_id: str,
    authorization: str = Header(None)
):
    """Get or create daily budget for a production day"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get production day
    day_response = client.table("backlot_production_days").select("*").eq("id", production_day_id).execute()
    if not day_response.data:
        raise HTTPException(status_code=404, detail="Production day not found")

    prod_day = day_response.data[0]
    project_id = prod_day["project_id"]

    await verify_budget_access(client, project_id, user_id)

    # Get budget
    budget_response = client.table("backlot_budgets").select("id").eq("project_id", project_id).execute()
    if not budget_response.data:
        raise HTTPException(status_code=404, detail="No budget found for this project")

    budget_id = budget_response.data[0]["id"]

    # Check if daily budget exists
    existing = client.table("backlot_daily_budgets").select("*").eq("production_day_id", production_day_id).execute()
    if existing.data:
        return existing.data[0]

    # Create daily budget
    daily_data = {
        "project_id": project_id,
        "budget_id": budget_id,
        "production_day_id": production_day_id,
        "date": prod_day["date"],
    }

    result = client.table("backlot_daily_budgets").insert(daily_data).execute()
    if not result.data:
        raise HTTPException(status_code=500, detail="Failed to create daily budget")

    return result.data[0]


@router.put("/daily-budgets/{daily_budget_id}", response_model=DailyBudget)
async def update_daily_budget(
    daily_budget_id: str,
    daily_input: DailyBudgetInput,
    authorization: str = Header(None)
):
    """Update a daily budget"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get daily budget to verify access
    existing = client.table("backlot_daily_budgets").select("project_id").eq("id", daily_budget_id).execute()
    if not existing.data:
        raise HTTPException(status_code=404, detail="Daily budget not found")

    await verify_budget_access(client, existing.data[0]["project_id"], user_id)

    # Update
    update_data = daily_input.model_dump(exclude_unset=True)
    update_data["updated_at"] = datetime.utcnow().isoformat()

    result = client.table("backlot_daily_budgets").update(update_data).eq("id", daily_budget_id).execute()
    if not result.data:
        raise HTTPException(status_code=500, detail="Failed to update daily budget")

    return result.data[0]


# =====================================================
# DAILY BUDGET ITEMS ENDPOINTS
# =====================================================

@router.get("/daily-budgets/{daily_budget_id}/items", response_model=List[DailyBudgetItem])
async def get_daily_budget_items(
    daily_budget_id: str,
    authorization: str = Header(None)
):
    """Get all items for a daily budget"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get daily budget to verify access
    db_response = client.table("backlot_daily_budgets").select("project_id").eq("id", daily_budget_id).execute()
    if not db_response.data:
        raise HTTPException(status_code=404, detail="Daily budget not found")

    await verify_budget_access(client, db_response.data[0]["project_id"], user_id)

    # Get items
    response = client.table("backlot_daily_budget_items").select("*").eq("daily_budget_id", daily_budget_id).order("sort_order").execute()
    return response.data or []


@router.post("/daily-budgets/{daily_budget_id}/items", response_model=DailyBudgetItem)
async def create_daily_budget_item(
    daily_budget_id: str,
    item: DailyBudgetItemInput,
    authorization: str = Header(None)
):
    """Create a new daily budget item"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get daily budget to verify access
    db_response = client.table("backlot_daily_budgets").select("project_id, budget_id").eq("id", daily_budget_id).execute()
    if not db_response.data:
        raise HTTPException(status_code=404, detail="Daily budget not found")

    await verify_budget_access(client, db_response.data[0]["project_id"], user_id)

    # If linked to a line item, get category name
    item_data = item.model_dump(exclude_unset=True)
    if item_data.get("budget_line_item_id") and not item_data.get("category_name"):
        line_item = client.table("backlot_budget_line_items").select("category_id").eq("id", item_data["budget_line_item_id"]).execute()
        if line_item.data and line_item.data[0].get("category_id"):
            category = client.table("backlot_budget_categories").select("name").eq("id", line_item.data[0]["category_id"]).execute()
            if category.data:
                item_data["category_name"] = category.data[0]["name"]

    item_data["daily_budget_id"] = daily_budget_id

    result = client.table("backlot_daily_budget_items").insert(item_data).execute()
    if not result.data:
        raise HTTPException(status_code=500, detail="Failed to create daily budget item")

    return result.data[0]


@router.put("/daily-budgets/{daily_budget_id}/items/{item_id}", response_model=DailyBudgetItem)
async def update_daily_budget_item(
    daily_budget_id: str,
    item_id: str,
    item: DailyBudgetItemInput,
    authorization: str = Header(None)
):
    """Update a daily budget item"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get daily budget to verify access
    db_response = client.table("backlot_daily_budgets").select("project_id").eq("id", daily_budget_id).execute()
    if not db_response.data:
        raise HTTPException(status_code=404, detail="Daily budget not found")

    await verify_budget_access(client, db_response.data[0]["project_id"], user_id)

    # Update
    item_data = item.model_dump(exclude_unset=True)
    item_data["updated_at"] = datetime.utcnow().isoformat()

    result = client.table("backlot_daily_budget_items").update(item_data).eq("id", item_id).eq("daily_budget_id", daily_budget_id).execute()
    if not result.data:
        raise HTTPException(status_code=404, detail="Item not found")

    return result.data[0]


@router.delete("/daily-budgets/{daily_budget_id}/items/{item_id}")
async def delete_daily_budget_item(
    daily_budget_id: str,
    item_id: str,
    authorization: str = Header(None)
):
    """Delete a daily budget item"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get daily budget to verify access
    db_response = client.table("backlot_daily_budgets").select("project_id").eq("id", daily_budget_id).execute()
    if not db_response.data:
        raise HTTPException(status_code=404, detail="Daily budget not found")

    await verify_budget_access(client, db_response.data[0]["project_id"], user_id)

    # Delete
    client.table("backlot_daily_budget_items").delete().eq("id", item_id).eq("daily_budget_id", daily_budget_id).execute()

    return {"success": True, "message": "Item deleted"}


# =====================================================
# DAILY BUDGET LABOR COSTS ENDPOINT
# =====================================================

class LaborCostEntry(BaseModel):
    """Labor cost entry for a crew member"""
    user_id: str
    user_name: Optional[str] = None
    user_avatar: Optional[str] = None
    role_title: Optional[str] = None
    department: Optional[str] = None
    position: Optional[str] = None
    hours_worked: float = 0
    overtime_hours: float = 0
    double_time_hours: float = 0
    rate_type: str = "daily"
    rate_amount: float = 0
    overtime_multiplier: float = 1.5
    double_time_multiplier: float = 2.0
    base_pay: float = 0
    overtime_pay: float = 0
    double_time_pay: float = 0
    kit_rental: float = 0
    car_allowance: float = 0
    phone_allowance: float = 0
    total_pay: float = 0
    rate_source: str = "entry"  # 'crew_rate', 'entry', 'budget'
    timecard_status: str = "draft"
    timecard_entry_id: Optional[str] = None


class DailyLaborCosts(BaseModel):
    """Aggregated labor costs for a production day"""
    production_day_id: str
    date: str
    entries: List[LaborCostEntry] = []
    total_base_pay: float = 0
    total_overtime_pay: float = 0
    total_double_time_pay: float = 0
    total_allowances: float = 0
    grand_total: float = 0
    approved_count: int = 0
    pending_count: int = 0


@router.get("/daily-budgets/{daily_budget_id}/labor-costs", response_model=DailyLaborCosts)
async def get_daily_budget_labor_costs(
    daily_budget_id: str,
    include_pending: bool = True,
    authorization: str = Header(None)
):
    """
    Get labor costs for a daily budget by aggregating timecard entries.

    Labor cost calculation priority:
    1. Crew rate schedule (if exists for user/role on this date)
    2. Timecard entry rate (fallback)
    3. Budget line item rate (last resort, not implemented yet)
    """
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]
    client = get_client()

    # Get daily budget with production day info
    db_response = client.table("backlot_daily_budgets").select(
        "*, production_day:production_day_id(id, date, project_id, day_number)"
    ).eq("id", daily_budget_id).execute()

    if not db_response.data:
        raise HTTPException(status_code=404, detail="Daily budget not found")

    daily_budget = db_response.data[0]
    prod_day = daily_budget.get("production_day") or {}
    project_id = prod_day.get("project_id") or daily_budget.get("project_id")
    day_date = prod_day.get("date")
    production_day_id = prod_day.get("id") or daily_budget.get("production_day_id")

    if not project_id:
        raise HTTPException(status_code=400, detail="Could not determine project")

    # Verify access
    await verify_budget_access(client, project_id, user_id)

    if not day_date:
        # Return empty if no date
        return DailyLaborCosts(
            production_day_id=production_day_id or "",
            date="",
            entries=[],
        )

    # Get timecard entries for this date
    statuses = ["approved"]
    if include_pending:
        statuses.extend(["submitted", "draft"])

    # Query timecard entries with timecard status filter
    entries_query = client.table("backlot_timecard_entries").select(
        "*, timecard:timecard_id(id, status, user_id)"
    ).eq("project_id", project_id).eq("shoot_date", day_date)

    entries_response = entries_query.execute()
    all_entries = entries_response.data or []

    # Filter by timecard status
    filtered_entries = [
        e for e in all_entries
        if e.get("timecard", {}).get("status") in statuses
    ]

    # Get user profiles for all unique user IDs
    user_ids = list(set(
        e.get("timecard", {}).get("user_id")
        for e in filtered_entries
        if e.get("timecard", {}).get("user_id")
    ))

    user_profiles = {}
    if user_ids:
        profiles_resp = client.table("profiles").select(
            "id, full_name, avatar_url"
        ).in_("id", user_ids).execute()
        for p in (profiles_resp.data or []):
            user_profiles[p["id"]] = p

    # Get crew rates for this project
    rates_resp = client.table("backlot_crew_rates").select(
        "*, role:role_id(id, title, department)"
    ).eq("project_id", project_id).execute()
    crew_rates = rates_resp.data or []

    # Build a lookup for crew rates by user_id
    def get_effective_rate(user_id: str, date: str):
        """Find the effective crew rate for a user on a specific date"""
        for rate in crew_rates:
            if rate.get("user_id") != user_id:
                continue
            start = rate.get("effective_start")
            end = rate.get("effective_end")
            # Check if date is within range
            if start and date < start:
                continue
            if end and date > end:
                continue
            return rate
        return None

    # Calculate labor costs for each entry
    labor_entries = []
    total_base = 0
    total_ot = 0
    total_dt = 0
    total_allowances = 0
    approved_count = 0
    pending_count = 0

    for entry in filtered_entries:
        timecard = entry.get("timecard") or {}
        tc_user_id = timecard.get("user_id")
        tc_status = timecard.get("status", "draft")

        if tc_status == "approved":
            approved_count += 1
        else:
            pending_count += 1

        profile = user_profiles.get(tc_user_id, {})
        hours = entry.get("hours_worked") or 0
        ot_hours = entry.get("overtime_hours") or 0
        dt_hours = entry.get("double_time_hours") or 0

        # Try to get crew rate
        crew_rate = get_effective_rate(tc_user_id, day_date) if tc_user_id else None

        if crew_rate:
            rate_source = "crew_rate"
            rate_type = crew_rate.get("rate_type", "daily")
            rate_amount = crew_rate.get("rate_amount", 0)
            ot_mult = crew_rate.get("overtime_multiplier", 1.5)
            dt_mult = crew_rate.get("double_time_multiplier", 2.0)
            kit_rental = crew_rate.get("kit_rental_rate") or 0
            car_allow = crew_rate.get("car_allowance") or 0
            phone_allow = crew_rate.get("phone_allowance") or 0
            role_info = crew_rate.get("role") or {}
            role_title = role_info.get("title")
            department = role_info.get("department") or entry.get("department")
        else:
            # Fall back to entry's rate
            rate_source = "entry"
            rate_type = entry.get("rate_type") or "daily"
            rate_amount = entry.get("rate_amount") or 0
            ot_mult = 1.5
            dt_mult = 2.0
            kit_rental = 0
            car_allow = 0
            phone_allow = 0
            role_title = entry.get("position")
            department = entry.get("department")

        # Calculate pay
        if rate_type == "hourly":
            hourly_rate = rate_amount
            base_pay = hours * hourly_rate
        elif rate_type == "daily":
            base_pay = rate_amount
            hourly_rate = rate_amount / 8 if rate_amount > 0 else 0
        elif rate_type == "weekly":
            base_pay = rate_amount / 5
            hourly_rate = rate_amount / 40 if rate_amount > 0 else 0
        else:  # flat
            base_pay = rate_amount
            hourly_rate = 0

        # Calculate OT/DT (only for non-flat rates)
        if rate_type != "flat" and hourly_rate > 0:
            ot_pay = ot_hours * hourly_rate * ot_mult
            dt_pay = dt_hours * hourly_rate * dt_mult
        else:
            ot_pay = 0
            dt_pay = 0

        total_pay = base_pay + ot_pay + dt_pay + kit_rental + car_allow + phone_allow

        labor_entries.append(LaborCostEntry(
            user_id=tc_user_id or "",
            user_name=profile.get("full_name"),
            user_avatar=profile.get("avatar_url"),
            role_title=role_title,
            department=department,
            position=entry.get("position"),
            hours_worked=hours,
            overtime_hours=ot_hours,
            double_time_hours=dt_hours,
            rate_type=rate_type,
            rate_amount=rate_amount,
            overtime_multiplier=ot_mult,
            double_time_multiplier=dt_mult,
            base_pay=round(base_pay, 2),
            overtime_pay=round(ot_pay, 2),
            double_time_pay=round(dt_pay, 2),
            kit_rental=kit_rental,
            car_allowance=car_allow,
            phone_allowance=phone_allow,
            total_pay=round(total_pay, 2),
            rate_source=rate_source,
            timecard_status=tc_status,
            timecard_entry_id=entry.get("id"),
        ))

        total_base += base_pay
        total_ot += ot_pay
        total_dt += dt_pay
        total_allowances += kit_rental + car_allow + phone_allow

    return DailyLaborCosts(
        production_day_id=production_day_id or "",
        date=day_date,
        entries=labor_entries,
        total_base_pay=round(total_base, 2),
        total_overtime_pay=round(total_ot, 2),
        total_double_time_pay=round(total_dt, 2),
        total_allowances=round(total_allowances, 2),
        grand_total=round(total_base + total_ot + total_dt + total_allowances, 2),
        approved_count=approved_count,
        pending_count=pending_count,
    )


# =====================================================
# DAILY BUDGET SCENE COSTS ENDPOINT
# =====================================================

class SceneExpenseItem(BaseModel):
    """An expense linked to a scene"""
    id: str
    expense_type: str  # 'receipt', 'mileage', 'kit_rental', 'per_diem', 'invoice_line_item'
    description: Optional[str] = None
    amount: float = 0
    vendor: Optional[str] = None
    user_name: Optional[str] = None
    date: Optional[str] = None
    status: Optional[str] = None


class SceneBreakdownCostItem(BaseModel):
    """A scene breakdown item with cost"""
    id: str
    item_type: str  # 'prop', 'wardrobe', 'makeup', 'special_effect', 'vehicle', 'animal', 'other'
    description: str
    quantity: int = 1
    estimated_cost: float = 0
    notes: Optional[str] = None


class SceneCostDetail(BaseModel):
    """Detailed costs for a single scene"""
    scene_id: str
    scene_number: Optional[str] = None
    scene_name: Optional[str] = None
    int_ext: Optional[str] = None
    location: Optional[str] = None

    # Breakdown items (from scene breakdown)
    breakdown_items: List[SceneBreakdownCostItem] = []
    breakdown_subtotal: float = 0

    # Expenses linked to this scene
    expenses: List[SceneExpenseItem] = []
    expenses_subtotal: float = 0

    # Total for this scene
    scene_total: float = 0


class DailySceneCosts(BaseModel):
    """Aggregated scene costs for a production day"""
    production_day_id: str
    date: str
    scenes: List[SceneCostDetail] = []
    total_breakdown_costs: float = 0
    total_expense_costs: float = 0
    grand_total: float = 0


@router.get("/daily-budgets/{daily_budget_id}/scene-costs", response_model=DailySceneCosts)
async def get_daily_budget_scene_costs(
    daily_budget_id: str,
    authorization: str = Header(None)
):
    """
    Get scene costs for a daily budget by aggregating:
    1. Scene breakdown items (props, wardrobe, etc.) for scenes shot that day
    2. Expenses linked to those scenes (receipts, mileage, kit rentals, per diem)
    3. Invoice line items linked to those scenes

    Note: Labor costs are NOT allocated to scenes (shown separately in labor costs endpoint).
    """
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]
    client = get_client()

    # Get daily budget with production day info
    db_response = client.table("backlot_daily_budgets").select(
        "*, production_day:production_day_id(id, date, project_id, day_number)"
    ).eq("id", daily_budget_id).execute()

    if not db_response.data:
        raise HTTPException(status_code=404, detail="Daily budget not found")

    daily_budget = db_response.data[0]
    prod_day = daily_budget.get("production_day") or {}
    project_id = prod_day.get("project_id") or daily_budget.get("project_id")
    day_date = prod_day.get("date")
    production_day_id = prod_day.get("id") or daily_budget.get("production_day_id")

    if not project_id:
        raise HTTPException(status_code=400, detail="Could not determine project")

    # Verify access
    await verify_budget_access(client, project_id, user_id)

    if not day_date or not production_day_id:
        return DailySceneCosts(
            production_day_id=production_day_id or "",
            date=day_date or "",
            scenes=[],
        )

    # Get scenes scheduled for this production day
    # Scenes are linked to production days via shooting_schedule or scene schedule
    schedule_response = client.table("backlot_shooting_schedule").select(
        "scene_id"
    ).eq("production_day_id", production_day_id).execute()

    scene_ids = list(set(s["scene_id"] for s in (schedule_response.data or []) if s.get("scene_id")))

    if not scene_ids:
        return DailySceneCosts(
            production_day_id=production_day_id,
            date=day_date,
            scenes=[],
        )

    # Get scene details
    scenes_response = client.table("backlot_scenes").select(
        "id, scene_number, scene_name, int_ext, location"
    ).in_("id", scene_ids).execute()
    scenes_by_id = {s["id"]: s for s in (scenes_response.data or [])}

    # Get scene breakdown items for these scenes
    breakdown_response = client.table("backlot_scene_breakdown_items").select(
        "id, scene_id, item_type, description, quantity, estimated_cost, notes"
    ).in_("scene_id", scene_ids).execute()
    breakdown_by_scene = {}
    for item in (breakdown_response.data or []):
        sid = item["scene_id"]
        if sid not in breakdown_by_scene:
            breakdown_by_scene[sid] = []
        breakdown_by_scene[sid].append(item)

    # Get expenses linked to these scenes
    # 1. Receipts
    receipts_response = client.table("backlot_receipts").select(
        "id, scene_id, description, amount, vendor_name, receipt_date, status"
    ).in_("scene_id", scene_ids).execute()
    receipts_by_scene = {}
    for r in (receipts_response.data or []):
        sid = r["scene_id"]
        if sid not in receipts_by_scene:
            receipts_by_scene[sid] = []
        receipts_by_scene[sid].append(r)

    # 2. Mileage entries
    mileage_response = client.table("backlot_mileage_entries").select(
        "id, scene_id, purpose, total_amount, date, status, user_id"
    ).in_("scene_id", scene_ids).execute()
    mileage_by_scene = {}
    user_ids_needed = set()
    for m in (mileage_response.data or []):
        sid = m["scene_id"]
        if sid not in mileage_by_scene:
            mileage_by_scene[sid] = []
        mileage_by_scene[sid].append(m)
        if m.get("user_id"):
            user_ids_needed.add(m["user_id"])

    # 3. Kit rentals
    kit_response = client.table("backlot_kit_rentals").select(
        "id, scene_id, kit_description, total_amount, start_date, status, user_id"
    ).in_("scene_id", scene_ids).execute()
    kit_by_scene = {}
    for k in (kit_response.data or []):
        sid = k["scene_id"]
        if sid not in kit_by_scene:
            kit_by_scene[sid] = []
        kit_by_scene[sid].append(k)
        if k.get("user_id"):
            user_ids_needed.add(k["user_id"])

    # 4. Per diem
    per_diem_response = client.table("backlot_per_diem").select(
        "id, scene_id, notes, total_amount, date, status, user_id"
    ).in_("scene_id", scene_ids).execute()
    per_diem_by_scene = {}
    for p in (per_diem_response.data or []):
        sid = p["scene_id"]
        if sid not in per_diem_by_scene:
            per_diem_by_scene[sid] = []
        per_diem_by_scene[sid].append(p)
        if p.get("user_id"):
            user_ids_needed.add(p["user_id"])

    # 5. Invoice line items
    invoice_items_response = client.table("backlot_invoice_line_items").select(
        "id, scene_id, description, amount, invoice:invoice_id(vendor_name, status)"
    ).in_("scene_id", scene_ids).execute()
    invoice_items_by_scene = {}
    for i in (invoice_items_response.data or []):
        sid = i["scene_id"]
        if sid not in invoice_items_by_scene:
            invoice_items_by_scene[sid] = []
        invoice_items_by_scene[sid].append(i)

    # Get user profiles for expense user names
    user_profiles = {}
    if user_ids_needed:
        profiles_resp = client.table("profiles").select(
            "id, full_name"
        ).in_("id", list(user_ids_needed)).execute()
        for p in (profiles_resp.data or []):
            user_profiles[p["id"]] = p.get("full_name")

    # Build scene cost details
    scene_costs = []
    total_breakdown = 0
    total_expenses = 0

    for scene_id in scene_ids:
        scene_info = scenes_by_id.get(scene_id, {})

        # Breakdown items
        breakdown_items = []
        breakdown_subtotal = 0
        for item in breakdown_by_scene.get(scene_id, []):
            cost = (item.get("estimated_cost") or 0) * (item.get("quantity") or 1)
            breakdown_items.append(SceneBreakdownCostItem(
                id=item["id"],
                item_type=item.get("item_type") or "other",
                description=item.get("description") or "",
                quantity=item.get("quantity") or 1,
                estimated_cost=item.get("estimated_cost") or 0,
                notes=item.get("notes"),
            ))
            breakdown_subtotal += cost

        # Expenses
        expenses = []
        expenses_subtotal = 0

        # Receipts
        for r in receipts_by_scene.get(scene_id, []):
            amount = r.get("amount") or 0
            expenses.append(SceneExpenseItem(
                id=r["id"],
                expense_type="receipt",
                description=r.get("description"),
                amount=amount,
                vendor=r.get("vendor_name"),
                date=r.get("receipt_date"),
                status=r.get("status"),
            ))
            expenses_subtotal += amount

        # Mileage
        for m in mileage_by_scene.get(scene_id, []):
            amount = m.get("total_amount") or 0
            expenses.append(SceneExpenseItem(
                id=m["id"],
                expense_type="mileage",
                description=m.get("purpose"),
                amount=amount,
                user_name=user_profiles.get(m.get("user_id")),
                date=m.get("date"),
                status=m.get("status"),
            ))
            expenses_subtotal += amount

        # Kit rentals
        for k in kit_by_scene.get(scene_id, []):
            amount = k.get("total_amount") or 0
            expenses.append(SceneExpenseItem(
                id=k["id"],
                expense_type="kit_rental",
                description=k.get("kit_description"),
                amount=amount,
                user_name=user_profiles.get(k.get("user_id")),
                date=k.get("start_date"),
                status=k.get("status"),
            ))
            expenses_subtotal += amount

        # Per diem
        for p in per_diem_by_scene.get(scene_id, []):
            amount = p.get("total_amount") or 0
            expenses.append(SceneExpenseItem(
                id=p["id"],
                expense_type="per_diem",
                description=p.get("notes") or "Per Diem",
                amount=amount,
                user_name=user_profiles.get(p.get("user_id")),
                date=p.get("date"),
                status=p.get("status"),
            ))
            expenses_subtotal += amount

        # Invoice line items
        for i in invoice_items_by_scene.get(scene_id, []):
            amount = i.get("amount") or 0
            invoice = i.get("invoice") or {}
            expenses.append(SceneExpenseItem(
                id=i["id"],
                expense_type="invoice_line_item",
                description=i.get("description"),
                amount=amount,
                vendor=invoice.get("vendor_name"),
                status=invoice.get("status"),
            ))
            expenses_subtotal += amount

        scene_total = breakdown_subtotal + expenses_subtotal
        total_breakdown += breakdown_subtotal
        total_expenses += expenses_subtotal

        scene_costs.append(SceneCostDetail(
            scene_id=scene_id,
            scene_number=scene_info.get("scene_number"),
            scene_name=scene_info.get("scene_name"),
            int_ext=scene_info.get("int_ext"),
            location=scene_info.get("location"),
            breakdown_items=breakdown_items,
            breakdown_subtotal=round(breakdown_subtotal, 2),
            expenses=expenses,
            expenses_subtotal=round(expenses_subtotal, 2),
            scene_total=round(scene_total, 2),
        ))

    # Sort scenes by scene number
    scene_costs.sort(key=lambda s: s.scene_number or "")

    return DailySceneCosts(
        production_day_id=production_day_id,
        date=day_date,
        scenes=scene_costs,
        total_breakdown_costs=round(total_breakdown, 2),
        total_expense_costs=round(total_expenses, 2),
        grand_total=round(total_breakdown + total_expenses, 2),
    )


# =====================================================
# DAILY BUDGET INVOICES ENDPOINT
# =====================================================

class DailyInvoiceLineItem(BaseModel):
    """A line item from an invoice"""
    id: str
    description: Optional[str] = None
    quantity: float = 1
    unit_price: float = 0
    amount: float = 0
    service_date: Optional[str] = None
    scene_id: Optional[str] = None
    scene_number: Optional[str] = None


class DailyInvoiceEntry(BaseModel):
    """An invoice for a production day"""
    id: str
    invoice_number: Optional[str] = None
    vendor_name: Optional[str] = None
    vendor_email: Optional[str] = None
    status: str = "draft"
    invoice_date: Optional[str] = None
    due_date: Optional[str] = None
    subtotal: float = 0
    tax_amount: float = 0
    total_amount: float = 0
    notes: Optional[str] = None
    line_items: List[DailyInvoiceLineItem] = []
    # How this invoice is linked to the day
    link_type: str = "production_day"  # 'production_day' or 'service_date'


class DailyInvoices(BaseModel):
    """Aggregated invoices for a production day"""
    production_day_id: str
    date: str
    invoices: List[DailyInvoiceEntry] = []
    total_amount: float = 0
    approved_total: float = 0
    pending_total: float = 0
    invoice_count: int = 0
    approved_count: int = 0
    pending_count: int = 0


@router.get("/daily-budgets/{daily_budget_id}/invoices", response_model=DailyInvoices)
async def get_daily_budget_invoices(
    daily_budget_id: str,
    include_pending: bool = True,
    authorization: str = Header(None)
):
    """
    Get invoices for a daily budget by finding invoices where:
    1. production_day_id matches this day, OR
    2. Line items have service_date within the production day

    Returns both approved and pending invoices (if include_pending=True).
    """
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]
    client = get_client()

    # Get daily budget with production day info
    db_response = client.table("backlot_daily_budgets").select(
        "*, production_day:production_day_id(id, date, project_id, day_number)"
    ).eq("id", daily_budget_id).execute()

    if not db_response.data:
        raise HTTPException(status_code=404, detail="Daily budget not found")

    daily_budget = db_response.data[0]
    prod_day = daily_budget.get("production_day") or {}
    project_id = prod_day.get("project_id") or daily_budget.get("project_id")
    day_date = prod_day.get("date")
    production_day_id = prod_day.get("id") or daily_budget.get("production_day_id")

    if not project_id:
        raise HTTPException(status_code=400, detail="Could not determine project")

    # Verify access
    await verify_budget_access(client, project_id, user_id)

    if not day_date or not production_day_id:
        return DailyInvoices(
            production_day_id=production_day_id or "",
            date=day_date or "",
            invoices=[],
        )

    # Build status filter
    statuses = ["approved", "sent", "paid"]
    if include_pending:
        statuses.extend(["pending_approval", "draft", "submitted"])

    # Get invoices directly linked to this production day
    direct_invoices_response = client.table("backlot_invoices").select(
        "*, line_items:backlot_invoice_line_items(id, description, quantity, unit_price, amount, service_date, scene_id)"
    ).eq("project_id", project_id).eq("production_day_id", production_day_id).in_("status", statuses).execute()

    direct_invoices = direct_invoices_response.data or []
    direct_invoice_ids = {inv["id"] for inv in direct_invoices}

    # Get invoices where any line item has service_date matching the production day
    line_items_response = client.table("backlot_invoice_line_items").select(
        "invoice_id"
    ).eq("service_date", day_date).execute()

    service_date_invoice_ids = list(set(
        li["invoice_id"] for li in (line_items_response.data or [])
        if li.get("invoice_id") and li["invoice_id"] not in direct_invoice_ids
    ))

    service_date_invoices = []
    if service_date_invoice_ids:
        service_invoices_response = client.table("backlot_invoices").select(
            "*, line_items:backlot_invoice_line_items(id, description, quantity, unit_price, amount, service_date, scene_id)"
        ).eq("project_id", project_id).in_("id", service_date_invoice_ids).in_("status", statuses).execute()
        service_date_invoices = service_invoices_response.data or []

    # Combine all invoices
    all_invoices = direct_invoices + service_date_invoices

    # Get scene numbers for any scene_ids in line items
    scene_ids = set()
    for inv in all_invoices:
        for li in (inv.get("line_items") or []):
            if li.get("scene_id"):
                scene_ids.add(li["scene_id"])

    scene_numbers = {}
    if scene_ids:
        scenes_resp = client.table("backlot_scenes").select(
            "id, scene_number"
        ).in_("id", list(scene_ids)).execute()
        for s in (scenes_resp.data or []):
            scene_numbers[s["id"]] = s.get("scene_number")

    # Build response
    invoice_entries = []
    total_amount = 0
    approved_total = 0
    pending_total = 0
    approved_count = 0
    pending_count = 0

    approved_statuses = {"approved", "sent", "paid"}

    for inv in all_invoices:
        inv_id = inv["id"]
        is_direct = inv_id in direct_invoice_ids
        link_type = "production_day" if is_direct else "service_date"
        status = inv.get("status", "draft")
        inv_total = inv.get("total_amount") or 0

        # Build line items
        line_items = []
        for li in (inv.get("line_items") or []):
            scene_id = li.get("scene_id")
            line_items.append(DailyInvoiceLineItem(
                id=li["id"],
                description=li.get("description"),
                quantity=li.get("quantity") or 1,
                unit_price=li.get("unit_price") or 0,
                amount=li.get("amount") or 0,
                service_date=li.get("service_date"),
                scene_id=scene_id,
                scene_number=scene_numbers.get(scene_id) if scene_id else None,
            ))

        invoice_entries.append(DailyInvoiceEntry(
            id=inv_id,
            invoice_number=inv.get("invoice_number"),
            vendor_name=inv.get("vendor_name"),
            vendor_email=inv.get("vendor_email"),
            status=status,
            invoice_date=inv.get("invoice_date"),
            due_date=inv.get("due_date"),
            subtotal=inv.get("subtotal") or 0,
            tax_amount=inv.get("tax_amount") or 0,
            total_amount=inv_total,
            notes=inv.get("notes"),
            line_items=line_items,
            link_type=link_type,
        ))

        total_amount += inv_total
        if status in approved_statuses:
            approved_total += inv_total
            approved_count += 1
        else:
            pending_total += inv_total
            pending_count += 1

    # Sort by invoice date
    invoice_entries.sort(key=lambda x: x.invoice_date or "", reverse=True)

    return DailyInvoices(
        production_day_id=production_day_id,
        date=day_date,
        invoices=invoice_entries,
        total_amount=round(total_amount, 2),
        approved_total=round(approved_total, 2),
        pending_total=round(pending_total, 2),
        invoice_count=len(invoice_entries),
        approved_count=approved_count,
        pending_count=pending_count,
    )


# =====================================================
# BUDGET-DAY LINKING ENDPOINTS
# =====================================================

@router.get("/production-days/{production_day_id}/suggested-line-items", response_model=List[SuggestedLineItemForDay])
async def get_suggested_line_items_for_day(
    production_day_id: str,
    authorization: str = Header(None)
):
    """Get suggested budget line items for a production day based on call sheet data"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get production day
    day_response = client.table("backlot_production_days").select("*").eq("id", production_day_id).execute()
    if not day_response.data:
        raise HTTPException(status_code=404, detail="Production day not found")

    prod_day = day_response.data[0]
    project_id = prod_day["project_id"]

    await verify_budget_access(client, project_id, user_id)

    # Get budget and line items
    budget_response = client.table("backlot_budgets").select("id").eq("project_id", project_id).execute()
    if not budget_response.data:
        return []

    budget_id = budget_response.data[0]["id"]

    line_items = client.table("backlot_budget_line_items").select("*").eq("budget_id", budget_id).execute()
    if not line_items.data:
        return []

    # Get call sheet for this day
    call_sheet = client.table("backlot_call_sheets").select("*").eq("production_day_id", production_day_id).limit(1).execute()

    # Get call sheet people (crew)
    people = []
    if call_sheet.data:
        people_response = client.table("backlot_call_sheet_people").select("*").eq("call_sheet_id", call_sheet.data[0]["id"]).execute()
        people = people_response.data or []

    suggestions = []

    for item in line_items.data:
        desc_lower = (item["description"] or "").lower()
        match_reason = None
        suggested_share = 0

        # Check if this is a daily rate item
        is_daily = item["rate_type"] == "daily"

        # Match by role in call sheet people
        for person in people:
            role_lower = (person.get("role") or "").lower()
            if role_lower and role_lower in desc_lower:
                match_reason = f"Role '{person.get('role')}' on call sheet"
                break
            # Also check department
            dept_lower = (person.get("department") or "").lower()
            if dept_lower and dept_lower in desc_lower:
                match_reason = f"Department '{person.get('department')}' on call sheet"
                break

        # Match by location if applicable
        location_name = prod_day.get("location_name", "").lower()
        if location_name and location_name in desc_lower:
            match_reason = f"Location match: {prod_day.get('location_name')}"

        # Match common production items
        common_daily_items = ["catering", "craft services", "crafty", "meals", "transport", "van", "fuel", "parking"]
        for common in common_daily_items:
            if common in desc_lower:
                match_reason = f"Common daily expense: {common}"
                break

        if match_reason:
            # Calculate suggested share
            if is_daily:
                suggested_share = item["rate_amount"]  # One day's rate
            else:
                # Divide total by number of production days
                days_count = client.table("backlot_production_days").select("id", count="exact").eq("project_id", project_id).execute()
                num_days = days_count.count if hasattr(days_count, 'count') else len(days_count.data or [])
                num_days = max(num_days, 1)
                suggested_share = item["estimated_total"] / num_days

            # Get category name
            cat_name = None
            if item.get("category_id"):
                cat_response = client.table("backlot_budget_categories").select("name").eq("id", item["category_id"]).execute()
                if cat_response.data:
                    cat_name = cat_response.data[0]["name"]

            suggestions.append(SuggestedLineItemForDay(
                line_item_id=item["id"],
                line_item_description=item["description"],
                category_name=cat_name,
                match_reason=match_reason,
                suggested_share=round(suggested_share, 2)
            ))

    return suggestions


@router.post("/daily-budgets/{daily_budget_id}/auto-populate")
async def auto_populate_daily_budget(
    daily_budget_id: str,
    authorization: str = Header(None)
):
    """Auto-populate daily budget items from suggested line items"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get daily budget
    db_response = client.table("backlot_daily_budgets").select("*").eq("id", daily_budget_id).execute()
    if not db_response.data:
        raise HTTPException(status_code=404, detail="Daily budget not found")

    daily_budget = db_response.data[0]
    await verify_budget_access(client, daily_budget["project_id"], user_id)

    # Get suggestions
    # We need to call our own endpoint logic here
    production_day_id = daily_budget["production_day_id"]

    # Get production day
    day_response = client.table("backlot_production_days").select("*").eq("id", production_day_id).execute()
    prod_day = day_response.data[0] if day_response.data else {}

    # Get budget and line items
    budget_id = daily_budget["budget_id"]
    line_items = client.table("backlot_budget_line_items").select("*").eq("budget_id", budget_id).execute()

    # Get call sheet
    call_sheet = client.table("backlot_call_sheets").select("*").eq("production_day_id", production_day_id).limit(1).execute()

    # Get people
    people = []
    if call_sheet.data:
        people_response = client.table("backlot_call_sheet_people").select("*").eq("call_sheet_id", call_sheet.data[0]["id"]).execute()
        people = people_response.data or []

    items_created = 0

    for item in line_items.data or []:
        desc_lower = (item["description"] or "").lower()
        match_reason = None

        # Check for matches
        for person in people:
            role_lower = (person.get("role") or "").lower()
            if role_lower and role_lower in desc_lower:
                match_reason = f"Role: {person.get('role')}"
                break
            dept_lower = (person.get("department") or "").lower()
            if dept_lower and dept_lower in desc_lower:
                match_reason = f"Department: {person.get('department')}"
                break

        location_name = prod_day.get("location_name", "").lower()
        if location_name and location_name in desc_lower:
            match_reason = f"Location: {prod_day.get('location_name')}"

        common_daily_items = ["catering", "craft services", "crafty", "meals", "transport", "van", "fuel", "parking"]
        for common in common_daily_items:
            if common in desc_lower:
                match_reason = f"Daily expense: {common}"
                break

        if match_reason:
            # Calculate share
            is_daily = item["rate_type"] == "daily"
            if is_daily:
                estimated = item["rate_amount"]
            else:
                days_count = client.table("backlot_production_days").select("id", count="exact").eq("project_id", daily_budget["project_id"]).execute()
                num_days = max(days_count.count if hasattr(days_count, 'count') else len(days_count.data or []), 1)
                estimated = item["estimated_total"] / num_days

            # Get category name
            cat_name = None
            if item.get("category_id"):
                cat_response = client.table("backlot_budget_categories").select("name").eq("id", item["category_id"]).execute()
                if cat_response.data:
                    cat_name = cat_response.data[0]["name"]

            # Check if already exists
            existing = client.table("backlot_daily_budget_items").select("id").eq("daily_budget_id", daily_budget_id).eq("budget_line_item_id", item["id"]).execute()
            if not existing.data:
                # Create item
                new_item = {
                    "daily_budget_id": daily_budget_id,
                    "budget_line_item_id": item["id"],
                    "label": item["description"],
                    "category_name": cat_name,
                    "estimated_amount": round(estimated, 2),
                    "actual_amount": 0,
                    "is_ad_hoc": False,
                    "sort_order": items_created
                }
                client.table("backlot_daily_budget_items").insert(new_item).execute()
                items_created += 1

    return {"success": True, "items_created": items_created, "message": f"Created {items_created} daily budget items"}


# =====================================================
# RECEIPTS SYSTEM - Models
# =====================================================

class ReceiptInput(BaseModel):
    """Input for creating/updating a receipt"""
    budget_id: Optional[str] = None
    daily_budget_id: Optional[str] = None
    budget_line_item_id: Optional[str] = None
    scene_id: Optional[str] = None
    vendor_name: Optional[str] = None
    description: Optional[str] = None
    purchase_date: Optional[str] = None
    amount: Optional[float] = None
    tax_amount: Optional[float] = None
    currency: Optional[str] = "USD"
    payment_method: Optional[str] = None
    reimbursement_status: Optional[str] = "not_applicable"
    reimbursement_to: Optional[str] = None
    notes: Optional[str] = None


class ReceiptMappingInput(BaseModel):
    """Input for mapping a receipt to budget items"""
    budget_line_item_id: Optional[str] = None
    daily_budget_id: Optional[str] = None
    scene_id: Optional[str] = None
    vendor_name: Optional[str] = None
    amount: Optional[float] = None
    purchase_date: Optional[str] = None
    is_verified: Optional[bool] = False


class ReceiptRegisterInput(BaseModel):
    """Input for registering an uploaded receipt file"""
    file_url: str
    original_filename: Optional[str] = None
    file_type: Optional[str] = "image/jpeg"
    file_size_bytes: Optional[int] = None
    run_ocr: bool = True
    daily_budget_id: Optional[str] = None
    scene_id: Optional[str] = None


class ReceiptManualInput(BaseModel):
    """Input for creating a receipt manually without a file"""
    vendor_name: str
    amount: float
    purchase_date: str  # YYYY-MM-DD format
    description: Optional[str] = None
    payment_method: Optional[str] = None
    tax_amount: Optional[float] = None
    budget_line_item_id: Optional[str] = None


class ReceiptUserInfo(BaseModel):
    """User info for receipt display"""
    display_name: Optional[str] = None
    full_name: Optional[str] = None


class Receipt(BaseModel):
    """Receipt response model"""
    id: str
    project_id: str
    budget_id: Optional[str] = None
    daily_budget_id: Optional[str] = None
    budget_line_item_id: Optional[str] = None
    scene_id: Optional[str] = None
    file_url: Optional[str] = None  # Optional for manual entries
    original_filename: Optional[str] = None
    file_type: Optional[str] = None
    file_size_bytes: Optional[int] = None
    vendor_name: Optional[str] = None
    description: Optional[str] = None
    purchase_date: Optional[str] = None
    amount: Optional[float] = None
    tax_amount: Optional[float] = None
    currency: Optional[str] = "USD"
    ocr_status: Optional[str] = "succeeded"
    ocr_confidence: Optional[float] = None
    raw_ocr_json: Optional[Dict[str, Any]] = None
    extracted_text: Optional[str] = None
    is_mapped: Optional[bool] = False
    is_verified: Optional[bool] = False
    payment_method: Optional[str] = None
    reimbursement_status: Optional[str] = "not_applicable"
    reimbursement_to: Optional[str] = None
    notes: Optional[str] = None
    created_by_user_id: Optional[str] = None
    created_by: Optional[ReceiptUserInfo] = None  # Joined user info for display
    created_at: Optional[str] = None
    updated_at: Optional[str] = None


class ReceiptOcrResponse(BaseModel):
    """Response from OCR processing"""
    success: bool
    vendor_name: Optional[str] = None
    amount: Optional[float] = None
    tax_amount: Optional[float] = None
    purchase_date: Optional[str] = None
    line_items: Optional[List[Dict[str, Any]]] = None
    confidence: float = 0
    raw_text: str = ""
    error: Optional[str] = None


class ReceiptCreateResponse(BaseModel):
    """Response from receipt creation"""
    receipt: Receipt
    ocr_result: Optional[ReceiptOcrResponse] = None


# =====================================================
# PROJECT CONTACTS ENDPOINTS
# =====================================================

class ProjectContactInput(BaseModel):
    """Input for creating/updating a contact"""
    contact_type: Optional[str] = "other"
    status: Optional[str] = "new"
    name: str
    company: Optional[str] = None
    email: Optional[str] = None
    phone: Optional[str] = None
    role_interest: Optional[str] = None
    notes: Optional[str] = None
    last_contact_date: Optional[str] = None
    next_follow_up_date: Optional[str] = None
    user_id: Optional[str] = None
    source: Optional[str] = None


@router.get("/projects/{project_id}/contacts")
async def get_project_contacts(
    project_id: str,
    contact_type: Optional[str] = None,
    status: Optional[str] = None,
    search: Optional[str] = None,
    limit: int = Query(100, ge=1, le=500),
    authorization: str = Header(None)
):
    """Get all contacts for a project with filters"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        query = client.table("backlot_project_contacts").select("*").eq(
            "project_id", project_id
        ).order("created_at", desc=True).limit(limit)

        contacts_result = query.execute()
        contacts = contacts_result.data or []

        # Apply filters client-side (could be optimized with proper SQL)
        if contact_type and contact_type != "all":
            contacts = [c for c in contacts if c.get("contact_type") == contact_type]
        if status and status != "all":
            contacts = [c for c in contacts if c.get("status") == status]
        if search:
            search_lower = search.lower()
            contacts = [c for c in contacts if
                search_lower in (c.get("name") or "").lower() or
                search_lower in (c.get("company") or "").lower() or
                search_lower in (c.get("email") or "").lower()
            ]

        # Fetch profiles for linked users
        if contacts:
            user_ids = set()
            for c in contacts:
                if c.get("user_id"):
                    user_ids.add(c["user_id"])
                if c.get("created_by"):
                    user_ids.add(c["created_by"])

            profile_map = {}
            if user_ids:
                profiles_result = client.table("profiles").select(
                    "id, username, full_name, display_name, avatar_url, role, is_order_member"
                ).in_("id", list(user_ids)).execute()
                profile_map = {p["id"]: p for p in (profiles_result.data or [])}

            for contact in contacts:
                contact["linked_user"] = profile_map.get(contact.get("user_id"))
                contact["creator"] = profile_map.get(contact.get("created_by"))

        return {"contacts": contacts}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting contacts: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/contacts/{contact_id}")
async def get_contact(
    contact_id: str,
    authorization: str = Header(None)
):
    """Get a single contact"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        contact_result = client.table("backlot_project_contacts").select("*").eq(
            "id", contact_id
        ).single().execute()

        if not contact_result.data:
            raise HTTPException(status_code=404, detail="Contact not found")

        contact = contact_result.data
        await verify_project_access(client, contact["project_id"], user["id"])

        # Fetch profiles
        user_ids = set()
        if contact.get("user_id"):
            user_ids.add(contact["user_id"])
        if contact.get("created_by"):
            user_ids.add(contact["created_by"])

        if user_ids:
            profiles_result = client.table("profiles").select(
                "id, username, full_name, display_name, avatar_url, role, is_order_member"
            ).in_("id", list(user_ids)).execute()
            profile_map = {p["id"]: p for p in (profiles_result.data or [])}
            contact["linked_user"] = profile_map.get(contact.get("user_id"))
            contact["creator"] = profile_map.get(contact.get("created_by"))

        return {"contact": contact}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting contact: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/contacts")
async def create_contact(
    project_id: str,
    input: ProjectContactInput,
    authorization: str = Header(None)
):
    """Create a new contact"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"], require_edit=True)

        contact_result = client.table("backlot_project_contacts").insert({
            "project_id": project_id,
            "contact_type": input.contact_type or "other",
            "status": input.status or "new",
            "name": input.name,
            "company": input.company,
            "email": input.email,
            "phone": input.phone,
            "role_interest": input.role_interest,
            "notes": input.notes,
            "last_contact_date": input.last_contact_date,
            "next_follow_up_date": input.next_follow_up_date,
            "user_id": input.user_id,
            "source": input.source,
            "created_by": user["id"]
        }).execute()

        if not contact_result.data:
            raise HTTPException(status_code=500, detail="Failed to create contact")

        return {"contact": contact_result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating contact: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/contacts/{contact_id}")
async def update_contact(
    contact_id: str,
    input: ProjectContactInput,
    authorization: str = Header(None)
):
    """Update a contact"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get contact to check project access
        contact_result = client.table("backlot_project_contacts").select("project_id").eq(
            "id", contact_id
        ).single().execute()

        if not contact_result.data:
            raise HTTPException(status_code=404, detail="Contact not found")

        await verify_project_access(client, contact_result.data["project_id"], user["id"], require_edit=True)

        update_data = {}
        if input.contact_type is not None:
            update_data["contact_type"] = input.contact_type
        if input.status is not None:
            update_data["status"] = input.status
        if input.name is not None:
            update_data["name"] = input.name
        if input.company is not None:
            update_data["company"] = input.company
        if input.email is not None:
            update_data["email"] = input.email
        if input.phone is not None:
            update_data["phone"] = input.phone
        if input.role_interest is not None:
            update_data["role_interest"] = input.role_interest
        if input.notes is not None:
            update_data["notes"] = input.notes
        if input.last_contact_date is not None:
            update_data["last_contact_date"] = input.last_contact_date
        if input.next_follow_up_date is not None:
            update_data["next_follow_up_date"] = input.next_follow_up_date
        if input.user_id is not None:
            update_data["user_id"] = input.user_id
        if input.source is not None:
            update_data["source"] = input.source

        result = client.table("backlot_project_contacts").update(update_data).eq(
            "id", contact_id
        ).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to update contact")

        return {"contact": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating contact: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/contacts/{contact_id}/status")
async def update_contact_status(
    contact_id: str,
    status: str = Query(...),
    authorization: str = Header(None)
):
    """Update contact status"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        contact_result = client.table("backlot_project_contacts").select("project_id").eq(
            "id", contact_id
        ).single().execute()

        if not contact_result.data:
            raise HTTPException(status_code=404, detail="Contact not found")

        await verify_project_access(client, contact_result.data["project_id"], user["id"], require_edit=True)

        result = client.table("backlot_project_contacts").update({
            "status": status
        }).eq("id", contact_id).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to update status")

        return {"contact": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating contact status: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/contacts/{contact_id}/log")
async def log_contact_interaction(
    contact_id: str,
    notes: Optional[str] = Body(None),
    authorization: str = Header(None)
):
    """Log a contact interaction"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        contact_result = client.table("backlot_project_contacts").select(
            "project_id, notes"
        ).eq("id", contact_id).single().execute()

        if not contact_result.data:
            raise HTTPException(status_code=404, detail="Contact not found")

        await verify_project_access(client, contact_result.data["project_id"], user["id"], require_edit=True)

        update_data = {
            "last_contact_date": datetime.utcnow().strftime("%Y-%m-%d")
        }

        if notes:
            timestamp = datetime.utcnow().strftime("%Y-%m-%d")
            new_note = f"[{timestamp}] {notes}"
            existing_notes = contact_result.data.get("notes")
            update_data["notes"] = f"{existing_notes}\n\n{new_note}" if existing_notes else new_note

        result = client.table("backlot_project_contacts").update(update_data).eq(
            "id", contact_id
        ).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to log contact")

        return {"contact": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error logging contact: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/contacts/{contact_id}")
async def delete_contact(
    contact_id: str,
    authorization: str = Header(None)
):
    """Delete a contact"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        contact_result = client.table("backlot_project_contacts").select("project_id").eq(
            "id", contact_id
        ).single().execute()

        if not contact_result.data:
            raise HTTPException(status_code=404, detail="Contact not found")

        await verify_project_access(client, contact_result.data["project_id"], user["id"], require_edit=True)

        client.table("backlot_project_contacts").delete().eq("id", contact_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting contact: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/contacts/stats")
async def get_contact_stats(
    project_id: str,
    authorization: str = Header(None)
):
    """Get contact statistics for a project"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        contacts_result = client.table("backlot_project_contacts").select(
            "contact_type, status"
        ).eq("project_id", project_id).execute()

        contacts = contacts_result.data or []

        stats = {
            "total": len(contacts),
            "by_type": {
                "investor": len([c for c in contacts if c.get("contact_type") == "investor"]),
                "crew": len([c for c in contacts if c.get("contact_type") == "crew"]),
                "collaborator": len([c for c in contacts if c.get("contact_type") == "collaborator"]),
                "vendor": len([c for c in contacts if c.get("contact_type") == "vendor"]),
                "talent": len([c for c in contacts if c.get("contact_type") == "talent"]),
                "other": len([c for c in contacts if c.get("contact_type") == "other"]),
            },
            "by_status": {
                "new": len([c for c in contacts if c.get("status") == "new"]),
                "contacted": len([c for c in contacts if c.get("status") == "contacted"]),
                "in_discussion": len([c for c in contacts if c.get("status") == "in_discussion"]),
                "confirmed": len([c for c in contacts if c.get("status") == "confirmed"]),
                "declined": len([c for c in contacts if c.get("status") == "declined"]),
                "archived": len([c for c in contacts if c.get("status") == "archived"]),
            },
            "needs_followup": len([c for c in contacts if c.get("status") not in ["confirmed", "declined", "archived"]]),
        }

        return stats

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting contact stats: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# FILE UPLOAD ENDPOINTS (S3)
# =====================================================

@router.post("/projects/{project_id}/upload-receipt")
async def upload_receipt_file(
    project_id: str,
    file: UploadFile = File(...),
    authorization: str = Header(None)
):
    """
    Upload a receipt file to S3 and return the URL.

    This should be called before registering the receipt.
    """
    from app.core.storage import storage_client
    import io

    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()
    await verify_budget_access(client, project_id, user_id)

    # Validate file type
    allowed_types = ["image/jpeg", "image/png", "image/gif", "image/webp", "application/pdf"]
    if file.content_type not in allowed_types:
        raise HTTPException(status_code=400, detail=f"Invalid file type. Allowed: {', '.join(allowed_types)}")

    # Generate unique filename
    import uuid
    ext = file.filename.split(".")[-1] if file.filename and "." in file.filename else "jpg"
    filename = f"receipts/{project_id}/{uuid.uuid4()}.{ext}"

    try:
        # Upload to S3
        file_content = await file.read()
        file_obj = io.BytesIO(file_content)

        storage_client.from_("backlot").upload(
            filename,
            file_obj,
            {"content_type": file.content_type}
        )

        # Get public URL
        file_url = storage_client.from_("backlot").get_public_url(filename)

        return {
            "success": True,
            "file_url": file_url,
            "file_path": filename,
            "content_type": file.content_type
        }

    except Exception as e:
        print(f"Error uploading receipt: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to upload file: {str(e)}")


@router.post("/projects/{project_id}/upload-call-sheet-logo")
async def upload_call_sheet_logo(
    project_id: str,
    file: UploadFile = File(...),
    authorization: str = Header(None)
):
    """
    Upload a call sheet logo to S3 and return the URL.

    The URL can then be used to update the project's header_logo_url.
    """
    from app.core.storage import storage_client
    import io

    print(f"[Logo Upload] Starting upload for project {project_id}")
    print(f"[Logo Upload] File: {file.filename}, Content-Type: {file.content_type}, Size: {file.size}")

    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]
    print(f"[Logo Upload] User authenticated: {user_id}")

    client = get_client()
    await verify_project_access(client, project_id, user_id, require_edit=True)
    print(f"[Logo Upload] Project access verified")

    # Validate file type - logos should be images
    allowed_types = ["image/jpeg", "image/png", "image/gif", "image/webp", "image/svg+xml"]
    if file.content_type not in allowed_types:
        raise HTTPException(status_code=400, detail=f"Invalid file type. Allowed: {', '.join(allowed_types)}")

    # Generate unique filename
    import uuid
    ext = file.filename.split(".")[-1] if file.filename and "." in file.filename else "png"
    filename = f"call-sheet-logos/{project_id}/{uuid.uuid4()}.{ext}"

    try:
        # Upload to S3
        print(f"[Logo Upload] Reading file content...")
        file_content = await file.read()
        print(f"[Logo Upload] File content size: {len(file_content)} bytes")
        file_obj = io.BytesIO(file_content)

        print(f"[Logo Upload] Uploading to S3: {filename}")
        storage_client.from_("backlot-files").upload(
            filename,
            file_obj,
            {"content_type": file.content_type}
        )
        print(f"[Logo Upload] S3 upload successful")

        # Get public URL
        logo_url = storage_client.from_("backlot-files").get_public_url(filename)
        print(f"[Logo Upload] Public URL: {logo_url}")

        return {
            "success": True,
            "logo_url": logo_url,
            "message": "Logo uploaded successfully"
        }

    except Exception as e:
        import traceback
        print(f"[Logo Upload] Error: {e}")
        print(f"[Logo Upload] Traceback: {traceback.format_exc()}")
        raise HTTPException(status_code=500, detail=f"Failed to upload logo: {str(e)}")


# =====================================================
# RECEIPTS ENDPOINTS
# =====================================================

@router.get("/projects/{project_id}/receipts", response_model=List[Receipt])
async def get_project_receipts(
    project_id: str,
    is_mapped: Optional[bool] = None,
    is_verified: Optional[bool] = None,
    daily_budget_id: Optional[str] = None,
    budget_line_item_id: Optional[str] = None,
    date_from: Optional[str] = None,
    date_to: Optional[str] = None,
    reimbursement_status: Optional[str] = None,
    authorization: str = Header(None)
):
    """Get all receipts for a project with optional filters"""
    from app.core.storage import storage_client

    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()
    await verify_budget_access(client, project_id, user_id)

    # Build query
    query = client.table("backlot_receipts").select("*").eq("project_id", project_id)

    if is_mapped is not None:
        query = query.eq("is_mapped", is_mapped)
    if is_verified is not None:
        query = query.eq("is_verified", is_verified)
    if daily_budget_id:
        query = query.eq("daily_budget_id", daily_budget_id)
    if budget_line_item_id:
        query = query.eq("budget_line_item_id", budget_line_item_id)
    if date_from:
        query = query.gte("purchase_date", date_from)
    if date_to:
        query = query.lte("purchase_date", date_to)
    if reimbursement_status:
        query = query.eq("reimbursement_status", reimbursement_status)

    response = query.order("created_at", desc=True).execute()
    receipts = response.data or []

    # Fetch user info for created_by display
    user_ids = list(set(r.get("created_by_user_id") for r in receipts if r.get("created_by_user_id")))
    user_map = {}
    if user_ids:
        try:
            users_resp = client.table("profiles").select("id, display_name, full_name").in_("id", user_ids).execute()
            for u in (users_resp.data or []):
                user_map[u["id"]] = {"display_name": u.get("display_name"), "full_name": u.get("full_name")}
        except Exception as e:
            print(f"Error fetching user info for receipts: {e}")

    # Add created_by object and generate signed URLs
    for receipt in receipts:
        # Add created_by object for display
        user_id = receipt.get("created_by_user_id")
        if user_id and user_id in user_map:
            receipt["created_by"] = user_map[user_id]
        else:
            receipt["created_by"] = None
        file_url = receipt.get("file_url")
        if file_url:
            # Extract the path from the URL (format: https://bucket.s3.region.amazonaws.com/path)
            # or handle s3:// format
            try:
                if file_url.startswith("s3://"):
                    # s3://bucket/path format
                    path = file_url.split("/", 3)[-1] if "/" in file_url[5:] else ""
                elif ".s3." in file_url and ".amazonaws.com/" in file_url:
                    # https://bucket.s3.region.amazonaws.com/path format
                    path = file_url.split(".amazonaws.com/", 1)[-1]
                else:
                    # Already a signed URL or other format, skip
                    continue

                if path:
                    signed = storage_client.from_("backlot").create_signed_url(path, expires_in=3600)
                    if signed.get("signedUrl"):
                        receipt["file_url"] = signed["signedUrl"]
            except Exception as e:
                print(f"Error generating signed URL for receipt {receipt.get('id')}: {e}")

    return receipts


@router.get("/projects/{project_id}/receipts/{receipt_id}", response_model=Receipt)
async def get_project_receipt(
    project_id: str,
    receipt_id: str,
    authorization: str = Header(None)
):
    """Get a single receipt by ID within a project context"""
    from app.core.storage import storage_client

    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()
    await verify_budget_access(client, project_id, user_id)

    response = client.table("backlot_receipts").select("*").eq("id", receipt_id).eq("project_id", project_id).execute()
    if not response.data:
        raise HTTPException(status_code=404, detail="Receipt not found")

    receipt = response.data[0]

    # Fetch user info for created_by display
    created_by_user_id = receipt.get("created_by_user_id")
    if created_by_user_id:
        try:
            user_resp = client.table("profiles").select("id, display_name, full_name").eq("id", created_by_user_id).single().execute()
            if user_resp.data:
                receipt["created_by"] = {"display_name": user_resp.data.get("display_name"), "full_name": user_resp.data.get("full_name")}
        except Exception as e:
            print(f"Error fetching user info for receipt {receipt_id}: {e}")

    # Fetch line item info if mapped
    if receipt.get("budget_line_item_id"):
        try:
            line_item_resp = client.table("backlot_budget_line_items").select("id, name, code").eq("id", receipt["budget_line_item_id"]).single().execute()
            if line_item_resp.data:
                receipt["line_item"] = line_item_resp.data
        except Exception as e:
            print(f"Error fetching line item for receipt {receipt_id}: {e}")

    # Fetch daily budget info if mapped
    if receipt.get("daily_budget_id"):
        try:
            daily_resp = client.table("backlot_daily_budgets").select("id, name, date").eq("id", receipt["daily_budget_id"]).single().execute()
            if daily_resp.data:
                receipt["daily_budget"] = daily_resp.data
        except Exception as e:
            print(f"Error fetching daily budget for receipt {receipt_id}: {e}")

    # Generate signed URL for the receipt file
    file_url = receipt.get("file_url")
    if file_url:
        try:
            if file_url.startswith("s3://"):
                path = file_url.split("/", 3)[-1] if "/" in file_url[5:] else ""
            elif ".s3." in file_url and ".amazonaws.com/" in file_url:
                path = file_url.split(".amazonaws.com/", 1)[-1]
            else:
                path = None

            if path:
                signed = storage_client.from_("backlot").create_signed_url(path, expires_in=3600)
                if signed.get("signedUrl"):
                    receipt["file_url"] = signed["signedUrl"]
        except Exception as e:
            print(f"Error generating signed URL for receipt {receipt_id}: {e}")

    return receipt


@router.get("/receipts/{receipt_id}", response_model=Receipt)
async def get_receipt(
    receipt_id: str,
    authorization: str = Header(None)
):
    """Get a receipt by ID"""
    from app.core.storage import storage_client

    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    response = client.table("backlot_receipts").select("*").eq("id", receipt_id).execute()
    if not response.data:
        raise HTTPException(status_code=404, detail="Receipt not found")

    receipt = response.data[0]
    await verify_budget_access(client, receipt["project_id"], user_id)

    # Generate signed URL for the receipt file
    file_url = receipt.get("file_url")
    if file_url:
        try:
            if file_url.startswith("s3://"):
                path = file_url.split("/", 3)[-1] if "/" in file_url[5:] else ""
            elif ".s3." in file_url and ".amazonaws.com/" in file_url:
                path = file_url.split(".amazonaws.com/", 1)[-1]
            else:
                path = None

            if path:
                signed = storage_client.from_("backlot").create_signed_url(path, expires_in=3600)
                if signed.get("signedUrl"):
                    receipt["file_url"] = signed["signedUrl"]
        except Exception as e:
            print(f"Error generating signed URL for receipt {receipt_id}: {e}")

    return receipt


@router.post("/projects/{project_id}/receipts/register", response_model=ReceiptCreateResponse)
async def register_receipt(
    project_id: str,
    data: ReceiptRegisterInput,
    authorization: str = Header(None)
):
    """
    Register an uploaded receipt file and optionally run OCR.

    The file should already be uploaded to S3 Storage.
    This endpoint registers it in the database and processes it.
    """
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()
    await verify_budget_access(client, project_id, user_id)

    # Get budget for the project
    budget_response = client.table("backlot_budgets").select("id").eq("project_id", project_id).execute()
    budget_id = budget_response.data[0]["id"] if budget_response.data else None

    # Create receipt record (only include columns that exist in the table)
    receipt_data = {
        "project_id": project_id,
        "budget_id": budget_id,
        "file_url": data.file_url,
        "original_filename": data.original_filename,
        "file_type": data.file_type,
        "file_size_bytes": data.file_size_bytes,
        "created_by_user_id": user_id,
        "ocr_status": "pending" if data.run_ocr else "succeeded",
    }

    result = client.table("backlot_receipts").insert(receipt_data).execute()
    if not result.data:
        raise HTTPException(status_code=500, detail="Failed to create receipt record")

    receipt = result.data[0]
    ocr_result = None

    # Run OCR if requested
    if data.run_ocr:
        from app.services.ocr_service import process_receipt

        # Update status to processing
        client.table("backlot_receipts").update({
            "ocr_status": "processing"
        }).eq("id", receipt["id"]).execute()

        try:
            ocr_data = await process_receipt(data.file_url, data.file_type or "image/jpeg")

            # Update receipt with OCR results
            update_data = {
                "ocr_status": "succeeded" if ocr_data.success else "failed",
                "ocr_confidence": ocr_data.confidence,
                "extracted_text": ocr_data.raw_text,
                "raw_ocr_json": ocr_data.to_dict(),
            }

            # If OCR extracted data, populate fields
            if ocr_data.success:
                if ocr_data.vendor_name:
                    update_data["vendor_name"] = ocr_data.vendor_name
                if ocr_data.amount:
                    update_data["amount"] = ocr_data.amount
                if ocr_data.tax_amount:
                    update_data["tax_amount"] = ocr_data.tax_amount
                if ocr_data.purchase_date:
                    update_data["purchase_date"] = ocr_data.purchase_date

            updated = client.table("backlot_receipts").update(update_data).eq("id", receipt["id"]).execute()
            receipt = updated.data[0] if updated.data else receipt

            ocr_result = ReceiptOcrResponse(
                success=ocr_data.success,
                vendor_name=ocr_data.vendor_name,
                amount=ocr_data.amount,
                tax_amount=ocr_data.tax_amount,
                purchase_date=ocr_data.purchase_date,
                line_items=ocr_data.line_items,
                confidence=ocr_data.confidence,
                raw_text=ocr_data.raw_text,
                error=ocr_data.error
            )

        except Exception as e:
            client.table("backlot_receipts").update({
                "ocr_status": "failed",
                "raw_ocr_json": {"error": str(e)}
            }).eq("id", receipt["id"]).execute()

            ocr_result = ReceiptOcrResponse(
                success=False,
                error=str(e)
            )

    return ReceiptCreateResponse(
        receipt=Receipt(**receipt),
        ocr_result=ocr_result
    )


@router.post("/projects/{project_id}/receipts/manual", response_model=Receipt)
async def create_manual_receipt(
    project_id: str,
    data: ReceiptManualInput,
    authorization: str = Header(None)
):
    """
    Create a receipt manually without a file upload.

    Use this when entering receipt data without an image/PDF.
    """
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()
    await verify_budget_access(client, project_id, user_id)

    # Get budget for the project
    budget_response = client.table("backlot_budgets").select("id").eq("project_id", project_id).execute()
    budget_id = budget_response.data[0]["id"] if budget_response.data else None

    # Create receipt record (only include columns that exist in the table)
    receipt_data = {
        "project_id": project_id,
        "budget_id": budget_id,
        "budget_line_item_id": data.budget_line_item_id,
        "vendor_name": data.vendor_name,
        "amount": data.amount,
        "tax_amount": data.tax_amount,
        "purchase_date": data.purchase_date,
        "description": data.description,
        "payment_method": data.payment_method,
        "created_by_user_id": user_id,
        "ocr_status": "succeeded",  # No OCR needed for manual entry
        "is_verified": True,  # Manual entry is considered verified
    }

    result = client.table("backlot_receipts").insert(receipt_data).execute()
    if not result.data:
        raise HTTPException(status_code=500, detail="Failed to create receipt record")

    return Receipt(**result.data[0])


@router.post("/receipts/{receipt_id}/reprocess-ocr", response_model=ReceiptOcrResponse)
async def reprocess_receipt_ocr(
    receipt_id: str,
    authorization: str = Header(None)
):
    """Re-run OCR on a receipt"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get receipt
    response = client.table("backlot_receipts").select("*").eq("id", receipt_id).execute()
    if not response.data:
        raise HTTPException(status_code=404, detail="Receipt not found")

    receipt = response.data[0]
    await verify_budget_access(client, receipt["project_id"], user_id)

    # Update status to processing
    client.table("backlot_receipts").update({
        "ocr_status": "processing"
    }).eq("id", receipt_id).execute()

    try:
        from app.services.ocr_service import process_receipt

        ocr_data = await process_receipt(
            receipt["file_url"],
            receipt.get("file_type") or "image/jpeg"
        )

        # Update receipt with OCR results
        update_data = {
            "ocr_status": "succeeded" if ocr_data.success else "failed",
            "ocr_confidence": ocr_data.confidence,
            "extracted_text": ocr_data.raw_text,
            "raw_ocr_json": ocr_data.to_dict(),
        }

        if ocr_data.success:
            if ocr_data.vendor_name:
                update_data["vendor_name"] = ocr_data.vendor_name
            if ocr_data.amount:
                update_data["amount"] = ocr_data.amount
            if ocr_data.tax_amount:
                update_data["tax_amount"] = ocr_data.tax_amount
            if ocr_data.purchase_date:
                update_data["purchase_date"] = ocr_data.purchase_date

        client.table("backlot_receipts").update(update_data).eq("id", receipt_id).execute()

        return ReceiptOcrResponse(
            success=ocr_data.success,
            vendor_name=ocr_data.vendor_name,
            amount=ocr_data.amount,
            tax_amount=ocr_data.tax_amount,
            purchase_date=ocr_data.purchase_date,
            line_items=ocr_data.line_items,
            confidence=ocr_data.confidence,
            raw_text=ocr_data.raw_text,
            error=ocr_data.error
        )

    except Exception as e:
        client.table("backlot_receipts").update({
            "ocr_status": "failed",
            "raw_ocr_json": {"error": str(e)}
        }).eq("id", receipt_id).execute()

        return ReceiptOcrResponse(
            success=False,
            error=str(e)
        )


@router.put("/receipts/{receipt_id}", response_model=Receipt)
async def update_receipt(
    receipt_id: str,
    receipt_input: ReceiptInput,
    authorization: str = Header(None)
):
    """Update a receipt"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get receipt to verify access and check current status
    existing = client.table("backlot_receipts").select("project_id, reimbursement_status, rejection_reason, denied_by, denied_at, denial_reason").eq("id", receipt_id).execute()
    if not existing.data:
        raise HTTPException(status_code=404, detail="Receipt not found")

    receipt = existing.data[0]
    await verify_budget_access(client, receipt["project_id"], user_id)

    # Update - only include columns that exist in the table
    input_data = receipt_input.model_dump(exclude_unset=True)

    # Columns that exist in backlot_receipts table
    valid_columns = {
        "vendor_name", "description", "purchase_date", "amount", "tax_amount",
        "payment_method", "budget_line_item_id", "is_mapped", "is_verified",
        "reimbursement_status", "reimbursement_to"
    }

    update_data = {k: v for k, v in input_data.items() if k in valid_columns}

    # Convert empty strings to None for fields that don't accept empty strings
    for key in ["purchase_date", "payment_method", "budget_line_item_id", "reimbursement_status", "reimbursement_to"]:
        if key in update_data and update_data[key] == "":
            update_data[key] = None

    # If editing a rejected/denied receipt, reset to draft so user can resubmit
    if receipt.get("reimbursement_status") in ["changes_requested", "denied"]:
        update_data["reimbursement_status"] = "draft"
        update_data["rejection_reason"] = None
        update_data["denied_by"] = None
        update_data["denied_at"] = None
        update_data["denial_reason"] = None

    update_data["updated_at"] = datetime.utcnow().isoformat()

    result = client.table("backlot_receipts").update(update_data).eq("id", receipt_id).execute()
    if not result.data:
        raise HTTPException(status_code=500, detail="Failed to update receipt")

    return result.data[0]


@router.put("/receipts/{receipt_id}/map", response_model=Receipt)
async def map_receipt(
    receipt_id: str,
    mapping: ReceiptMappingInput,
    authorization: str = Header(None)
):
    """Map a receipt to a budget line item and/or daily budget"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get receipt to verify access
    existing = client.table("backlot_receipts").select("*").eq("id", receipt_id).execute()
    if not existing.data:
        raise HTTPException(status_code=404, detail="Receipt not found")

    receipt = existing.data[0]
    await verify_budget_access(client, receipt["project_id"], user_id)

    # Build update data
    update_data = {
        "updated_at": datetime.utcnow().isoformat(),
        "is_mapped": True,
    }

    if mapping.budget_line_item_id is not None:
        update_data["budget_line_item_id"] = mapping.budget_line_item_id
    if mapping.daily_budget_id is not None:
        update_data["daily_budget_id"] = mapping.daily_budget_id
    if mapping.scene_id is not None:
        update_data["scene_id"] = mapping.scene_id
    if mapping.vendor_name is not None:
        update_data["vendor_name"] = mapping.vendor_name
    if mapping.amount is not None:
        update_data["amount"] = mapping.amount
    if mapping.purchase_date is not None:
        update_data["purchase_date"] = mapping.purchase_date
    if mapping.is_verified is not None:
        update_data["is_verified"] = mapping.is_verified

    result = client.table("backlot_receipts").update(update_data).eq("id", receipt_id).execute()
    if not result.data:
        raise HTTPException(status_code=500, detail="Failed to map receipt")

    return result.data[0]


@router.put("/receipts/{receipt_id}/verify", response_model=Receipt)
async def verify_receipt(
    receipt_id: str,
    authorization: str = Header(None)
):
    """Mark a receipt as verified (user confirmed the extracted data)"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get receipt to verify access
    existing = client.table("backlot_receipts").select("project_id").eq("id", receipt_id).execute()
    if not existing.data:
        raise HTTPException(status_code=404, detail="Receipt not found")

    await verify_budget_access(client, existing.data[0]["project_id"], user_id)

    result = client.table("backlot_receipts").update({
        "is_verified": True,
        "updated_at": datetime.utcnow().isoformat()
    }).eq("id", receipt_id).execute()

    if not result.data:
        raise HTTPException(status_code=500, detail="Failed to verify receipt")

    return result.data[0]


@router.delete("/receipts/{receipt_id}")
async def delete_receipt(
    receipt_id: str,
    authorization: str = Header(None)
):
    """Delete a receipt"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get receipt to verify access
    existing = client.table("backlot_receipts").select("project_id, file_url").eq("id", receipt_id).execute()
    if not existing.data:
        raise HTTPException(status_code=404, detail="Receipt not found")

    await verify_budget_access(client, existing.data[0]["project_id"], user_id)

    # Delete from database (file cleanup can be done separately)
    client.table("backlot_receipts").delete().eq("id", receipt_id).execute()

    return {"success": True, "message": "Receipt deleted"}


@router.get("/projects/{project_id}/receipts/export")
async def export_receipts_csv(
    project_id: str,
    date_from: Optional[str] = None,
    date_to: Optional[str] = None,
    authorization: str = Header(None)
):
    """Export receipts as CSV for tax/accounting purposes"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()
    await verify_budget_access(client, project_id, user_id)

    # Build query
    query = client.table("backlot_receipts").select("*").eq("project_id", project_id)

    if date_from:
        query = query.gte("purchase_date", date_from)
    if date_to:
        query = query.lte("purchase_date", date_to)

    response = query.order("purchase_date").execute()
    receipts = response.data or []

    # Build CSV
    import csv
    from io import StringIO

    output = StringIO()
    writer = csv.writer(output)

    # Header row
    writer.writerow([
        "Date", "Vendor", "Description", "Amount", "Tax Amount",
        "Category", "Line Item", "Production Day", "Payment Method",
        "Reimbursement Status", "File URL"
    ])

    for r in receipts:
        # Get category and line item names
        category_name = ""
        line_item_name = ""
        if r.get("budget_line_item_id"):
            li = client.table("backlot_budget_line_items").select("description, category_id").eq("id", r["budget_line_item_id"]).execute()
            if li.data:
                line_item_name = li.data[0].get("description", "")
                if li.data[0].get("category_id"):
                    cat = client.table("backlot_budget_categories").select("name").eq("id", li.data[0]["category_id"]).execute()
                    if cat.data:
                        category_name = cat.data[0].get("name", "")

        # Get production day
        prod_day = ""
        if r.get("daily_budget_id"):
            db = client.table("backlot_daily_budgets").select("date, production_day_id").eq("id", r["daily_budget_id"]).execute()
            if db.data:
                prod_day = db.data[0].get("date", "")

        writer.writerow([
            r.get("purchase_date", ""),
            r.get("vendor_name", ""),
            r.get("description", ""),
            r.get("amount", ""),
            r.get("tax_amount", ""),
            category_name,
            line_item_name,
            prod_day,
            r.get("payment_method", ""),
            r.get("reimbursement_status", ""),
            r.get("file_url", "")
        ])

    csv_content = output.getvalue()

    return Response(
        content=csv_content,
        media_type="text/csv",
        headers={
            "Content-Disposition": f'attachment; filename="receipts_{project_id}_{datetime.utcnow().strftime("%Y%m%d")}.csv"'
        }
    )


# =====================================================
# PROFESSIONAL BUDGET SYSTEM - Templates & Top Sheet
# =====================================================

@router.get("/budget-templates", response_model=List[str])
async def get_available_budget_templates(
    authorization: str = Header(None)
):
    """Get list of available budget project types"""
    await get_current_user_from_token(authorization)
    return ["feature", "episodic", "documentary", "music_video", "commercial", "short", "custom"]


@router.get("/budget-templates/{project_type}", response_model=List[BudgetAccountTemplate])
async def get_budget_template_accounts(
    project_type: str,
    include_all: bool = False,
    authorization: str = Header(None)
):
    """Get account templates for a specific project type"""
    await get_current_user_from_token(authorization)

    client = get_client()

    # Get template accounts
    query = client.table("backlot_budget_accounts").select("*").eq("project_type", project_type)
    if not include_all:
        query = query.eq("is_common", True)

    response = query.order("sort_order").execute()
    return response.data or []


@router.get("/budget-templates/{project_type}/preview", response_model=BudgetTemplatePreview)
async def preview_budget_template(
    project_type: str,
    include_common_only: bool = True,
    authorization: str = Header(None)
):
    """Preview what a budget template will create"""
    await get_current_user_from_token(authorization)

    client = get_client()

    # Get template accounts
    query = client.table("backlot_budget_accounts").select("*").eq("project_type", project_type)
    if include_common_only:
        query = query.eq("is_common", True)

    response = query.order("sort_order").execute()
    accounts = response.data or []

    # Group by category
    categories_dict = {}
    for account in accounts:
        cat_name = account["category_name"]
        if cat_name not in categories_dict:
            categories_dict[cat_name] = {
                "name": cat_name,
                "category_type": account["category_type"],
                "line_items": []
            }
        categories_dict[cat_name]["line_items"].append({
            "account_code": account["account_code"],
            "name": account["name"],
            "calc_mode": account["default_calc_mode"]
        })

    return BudgetTemplatePreview(
        project_type=project_type,
        category_count=len(categories_dict),
        line_item_count=len(accounts),
        categories=list(categories_dict.values())
    )


@router.post("/projects/{project_id}/budget/from-template", response_model=Budget)
async def create_budget_from_template(
    project_id: str,
    template_input: CreateBudgetFromTemplateInput,
    authorization: str = Header(None)
):
    """Create a budget from a project type template"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()
    await verify_budget_access(client, project_id, user_id)

    # Check if budget already exists
    existing = client.table("backlot_budgets").select("id").eq("project_id", project_id).eq("name", template_input.name or "Main Budget").execute()
    if existing.data:
        raise HTTPException(status_code=400, detail="A budget with this name already exists for this project")

    # Get template accounts
    query = client.table("backlot_budget_accounts").select("*").eq("project_type", template_input.project_type)
    if template_input.include_common_only:
        query = query.eq("is_common", True)

    accounts_response = query.order("sort_order").execute()
    accounts = accounts_response.data or []

    if not accounts:
        raise HTTPException(status_code=404, detail=f"No template accounts found for project type: {template_input.project_type}")

    # Create the budget
    budget_data = {
        "project_id": project_id,
        "name": template_input.name or "Main Budget",
        "project_type_template": template_input.project_type,
        "shoot_days": template_input.shoot_days or 0,
        "prep_days": template_input.prep_days or 0,
        "wrap_days": template_input.wrap_days or 0,
        "post_days": template_input.post_days or 0,
        "episode_count": template_input.episode_count or 1,
        "union_type": template_input.union_type or "non_union",
        "created_by": user_id,
        "status": "draft"
    }

    budget_result = client.table("backlot_budgets").insert(budget_data).execute()
    if not budget_result.data:
        raise HTTPException(status_code=500, detail="Failed to create budget")

    budget = budget_result.data[0]
    budget_id = budget["id"]

    # Group accounts by category and create categories + line items
    categories_dict = {}
    for account in accounts:
        cat_name = account["category_name"]
        if cat_name not in categories_dict:
            categories_dict[cat_name] = {
                "accounts": [],
                "category_type": account["category_type"],
                "sort_order": account["sort_order"] // 100  # Use first digit as category order
            }
        categories_dict[cat_name]["accounts"].append(account)

    # Create categories
    category_map = {}  # Maps category_name to category_id
    for cat_name, cat_info in categories_dict.items():
        cat_data = {
            "budget_id": budget_id,
            "name": cat_name,
            "code": str(cat_info["sort_order"] + 1),
            "category_type": cat_info["category_type"],
            "is_above_the_line": cat_info["category_type"] == "above_the_line",
            "sort_order": cat_info["sort_order"]
        }
        cat_result = client.table("backlot_budget_categories").insert(cat_data).execute()
        if cat_result.data:
            category_map[cat_name] = cat_result.data[0]["id"]

    # Create line items from accounts
    line_item_order = 0
    for cat_name, cat_info in categories_dict.items():
        category_id = category_map.get(cat_name)
        for account in cat_info["accounts"]:
            line_item_data = {
                "budget_id": budget_id,
                "category_id": category_id,
                "account_code": account["account_code"],
                "description": account["name"],
                "rate_type": "flat",
                "calc_mode": account["default_calc_mode"],
                "units": account.get("default_units"),
                "department": account.get("department"),
                "phase": account.get("phase"),
                "source_type": "template",
                "source_id": account["id"],
                "sort_order": line_item_order
            }
            client.table("backlot_budget_line_items").insert(line_item_data).execute()
            line_item_order += 1

    # Return the created budget
    return budget


@router.get("/projects/{project_id}/budget/top-sheet", response_model=TopSheetData)
async def get_budget_top_sheet(
    project_id: str,
    force_refresh: bool = False,
    authorization: str = Header(None)
):
    """Get the Top Sheet summary for a project budget"""
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()
    await verify_budget_access(client, project_id, user_id)

    # Get budget
    budget_response = client.table("backlot_budgets").select("*").eq("project_id", project_id).execute()
    if not budget_response.data:
        raise HTTPException(status_code=404, detail="Budget not found")

    budget = budget_response.data[0]
    budget_id = budget["id"]

    # Get project for title
    project_response = client.table("backlot_projects").select("title").eq("id", project_id).execute()
    project_title = project_response.data[0]["title"] if project_response.data else "Untitled"

    # Get categories with their line item totals
    categories_response = client.table("backlot_budget_categories").select("*").eq("budget_id", budget_id).order("sort_order").execute()
    categories = categories_response.data or []

    # Get all line items
    line_items_response = client.table("backlot_budget_line_items").select("*").eq("budget_id", budget_id).execute()
    line_items = line_items_response.data or []

    # Build sections by category type
    sections = {
        "above_the_line": {"categories": [], "total": 0},
        "production": {"categories": [], "total": 0},
        "post": {"categories": [], "total": 0},
        "other": {"categories": [], "total": 0}
    }
    fringes_total = 0

    for cat in categories:
        cat_id = cat["id"]
        cat_items = [li for li in line_items if li.get("category_id") == cat_id]
        cat_estimated = sum(li.get("estimated_total", 0) or 0 for li in cat_items)
        cat_actual = sum(li.get("actual_total", 0) or 0 for li in cat_items)
        cat_variance = cat_actual - cat_estimated

        # Add fringe amounts
        cat_fringes = sum(li.get("estimated_total", 0) or 0 for li in cat_items if li.get("is_fringe"))
        fringes_total += cat_fringes

        cat_type = cat.get("category_type", "production")
        if cat_type not in sections:
            cat_type = "other"

        category_row = TopSheetCategoryRow(
            code=cat.get("code"),
            name=cat.get("name", ""),
            estimated=cat_estimated,
            actual=cat_actual,
            variance=cat_variance
        )
        sections[cat_type]["categories"].append(category_row)
        sections[cat_type]["total"] += cat_estimated

    # Build section objects
    above_the_line = TopSheetSection(
        label="Above the Line",
        total=sections["above_the_line"]["total"],
        categories=sections["above_the_line"]["categories"]
    )
    production = TopSheetSection(
        label="Production",
        total=sections["production"]["total"],
        categories=sections["production"]["categories"]
    )
    post = TopSheetSection(
        label="Post-Production",
        total=sections["post"]["total"],
        categories=sections["post"]["categories"]
    )
    other = TopSheetSection(
        label="Other / Indirect",
        total=sections["other"]["total"],
        categories=sections["other"]["categories"]
    )

    subtotal = above_the_line.total + production.total + post.total + other.total
    contingency_pct = budget.get("contingency_percent", 10) or 10
    contingency_amount = subtotal * contingency_pct / 100
    grand_total = subtotal + contingency_amount

    # Update budget grand total
    client.table("backlot_budgets").update({
        "grand_total": grand_total,
        "fringes_total": fringes_total,
        "has_top_sheet": True
    }).eq("id", budget_id).execute()

    return TopSheetData(
        budget_id=budget_id,
        project_title=project_title,
        project_type=budget.get("project_type_template", "feature_film"),
        prepared_date=budget.get("created_at", datetime.utcnow().isoformat())[:10],
        above_the_line=above_the_line,
        production=production,
        post=post,
        other=other,
        subtotal=subtotal,
        contingency_percent=contingency_pct,
        contingency_amount=contingency_amount,
        fringes_total=fringes_total,
        grand_total=grand_total,
        is_stale=False,
        last_computed=datetime.utcnow().isoformat()
    )


@router.post("/projects/{project_id}/budget/compute-top-sheet")
async def compute_top_sheet(
    project_id: str,
    authorization: str = Header(None)
):
    """Force recomputation of the Top Sheet"""
    return await get_budget_top_sheet(project_id, force_refresh=True, authorization=authorization)


# =====================================================
# BUDGET-TO-DAILY BUDGET SYNC
# =====================================================

class BudgetToDailySyncInput(BaseModel):
    """Input for syncing budget to daily budgets"""
    sync_mode: str = "full"  # 'full' or 'incremental'
    include_phases: Optional[List[str]] = None  # e.g., ['production', 'prep']
    include_departments: Optional[List[str]] = None
    split_method: str = "equal"  # 'equal', 'weighted', 'manual'
    production_day_ids: Optional[List[str]] = None  # Specific days to sync, or None for all


class DailyBudgetSyncResult(BaseModel):
    """Result of syncing budget to daily budgets"""
    daily_budget_id: str
    production_day_id: str
    date: str
    items_created: int
    items_updated: int
    items_removed: int
    total_estimated: float
    warnings: List[str]


class BudgetSyncSummary(BaseModel):
    """Summary of budget-to-daily sync operation"""
    total_days_synced: int
    total_items_created: int
    total_items_updated: int
    total_items_removed: int
    daily_results: List[DailyBudgetSyncResult]
    warnings: List[str]


def calculate_daily_allocation(
    line_item: dict,
    total_days: int,
    day_index: int,
    split_method: str
) -> float:
    """Calculate how much of a line item to allocate to a specific day"""
    estimated = line_item.get("estimated_total", 0) or 0
    calc_mode = line_item.get("calc_mode", "flat")

    if estimated == 0 or total_days == 0:
        return 0

    # Items with per-day calculation
    if calc_mode in ["rate_x_days", "rate_x_hours"]:
        # These are already daily rates, allocate full rate per day
        rate = line_item.get("rate_amount", 0) or 0
        return rate

    # Flat items - split across all days
    if split_method == "equal":
        return estimated / total_days

    # Weighted could be based on call sheet complexity, but default to equal
    return estimated / total_days


@router.post("/projects/{project_id}/budget/sync-to-daily", response_model=BudgetSyncSummary)
async def sync_budget_to_daily_budgets(
    project_id: str,
    sync_input: BudgetToDailySyncInput = BudgetToDailySyncInput(),
    authorization: str = Header(None)
):
    """
    Sync main budget line items to daily budgets.

    This interprets the main budget and creates/updates daily budget items
    for each production day based on the line item's calc_mode and phase.
    """
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()
    await verify_budget_access(client, project_id, user_id)

    # Get budget
    budget_response = client.table("backlot_budgets").select("*").eq("project_id", project_id).execute()
    if not budget_response.data:
        raise HTTPException(status_code=404, detail="Budget not found")

    budget = budget_response.data[0]
    budget_id = budget["id"]

    # Get production days
    days_query = client.table("backlot_production_days").select("*").eq("project_id", project_id)
    if sync_input.production_day_ids:
        days_query = days_query.in_("id", sync_input.production_day_ids)

    days_response = days_query.order("date").execute()
    production_days = days_response.data or []

    if not production_days:
        raise HTTPException(status_code=400, detail="No production days found to sync")

    total_shoot_days = len([d for d in production_days if d.get("type") == "shoot"])
    total_days = len(production_days)

    # Get line items with categories
    line_items_response = client.table("backlot_budget_line_items").select(
        "*, category:backlot_budget_categories(id, name, category_type, phase)"
    ).eq("budget_id", budget_id).execute()
    line_items = line_items_response.data or []

    # Filter line items by phase if specified
    if sync_input.include_phases:
        line_items = [
            li for li in line_items
            if li.get("phase") in sync_input.include_phases
            or (li.get("category") and li["category"].get("phase") in sync_input.include_phases)
        ]

    # Filter by department if specified
    if sync_input.include_departments:
        line_items = [
            li for li in line_items
            if li.get("department") in sync_input.include_departments
        ]

    # Group line items by which days they apply to
    # Production phase items -> shoot days
    # Prep phase items -> prep days
    # Post phase items -> post days
    # Flat items without phase -> spread across all shoot days

    daily_results = []
    warnings = []
    total_created = 0
    total_updated = 0
    total_removed = 0

    for day_index, prod_day in enumerate(production_days):
        day_id = prod_day["id"]
        day_date = prod_day.get("date", "")
        day_type = prod_day.get("type", "shoot")

        # Get or create daily budget for this day
        daily_budget_response = client.table("backlot_daily_budgets").select("*").eq(
            "production_day_id", day_id
        ).execute()

        if daily_budget_response.data:
            daily_budget = daily_budget_response.data[0]
        else:
            # Create daily budget
            daily_budget_data = {
                "project_id": project_id,
                "budget_id": budget_id,
                "production_day_id": day_id,
                "date": day_date
            }
            create_response = client.table("backlot_daily_budgets").insert(daily_budget_data).execute()
            if not create_response.data:
                warnings.append(f"Failed to create daily budget for {day_date}")
                continue
            daily_budget = create_response.data[0]

        daily_budget_id = daily_budget["id"]

        # Get existing items for this daily budget (for update/remove)
        existing_items_response = client.table("backlot_daily_budget_items").select("*").eq(
            "daily_budget_id", daily_budget_id
        ).execute()
        existing_items = {
            item.get("budget_line_item_id"): item
            for item in (existing_items_response.data or [])
            if item.get("budget_line_item_id")
        }

        items_created = 0
        items_updated = 0
        items_removed = 0
        day_total = 0
        day_warnings = []

        # Determine which line items apply to this day
        applicable_items = []
        for li in line_items:
            li_phase = li.get("phase") or (li.get("category") or {}).get("phase")
            calc_mode = li.get("calc_mode", "flat")

            # Skip items that don't apply to this day type
            if day_type == "shoot":
                # Shoot days get production phase items and items calculated by day
                if li_phase in ["production", None] or calc_mode in ["rate_x_days"]:
                    applicable_items.append(li)
            elif day_type == "prep":
                if li_phase == "prep":
                    applicable_items.append(li)
            elif day_type == "wrap":
                if li_phase == "wrap":
                    applicable_items.append(li)
            # For other day types, skip

        # Process applicable items
        processed_item_ids = set()

        for li in applicable_items:
            li_id = li["id"]
            processed_item_ids.add(li_id)

            # Calculate allocation for this day
            allocation = calculate_daily_allocation(
                li,
                total_shoot_days if day_type == "shoot" else total_days,
                day_index,
                sync_input.split_method
            )

            if allocation <= 0:
                continue

            day_total += allocation

            item_data = {
                "daily_budget_id": daily_budget_id,
                "budget_line_item_id": li_id,
                "label": li.get("description", ""),
                "category_name": (li.get("category") or {}).get("name"),
                "estimated_amount": allocation,
                "is_ad_hoc": False,
                "sort_order": li.get("sort_order", 0)
            }

            if li_id in existing_items:
                # Update existing item
                existing = existing_items[li_id]
                client.table("backlot_daily_budget_items").update({
                    "estimated_amount": allocation,
                    "label": item_data["label"],
                    "category_name": item_data["category_name"],
                    "updated_at": datetime.utcnow().isoformat()
                }).eq("id", existing["id"]).execute()
                items_updated += 1
            else:
                # Create new item
                client.table("backlot_daily_budget_items").insert(item_data).execute()
                items_created += 1

        # Remove items that are no longer applicable (if full sync)
        if sync_input.sync_mode == "full":
            for li_id, existing_item in existing_items.items():
                if li_id not in processed_item_ids and not existing_item.get("is_ad_hoc"):
                    client.table("backlot_daily_budget_items").delete().eq(
                        "id", existing_item["id"]
                    ).execute()
                    items_removed += 1

        # Update daily budget totals
        client.table("backlot_daily_budgets").update({
            "estimated_total": day_total,
            "updated_at": datetime.utcnow().isoformat()
        }).eq("id", daily_budget_id).execute()

        daily_results.append(DailyBudgetSyncResult(
            daily_budget_id=daily_budget_id,
            production_day_id=day_id,
            date=day_date,
            items_created=items_created,
            items_updated=items_updated,
            items_removed=items_removed,
            total_estimated=day_total,
            warnings=day_warnings
        ))

        total_created += items_created
        total_updated += items_updated
        total_removed += items_removed
        warnings.extend(day_warnings)

    return BudgetSyncSummary(
        total_days_synced=len(daily_results),
        total_items_created=total_created,
        total_items_updated=total_updated,
        total_items_removed=total_removed,
        daily_results=daily_results,
        warnings=warnings
    )


@router.post("/projects/{project_id}/budget/sync-day/{production_day_id}", response_model=DailyBudgetSyncResult)
async def sync_budget_to_single_day(
    project_id: str,
    production_day_id: str,
    authorization: str = Header(None)
):
    """Sync budget to a single production day"""
    sync_input = BudgetToDailySyncInput(
        sync_mode="full",
        production_day_ids=[production_day_id]
    )

    result = await sync_budget_to_daily_budgets(project_id, sync_input, authorization)

    if result.daily_results:
        return result.daily_results[0]

    raise HTTPException(status_code=400, detail="Failed to sync day")


# =====================================================
# BUDGET PDF EXPORT
# =====================================================

class BudgetPdfExportInput(BaseModel):
    """Options for budget PDF export"""
    include_top_sheet: bool = True
    include_detail: bool = True
    include_daily_budgets: bool = False
    include_receipts_summary: bool = False
    include_notes: bool = True
    show_actuals: bool = True
    show_variance: bool = True
    category_types: Optional[List[str]] = None  # Filter to specific category types


def generate_budget_pdf_html(
    project: Dict[str, Any],
    budget: Dict[str, Any],
    categories: List[Dict[str, Any]],
    line_items: List[Dict[str, Any]],
    top_sheet: Optional[Dict[str, Any]],
    options: BudgetPdfExportInput
) -> str:
    """Generate HTML for budget PDF"""
    # Group line items by category
    items_by_category = {}
    for item in line_items:
        cat_id = item.get("category_id") or "uncategorized"
        if cat_id not in items_by_category:
            items_by_category[cat_id] = []
        items_by_category[cat_id].append(item)

    # Format currency helper
    def fmt_currency(amount: float, currency: str = "USD") -> str:
        if currency == "USD":
            return f"${amount:,.2f}"
        elif currency == "EUR":
            return f"{amount:,.2f}"
        elif currency == "GBP":
            return f"{amount:,.2f}"
        else:
            return f"{currency} {amount:,.2f}"

    currency = budget.get("currency", "USD")

    html = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <style>
            body {{
                font-family: 'Helvetica Neue', Arial, sans-serif;
                font-size: 10pt;
                color: #333;
                margin: 0;
                padding: 20px;
            }}
            .header {{
                text-align: center;
                margin-bottom: 30px;
                border-bottom: 2px solid #333;
                padding-bottom: 15px;
            }}
            .header h1 {{
                font-size: 18pt;
                margin: 0 0 5px 0;
                text-transform: uppercase;
            }}
            .header h2 {{
                font-size: 14pt;
                margin: 0 0 10px 0;
                font-weight: normal;
            }}
            .header .meta {{
                font-size: 9pt;
                color: #666;
            }}
            .section {{
                margin-bottom: 25px;
            }}
            .section-title {{
                font-size: 12pt;
                font-weight: bold;
                background-color: #f5f5f5;
                padding: 8px 12px;
                margin-bottom: 10px;
                border-left: 4px solid #333;
            }}
            table {{
                width: 100%;
                border-collapse: collapse;
                margin-bottom: 15px;
            }}
            th, td {{
                padding: 6px 8px;
                text-align: left;
                border-bottom: 1px solid #ddd;
            }}
            th {{
                background-color: #f9f9f9;
                font-weight: bold;
                font-size: 9pt;
            }}
            td.amount {{
                text-align: right;
                font-family: 'Monaco', 'Courier New', monospace;
            }}
            .variance-positive {{
                color: #c53030;
            }}
            .variance-negative {{
                color: #276749;
            }}
            .total-row {{
                font-weight: bold;
                background-color: #f5f5f5;
            }}
            .grand-total-row {{
                font-weight: bold;
                font-size: 11pt;
                background-color: #333;
                color: white;
            }}
            .grand-total-row td {{
                border-bottom: none;
            }}
            .category-header {{
                background-color: #e8e8e8;
                font-weight: bold;
            }}
            .top-sheet-table th {{
                background-color: #333;
                color: white;
            }}
            .tax-line-item {{
                font-style: italic;
                color: #666;
                background-color: #fafafa;
            }}
            .tax-line-item td {{
                border-bottom: 1px dashed #ccc;
            }}
            .tax-badge {{
                display: inline-block;
                background-color: #fcdc58;
                color: #333;
                font-size: 8pt;
                padding: 2px 6px;
                border-radius: 3px;
                margin-left: 8px;
                font-weight: normal;
            }}
            .notes-section {{
                margin-top: 30px;
            }}
            .notes-header {{
                background-color: #333;
                color: white;
                padding: 8px 12px;
                font-size: 12pt;
                font-weight: bold;
            }}
            .notes-subheader {{
                background-color: #e6e6fa;
                padding: 6px 12px;
                font-size: 11pt;
                font-weight: bold;
                margin-top: 15px;
            }}
            .note-item {{
                padding: 10px 12px;
                border-bottom: 1px solid #eee;
            }}
            .note-item-header {{
                font-weight: bold;
                color: #333;
                margin-bottom: 5px;
            }}
            .note-content {{
                color: #555;
                font-size: 9pt;
                line-height: 1.4;
            }}
            .note-label {{
                display: inline-block;
                font-size: 8pt;
                padding: 1px 4px;
                border-radius: 2px;
                margin-right: 5px;
            }}
            .note-label-public {{
                background-color: #d4edda;
                color: #155724;
            }}
            .note-label-internal {{
                background-color: #fff3cd;
                color: #856404;
            }}
            .budget-notes {{
                padding: 12px;
                background-color: #f9f9f9;
                border-left: 3px solid #333;
                margin: 10px 0;
            }}
            .page-break {{
                page-break-before: always;
            }}
            .footer {{
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                text-align: center;
                font-size: 8pt;
                color: #999;
                padding: 10px;
            }}
        </style>
    </head>
    <body>
        <div class="header">
            <h1>{project.get("title", "Production Budget")}</h1>
            <h2>{budget.get("name", "Budget")}</h2>
            <div class="meta">
                Generated: {datetime.utcnow().strftime("%B %d, %Y at %I:%M %p UTC")}<br>
                Currency: {currency} | Status: {budget.get("status", "draft").replace("_", " ").title()}
            </div>
        </div>
    """

    # Top Sheet section
    if options.include_top_sheet and top_sheet:
        html += """
        <div class="section">
            <div class="section-title">TOP SHEET SUMMARY</div>
            <table class="top-sheet-table">
                <thead>
                    <tr>
                        <th style="width: 40%">Category</th>
                        <th style="width: 20%" class="amount">Estimated</th>
        """
        if options.show_actuals:
            html += '<th style="width: 20%" class="amount">Actual</th>'
        if options.show_variance:
            html += '<th style="width: 20%" class="amount">Variance</th>'
        html += """
                    </tr>
                </thead>
                <tbody>
        """

        # Above the Line
        atl_total = top_sheet.get("above_the_line_total", 0)
        html += f"""
                    <tr class="category-header">
                        <td>ABOVE THE LINE</td>
                        <td class="amount">{fmt_currency(atl_total, currency)}</td>
        """
        if options.show_actuals:
            html += f'<td class="amount">-</td>'
        if options.show_variance:
            html += f'<td class="amount">-</td>'
        html += "</tr>"

        # Production
        prod_total = top_sheet.get("production_total", 0)
        html += f"""
                    <tr class="category-header">
                        <td>PRODUCTION</td>
                        <td class="amount">{fmt_currency(prod_total, currency)}</td>
        """
        if options.show_actuals:
            html += f'<td class="amount">-</td>'
        if options.show_variance:
            html += f'<td class="amount">-</td>'
        html += "</tr>"

        # Post
        post_total = top_sheet.get("post_total", 0)
        html += f"""
                    <tr class="category-header">
                        <td>POST-PRODUCTION</td>
                        <td class="amount">{fmt_currency(post_total, currency)}</td>
        """
        if options.show_actuals:
            html += f'<td class="amount">-</td>'
        if options.show_variance:
            html += f'<td class="amount">-</td>'
        html += "</tr>"

        # Other
        other_total = top_sheet.get("other_total", 0)
        html += f"""
                    <tr class="category-header">
                        <td>OTHER / INDIRECT</td>
                        <td class="amount">{fmt_currency(other_total, currency)}</td>
        """
        if options.show_actuals:
            html += f'<td class="amount">-</td>'
        if options.show_variance:
            html += f'<td class="amount">-</td>'
        html += "</tr>"

        # Subtotal
        subtotal = top_sheet.get("subtotal", 0)
        html += f"""
                    <tr class="total-row">
                        <td>SUBTOTAL</td>
                        <td class="amount">{fmt_currency(subtotal, currency)}</td>
        """
        if options.show_actuals:
            html += f'<td class="amount">-</td>'
        if options.show_variance:
            html += f'<td class="amount">-</td>'
        html += "</tr>"

        # Contingency
        contingency_pct = budget.get("contingency_percent", 0)
        contingency_amt = top_sheet.get("contingency_amount", 0)
        html += f"""
                    <tr>
                        <td>Contingency ({contingency_pct}%)</td>
                        <td class="amount">{fmt_currency(contingency_amt, currency)}</td>
        """
        if options.show_actuals:
            html += f'<td class="amount">-</td>'
        if options.show_variance:
            html += f'<td class="amount">-</td>'
        html += "</tr>"

        # Grand Total
        grand_total = top_sheet.get("grand_total", 0)
        html += f"""
                    <tr class="grand-total-row">
                        <td>GRAND TOTAL</td>
                        <td class="amount">{fmt_currency(grand_total, currency)}</td>
        """
        if options.show_actuals:
            actual_total = budget.get("actual_total", 0)
            html += f'<td class="amount">{fmt_currency(actual_total, currency)}</td>'
        if options.show_variance:
            variance = budget.get("variance", 0)
            variance_class = "variance-positive" if variance > 0 else "variance-negative" if variance < 0 else ""
            html += f'<td class="amount {variance_class}">{fmt_currency(variance, currency)}</td>'
        html += """
                    </tr>
                </tbody>
            </table>
        </div>
        """

    # Detail section
    if options.include_detail:
        html += """
        <div class="section page-break">
            <div class="section-title">BUDGET DETAIL</div>
        """

        # Filter categories by type if specified
        filtered_categories = categories
        if options.category_types:
            filtered_categories = [
                c for c in categories
                if c.get("category_type") in options.category_types
            ]

        for category in filtered_categories:
            cat_id = category.get("id")
            cat_name = category.get("name", "Uncategorized")
            cat_code = category.get("code") or ""
            cat_items = items_by_category.get(cat_id, [])
            is_taxable = category.get("is_taxable", False)
            tax_rate = category.get("tax_rate", 0) or 0

            estimated_subtotal = category.get("estimated_subtotal", 0)
            actual_subtotal = category.get("actual_subtotal", 0)

            # Tax badge for taxable categories
            tax_badge = ""
            if is_taxable and tax_rate > 0:
                tax_badge = f'<span class="tax-badge">+{tax_rate * 100:.2f}% tax</span>'

            html += f"""
            <table>
                <thead>
                    <tr class="category-header">
                        <th colspan="2">{cat_code} {cat_name}{tax_badge}</th>
                        <th class="amount">Rate</th>
                        <th class="amount">Qty</th>
                        <th class="amount">Estimated</th>
            """
            if options.show_actuals:
                html += '<th class="amount">Actual</th>'
            if options.show_variance:
                html += '<th class="amount">Variance</th>'
            html += """
                    </tr>
                </thead>
                <tbody>
            """

            for item in cat_items:
                account_code = item.get("account_code") or ""
                description = item.get("description", "")
                rate = item.get("rate_amount", 0)
                qty = item.get("quantity", 1)
                estimated = item.get("estimated_total", 0)
                actual = item.get("actual_total", 0)
                variance = actual - estimated
                is_tax_line = item.get("is_tax_line_item", False)

                variance_class = "variance-positive" if variance > 0 else "variance-negative" if variance < 0 else ""
                row_class = "tax-line-item" if is_tax_line else ""

                # Tax line items show "(Auto-calculated)" after description
                display_desc = f"{description} <em>(Auto-calculated)</em>" if is_tax_line else description

                html += f"""
                    <tr class="{row_class}">
                        <td style="width: 10%">{account_code}</td>
                        <td style="width: 35%">{display_desc}</td>
                        <td class="amount">{fmt_currency(rate, currency)}</td>
                        <td class="amount">{qty}</td>
                        <td class="amount">{fmt_currency(estimated, currency)}</td>
                """
                if options.show_actuals:
                    html += f'<td class="amount">{fmt_currency(actual, currency)}</td>'
                if options.show_variance:
                    html += f'<td class="amount {variance_class}">{fmt_currency(variance, currency)}</td>'
                html += "</tr>"

            # Category subtotal
            cat_variance = actual_subtotal - estimated_subtotal
            cat_variance_class = "variance-positive" if cat_variance > 0 else "variance-negative" if cat_variance < 0 else ""

            html += f"""
                    <tr class="total-row">
                        <td colspan="4" style="text-align: right">Subtotal:</td>
                        <td class="amount">{fmt_currency(estimated_subtotal, currency)}</td>
            """
            if options.show_actuals:
                html += f'<td class="amount">{fmt_currency(actual_subtotal, currency)}</td>'
            if options.show_variance:
                html += f'<td class="amount {cat_variance_class}">{fmt_currency(cat_variance, currency)}</td>'
            html += """
                    </tr>
                </tbody>
            </table>
            """

        html += "</div>"

    # Notes Addendum section
    if options.include_notes:
        # Filter out tax line items from notes
        non_tax_line_items = [li for li in line_items if not li.get('is_tax_line_item')]

        # Helper to check if item has notes
        def has_notes(li):
            notes = li.get('notes', '') or ''
            internal_notes = li.get('internal_notes', '') or ''
            return notes.strip() or internal_notes.strip()

        items_with_notes = [li for li in non_tax_line_items if has_notes(li)]
        budget_notes = (budget.get('notes', '') or '').strip()

        if items_with_notes or budget_notes:
            # Build category lookup map
            category_map = {cat.get('id'): cat for cat in categories}

            html += """
        <div class="section notes-section page-break">
            """

            # Header with count
            header_text = "NOTES ADDENDUM"
            if items_with_notes:
                header_text += f" ({len(items_with_notes)} of {len(non_tax_line_items)} items)"

            html += f'<div class="notes-header">{header_text}</div>'

            # Budget-level notes first
            if budget_notes:
                html += '<div class="notes-subheader">BUDGET NOTES</div>'
                html += f'<div class="budget-notes">{budget_notes.replace(chr(10), "<br>")}</div>'

            # Line item notes
            if items_with_notes:
                html += '<div class="notes-subheader">LINE ITEM NOTES</div>'

                # Group by category
                items_by_cat = {}
                uncategorized = []
                for li in items_with_notes:
                    cat_id = li.get('category_id')
                    if cat_id and cat_id in category_map:
                        if cat_id not in items_by_cat:
                            items_by_cat[cat_id] = []
                        items_by_cat[cat_id].append(li)
                    else:
                        uncategorized.append(li)

                # Display by category
                for cat_id, items in items_by_cat.items():
                    cat = category_map.get(cat_id, {})
                    cat_name = cat.get('name', 'Unknown')
                    cat_code = cat.get('code', '')

                    for item in items:
                        account_code = item.get('account_code', '')
                        description = item.get('description', 'Unnamed')
                        notes = (item.get('notes', '') or '').strip()
                        internal_notes = (item.get('internal_notes', '') or '').strip()

                        html += '<div class="note-item">'
                        html += f'<div class="note-item-header">{cat_code} {cat_name} &gt; {account_code} {description}</div>'

                        if notes:
                            html += f'<div class="note-content"><span class="note-label note-label-public">Public</span>{notes.replace(chr(10), "<br>")}</div>'
                        if internal_notes:
                            html += f'<div class="note-content"><span class="note-label note-label-internal">Internal</span>{internal_notes.replace(chr(10), "<br>")}</div>'

                        html += '</div>'

                # Uncategorized items
                for item in uncategorized:
                    account_code = item.get('account_code', '')
                    description = item.get('description', 'Unnamed')
                    notes = (item.get('notes', '') or '').strip()
                    internal_notes = (item.get('internal_notes', '') or '').strip()

                    html += '<div class="note-item">'
                    html += f'<div class="note-item-header">{account_code} {description}</div>'

                    if notes:
                        html += f'<div class="note-content"><span class="note-label note-label-public">Public</span>{notes.replace(chr(10), "<br>")}</div>'
                    if internal_notes:
                        html += f'<div class="note-content"><span class="note-label note-label-internal">Internal</span>{internal_notes.replace(chr(10), "<br>")}</div>'

                    html += '</div>'

            html += "</div>"

    # Footer
    html += """
        <div class="footer">
            Generated by Second Watch Network - Backlot Production Management
        </div>
    </body>
    </html>
    """

    return html


@router.get("/projects/{project_id}/budget/export-pdf")
async def export_budget_pdf(
    project_id: str,
    budget_id: str = None,
    include_top_sheet: bool = True,
    include_detail: bool = True,
    include_daily_budgets: bool = False,
    include_receipts_summary: bool = False,
    include_notes: bool = True,
    show_actuals: bool = True,
    show_variance: bool = True,
    authorization: str = Header(None)
):
    """Export budget as PDF. If budget_id is provided, exports that specific budget.
    Otherwise exports the first budget found for the project."""
    if not authorization:
        raise HTTPException(status_code=401, detail="Not authenticated")

    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get budget - either specific one or first for project
    if budget_id:
        budget_response = client.table("backlot_budgets").select("*").eq("id", budget_id).eq("project_id", project_id).execute()
    else:
        budget_response = client.table("backlot_budgets").select("*").eq("project_id", project_id).execute()
    if not budget_response.data:
        raise HTTPException(status_code=404, detail="Budget not found")
    budget = budget_response.data[0]
    budget_id = budget["id"]

    # Get project
    project_response = client.table("backlot_projects").select("*").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")
    project = project_response.data[0]

    # Get categories
    categories_response = client.table("backlot_budget_categories").select("*").eq(
        "budget_id", budget_id
    ).order("sort_order").execute()
    categories = categories_response.data or []

    # Get line items
    line_items_response = client.table("backlot_budget_line_items").select("*").eq(
        "budget_id", budget_id
    ).order("sort_order").execute()
    line_items = line_items_response.data or []

    # Get top sheet cache if available, or compute it dynamically
    top_sheet = None
    try:
        top_sheet_response = client.table("backlot_budget_top_sheet_cache").select("*").eq(
            "budget_id", budget_id
        ).execute()
        if top_sheet_response.data:
            top_sheet = top_sheet_response.data[0]
    except Exception:
        # Table may not exist, compute dynamically
        pass

    if top_sheet is None:
        # Compute top sheet dynamically from categories
        above_the_line_total = 0
        production_total = 0
        post_total = 0
        other_total = 0

        for cat in categories:
            cat_type = cat.get("category_type", "other")
            estimated = cat.get("estimated_subtotal", 0) or 0

            if cat_type == "above_the_line":
                above_the_line_total += estimated
            elif cat_type == "production":
                production_total += estimated
            elif cat_type == "post":
                post_total += estimated
            else:
                other_total += estimated

        subtotal = above_the_line_total + production_total + post_total + other_total
        contingency_pct = budget.get("contingency_percent", 0) or 0
        contingency_amount = subtotal * contingency_pct / 100
        grand_total = subtotal + contingency_amount

        top_sheet = {
            "above_the_line_total": above_the_line_total,
            "production_total": production_total,
            "post_total": post_total,
            "other_total": other_total,
            "subtotal": subtotal,
            "contingency_amount": contingency_amount,
            "grand_total": grand_total
        }

    # Generate PDF options
    options = BudgetPdfExportInput(
        include_top_sheet=include_top_sheet,
        include_detail=include_detail,
        include_daily_budgets=include_daily_budgets,
        include_receipts_summary=include_receipts_summary,
        include_notes=include_notes,
        show_actuals=show_actuals,
        show_variance=show_variance
    )

    # Generate HTML
    html_content = generate_budget_pdf_html(
        project=project,
        budget=budget,
        categories=categories,
        line_items=line_items,
        top_sheet=top_sheet,
        options=options
    )

    # Generate PDF using fpdf2 (pure Python, no system dependencies)
    budget_name = budget.get('name', 'Budget')
    filename = f"{project.get('title', 'budget')}-{budget_name}-{datetime.utcnow().strftime('%Y%m%d')}.pdf"
    project_title = project.get('title', 'Project')
    currency = budget.get('currency', 'USD')

    try:
        from fpdf import FPDF
        import io

        def fmt_currency(value, curr):
            if curr == 'USD':
                return f"${value:,.2f}"
            elif curr == 'GBP':
                return f"{value:,.2f}"
            elif curr == 'EUR':
                return f"{value:,.2f}"
            return f"{curr} {value:,.2f}"

        def sanitize_text(text):
            """Replace Unicode characters with ASCII equivalents for FPDF compatibility."""
            if not text:
                return text
            # Common Unicode replacements
            replacements = {
                '\u2122': '(TM)',  # 
                '\u00ae': '(R)',   # 
                '\u00a9': '(C)',   # 
                '\u2019': "'",     # '
                '\u2018': "'",     # '
                '\u201c': '"',     # "
                '\u201d': '"',     # "
                '\u2013': '-',     # 
                '\u2014': '--',    # 
                '\u2026': '...',   # 
                '\u00b0': ' deg',  # 
                '\u00bd': '1/2',   # 
                '\u00bc': '1/4',   # 
                '\u00be': '3/4',   # 
                '\u00d7': 'x',     # 
                '\u2022': '*',     # 
                '\u00a0': ' ',     # non-breaking space
            }
            for char, replacement in replacements.items():
                text = text.replace(char, replacement)
            # Remove any remaining non-latin1 characters
            return text.encode('latin-1', errors='replace').decode('latin-1')

        # Create PDF
        pdf = FPDF()
        pdf.set_auto_page_break(auto=True, margin=15)
        pdf.add_page()

        # Title - Project name
        pdf.set_font('Helvetica', 'B', 18)
        pdf.cell(0, 10, sanitize_text(project_title), ln=True, align='C')

        # Subtitle - Budget name
        pdf.set_font('Helvetica', 'B', 14)
        pdf.cell(0, 8, sanitize_text(budget_name), ln=True, align='C')
        pdf.ln(3)

        # Budget metadata
        pdf.set_font('Helvetica', '', 10)
        pdf.cell(0, 6, f"Generated: {datetime.utcnow().strftime('%B %d, %Y')}", ln=True, align='C')
        pdf.ln(10)

        # Top Sheet Section (if requested)
        if include_top_sheet and top_sheet:
            pdf.set_font('Helvetica', 'B', 14)
            pdf.set_fill_color(51, 51, 51)
            pdf.set_text_color(255, 255, 255)
            pdf.cell(0, 8, "  TOP SHEET SUMMARY", ln=True, fill=True)
            pdf.set_text_color(0, 0, 0)
            pdf.ln(3)

            pdf.set_font('Helvetica', '', 11)

            # Helper to get total from either flat or nested format
            def get_section_total(section_key, flat_key):
                # Try nested format first (from cache)
                section = top_sheet.get(section_key)
                if isinstance(section, dict) and 'total' in section:
                    return section.get('total', 0) or 0
                # Fall back to flat format (dynamically computed)
                return top_sheet.get(flat_key, 0) or 0

            # Summary rows
            summary_items = [
                ("Above the Line", get_section_total('above_the_line', 'above_the_line_total')),
                ("Production", get_section_total('production', 'production_total')),
                ("Post Production", get_section_total('post', 'post_total')),
                ("Other", get_section_total('other', 'other_total')),
            ]

            for label, amount in summary_items:
                pdf.cell(120, 7, f"  {label}", border=0)
                pdf.cell(0, 7, fmt_currency(amount, currency), ln=True, align='R')

            pdf.set_font('Helvetica', 'B', 11)
            pdf.cell(120, 7, "  Subtotal", border='T')
            pdf.cell(0, 7, fmt_currency(top_sheet.get('subtotal', 0) or 0, currency), ln=True, align='R', border='T')

            contingency = top_sheet.get('contingency_amount', 0) or 0
            if contingency > 0:
                pdf.set_font('Helvetica', '', 11)
                pdf.cell(120, 7, f"  Contingency ({budget.get('contingency_percent', 0)}%)", border=0)
                pdf.cell(0, 7, fmt_currency(contingency, currency), ln=True, align='R')

            pdf.set_font('Helvetica', 'B', 12)
            pdf.set_fill_color(230, 230, 230)
            pdf.cell(120, 8, "  GRAND TOTAL", fill=True)
            pdf.cell(0, 8, fmt_currency(top_sheet.get('grand_total', 0) or 0, currency), ln=True, align='R', fill=True)
            pdf.ln(10)

        # Detail Section (if requested)
        if include_detail and categories:
            pdf.set_font('Helvetica', 'B', 14)
            pdf.set_fill_color(51, 51, 51)
            pdf.set_text_color(255, 255, 255)
            pdf.cell(0, 8, "  BUDGET DETAIL", ln=True, fill=True)
            pdf.set_text_color(0, 0, 0)
            pdf.ln(3)

            for cat in categories:
                cat_id = cat.get('id')
                cat_name = cat.get('name', 'Unnamed Category')
                cat_code = cat.get('account_code', '')
                estimated_subtotal = cat.get('estimated_subtotal', 0) or 0
                actual_subtotal = cat.get('actual_subtotal', 0) or 0

                # Category header
                pdf.set_font('Helvetica', 'B', 11)
                pdf.set_fill_color(200, 200, 200)
                cat_title = f"  {cat_code} - {cat_name}" if cat_code else f"  {cat_name}"
                pdf.cell(0, 7, sanitize_text(cat_title), ln=True, fill=True)

                # Line items for this category
                cat_items = [li for li in line_items if li.get('category_id') == cat_id]

                if cat_items:
                    # Table header
                    pdf.set_font('Helvetica', 'B', 9)
                    pdf.set_fill_color(240, 240, 240)
                    pdf.cell(20, 6, "Code", border=1, fill=True)
                    pdf.cell(60, 6, "Description", border=1, fill=True)
                    pdf.cell(25, 6, "Rate", border=1, align='R', fill=True)
                    pdf.cell(15, 6, "Qty", border=1, align='R', fill=True)
                    pdf.cell(30, 6, "Estimated", border=1, align='R', fill=True)
                    if show_actuals:
                        pdf.cell(30, 6, "Actual", border=1, align='R', fill=True)
                    pdf.ln()

                    # Line items
                    pdf.set_font('Helvetica', '', 9)
                    for li in cat_items:
                        account_code = li.get('account_code', '') or ''
                        description = li.get('description', '') or ''
                        rate = li.get('rate_amount', 0) or 0
                        qty = li.get('quantity', 0) or 0
                        estimated = li.get('estimated_total', 0) or 0
                        actual = li.get('actual_total', 0) or 0

                        # Truncate description if too long
                        if len(description) > 35:
                            description = description[:32] + '...'

                        pdf.cell(20, 5, sanitize_text(str(account_code)[:10]), border=1)
                        pdf.cell(60, 5, sanitize_text(description), border=1)
                        pdf.cell(25, 5, fmt_currency(rate, currency), border=1, align='R')
                        pdf.cell(15, 5, str(qty), border=1, align='R')
                        pdf.cell(30, 5, fmt_currency(estimated, currency), border=1, align='R')
                        if show_actuals:
                            pdf.cell(30, 5, fmt_currency(actual, currency), border=1, align='R')
                        pdf.ln()

                # Category subtotal
                pdf.set_font('Helvetica', 'B', 9)
                pdf.cell(120, 6, "  Subtotal:", border=0, align='R')
                pdf.cell(30, 6, fmt_currency(estimated_subtotal, currency), border='T', align='R')
                if show_actuals:
                    pdf.cell(30, 6, fmt_currency(actual_subtotal, currency), border='T', align='R')
                pdf.ln(8)

        # Notes Addendum - collect all line items with notes (check both notes and internal_notes fields)
        if include_notes:
            def has_notes(li):
                notes = li.get('notes', '') or ''
                internal_notes = li.get('internal_notes', '') or ''
                return notes.strip() or internal_notes.strip()

            # Filter out tax line items from notes display
            non_tax_line_items = [li for li in line_items if not li.get('is_tax_line_item')]
            items_with_notes = [li for li in non_tax_line_items if has_notes(li)]
            budget_notes = (budget.get('notes', '') or '').strip()

            if items_with_notes or budget_notes:
                # New page for notes addendum
                pdf.add_page()

                # Header
                pdf.set_font('Helvetica', 'B', 14)
                pdf.set_fill_color(51, 51, 51)
                pdf.set_text_color(255, 255, 255)
                header_text = f"  NOTES ADDENDUM"
                if items_with_notes:
                    header_text += f" ({len(items_with_notes)} of {len(non_tax_line_items)} items)"
                pdf.cell(0, 8, header_text, ln=True, fill=True)
                pdf.set_text_color(0, 0, 0)
                pdf.ln(8)

                # Budget-level notes first (before line item notes)
                if budget_notes:
                    pdf.set_font('Helvetica', 'B', 12)
                    pdf.set_fill_color(230, 230, 250)
                    pdf.cell(0, 7, "  BUDGET NOTES", ln=True, fill=True)
                    pdf.ln(3)
                    pdf.set_font('Helvetica', '', 10)
                    # Handle multi-line notes
                    for line in budget_notes.split('\n'):
                        pdf.multi_cell(0, 5, sanitize_text(f"  {line}"))
                    pdf.ln(8)

                # Line item notes section (only if there are items with notes)
                if items_with_notes:
                    pdf.set_font('Helvetica', 'B', 12)
                    pdf.set_fill_color(230, 230, 250)
                    pdf.cell(0, 7, "  LINE ITEM NOTES", ln=True, fill=True)
                    pdf.ln(3)

                # Build category lookup map
                category_map = {cat.get('id'): cat for cat in categories}

                # Group items by category_id
                items_by_category = {}
                uncategorized_items = []
                for li in items_with_notes:
                    cat_id = li.get('category_id')
                    if cat_id and cat_id in category_map:
                        if cat_id not in items_by_category:
                            items_by_category[cat_id] = []
                        items_by_category[cat_id].append(li)
                    else:
                        uncategorized_items.append(li)

                # Helper to extract numeric part of account code for sorting
                import re
                def get_sort_key(li):
                    code = li.get('account_code', '') or ''
                    # Try to extract numeric portion for sorting
                    numbers = re.findall(r'\d+', code)
                    if numbers:
                        return (int(numbers[0]), code, li.get('description', ''))
                    return (999999, code, li.get('description', ''))

                # Sort categories by their sort_order
                sorted_categories = sorted(
                    [cat for cat in categories if cat.get('id') in items_by_category],
                    key=lambda c: c.get('sort_order', 0) or 0
                )

                # Render notes grouped by category
                for cat in sorted_categories:
                    cat_id = cat.get('id')
                    cat_name = cat.get('name', 'Unnamed Category')
                    cat_code = cat.get('account_code', '')
                    cat_items = sorted(items_by_category[cat_id], key=get_sort_key)

                    # Category header
                    pdf.set_font('Helvetica', 'B', 11)
                    pdf.set_fill_color(200, 200, 200)
                    cat_title = f"  {cat_code} - {cat_name}" if cat_code else f"  {cat_name}"
                    pdf.cell(0, 7, sanitize_text(cat_title), ln=True, fill=True)
                    pdf.ln(3)

                    for li in cat_items:
                        account_code = li.get('account_code', '') or ''
                        description = li.get('description', '') or 'No description'
                        notes = li.get('notes', '') or ''
                        internal_notes = li.get('internal_notes', '') or ''

                        # Combine notes if both exist
                        combined_notes = notes.strip()
                        if internal_notes.strip():
                            if combined_notes:
                                combined_notes += f"\n\n[Internal] {internal_notes.strip()}"
                            else:
                                combined_notes = internal_notes.strip()

                        # Item header: Code - Name
                        pdf.set_font('Helvetica', 'B', 10)
                        header_text = f"{account_code} - {description}" if account_code else description
                        if len(header_text) > 90:
                            header_text = header_text[:87] + '...'
                        pdf.cell(0, 6, sanitize_text(header_text), ln=True)

                        # Notes
                        pdf.set_font('Helvetica', '', 9)
                        pdf.set_x(pdf.get_x() + 5)
                        pdf.multi_cell(180, 5, sanitize_text(combined_notes))
                        pdf.ln(4)

                        # Add page break if getting close to bottom
                        if pdf.get_y() > 260:
                            pdf.add_page()

                    pdf.ln(4)

                # Render uncategorized items at the end if any
                if uncategorized_items:
                    uncategorized_items = sorted(uncategorized_items, key=get_sort_key)
                    pdf.set_font('Helvetica', 'B', 11)
                    pdf.set_fill_color(200, 200, 200)
                    pdf.cell(0, 7, "  Uncategorized", ln=True, fill=True)
                    pdf.ln(3)

                    for li in uncategorized_items:
                        account_code = li.get('account_code', '') or ''
                        description = li.get('description', '') or 'No description'
                        notes = li.get('notes', '') or ''
                        internal_notes = li.get('internal_notes', '') or ''

                        combined_notes = notes.strip()
                        if internal_notes.strip():
                            if combined_notes:
                                combined_notes += f"\n\n[Internal] {internal_notes.strip()}"
                            else:
                                combined_notes = internal_notes.strip()

                        pdf.set_font('Helvetica', 'B', 10)
                        header_text = f"{account_code} - {description}" if account_code else description
                        if len(header_text) > 90:
                            header_text = header_text[:87] + '...'
                        pdf.cell(0, 6, sanitize_text(header_text), ln=True)

                        pdf.set_font('Helvetica', '', 9)
                        pdf.set_x(pdf.get_x() + 5)
                        pdf.multi_cell(180, 5, sanitize_text(combined_notes))
                        pdf.ln(4)

                        if pdf.get_y() > 260:
                            pdf.add_page()

        # Footer
        pdf.ln(10)
        pdf.set_font('Helvetica', 'I', 8)
        pdf.set_text_color(128, 128, 128)
        pdf.cell(0, 5, "Generated by Second Watch Network - Backlot Production Management", align='C')

        # Output PDF
        pdf_bytes = pdf.output()

        return Response(
            content=bytes(pdf_bytes),
            media_type="application/pdf",
            headers={
                "Content-Disposition": f'attachment; filename="{filename}"'
            }
        )
    except Exception as pdf_err:
        import traceback
        error_details = traceback.format_exc()
        print(f"PDF generation failed: {pdf_err}")
        print(f"Full traceback:\n{error_details}")

        # Fallback to HTML download with error info in filename
        filename = filename.replace('.pdf', '-pdf-failed.html')
        return Response(
            content=f"<!-- PDF Error: {pdf_err}\n{error_details} -->\n" + html_content,
            media_type="text/html",
            headers={
                "Content-Disposition": f'attachment; filename="{filename}"'
            }
        )


@router.get("/projects/{project_id}/budget/export-html")
async def export_budget_html(
    project_id: str,
    budget_id: str = None,
    include_top_sheet: bool = True,
    include_detail: bool = True,
    include_daily_budgets: bool = False,
    include_receipts_summary: bool = False,
    include_notes: bool = True,
    show_actuals: bool = True,
    show_variance: bool = True,
    authorization: str = Header(None)
):
    """Export budget as HTML file. If budget_id is provided, exports that specific budget.
    Otherwise exports the first budget found for the project."""
    if not authorization:
        raise HTTPException(status_code=401, detail="Not authenticated")

    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get budget - either specific one or first for project
    if budget_id:
        budget_response = client.table("backlot_budgets").select("*").eq("id", budget_id).eq("project_id", project_id).execute()
    else:
        budget_response = client.table("backlot_budgets").select("*").eq("project_id", project_id).execute()
    if not budget_response.data:
        raise HTTPException(status_code=404, detail="Budget not found")
    budget = budget_response.data[0]
    budget_id = budget["id"]

    # Get project
    project_response = client.table("backlot_projects").select("*").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")
    project = project_response.data[0]

    # Get categories
    categories_response = client.table("backlot_budget_categories").select("*").eq(
        "budget_id", budget_id
    ).order("sort_order").execute()
    categories = categories_response.data or []

    # Get line items
    line_items_response = client.table("backlot_budget_line_items").select("*").eq(
        "budget_id", budget_id
    ).order("sort_order").execute()
    line_items = line_items_response.data or []

    # Compute top sheet dynamically
    above_the_line_total = 0
    production_total = 0
    post_total = 0
    other_total = 0

    for cat in categories:
        cat_type = cat.get("category_type", "other")
        estimated = cat.get("estimated_subtotal", 0) or 0

        if cat_type == "above_the_line":
            above_the_line_total += estimated
        elif cat_type == "production":
            production_total += estimated
        elif cat_type == "post":
            post_total += estimated
        else:
            other_total += estimated

    subtotal = above_the_line_total + production_total + post_total + other_total
    contingency_pct = budget.get("contingency_percent", 0) or 0
    contingency_amount = subtotal * contingency_pct / 100
    grand_total = subtotal + contingency_amount

    top_sheet = {
        "above_the_line_total": above_the_line_total,
        "production_total": production_total,
        "post_total": post_total,
        "other_total": other_total,
        "subtotal": subtotal,
        "contingency_amount": contingency_amount,
        "grand_total": grand_total
    }

    # Generate PDF options
    options = BudgetPdfExportInput(
        include_top_sheet=include_top_sheet,
        include_detail=include_detail,
        include_daily_budgets=include_daily_budgets,
        include_receipts_summary=include_receipts_summary,
        include_notes=include_notes,
        show_actuals=show_actuals,
        show_variance=show_variance
    )

    # Generate HTML
    html_content = generate_budget_pdf_html(
        project=project,
        budget=budget,
        categories=categories,
        line_items=line_items,
        top_sheet=top_sheet,
        options=options
    )

    filename = f"{project.get('title', 'budget')}-budget-{datetime.utcnow().strftime('%Y%m%d')}.html"

    return Response(
        content=html_content,
        media_type="text/html",
        headers={
            "Content-Disposition": f'attachment; filename="{filename}"'
        }
    )


# =============================================================================
# BUDGET BUNDLE ENDPOINTS - Intentional Budget Creation
# =============================================================================

def _convert_bundle_to_response(bundle, is_recommended: bool = False) -> DepartmentBundleResponse:
    """Convert internal bundle to API response format"""
    total_items = sum(
        len(cat.line_items)
        for cat in bundle.categories
    )
    return DepartmentBundleResponse(
        id=bundle.id,
        name=bundle.name,
        description=bundle.description,
        category_type=bundle.category_type.value,
        icon=bundle.icon,
        categories=[
            BundleCategoryResponse(
                name=cat.name,
                code=cat.code,
                account_code_prefix=cat.account_code_prefix,
                category_type=cat.category_type.value,
                sort_order=cat.sort_order,
                color=cat.color,
                line_items=[
                    BundleLineItemResponse(
                        account_code=item.account_code,
                        description=item.description,
                        calc_mode=item.calc_mode.value,
                        default_units=item.default_units,
                        department=item.department,
                        phase=item.phase.value if item.phase else None,
                        is_essential=item.is_essential
                    )
                    for item in cat.line_items
                ]
            )
            for cat in bundle.categories
        ],
        total_line_items=total_items,
        is_recommended=is_recommended
    )


@router.get("/budget-bundles", response_model=BundleListResponse)
async def get_budget_bundles():
    """
    Get all available department bundles for budget creation.

    These bundles are building blocks for intentional budget creation.
    Users can select which bundles to include when creating a budget.
    """
    from app.services.budget_templates import (
        get_all_bundles,
        BudgetProjectType,
        CategoryType
    )

    all_bundles = get_all_bundles()

    return BundleListResponse(
        bundles=[_convert_bundle_to_response(b) for b in all_bundles],
        project_types=[pt.value for pt in BudgetProjectType],
        category_types=[ct.value for ct in CategoryType]
    )


@router.get("/budget-bundles/recommended/{project_type}", response_model=RecommendedBundlesResponse)
async def get_recommended_bundles_for_project_type(project_type: str):
    """
    Get recommended bundles for a specific project type.

    Returns three lists:
    - recommended: Bundles commonly used for this project type
    - core_essentials: Minimal bundles with essential items only
    - all_available: All bundles (for "add more" UI)
    """
    from app.services.budget_templates import (
        get_all_bundles,
        get_recommended_bundles,
        get_core_essentials_bundles,
        BudgetProjectType
    )

    try:
        pt = BudgetProjectType(project_type)
    except ValueError:
        pt = BudgetProjectType.FEATURE

    recommended = get_recommended_bundles(pt)
    recommended_ids = {b.id for b in recommended}

    core = get_core_essentials_bundles()
    core_ids = {b.id for b in core}

    all_bundles = get_all_bundles()

    return RecommendedBundlesResponse(
        project_type=pt.value,
        recommended=[_convert_bundle_to_response(b, is_recommended=True) for b in recommended],
        core_essentials=[_convert_bundle_to_response(b) for b in core],
        all_available=[_convert_bundle_to_response(b, is_recommended=(b.id in recommended_ids)) for b in all_bundles]
    )


@router.get("/budget-bundles/{bundle_id}", response_model=DepartmentBundleResponse)
async def get_bundle_by_id(bundle_id: str):
    """Get a specific bundle by ID"""
    from app.services.budget_templates import get_bundle_by_id as get_bundle

    bundle = get_bundle(bundle_id)
    if not bundle:
        raise HTTPException(status_code=404, detail=f"Bundle '{bundle_id}' not found")

    return _convert_bundle_to_response(bundle)


@router.post("/projects/{project_id}/budget/from-bundles", response_model=BudgetCreationResult)
async def create_budget_from_bundles(
    project_id: str,
    options: CreateBudgetFromBundlesInput,
    authorization: str = Header(None)
):
    """
    Create a budget with intentional seeding from selected bundles.

    This is the PRIMARY budget creation endpoint. It respects the
    "no auto-populate giant templates" rule by only including what
    the user explicitly selects.

    Seed modes:
    - "blank": Creates budget with no categories or line items
    - "categories_only": Creates high-level categories only (no line items)
    - "bundles": Creates categories and line items from selected bundles
    - "essentials": Creates from core essential items only
    """
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()
    await verify_budget_access(client, project_id, user_id)

    # Check if budget already exists
    existing = client.table("backlot_budgets").select("id").eq("project_id", project_id).eq("name", options.name).execute()
    if existing.data:
        raise HTTPException(status_code=400, detail="A budget with this name already exists for this project")

    # Import template service
    from app.services.budget_templates import (
        get_bundle_by_id as get_bundle,
        get_core_essentials_bundles,
        get_high_level_categories,
        get_categories_from_bundles,
        filter_essential_items,
        BudgetProjectType
    )

    try:
        pt = BudgetProjectType(options.project_type)
    except ValueError:
        pt = BudgetProjectType.FEATURE

    # Create the budget record
    # Note: variance and contingency_amount are GENERATED columns in the database
    # They are computed automatically and cannot be inserted directly
    budget_data = {
        "project_id": project_id,
        "name": options.name,
        "currency": options.currency,
        "contingency_percent": options.contingency_percent,
        "status": "draft",
        "estimated_total": 0,
        "actual_total": 0,
        # variance is GENERATED AS (actual_total - estimated_total)
        # contingency_amount is GENERATED AS (estimated_total * contingency_percent / 100)
        "version": 1,
        "created_by": user_id,
        "project_type_template": options.project_type,
        "has_top_sheet": True,
        "shoot_days": options.shoot_days,
        "prep_days": options.prep_days,
        "wrap_days": options.wrap_days,
        "post_days": options.post_days,
        "episode_count": options.episode_count,
        "union_type": options.union_type
    }

    result = client.table("backlot_budgets").insert(budget_data).execute()
    if not result.data:
        raise HTTPException(status_code=500, detail="Failed to create budget")

    budget = result.data[0]
    budget_id = budget["id"]

    categories_created = 0
    line_items_created = 0
    bundles_used = []

    # Get categories to create based on seed_mode
    categories_to_create = []

    if options.seed_mode == "blank":
        # No seeding - budget starts completely empty
        pass

    elif options.seed_mode == "categories_only":
        # Create high-level category shells without line items
        categories_to_create = get_high_level_categories(pt)
        # Filter based on user preferences
        if not options.include_above_the_line:
            categories_to_create = [c for c in categories_to_create if c.category_type.value != "above_the_line"]
        if not options.include_production:
            categories_to_create = [c for c in categories_to_create if c.category_type.value != "production"]
        if not options.include_post:
            categories_to_create = [c for c in categories_to_create if c.category_type.value != "post"]
        if not options.include_other:
            categories_to_create = [c for c in categories_to_create if c.category_type.value != "other"]
        # Clear line items for categories_only mode
        for cat in categories_to_create:
            cat.line_items = []

    elif options.seed_mode == "essentials":
        # Get core essential bundles
        essential_bundles = get_core_essentials_bundles()
        for bundle in essential_bundles:
            filtered = filter_essential_items(bundle)
            bundles_used.append(bundle.id)
            for cat in filtered.categories:
                categories_to_create.append(cat)

    elif options.seed_mode == "bundles":
        # Use selected bundles
        if options.selected_bundle_ids:
            categories_to_create = get_categories_from_bundles(
                options.selected_bundle_ids,
                essentials_only=False
            )
            bundles_used = options.selected_bundle_ids

    # Create categories and line items
    category_id_map = {}  # Track created category IDs by code

    for cat in categories_to_create:
        # Check if we already created this category (avoid duplicates)
        if cat.code in category_id_map:
            continue

        cat_data = {
            "budget_id": budget_id,
            "name": cat.name,
            "code": cat.code,
            "account_code_prefix": cat.account_code_prefix,
            "category_type": cat.category_type.value,
            "sort_order": cat.sort_order,
            "color": cat.color,
            "estimated_subtotal": 0,
            "actual_subtotal": 0,
            "is_above_the_line": cat.category_type.value == "above_the_line"
        }

        cat_result = client.table("backlot_budget_categories").insert(cat_data).execute()
        if cat_result.data:
            categories_created += 1
            cat_id = cat_result.data[0]["id"]
            category_id_map[cat.code] = cat_id

            # Create line items for this category
            for idx, item in enumerate(cat.line_items):
                # Note: estimated_total and variance are GENERATED columns in backlot_budget_line_items
                # estimated_total = rate_amount * quantity (computed by DB)
                # variance = actual_total - estimated_total (computed by DB)
                item_data = {
                    "budget_id": budget_id,
                    "category_id": cat_id,
                    "account_code": item.account_code,
                    "description": item.description,
                    "rate_type": "flat" if item.calc_mode.value == "flat" else "daily",
                    "rate_amount": 0,
                    "quantity": 1,
                    "units": item.default_units,
                    # estimated_total is GENERATED AS (rate_amount * quantity)
                    "actual_total": 0,
                    # variance is GENERATED AS (actual_total - estimated_total)
                    "is_allocated_to_days": False,
                    "total_allocated": 0,
                    "is_locked": False,
                    "sort_order": idx,
                    "calc_mode": item.calc_mode.value,
                    "department": item.department,
                    "phase": item.phase.value if item.phase else None
                }

                item_result = client.table("backlot_budget_line_items").insert(item_data).execute()
                if item_result.data:
                    line_items_created += 1

    return BudgetCreationResult(
        budget=Budget(**budget),
        categories_created=categories_created,
        line_items_created=line_items_created,
        bundles_used=bundles_used,
        seed_mode=options.seed_mode
    )


@router.post("/budgets/{budget_id}/add-bundle", response_model=Dict[str, Any])
async def add_bundle_to_budget(
    budget_id: str,
    bundle_id: str,
    essentials_only: bool = False,
    authorization: str = Header(None)
):
    """
    Add a department bundle to an existing budget.

    This allows users to incrementally add bundles after budget creation.
    Categories and line items from the bundle will be added.
    """
    current_user = await get_current_user_from_token(authorization)
    user_id = current_user["id"]

    client = get_client()

    # Get budget
    budget_response = client.table("backlot_budgets").select("project_id, status").eq("id", budget_id).execute()
    if not budget_response.data:
        raise HTTPException(status_code=404, detail="Budget not found")

    budget = budget_response.data[0]
    if budget["status"] == "locked":
        raise HTTPException(status_code=400, detail="Cannot modify a locked budget")

    await verify_budget_access(client, budget["project_id"], user_id)

    # Get the bundle
    from app.services.budget_templates import get_bundle_by_id as get_bundle, filter_essential_items

    bundle = get_bundle(bundle_id)
    if not bundle:
        raise HTTPException(status_code=404, detail=f"Bundle '{bundle_id}' not found")

    # Filter to essentials if requested
    if essentials_only:
        bundle = filter_essential_items(bundle)

    # Get existing categories for this budget
    existing_cats = client.table("backlot_budget_categories").select("code").eq("budget_id", budget_id).execute()
    existing_codes = {c["code"] for c in (existing_cats.data or [])}

    categories_created = 0
    line_items_created = 0

    for cat in bundle.categories:
        # Check if category already exists
        if cat.code in existing_codes:
            # Get existing category ID
            cat_lookup = client.table("backlot_budget_categories").select("id").eq("budget_id", budget_id).eq("code", cat.code).execute()
            if cat_lookup.data:
                cat_id = cat_lookup.data[0]["id"]
                # Add line items to existing category
                for idx, item in enumerate(cat.line_items):
                    # Check if line item already exists
                    existing_item = client.table("backlot_budget_line_items").select("id").eq("budget_id", budget_id).eq("account_code", item.account_code).execute()
                    if not existing_item.data:
                        # Note: estimated_total and variance are GENERATED columns
                        item_data = {
                            "budget_id": budget_id,
                            "category_id": cat_id,
                            "account_code": item.account_code,
                            "description": item.description,
                            "rate_type": "flat" if item.calc_mode.value == "flat" else "daily",
                            "rate_amount": 0,
                            "quantity": 1,
                            "units": item.default_units,
                            # estimated_total is GENERATED AS (rate_amount * quantity)
                            "actual_total": 0,
                            # variance is GENERATED AS (actual_total - estimated_total)
                            "is_allocated_to_days": False,
                            "total_allocated": 0,
                            "is_locked": False,
                            "sort_order": 999 + idx,
                            "calc_mode": item.calc_mode.value,
                            "department": item.department,
                            "phase": item.phase.value if item.phase else None
                        }
                        item_result = client.table("backlot_budget_line_items").insert(item_data).execute()
                        if item_result.data:
                            line_items_created += 1
        else:
            # Create new category
            cat_data = {
                "budget_id": budget_id,
                "name": cat.name,
                "code": cat.code,
                "account_code_prefix": cat.account_code_prefix,
                "category_type": cat.category_type.value,
                "sort_order": cat.sort_order,
                "color": cat.color,
                "estimated_subtotal": 0,
                "actual_subtotal": 0,
                "is_above_the_line": cat.category_type.value == "above_the_line"
            }

            cat_result = client.table("backlot_budget_categories").insert(cat_data).execute()
            if cat_result.data:
                categories_created += 1
                cat_id = cat_result.data[0]["id"]
                existing_codes.add(cat.code)

                # Create line items
                for idx, item in enumerate(cat.line_items):
                    # Note: estimated_total and variance are GENERATED columns
                    item_data = {
                        "budget_id": budget_id,
                        "category_id": cat_id,
                        "account_code": item.account_code,
                        "description": item.description,
                        "rate_type": "flat" if item.calc_mode.value == "flat" else "daily",
                        "rate_amount": 0,
                        "quantity": 1,
                        "units": item.default_units,
                        # estimated_total is GENERATED AS (rate_amount * quantity)
                        "actual_total": 0,
                        # variance is GENERATED AS (actual_total - estimated_total)
                        "is_allocated_to_days": False,
                        "total_allocated": 0,
                        "is_locked": False,
                        "sort_order": idx,
                        "calc_mode": item.calc_mode.value,
                        "department": item.department,
                        "phase": item.phase.value if item.phase else None
                    }

                    item_result = client.table("backlot_budget_line_items").insert(item_data).execute()
                    if item_result.data:
                        line_items_created += 1

    return {
        "success": True,
        "bundle_id": bundle_id,
        "categories_created": categories_created,
        "line_items_created": line_items_created,
        "message": f"Added bundle '{bundle.name}' to budget"
    }


# =====================================================
# Global Location Library API Endpoints
# =====================================================

class LocationInput(BaseModel):
    """Input model for creating/updating a location"""
    name: str
    description: Optional[str] = None
    scene_description: Optional[str] = None
    address: Optional[str] = None
    city: Optional[str] = None
    state: Optional[str] = None
    zip: Optional[str] = None
    country: str = "USA"
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    contact_name: Optional[str] = None
    contact_phone: Optional[str] = None
    contact_email: Optional[str] = None
    parking_notes: Optional[str] = None
    load_in_notes: Optional[str] = None
    power_available: bool = True
    restrooms_available: bool = True
    permit_required: bool = False
    permit_notes: Optional[str] = None
    permit_obtained: bool = False
    location_fee: Optional[float] = None
    fee_notes: Optional[str] = None
    images: Optional[List[str]] = None
    is_public: bool = True  # Deprecated: use visibility instead
    visibility: str = "public"  # "public", "unlisted", or "private"
    region_tag: Optional[str] = None
    location_type: Optional[str] = None
    amenities: Optional[List[str]] = None


class LocationSearchParams(BaseModel):
    """Search parameters for global location library"""
    query: Optional[str] = None
    region: Optional[str] = None
    city: Optional[str] = None
    state: Optional[str] = None
    location_type: Optional[str] = None
    limit: int = 50
    offset: int = 0


class ProjectLocationAttachment(BaseModel):
    """Model for attaching a location to a project"""
    location_id: str
    project_notes: Optional[str] = None
    scene_description: Optional[str] = None


@router.get("/locations/global")
async def search_global_locations(
    query: Optional[str] = None,
    region: Optional[str] = None,
    city: Optional[str] = None,
    state: Optional[str] = None,
    location_type: Optional[str] = None,
    limit: int = 50,
    offset: int = 0,
    authorization: str = Header(None)
):
    """
    Search the global location library.
    Returns public locations matching the search criteria.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Build query for public locations (visibility = 'public')
        q = client.table("backlot_locations").select("*").eq("visibility", "public")

        # Apply filters
        if query:
            # Search by name, address, or city
            q = q.or_(f"name.ilike.%{query}%,address.ilike.%{query}%,city.ilike.%{query}%")

        if region:
            q = q.eq("region_tag", region)

        if city:
            q = q.ilike("city", f"%{city}%")

        if state:
            q = q.eq("state", state)

        if location_type:
            q = q.eq("location_type", location_type)

        # Apply pagination and ordering
        q = q.order("name").range(offset, offset + limit - 1)

        result = q.execute()

        return {
            "locations": result.data or [],
            "count": len(result.data or []),
            "offset": offset,
            "limit": limit
        }

    except Exception as e:
        print(f"Error searching global locations: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/locations/regions")
async def get_location_regions(authorization: str = Header(None)):
    """
    Get a list of distinct region tags from the location library.
    Useful for populating a region filter dropdown.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        result = client.table("backlot_locations").select("region_tag").eq("visibility", "public").execute()

        # Extract unique regions (filters out nulls)
        regions = list(set([r["region_tag"] for r in result.data if r.get("region_tag")]))
        regions.sort()

        return {"regions": regions}

    except Exception as e:
        print(f"Error fetching regions: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/locations/types")
async def get_location_types(authorization: str = Header(None)):
    """
    Get a list of distinct location types from the library.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        result = client.table("backlot_locations").select("location_type").eq("visibility", "public").execute()

        # Extract unique types (filters out nulls)
        types = list(set([r["location_type"] for r in result.data if r.get("location_type")]))
        types.sort()

        return {"types": types}

    except Exception as e:
        print(f"Error fetching location types: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/locations")
async def get_project_locations(
    project_id: str,
    authorization: str = Header(None)
):
    """
    Get all locations attached to a project.
    Returns both the attachment info and the full location data.
    """
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    # Verify project access using helper function
    await verify_project_access(client, project_id, user_id)

    try:
        # Get attached locations
        result = client.table("backlot_project_locations").select("*").eq("project_id", project_id).execute()

        # Get location IDs
        location_ids = [pl.get("location_id") for pl in (result.data or []) if pl.get("location_id")]

        # Get location details if we have any locations
        locations_map = {}
        if location_ids:
            locations_result = client.table("backlot_locations").select("*").in_("id", location_ids).execute()
            locations_map = {str(loc["id"]): loc for loc in (locations_result.data or [])}

        # Combine the data
        locations = []
        for pl in result.data or []:
            location_id = str(pl.get("location_id", ""))
            location = locations_map.get(location_id, {})
            if location:
                locations.append({
                    **location,
                    "attachment_id": pl["id"],
                    "project_notes": pl.get("project_notes"),
                    "scene_description_override": pl.get("scene_description"),
                    "attached_at": pl.get("attached_at"),
                    "attached_by_user_id": pl.get("attached_by_user_id")
                })

        return {"locations": locations}

    except Exception as e:
        print(f"Error fetching project locations: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/locations")
async def create_project_location(
    project_id: str,
    location: LocationInput,
    authorization: str = Header(None)
):
    """
    Create a new location from a project context.
    The location is added to the global library (if is_public=True)
    and automatically attached to the project.
    """
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    # Convert Cognito ID to profile ID
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    if not profile_id:
        raise HTTPException(status_code=404, detail="User profile not found")

    # Convert to string for database comparisons
    profile_id_str = str(profile_id)

    # Verify project membership with edit permissions (check both owner and members)
    project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    is_owner = str(project_response.data[0]["owner_id"]) == profile_id_str

    if not is_owner:
        member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id_str).execute()
        if not member_response.data:
            raise HTTPException(status_code=403, detail="Access denied - not a project member")

        member = member_response.data[0]
        if member["role"] not in ["owner", "admin", "editor"]:
            raise HTTPException(status_code=403, detail="You don't have permission to create locations")

    try:
        # Create the location in the global library
        location_data = {
            "name": location.name,
            "description": location.description,
            "scene_description": location.scene_description,
            "address": location.address,
            "city": location.city,
            "state": location.state,
            "zip": location.zip,
            "country": location.country,
            "latitude": location.latitude,
            "longitude": location.longitude,
            "contact_name": location.contact_name,
            "contact_phone": location.contact_phone,
            "contact_email": location.contact_email,
            "parking_notes": location.parking_notes,
            "load_in_notes": location.load_in_notes,
            "power_available": location.power_available,
            "restrooms_available": location.restrooms_available,
            "permit_required": location.permit_required,
            "permit_notes": location.permit_notes,
            "permit_obtained": location.permit_obtained,
            "location_fee": location.location_fee,
            "fee_notes": location.fee_notes,
            "images": location.images or [],
            "is_public": location.visibility == "public" if location.visibility else location.is_public,
            "visibility": location.visibility or ("public" if location.is_public else "private"),
            "region_tag": location.region_tag,
            "location_type": location.location_type,
            "amenities": location.amenities or [],
            "created_by_user_id": profile_id,
            "created_by_project_id": project_id,
            "project_id": None  # Global location, not project-specific
        }

        loc_result = client.table("backlot_locations").insert(location_data).execute()

        if not loc_result.data:
            raise HTTPException(status_code=500, detail="Failed to create location")

        new_location = loc_result.data[0]

        # Automatically attach to the project
        attachment_data = {
            "project_id": project_id,
            "location_id": new_location["id"],
            "attached_by_user_id": profile_id
        }

        client.table("backlot_project_locations").insert(attachment_data).execute()

        return {
            "success": True,
            "location": new_location,
            "message": "Location created and attached to project"
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating location: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/locations/attach")
async def attach_location_to_project(
    project_id: str,
    attachment: ProjectLocationAttachment,
    authorization: str = Header(None)
):
    """
    Attach an existing location from the global library to a project.
    """
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    # Convert Cognito ID to profile ID
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    if not profile_id:
        raise HTTPException(status_code=404, detail="User profile not found")

    # Convert to string for database comparisons
    profile_id_str = str(profile_id)

    # Verify project membership (check both owner and members)
    project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    is_owner = str(project_response.data[0]["owner_id"]) == profile_id_str

    if not is_owner:
        member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id_str).execute()
        if not member_response.data:
            raise HTTPException(status_code=403, detail="Access denied - not a project member")

    try:
        # Verify the location exists and is accessible
        loc_result = client.table("backlot_locations").select("id, name, is_public").eq("id", attachment.location_id).execute()

        if not loc_result.data:
            raise HTTPException(status_code=404, detail="Location not found")

        location = loc_result.data[0]
        if not location.get("is_public"):
            raise HTTPException(status_code=403, detail="Cannot attach a private location")

        # Check if already attached
        existing = client.table("backlot_project_locations").select("id").eq("project_id", project_id).eq("location_id", attachment.location_id).execute()

        if existing.data:
            return {
                "success": True,
                "message": "Location already attached to project",
                "attachment_id": existing.data[0]["id"]
            }

        # Create the attachment
        attachment_data = {
            "project_id": project_id,
            "location_id": attachment.location_id,
            "project_notes": attachment.project_notes,
            "scene_description": attachment.scene_description,
            "attached_by_user_id": profile_id
        }

        result = client.table("backlot_project_locations").insert(attachment_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to attach location")

        return {
            "success": True,
            "message": f"Location '{location['name']}' attached to project",
            "attachment_id": result.data[0]["id"]
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error attaching location: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/projects/{project_id}/locations/{location_id}")
async def detach_location_from_project(
    project_id: str,
    location_id: str,
    authorization: str = Header(None)
):
    """
    Detach a location from a project.
    This does NOT delete the location from the global library.
    """
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    # Verify project membership (check both owner and members)
    project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)

    if not is_owner:
        member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
        if not member_response.data:
            raise HTTPException(status_code=403, detail="Access denied - not a project member")

    try:
        # Delete the attachment
        result = client.table("backlot_project_locations").delete().eq("project_id", project_id).eq("location_id", location_id).execute()

        return {
            "success": True,
            "message": "Location detached from project"
        }

    except Exception as e:
        print(f"Error detaching location: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/locations/{location_id}")
async def get_location(
    location_id: str,
    authorization: str = Header(None)
):
    """
    Get a single location by ID.
    Only returns public locations or locations the user created.
    """
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        result = client.table("backlot_locations").select("*").eq("id", location_id).execute()

        if not result.data:
            raise HTTPException(status_code=404, detail="Location not found")

        location = result.data[0]

        # Check access based on visibility:
        # - "public" or "unlisted": anyone can view (unlisted = accessible via direct link)
        # - "private": only creator can view
        visibility = location.get("visibility", "public" if location.get("is_public") else "private")
        if visibility == "private" and str(location.get("created_by_user_id")) != str(user_id):
            raise HTTPException(status_code=403, detail="Access denied - this location is private")

        return {"location": location}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching location: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/locations/{location_id}")
async def update_location(
    location_id: str,
    location: LocationInput,
    authorization: str = Header(None)
):
    """
    Update a location.
    Only the creator can update a location.
    """
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Verify ownership
        existing = client.table("backlot_locations").select("id, created_by_user_id").eq("id", location_id).execute()

        if not existing.data:
            raise HTTPException(status_code=404, detail="Location not found")

        if existing.data[0].get("created_by_user_id") != user_id:
            raise HTTPException(status_code=403, detail="Only the creator can update this location")

        # Update the location
        update_data = {
            "name": location.name,
            "description": location.description,
            "scene_description": location.scene_description,
            "address": location.address,
            "city": location.city,
            "state": location.state,
            "zip": location.zip,
            "country": location.country,
            "latitude": location.latitude,
            "longitude": location.longitude,
            "contact_name": location.contact_name,
            "contact_phone": location.contact_phone,
            "contact_email": location.contact_email,
            "parking_notes": location.parking_notes,
            "load_in_notes": location.load_in_notes,
            "power_available": location.power_available,
            "restrooms_available": location.restrooms_available,
            "permit_required": location.permit_required,
            "permit_notes": location.permit_notes,
            "permit_obtained": location.permit_obtained,
            "location_fee": location.location_fee,
            "fee_notes": location.fee_notes,
            "images": location.images or [],
            "is_public": location.visibility == "public" if location.visibility else location.is_public,
            "visibility": location.visibility or ("public" if location.is_public else "private"),
            "region_tag": location.region_tag,
            "location_type": location.location_type,
            "amenities": location.amenities or []
        }

        result = client.table("backlot_locations").update(update_data).eq("id", location_id).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to update location")

        return {
            "success": True,
            "location": result.data[0]
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating location: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/locations/{location_id}")
async def delete_location(
    location_id: str,
    authorization: str = Header(None)
):
    """
    Delete a location from the global library.
    Only the creator can delete a location.
    This will also remove all project attachments.
    """
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Verify ownership
        existing = client.table("backlot_locations").select("id, created_by_user_id, name").eq("id", location_id).execute()

        if not existing.data:
            raise HTTPException(status_code=404, detail="Location not found")

        if existing.data[0].get("created_by_user_id") != user_id:
            raise HTTPException(status_code=403, detail="Only the creator can delete this location")

        location_name = existing.data[0].get("name", "Unknown")

        # Delete the location (cascade will remove attachments)
        client.table("backlot_locations").delete().eq("id", location_id).execute()

        return {
            "success": True,
            "message": f"Location '{location_name}' deleted"
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting location: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/projects/{project_id}/locations/{location_id}")
async def update_project_location_notes(
    project_id: str,
    location_id: str,
    project_notes: Optional[str] = None,
    scene_description: Optional[str] = None,
    authorization: str = Header(None)
):
    """
    Update project-specific notes for an attached location.
    """
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    # Verify project membership (check both owner and members)
    project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)

    if not is_owner:
        member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
        if not member_response.data:
            raise HTTPException(status_code=403, detail="Access denied - not a project member")

    try:
        # Find the attachment
        existing = client.table("backlot_project_locations").select("id").eq("project_id", project_id).eq("location_id", location_id).execute()

        if not existing.data:
            raise HTTPException(status_code=404, detail="Location not attached to this project")

        # Update the attachment
        update_data = {}
        if project_notes is not None:
            update_data["project_notes"] = project_notes
        if scene_description is not None:
            update_data["scene_description"] = scene_description

        if update_data:
            result = client.table("backlot_project_locations").update(update_data).eq("id", existing.data[0]["id"]).execute()

            return {
                "success": True,
                "attachment": result.data[0] if result.data else None
            }

        return {"success": True, "message": "No changes made"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating project location notes: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# LOCATION SCOUT PHOTOS
# =====================================================

class ScoutPhotoInput(BaseModel):
    """Input model for creating/updating scout photos"""
    image_url: str
    thumbnail_url: Optional[str] = None
    original_filename: Optional[str] = None
    # Composition & vantage
    angle_label: Optional[str] = None
    vantage_type: Optional[str] = None  # wide, medium, close-up, detail, overhead, drone
    camera_facing: Optional[str] = None  # cardinal direction
    # Time & conditions
    time_of_day: Optional[str] = None  # morning, midday, afternoon, golden_hour, blue_hour, night
    shoot_date: Optional[str] = None  # ISO date string
    weather: Optional[str] = None
    # Practical notes
    light_notes: Optional[str] = None
    sound_notes: Optional[str] = None
    access_notes: Optional[str] = None
    power_notes: Optional[str] = None
    parking_notes: Optional[str] = None
    restrictions_notes: Optional[str] = None
    general_notes: Optional[str] = None
    # Classification
    is_primary: Optional[bool] = False
    interior_exterior: Optional[str] = None  # interior, exterior, both


class ScoutPhotoUpdateInput(BaseModel):
    """Input model for updating scout photos (all fields optional)"""
    image_url: Optional[str] = None
    thumbnail_url: Optional[str] = None
    original_filename: Optional[str] = None
    angle_label: Optional[str] = None
    vantage_type: Optional[str] = None
    camera_facing: Optional[str] = None
    time_of_day: Optional[str] = None
    shoot_date: Optional[str] = None
    weather: Optional[str] = None
    light_notes: Optional[str] = None
    sound_notes: Optional[str] = None
    access_notes: Optional[str] = None
    power_notes: Optional[str] = None
    parking_notes: Optional[str] = None
    restrictions_notes: Optional[str] = None
    general_notes: Optional[str] = None
    is_primary: Optional[bool] = None
    interior_exterior: Optional[str] = None


async def can_user_edit_location(client, user_id: str, location_id: str) -> bool:
    """Check if user has permission to edit a location (for adding/editing scout photos)"""
    # Check if user is the location creator
    location = client.table("backlot_locations").select("created_by_user_id, project_id").eq("id", location_id).execute()
    if not location.data:
        return False

    loc_data = location.data[0]

    # User is creator
    if loc_data.get("created_by_user_id") == user_id:
        return True

    # User is member of the project that owns the location
    if loc_data.get("project_id"):
        member = client.table("backlot_project_members").select("role").eq("project_id", loc_data["project_id"]).eq("user_id", user_id).execute()
        if member.data:
            return True

    # User is member of a project that has attached this location
    attachments = client.table("backlot_project_locations").select("project_id").eq("location_id", location_id).execute()
    if attachments.data:
        for att in attachments.data:
            member = client.table("backlot_project_members").select("role").eq("project_id", att["project_id"]).eq("user_id", user_id).execute()
            if member.data:
                return True

    # Check if user is admin/superadmin
    user_data = client.table("users").select("is_admin, is_superadmin").eq("id", user_id).execute()
    if user_data.data:
        if user_data.data[0].get("is_admin") or user_data.data[0].get("is_superadmin"):
            return True

    return False


async def can_user_view_location(client, user_id: str, location_id: str) -> bool:
    """Check if user can view a location and its scout photos"""
    location = client.table("backlot_locations").select("is_public, created_by_user_id, project_id").eq("id", location_id).execute()
    if not location.data:
        return False

    loc_data = location.data[0]

    # Public locations are viewable by all authenticated users
    if loc_data.get("is_public"):
        return True

    # User is creator
    if loc_data.get("created_by_user_id") == user_id:
        return True

    # User is member of owning project
    if loc_data.get("project_id"):
        member = client.table("backlot_project_members").select("role").eq("project_id", loc_data["project_id"]).eq("user_id", user_id).execute()
        if member.data:
            return True

    # User is member of a project that has attached this location
    attachments = client.table("backlot_project_locations").select("project_id").eq("location_id", location_id).execute()
    if attachments.data:
        for att in attachments.data:
            member = client.table("backlot_project_members").select("role").eq("project_id", att["project_id"]).eq("user_id", user_id).execute()
            if member.data:
                return True

    # Check if user is admin/superadmin
    user_data = client.table("users").select("is_admin, is_superadmin").eq("id", user_id).execute()
    if user_data.data:
        if user_data.data[0].get("is_admin") or user_data.data[0].get("is_superadmin"):
            return True

    return False


@router.get("/locations/{location_id}/scout-photos")
async def get_location_scout_photos(
    location_id: str,
    vantage_type: Optional[str] = None,
    time_of_day: Optional[str] = None,
    interior_exterior: Optional[str] = None,
    authorization: str = Header(None)
):
    """
    Get all scout photos for a location with optional filters.
    """
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    # Verify user can view this location
    if not await can_user_view_location(client, user_id, location_id):
        raise HTTPException(status_code=403, detail="Access denied")

    try:
        query = client.table("backlot_location_scout_photos").select("*").eq("location_id", location_id)

        if vantage_type:
            query = query.eq("vantage_type", vantage_type)
        if time_of_day:
            query = query.eq("time_of_day", time_of_day)
        if interior_exterior:
            query = query.eq("interior_exterior", interior_exterior)

        query = query.order("is_primary", desc=True).order("created_at", desc=True)
        result = query.execute()

        return {
            "success": True,
            "photos": result.data or [],
            "count": len(result.data) if result.data else 0
        }

    except Exception as e:
        print(f"Error fetching scout photos: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/locations/{location_id}/scout-photos")
async def create_scout_photo(
    location_id: str,
    photo: ScoutPhotoInput,
    authorization: str = Header(None)
):
    """
    Create a new scout photo for a location.
    """
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    # Verify user can edit this location
    if not await can_user_edit_location(client, user_id, location_id):
        raise HTTPException(status_code=403, detail="Access denied - cannot edit this location")

    try:
        # If this is set as primary, unset any existing primary photos
        if photo.is_primary:
            client.table("backlot_location_scout_photos").update({"is_primary": False}).eq("location_id", location_id).eq("is_primary", True).execute()

        insert_data = {
            "location_id": location_id,
            "image_url": photo.image_url,
            "thumbnail_url": photo.thumbnail_url,
            "original_filename": photo.original_filename,
            "angle_label": photo.angle_label,
            "vantage_type": photo.vantage_type,
            "camera_facing": photo.camera_facing,
            "time_of_day": photo.time_of_day,
            "shoot_date": photo.shoot_date,
            "weather": photo.weather,
            "light_notes": photo.light_notes,
            "sound_notes": photo.sound_notes,
            "access_notes": photo.access_notes,
            "power_notes": photo.power_notes,
            "parking_notes": photo.parking_notes,
            "restrictions_notes": photo.restrictions_notes,
            "general_notes": photo.general_notes,
            "is_primary": photo.is_primary or False,
            "interior_exterior": photo.interior_exterior,
            "uploaded_by_user_id": user_id,
        }

        result = client.table("backlot_location_scout_photos").insert(insert_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create scout photo")

        return {
            "success": True,
            "photo": result.data[0]
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating scout photo: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/location-scout-photos/{photo_id}")
async def get_scout_photo(
    photo_id: str,
    authorization: str = Header(None)
):
    """
    Get a single scout photo by ID.
    """
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        result = client.table("backlot_location_scout_photos").select("*").eq("id", photo_id).execute()

        if not result.data:
            raise HTTPException(status_code=404, detail="Scout photo not found")

        photo = result.data[0]

        # Verify user can view the location
        if not await can_user_view_location(client, user_id, photo["location_id"]):
            raise HTTPException(status_code=403, detail="Access denied")

        return {
            "success": True,
            "photo": photo
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching scout photo: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/location-scout-photos/{photo_id}")
async def update_scout_photo(
    photo_id: str,
    photo: ScoutPhotoUpdateInput,
    authorization: str = Header(None)
):
    """
    Update a scout photo.
    """
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get existing photo
        existing = client.table("backlot_location_scout_photos").select("*").eq("id", photo_id).execute()

        if not existing.data:
            raise HTTPException(status_code=404, detail="Scout photo not found")

        existing_photo = existing.data[0]

        # Check if user is uploader or can edit location
        is_uploader = existing_photo.get("uploaded_by_user_id") == user_id
        can_edit = await can_user_edit_location(client, user_id, existing_photo["location_id"])

        if not is_uploader and not can_edit:
            raise HTTPException(status_code=403, detail="Access denied - cannot edit this photo")

        # If setting as primary, unset others first
        if photo.is_primary:
            client.table("backlot_location_scout_photos").update({"is_primary": False}).eq("location_id", existing_photo["location_id"]).eq("is_primary", True).neq("id", photo_id).execute()

        # Build update data (only include non-None fields)
        update_data = {}
        for field, value in photo.model_dump().items():
            if value is not None:
                update_data[field] = value

        if update_data:
            result = client.table("backlot_location_scout_photos").update(update_data).eq("id", photo_id).execute()
            return {
                "success": True,
                "photo": result.data[0] if result.data else None
            }

        return {"success": True, "message": "No changes made"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating scout photo: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/location-scout-photos/{photo_id}")
async def delete_scout_photo(
    photo_id: str,
    authorization: str = Header(None)
):
    """
    Delete a scout photo.
    """
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get existing photo
        existing = client.table("backlot_location_scout_photos").select("*").eq("id", photo_id).execute()

        if not existing.data:
            raise HTTPException(status_code=404, detail="Scout photo not found")

        existing_photo = existing.data[0]

        # Check if user is uploader or can edit location
        is_uploader = existing_photo.get("uploaded_by_user_id") == user_id
        can_edit = await can_user_edit_location(client, user_id, existing_photo["location_id"])

        if not is_uploader and not can_edit:
            raise HTTPException(status_code=403, detail="Access denied - cannot delete this photo")

        client.table("backlot_location_scout_photos").delete().eq("id", photo_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting scout photo: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/locations/{location_id}/scout-summary")
async def get_location_scout_summary(
    location_id: str,
    authorization: str = Header(None)
):
    """
    Get a summary of scout photo info for a location (for call sheet previews).
    Returns primary photo, key practical notes, and smart tags.
    """
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    # Verify user can view this location
    if not await can_user_view_location(client, user_id, location_id):
        raise HTTPException(status_code=403, detail="Access denied")

    try:
        # Get all scout photos for this location
        photos = client.table("backlot_location_scout_photos").select("*").eq("location_id", location_id).order("is_primary", desc=True).order("created_at", desc=True).execute()

        if not photos.data:
            return {
                "success": True,
                "has_scout_photos": False,
                "primary_photo": None,
                "photo_count": 0,
                "practical_summary": None,
                "tags": []
            }

        # Get primary photo (first one after sorting)
        primary = photos.data[0]

        # Aggregate practical notes from all photos
        practical_summary = {
            "access": None,
            "parking": None,
            "power": None,
            "sound": None,
            "light": None,
            "restrictions": None
        }

        tags = set()

        for photo in photos.data:
            # Aggregate notes (take first non-null for each category)
            if not practical_summary["access"] and photo.get("access_notes"):
                practical_summary["access"] = photo["access_notes"]
            if not practical_summary["parking"] and photo.get("parking_notes"):
                practical_summary["parking"] = photo["parking_notes"]
            if not practical_summary["power"] and photo.get("power_notes"):
                practical_summary["power"] = photo["power_notes"]
            if not practical_summary["sound"] and photo.get("sound_notes"):
                practical_summary["sound"] = photo["sound_notes"]
            if not practical_summary["light"] and photo.get("light_notes"):
                practical_summary["light"] = photo["light_notes"]
            if not practical_summary["restrictions"] and photo.get("restrictions_notes"):
                practical_summary["restrictions"] = photo["restrictions_notes"]

            # Derive tags from notes
            sound = (photo.get("sound_notes") or "").lower()
            light = (photo.get("light_notes") or "").lower()
            power = (photo.get("power_notes") or "").lower()
            parking = (photo.get("parking_notes") or "").lower()
            access = (photo.get("access_notes") or "").lower()

            # Sound tags
            if "quiet" in sound or "silent" in sound:
                tags.add("Quiet")
            if "road" in sound or "traffic" in sound or "freeway" in sound:
                tags.add("Road Noise")
            if "plane" in sound or "airplane" in sound or "airport" in sound:
                tags.add("Airport Noise")

            # Light tags
            if "natural" in light or "window" in light:
                tags.add("Natural Light")
            if "north" in light and "facing" in light:
                tags.add("North-Facing")

            # Power tags
            if "100a" in power or "200a" in power or "tie-in" in power:
                tags.add("Full Power")
            if "house power" in power or "limited" in power:
                tags.add("Limited Power")

            # Parking tags
            if "lot" in parking or "ample" in parking or "plenty" in parking:
                tags.add("Good Parking")
            if "limited" in parking or "no parking" in parking:
                tags.add("Limited Parking")

            # Access tags
            if "truck" in access or "loading" in access:
                tags.add("Truck Access")
            if "elevator" in access and "no elevator" not in access:
                tags.add("Elevator")
            if "stairs only" in access:
                tags.add("Stairs Only")

        return {
            "success": True,
            "has_scout_photos": True,
            "primary_photo": {
                "id": primary["id"],
                "image_url": primary["image_url"],
                "thumbnail_url": primary.get("thumbnail_url") or primary["image_url"],
                "angle_label": primary.get("angle_label"),
                "vantage_type": primary.get("vantage_type"),
                "time_of_day": primary.get("time_of_day")
            },
            "photo_count": len(photos.data),
            "practical_summary": practical_summary,
            "tags": list(tags)
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching scout summary: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# SCRIPT BREAKDOWN ENDPOINTS
# =====================================================

# Pydantic models for script breakdown
class ScriptInput(BaseModel):
    title: str
    file_url: Optional[str] = None
    format: Optional[str] = None  # pdf, fdx, fountain, manual
    version: Optional[str] = None

class SceneInput(BaseModel):
    scene_number: str
    slugline: Optional[str] = None
    description: Optional[str] = None
    page_length: Optional[float] = 0
    page_start: Optional[float] = None
    page_end: Optional[float] = None
    location_hint: Optional[str] = None
    int_ext: Optional[str] = None
    time_of_day: Optional[str] = None
    location_id: Optional[str] = None
    director_notes: Optional[str] = None
    ad_notes: Optional[str] = None
    coverage_status: Optional[str] = None  # not_scheduled, scheduled, shot, needs_pickup

class SceneCoverageUpdate(BaseModel):
    is_scheduled: Optional[bool] = None
    is_shot: Optional[bool] = None
    needs_pickup: Optional[bool] = None
    pickup_notes: Optional[str] = None
    scheduled_day_id: Optional[str] = None
    shot_day_id: Optional[str] = None

class BreakdownItemInput(BaseModel):
    type: str  # cast, background, prop, vehicle, sfx, vfx, wardrobe, makeup, location, other
    label: str
    quantity: Optional[int] = 1
    notes: Optional[str] = None
    linked_entity_id: Optional[str] = None
    linked_entity_type: Optional[str] = None
    department: Optional[str] = None  # cast, locations, props, wardrobe, makeup, sfx, vfx, background, stunts, camera, sound
    stripboard_day: Optional[int] = None  # Optional mapping to schedule day
    scene_id: Optional[str] = None  # Allow moving item to a different scene

class CallSheetSceneLinkInput(BaseModel):
    scene_id: str
    sequence: Optional[int] = 0
    estimated_time_minutes: Optional[int] = None
    notes: Optional[str] = None


# =====================================================
# SCRIPTS CRUD
# =====================================================

@router.get("/projects/{project_id}/scripts")
async def get_project_scripts(
    project_id: str,
    authorization: str = Header(None)
):
    """Get all scripts for a project"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    # Convert Cognito user ID to profile ID
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    if not profile_id:
        raise HTTPException(status_code=403, detail="Profile not found")

    # Verify project access
    project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    is_owner = project_response.data[0]["owner_id"] == profile_id
    if not is_owner:
        member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id).execute()
        if not member_response.data:
            raise HTTPException(status_code=403, detail="Access denied - not a project member")

    try:
        result = client.table("backlot_scripts").select("*").eq("project_id", project_id).order("created_at", desc=True).execute()
        scripts = result.data or []

        # Convert S3 paths to signed URLs for PDF viewing
        for script in scripts:
            if script.get("file_url") and script["file_url"].startswith("s3://"):
                # Extract bucket and path from s3://bucket/path format
                s3_uri = script["file_url"][5:]  # Remove 's3://'
                parts = s3_uri.split("/", 1)
                if len(parts) == 2:
                    bucket_name, s3_path = parts
                    # Generate signed URL (24 hours expiry for viewing)
                    signed_url = get_signed_url('backlot-files', s3_path, expires_in=86400)
                    script["file_url"] = signed_url

        return {"scripts": scripts}
    except Exception as e:
        print(f"Error fetching scripts: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/scripts")
async def create_script(
    project_id: str,
    script: ScriptInput,
    authorization: str = Header(None)
):
    """Create a new script for a project"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    # Convert Cognito user ID to profile ID
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    if not profile_id:
        raise HTTPException(status_code=403, detail="Profile not found")

    # Verify project edit access using the helper function
    await verify_project_access(client, project_id, profile_id, require_edit=True)

    try:
        script_data = {
            "project_id": project_id,
            "title": script.title,
            "file_url": script.file_url,
            "format": script.format or "manual",
            "version": script.version,
            "parse_status": "manual" if not script.file_url else "pending",
            "created_by_user_id": str(profile_id)
        }

        result = client.table("backlot_scripts").insert(script_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create script")

        return {"success": True, "script": result.data[0]}
    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating script: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/scripts/import")
async def import_script(
    project_id: str,
    file: UploadFile = File(...),
    title: str = Form(...),
    version: str = Form(None),
    authorization: str = Header(None)
):
    """Import a script file (PDF or FDX) and parse scenes"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    # Convert Cognito user ID to profile ID
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    if not profile_id:
        raise HTTPException(status_code=403, detail="Profile not found")

    # Verify project edit access using the helper function
    await verify_project_access(client, project_id, profile_id, require_edit=True)

    try:
        # Determine format from file extension
        filename = file.filename or "script"
        ext = filename.split(".")[-1].lower() if "." in filename else ""

        if ext not in ["pdf", "fdx", "txt", "fountain"]:
            raise HTTPException(status_code=400, detail="Only PDF, FDX, TXT, and Fountain files are supported")

        # Read file content
        content = await file.read()

        # Debug logging
        print(f"Script import: filename={filename}, ext={ext}, content_type={type(content)}, content_len={len(content) if content else 0}")

        if not content:
            raise HTTPException(status_code=400, detail="Empty file uploaded")

        # Initialize variables for extraction
        page_count = None
        text_content = None  # For the script editor
        parsed_scenes = []
        title_page_data = None  # Structured title page metadata

        # Use the improved script parser
        try:
            from app.utils.script_parser import parse_script_file

            parse_result = parse_script_file(content, ext)
            text_content = parse_result.text_content
            page_count = parse_result.page_count

            # Extract structured title page data if available
            if parse_result.title_page_data:
                from dataclasses import asdict
                title_page_data = asdict(parse_result.title_page_data)
                # Remove None values for cleaner JSON
                title_page_data = {k: v for k, v in title_page_data.items() if v is not None}

            # Calculate page_length from sequential page_start values
            scenes_list = parse_result.scenes
            scenes_list = sorted(scenes_list, key=lambda s: (s.page_start or 0, s.sequence or 0))

            for i, scene in enumerate(scenes_list):
                if scene.page_start is not None:
                    # Get next scene's page_start to calculate length
                    if i + 1 < len(scenes_list) and scenes_list[i + 1].page_start is not None:
                        next_page_start = scenes_list[i + 1].page_start
                        calculated_length = float(next_page_start - scene.page_start)
                        scene.page_length = max(0.125, calculated_length)  # Minimum 1/8 page
                    else:
                        # Last scene - estimate 1 page if no next scene info
                        scene.page_length = 1.0
                else:
                    scene.page_length = 1.0  # Default if no page info

            # Convert parsed scenes to dict format for database
            for scene in scenes_list:
                parsed_scenes.append({
                    "scene_number": scene.scene_number,
                    "slugline": scene.slugline,
                    "int_ext": scene.int_ext,
                    "time_of_day": scene.time_of_day,
                    "set_name": scene.location_hint,
                    "page_start": scene.page_start,
                    "page_length": scene.page_length,
                    "sequence": scene.sequence
                })

            print(f"Parsed {ext.upper()} file: {page_count} pages, {len(parsed_scenes)} scenes")
            if parsed_scenes:
                print(f"First 5 scenes: {[s.get('slugline', '')[:50] for s in parsed_scenes[:5]]}")
            else:
                print(f"No scenes found. Text content preview: {text_content[:500] if text_content else 'None'}")

        except ImportError as ie:
            print(f"Script parser import error: {ie}")
            # Fallback to basic text extraction
            if ext == "pdf":
                try:
                    from pypdf import PdfReader
                    import io
                    pdf_reader = PdfReader(io.BytesIO(content))
                    page_count = len(pdf_reader.pages)
                    text_parts = []
                    for page in pdf_reader.pages:
                        text_parts.append(page.extract_text() or "")
                    text_content = "\n".join(text_parts)
                except Exception as e:
                    print(f"PDF fallback error: {e}")
            elif ext in ["txt", "fountain", "fdx"]:
                try:
                    text_content = content.decode('utf-8')
                    page_count = max(1, len(text_content) // 3000)
                except Exception as e:
                    print(f"Text fallback error: {e}")

        except Exception as parse_err:
            print(f"Script parsing error: {parse_err}")
            # Continue with basic fallback
            if ext == "pdf":
                try:
                    from pypdf import PdfReader
                    import io
                    pdf_reader = PdfReader(io.BytesIO(content))
                    page_count = len(pdf_reader.pages)
                except:
                    pass
            elif ext in ["txt", "fountain"]:
                try:
                    text_content = content.decode('utf-8')
                    page_count = max(1, len(text_content) // 3000)
                except:
                    pass

        # Upload file to S3 for PDF viewing
        file_url = None
        try:
            import io
            # Generate unique filename
            unique_filename = generate_unique_filename(filename)
            s3_path = f"scripts/{project_id}/{unique_filename}"

            # Upload to S3
            file_obj = io.BytesIO(content)
            upload_result = upload_file(
                'backlot-files',
                s3_path,
                file_obj,
                content_type=f"application/{ext}" if ext in ['pdf'] else 'application/octet-stream'
            )

            # Get signed URL for private access (1 week expiry)
            file_url = get_signed_url('backlot-files', s3_path, expires_in=604800)

            # Store the S3 path in file_url for later signed URL generation
            # We'll store the path, not the signed URL, so we can regenerate signed URLs
            file_url = f"s3://{BACKLOT_FILES_BUCKET}/{s3_path}"

            print(f"Uploaded script to S3: {s3_path}")
        except Exception as upload_err:
            print(f"S3 upload error (continuing without file): {upload_err}")
            # Continue without file URL - text content is still available

        # Create script record with text_content for the editor
        script_data = {
            "project_id": project_id,
            "title": title,
            "file_url": file_url,  # S3 path for the uploaded file
            "format": ext,
            "version": version or "v1",
            "version_number": 1,
            "color_code": "white",
            "is_current": True,
            "is_locked": False,
            "parse_status": "completed" if text_content else "pending",
            "created_by_user_id": profile_id,
            "total_pages": page_count,
            "total_scenes": len(parsed_scenes),
            "text_content": text_content,  # For the script editor
            "title_page_data": title_page_data  # Structured title page metadata
        }

        script_result = client.table("backlot_scripts").insert(script_data).execute()

        if not script_result.data:
            raise HTTPException(status_code=500, detail="Failed to create script record")

        script = script_result.data[0]

        # Create scene records if any were parsed
        # Deduplicate scenes by slugline (same scene heading = same scene)
        # Also check against existing scenes in the project to avoid duplicates
        if parsed_scenes:
            # Get existing scenes for this project to avoid duplicates
            existing_scenes_result = client.table("backlot_scenes").select(
                "id, scene_number, slugline"
            ).eq("project_id", project_id).execute()
            existing_by_number = {s["scene_number"]: s for s in (existing_scenes_result.data or [])}
            existing_sluglines = {(s.get("slugline") or "").strip().upper() for s in (existing_scenes_result.data or [])}

            seen_sluglines = set()
            unique_scenes = []
            scenes_to_update = []
            skipped_existing = 0
            skipped_duplicate = 0
            scene_sequence = 0

            for scene_data in parsed_scenes:
                slugline = scene_data.get("slugline", "").strip().upper()

                # Skip duplicate sluglines within this import
                if slugline in seen_sluglines:
                    skipped_duplicate += 1
                    continue

                seen_sluglines.add(slugline)
                scene_sequence += 1

                # Update sequence to reflect unique scenes only
                scene_data["sequence"] = scene_sequence
                scene_data["scene_number"] = str(scene_sequence)
                scene_data["project_id"] = project_id
                scene_data["script_id"] = script["id"]

                # Check if this scene already exists (by scene_number or slugline)
                if scene_data["scene_number"] in existing_by_number:
                    # Update existing scene instead of creating duplicate
                    existing_id = existing_by_number[scene_data["scene_number"]]["id"]
                    scenes_to_update.append((existing_id, scene_data))
                elif slugline in existing_sluglines:
                    # Scene with same slugline exists, skip to avoid duplicate
                    skipped_existing += 1
                    continue
                else:
                    unique_scenes.append(scene_data)

            print(f"Scene processing: {len(unique_scenes)} new, {len(scenes_to_update)} updated, {skipped_existing} skipped (already exist), {skipped_duplicate} skipped (duplicates in import)")

            # Update existing scenes
            for existing_id, scene_data in scenes_to_update:
                client.table("backlot_scenes").update(scene_data).eq("id", existing_id).execute()

            # Insert only truly new scenes
            if unique_scenes:
                client.table("backlot_scenes").insert(unique_scenes).execute()

            # Track total scenes processed (new + updated)
            total_scenes_processed = len(unique_scenes) + len(scenes_to_update)

            # Get actual total scenes count from database
            total_scenes_result = client.table("backlot_scenes").select(
                "id", count="exact"
            ).eq("project_id", project_id).execute()
            total_scenes_count = total_scenes_result.count or len(unique_scenes) + len(existing_by_number)

            # Update script's total_scenes with actual count
            client.table("backlot_scripts").update({
                "total_scenes": total_scenes_count
            }).eq("id", script["id"]).execute()

            # Update parsed_scenes for response message
            parsed_scenes = [{"id": "new"}] * total_scenes_processed  # Just for counting

        # Build response message
        text_extracted = bool(text_content)
        scenes_found = len(parsed_scenes)

        if text_extracted and scenes_found:
            message = f"Script imported ({page_count or 'unknown'} pages, {scenes_found} scenes detected). Text extracted for editor."
        elif text_extracted:
            message = f"Script imported ({page_count or 'unknown'} pages). Text extracted for editor, no scenes auto-detected."
        elif scenes_found:
            message = f"Script imported ({page_count or 'unknown'} pages, {scenes_found} scenes detected). Text extraction limited."
        else:
            message = f"Script imported ({page_count or 'unknown'} pages). Manual scene entry may be needed."

        return {
            "success": True,
            "script": script,
            "scenes_created": len(parsed_scenes),
            "scenes_parsed": len(parsed_scenes),
            "page_count": page_count,
            "text_extracted": text_extracted,
            "message": message
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error importing script: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/scripts/{script_id}")
async def get_script(
    script_id: str,
    authorization: str = Header(None)
):
    """Get a single script with scene count"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    # Convert Cognito user ID to profile ID
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    if not profile_id:
        raise HTTPException(status_code=403, detail="Profile not found")

    try:
        result = client.table("backlot_scripts").select("*").eq("id", script_id).single().execute()

        if not result.data:
            raise HTTPException(status_code=404, detail="Script not found")

        script = result.data

        # Verify access
        project_response = client.table("backlot_projects").select("owner_id").eq("id", script["project_id"]).execute()
        if not project_response.data:
            raise HTTPException(status_code=404, detail="Project not found")

        is_owner = project_response.data[0]["owner_id"] == profile_id
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", script["project_id"]).eq("user_id", profile_id).execute()
            if not member_response.data:
                raise HTTPException(status_code=403, detail="Access denied - not a project member")

        # Get scene count
        scene_result = client.table("backlot_scenes").select("id", count="exact").eq("script_id", script_id).execute()
        script["scene_count"] = scene_result.count or 0

        # Convert S3 path to signed URL for PDF viewing
        if script.get("file_url") and script["file_url"].startswith("s3://"):
            s3_uri = script["file_url"][5:]  # Remove 's3://'
            parts = s3_uri.split("/", 1)
            if len(parts) == 2:
                bucket_name, s3_path = parts
                signed_url = get_signed_url('backlot-files', s3_path, expires_in=86400)
                script["file_url"] = signed_url

        return {"script": script}
    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching script: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/scripts/{script_id}")
async def update_script(
    script_id: str,
    script: ScriptInput,
    authorization: str = Header(None)
):
    """Update a script"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get script and verify access
        existing = client.table("backlot_scripts").select("project_id").eq("id", script_id).single().execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Script not found")

        project_id = existing.data["project_id"]
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()

        is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin", "editor"]:
                raise HTTPException(status_code=403, detail="You don't have permission to edit scripts")

        update_data = {
            "title": script.title,
            "version": script.version
        }
        if script.file_url:
            update_data["file_url"] = script.file_url
        if script.format:
            update_data["format"] = script.format

        result = client.table("backlot_scripts").update(update_data).eq("id", script_id).execute()
        return {"success": True, "script": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating script: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/scripts/{script_id}")
async def delete_script(
    script_id: str,
    authorization: str = Header(None)
):
    """Delete a script and all its scenes"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    try:
        # Convert Cognito ID to profile ID
        profile_id = get_profile_id_from_cognito_id(cognito_user_id)

        # Get script and verify access
        existing = client.table("backlot_scripts").select("project_id").eq("id", script_id).single().execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Script not found")

        project_id = existing.data["project_id"]
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()

        is_owner = project_response.data[0]["owner_id"] == profile_id
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin"]:
                raise HTTPException(status_code=403, detail="Only admins can delete scripts")

        # Delete script (cascades to scenes and breakdown items)
        client.table("backlot_scripts").delete().eq("id", script_id).execute()
        return {"success": True, "message": "Script deleted"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting script: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# SCRIPT TITLE PAGE
# =====================================================

class TitlePageContactInput(BaseModel):
    """Contact information for title page"""
    name: Optional[str] = None
    company: Optional[str] = None
    address: Optional[str] = None
    phone: Optional[str] = None
    email: Optional[str] = None


class TitlePageDraftInfoInput(BaseModel):
    """Draft information for title page"""
    date: Optional[str] = None
    revision: Optional[str] = None


class TitlePageDataInput(BaseModel):
    """Input for updating title page data"""
    title: Optional[str] = None
    written_by: Optional[List[str]] = None
    based_on: Optional[str] = None
    contact: Optional[TitlePageContactInput] = None
    draft_info: Optional[TitlePageDraftInfoInput] = None
    copyright: Optional[str] = None
    additional_lines: Optional[List[str]] = None


@router.get("/scripts/{script_id}/title-page")
async def get_script_title_page(
    script_id: str,
    authorization: str = Header(None)
):
    """Get title page data for a script"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    # Convert Cognito user ID to profile ID
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    if not profile_id:
        raise HTTPException(status_code=403, detail="Profile not found")

    try:
        result = client.table("backlot_scripts").select("id, project_id, title, title_page_data").eq("id", script_id).single().execute()

        if not result.data:
            raise HTTPException(status_code=404, detail="Script not found")

        script = result.data

        # Verify access
        project_response = client.table("backlot_projects").select("owner_id").eq("id", script["project_id"]).execute()
        if not project_response.data:
            raise HTTPException(status_code=404, detail="Project not found")

        is_owner = project_response.data[0]["owner_id"] == profile_id
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", script["project_id"]).eq("user_id", profile_id).execute()
            if not member_response.data:
                raise HTTPException(status_code=403, detail="Access denied - not a project member")

        return {
            "script_id": script["id"],
            "script_title": script["title"],
            "title_page_data": script.get("title_page_data")
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching title page: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/scripts/{script_id}/title-page")
async def update_script_title_page(
    script_id: str,
    title_page_data: TitlePageDataInput,
    authorization: str = Header(None)
):
    """Update title page data for a script"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    # Convert Cognito user ID to profile ID
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    if not profile_id:
        raise HTTPException(status_code=403, detail="Profile not found")

    try:
        # Get script and verify access
        existing = client.table("backlot_scripts").select("project_id").eq("id", script_id).single().execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Script not found")

        project_id = existing.data["project_id"]
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()

        is_owner = project_response.data[0]["owner_id"] == profile_id
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin", "editor"]:
                raise HTTPException(status_code=403, detail="You don't have permission to edit scripts")

        # Convert Pydantic model to dict, removing None values
        title_page_dict = title_page_data.model_dump(exclude_none=True)

        # Convert nested models to dicts
        if "contact" in title_page_dict and title_page_dict["contact"]:
            title_page_dict["contact"] = {k: v for k, v in title_page_dict["contact"].items() if v is not None}
        if "draft_info" in title_page_dict and title_page_dict["draft_info"]:
            title_page_dict["draft_info"] = {k: v for k, v in title_page_dict["draft_info"].items() if v is not None}

        result = client.table("backlot_scripts").update({
            "title_page_data": title_page_dict if title_page_dict else None
        }).eq("id", script_id).execute()

        return {
            "success": True,
            "script_id": script_id,
            "title_page_data": title_page_dict
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating title page: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# SCRIPT VERSIONING
# =====================================================

class CreateScriptVersionInput(BaseModel):
    """Input for creating a new script version"""
    version_label: Optional[str] = None
    color_code: Optional[str] = "blue"
    revision_notes: Optional[str] = None
    carry_over_text: bool = True
    carry_over_scenes: bool = True

class UpdateScriptTextInput(BaseModel):
    """Input for updating script text content"""
    text_content: str
    create_new_version: bool = False
    version_label: Optional[str] = None
    color_code: Optional[str] = None
    revision_notes: Optional[str] = None


@router.get("/scripts/{script_id}/versions")
async def get_script_version_history(
    script_id: str,
    authorization: str = Header(None)
):
    """Get the version history for a script"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    # Convert Cognito user ID to profile ID
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    if not profile_id:
        raise HTTPException(status_code=403, detail="Profile not found")

    try:
        # Get script and verify access
        script_response = client.table("backlot_scripts").select("project_id").eq("id", script_id).single().execute()
        if not script_response.data:
            raise HTTPException(status_code=404, detail="Script not found")

        project_id = script_response.data["project_id"]

        # Verify project access
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        if not project_response.data:
            raise HTTPException(status_code=404, detail="Project not found")

        is_owner = project_response.data[0]["owner_id"] == profile_id
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id).execute()
            if not member_response.data:
                raise HTTPException(status_code=403, detail="Access denied - not a project member")

        # Use database function to get version history
        try:
            result = client.rpc("get_script_version_history", {"p_script_id": script_id}).execute()
            versions = result.data or []
        except Exception as rpc_err:
            # Fallback: find root and traverse manually
            print(f"RPC failed, using fallback: {rpc_err}")

            # Find the root script (no parent) in the chain
            current_id = script_id
            visited = set()
            while True:
                if current_id in visited:
                    break
                visited.add(current_id)
                current_script = client.table("backlot_scripts").select("id, parent_version_id").eq("id", current_id).single().execute()
                if not current_script.data or not current_script.data.get("parent_version_id"):
                    break
                current_id = current_script.data["parent_version_id"]

            root_id = current_id

            # Get all versions descending from root
            versions_result = client.table("backlot_scripts").select(
                "id, version, version_number, color_code, is_current, is_locked, revision_notes, created_at, created_by_user_id, parent_version_id"
            ).eq("project_id", project_id).order("version_number").execute()

            # Filter to only scripts in this version chain
            all_versions = versions_result.data or []
            chain_ids = {root_id}

            # Build the chain by iterating
            changed = True
            while changed:
                changed = False
                for v in all_versions:
                    if v.get("parent_version_id") in chain_ids and v["id"] not in chain_ids:
                        chain_ids.add(v["id"])
                        changed = True

            versions = [v for v in all_versions if v["id"] in chain_ids]

        return {"versions": versions}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching version history: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/scripts/{script_id}/versions")
async def create_script_version(
    script_id: str,
    input_data: CreateScriptVersionInput,
    authorization: str = Header(None)
):
    """Create a new version from an existing script"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get the source script
        source_script = client.table("backlot_scripts").select("*").eq("id", script_id).single().execute()
        if not source_script.data:
            raise HTTPException(status_code=404, detail="Script not found")

        source = source_script.data
        project_id = source["project_id"]

        # Verify edit access
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin", "editor"]:
                raise HTTPException(status_code=403, detail="You don't have permission to create script versions")

        # Calculate next version number
        current_version = source.get("version_number") or 1
        next_version = current_version + 1

        # Industry standard color code sequence
        color_sequence = ["white", "blue", "pink", "yellow", "green", "goldenrod", "buff", "salmon", "cherry", "tan", "gray", "ivory"]
        default_color = color_sequence[min(next_version - 1, len(color_sequence) - 1)]

        # Create new version
        new_script_data = {
            "project_id": project_id,
            "title": source["title"],
            "file_url": source.get("file_url"),
            "format": source.get("format"),
            "version": input_data.version_label or f"v{next_version}",
            "version_number": next_version,
            "parent_version_id": script_id,
            "color_code": input_data.color_code or default_color,
            "revision_notes": input_data.revision_notes,
            "is_current": True,
            "is_locked": False,
            "text_content": source.get("text_content") if input_data.carry_over_text else None,
            "page_count": source.get("page_count"),
            "total_scenes": source.get("total_scenes"),
            "total_pages": source.get("total_pages"),
            "parse_status": source.get("parse_status"),
            "created_by_user_id": user_id
        }

        # Mark old versions as not current
        client.table("backlot_scripts").update({"is_current": False}).eq("project_id", project_id).execute()

        # Create new version
        new_script_result = client.table("backlot_scripts").insert(new_script_data).execute()
        if not new_script_result.data:
            raise HTTPException(status_code=500, detail="Failed to create new version")

        new_script = new_script_result.data[0]

        # Optionally copy scenes to new version
        scenes_copied = 0
        if input_data.carry_over_scenes:
            source_scenes = client.table("backlot_scenes").select("*").eq("script_id", script_id).execute()
            if source_scenes.data:
                for scene in source_scenes.data:
                    new_scene_data = {
                        "project_id": project_id,
                        "script_id": new_script["id"],
                        "scene_number": scene.get("scene_number"),
                        "slugline": scene.get("slugline"),
                        "description": scene.get("description"),
                        "synopsis": scene.get("synopsis"),
                        "page_length": scene.get("page_length"),
                        "int_ext": scene.get("int_ext"),
                        "time_of_day": scene.get("time_of_day"),
                        "location_hint": scene.get("location_hint"),
                        "location_id": scene.get("location_id"),
                        "sequence": scene.get("sequence"),
                        "coverage_status": scene.get("coverage_status", "not_scheduled"),
                        "is_omitted": scene.get("is_omitted", False)
                    }
                    client.table("backlot_scenes").insert(new_scene_data).execute()
                    scenes_copied += 1

        return {
            "success": True,
            "script": new_script,
            "scenes_copied": scenes_copied,
            "message": f"Created version {new_script['version']} ({new_script['color_code']})"
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating script version: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/scripts/{script_id}/set-current")
async def set_current_script_version(
    script_id: str,
    authorization: str = Header(None)
):
    """Set a script version as the current active version"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get script and verify access
        script = client.table("backlot_scripts").select("project_id, is_locked").eq("id", script_id).single().execute()
        if not script.data:
            raise HTTPException(status_code=404, detail="Script not found")

        project_id = script.data["project_id"]

        # Verify edit access
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin", "editor"]:
                raise HTTPException(status_code=403, detail="You don't have permission to change script versions")

        # Mark all versions in this project as not current
        client.table("backlot_scripts").update({"is_current": False}).eq("project_id", project_id).execute()

        # Set this version as current
        result = client.table("backlot_scripts").update({"is_current": True}).eq("id", script_id).execute()

        return {"success": True, "script": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error setting current version: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/scripts/{script_id}/lock")
async def lock_script_version(
    script_id: str,
    authorization: str = Header(None)
):
    """Lock a script version to prevent editing"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get script and verify access
        script = client.table("backlot_scripts").select("project_id").eq("id", script_id).single().execute()
        if not script.data:
            raise HTTPException(status_code=404, detail="Script not found")

        project_id = script.data["project_id"]

        # Verify edit access (only owners/admins can lock)
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin"]:
                raise HTTPException(status_code=403, detail="Only admins can lock script versions")

        # Lock the version
        result = client.table("backlot_scripts").update({
            "is_locked": True,
            "locked_by_user_id": user_id,
            "locked_at": "now()"
        }).eq("id", script_id).execute()

        return {"success": True, "script": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error locking script: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/scripts/{script_id}/unlock")
async def unlock_script_version(
    script_id: str,
    authorization: str = Header(None)
):
    """Unlock a script version to allow editing"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get script and verify access
        script = client.table("backlot_scripts").select("project_id").eq("id", script_id).single().execute()
        if not script.data:
            raise HTTPException(status_code=404, detail="Script not found")

        project_id = script.data["project_id"]

        # Verify edit access (only owners/admins can unlock)
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin"]:
                raise HTTPException(status_code=403, detail="Only admins can unlock script versions")

        # Unlock the version
        result = client.table("backlot_scripts").update({
            "is_locked": False,
            "locked_by_user_id": None,
            "locked_at": None
        }).eq("id", script_id).execute()

        return {"success": True, "script": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error unlocking script: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/scripts/{script_id}/text")
async def update_script_text(
    script_id: str,
    input_data: UpdateScriptTextInput,
    authorization: str = Header(None)
):
    """Update the text content of a script (for the editor)"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get script and verify access
        script = client.table("backlot_scripts").select("*").eq("id", script_id).single().execute()
        if not script.data:
            raise HTTPException(status_code=404, detail="Script not found")

        script_data = script.data
        project_id = script_data["project_id"]

        # Check if locked
        if script_data.get("is_locked"):
            raise HTTPException(status_code=403, detail="This script version is locked and cannot be edited")

        # Verify edit access
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin", "editor"]:
                raise HTTPException(status_code=403, detail="You don't have permission to edit scripts")

        # Parse script text to extract scenes
        from app.utils.script_parser import parse_fountain
        parsed_result = parse_fountain(input_data.text_content or "")
        parsed_scenes = parsed_result.scenes
        scene_count = len(parsed_scenes)

        if input_data.create_new_version:
            # Create a new version with the updated text
            current_version = script_data.get("version_number") or 1
            next_version = current_version + 1

            color_sequence = ["white", "blue", "pink", "yellow", "green", "goldenrod", "buff", "salmon", "cherry", "tan", "gray", "ivory"]
            default_color = color_sequence[min(next_version - 1, len(color_sequence) - 1)]
            color_code = input_data.color_code or default_color
            version_label = input_data.version_label or f"v{next_version}"

            # Generate PDF from text content with revision color
            generated_pdf_url = None
            try:
                from app.services.screenplay_pdf_service import generate_screenplay_pdf
                from datetime import datetime
                import io

                pdf_bytes = generate_screenplay_pdf(
                    text_content=input_data.text_content or "",
                    title=script_data["title"],
                    version=version_label,
                    color_code=color_code,
                    revision_date=datetime.now().strftime("%B %d, %Y"),
                )

                # Upload PDF to S3
                s3_filename = f"{script_data['title'].replace(' ', '_')}_{version_label}_{color_code}.pdf"
                s3_path = f"scripts/{project_id}/{generate_unique_filename(s3_filename)}"

                upload_file(
                    bucket=BACKLOT_FILES_BUCKET,
                    path=s3_path,
                    file=io.BytesIO(pdf_bytes),
                    content_type="application/pdf"
                )

                generated_pdf_url = f"s3://{BACKLOT_FILES_BUCKET}/{s3_path}"
                print(f"Generated revision PDF: {generated_pdf_url}")
            except Exception as pdf_error:
                print(f"Warning: Failed to generate revision PDF: {pdf_error}")
                # Continue without PDF - not a fatal error

            new_script_data = {
                "project_id": project_id,
                "title": script_data["title"],
                "file_url": generated_pdf_url or script_data.get("file_url"),
                "format": "pdf" if generated_pdf_url else script_data.get("format"),
                "version": version_label,
                "version_number": next_version,
                "parent_version_id": script_id,
                "color_code": color_code,
                "revision_notes": input_data.revision_notes,
                "is_current": True,
                "is_locked": False,
                "text_content": input_data.text_content,
                "page_count": script_data.get("page_count"),
                "total_scenes": scene_count,
                "total_pages": script_data.get("total_pages"),
                "parse_status": "manual",
                "created_by_user_id": user_id
            }

            # Mark old versions as not current
            client.table("backlot_scripts").update({"is_current": False}).eq("project_id", project_id).execute()

            # Create new version
            result = client.table("backlot_scripts").insert(new_script_data).execute()
            new_script_id = result.data[0]["id"] if result.data else None

            # Copy highlights from the old script to the new script
            highlights_copied = 0
            if new_script_id:
                old_highlights = client.table("backlot_script_highlight_breakdowns").select(
                    "page_number, rect_x, rect_y, rect_width, rect_height, highlighted_text, suggested_label, category, color, status, breakdown_item_id"
                ).eq("script_id", script_id).execute()

                if old_highlights.data:
                    new_highlights = []
                    for h in old_highlights.data:
                        new_highlights.append({
                            "script_id": new_script_id,
                            "page_number": h.get("page_number"),
                            "rect_x": h.get("rect_x"),
                            "rect_y": h.get("rect_y"),
                            "rect_width": h.get("rect_width"),
                            "rect_height": h.get("rect_height"),
                            "highlighted_text": h.get("highlighted_text"),
                            "suggested_label": h.get("suggested_label"),
                            "category": h.get("category"),
                            "color": h.get("color"),
                            "status": h.get("status"),
                            "breakdown_item_id": h.get("breakdown_item_id"),
                        })
                    if new_highlights:
                        client.table("backlot_script_highlight_breakdowns").insert(new_highlights).execute()
                        highlights_copied = len(new_highlights)

            # Sync scenes to the project from the parsed script
            if new_script_id and parsed_scenes:
                await sync_scenes_from_script(client, project_id, new_script_id, parsed_scenes)

            return {
                "success": True,
                "script": result.data[0] if result.data else None,
                "new_version_created": True,
                "scenes_synced": scene_count,
                "highlights_copied": highlights_copied,
                "message": f"Created new version {new_script_data['version']} with {scene_count} scenes and {highlights_copied} highlights"
            }
        else:
            # Update text in place
            result = client.table("backlot_scripts").update({
                "text_content": input_data.text_content,
                "total_scenes": scene_count
            }).eq("id", script_id).execute()

            # Sync scenes to the project from the parsed script
            if parsed_scenes:
                await sync_scenes_from_script(client, project_id, script_id, parsed_scenes)

            return {
                "success": True,
                "script": result.data[0] if result.data else None,
                "new_version_created": False,
                "scenes_synced": scene_count,
                "message": f"Script text updated with {scene_count} scenes"
            }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating script text: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/scripts/{script_id}/extract-text")
async def extract_text_from_script_pdf(
    script_id: str,
    force: bool = False,
    authorization: str = Header(None)
):
    """Extract text content from a script's PDF file for editing.

    Args:
        force: If True, re-extract even if text_content already exists
    """
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    db_client = get_client()

    try:
        # Get script and verify access
        script = db_client.table("backlot_scripts").select("*").eq("id", script_id).single().execute()
        if not script.data:
            raise HTTPException(status_code=404, detail="Script not found")

        script_data = script.data
        project_id = script_data["project_id"]

        # Verify project edit access
        project_response = db_client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        if not project_response.data:
            raise HTTPException(status_code=404, detail="Project not found")

        is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)
        if not is_owner:
            member_response = db_client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["admin", "editor"]:
                raise HTTPException(status_code=403, detail="Edit access required")

        # Check if script has a file URL
        file_url = script_data.get("file_url")
        if not file_url:
            raise HTTPException(status_code=400, detail="Script has no PDF file to extract from")

        # Check if already has text content (unless force is True)
        if script_data.get("text_content") and not force:
            return {
                "success": True,
                "text_content": script_data["text_content"],
                "already_extracted": True,
                "message": "Script already has text content. Use force=true to re-extract."
            }

        # Get signed URL if it's an S3 path
        download_url = file_url
        if file_url.startswith("s3://"):
            s3_uri = file_url[5:]  # Remove 's3://'
            parts = s3_uri.split("/", 1)
            if len(parts) == 2:
                bucket_name, s3_path = parts
                download_url = get_signed_url('backlot-files', s3_path, expires_in=300)

        # Download the PDF from storage
        import httpx

        print(f"extract-text: Downloading PDF from {download_url[:100]}...")
        async with httpx.AsyncClient(timeout=60.0) as http_client:
            response = await http_client.get(download_url)
            if response.status_code != 200:
                raise HTTPException(status_code=500, detail=f"Failed to download script PDF: {response.status_code}")
            content = response.content
            print(f"extract-text: Downloaded {len(content)} bytes")

        # Use pdftotext directly for raw text extraction (preserves all content)
        # The heavy formatting in parse_script_file loses ~10% of characters
        try:
            from app.utils.script_parser import extract_pdf_with_pdftotext
            import subprocess
            import tempfile
            import os

            print(f"extract-text: Using pdftotext for raw extraction...")

            # Try pdftotext first (best layout preservation, keeps all content)
            try:
                raw_text, page_count = extract_pdf_with_pdftotext(content)

                # Split by form feed to get individual pages
                pages = raw_text.split('\f')
                print(f"extract-text: pdftotext extracted {page_count} pages ({len(pages)} page blocks), {len(raw_text)} raw chars")

                # Skip the first page (title page) if there are multiple pages
                if len(pages) > 1:
                    # Join pages starting from page 2 (index 1)
                    text_content = '\n\n'.join(pages[1:])
                    print(f"extract-text: Skipped title page, kept {len(pages)-1} pages, {len(text_content)} chars")
                else:
                    text_content = raw_text.replace('\f', '\n\n')
                    print(f"extract-text: Single page, keeping all {len(text_content)} chars")

            except FileNotFoundError:
                print(f"extract-text: pdftotext not available, falling back to pypdf")
                raise ImportError("pdftotext not installed")

            if not text_content.strip():
                raise HTTPException(status_code=400, detail="Could not extract text from PDF. The PDF may be image-based.")

        except ImportError as ie:
            print(f"extract-text: pdftotext not available: {ie}, falling back to pypdf")
            # Fallback to basic pypdf extraction
            from pypdf import PdfReader
            import io

            pdf_reader = PdfReader(io.BytesIO(content))
            page_count = len(pdf_reader.pages)
            extracted_pages = []

            # Skip first page (title page), start from index 1
            for i, page in enumerate(pdf_reader.pages):
                if i == 0:  # Skip title page
                    continue
                page_text = page.extract_text() or ""
                if page_text.strip():
                    extracted_pages.append(page_text)

            text_content = "\n\n".join(extracted_pages)
            print(f"extract-text: pypdf extracted {page_count} pages (skipped title page), {len(text_content)} chars")

            if not text_content.strip():
                raise HTTPException(status_code=400, detail="Could not extract text from PDF. The PDF may be image-based.")

        except Exception as pdf_err:
            import traceback
            print(f"extract-text: PDF extraction error: {pdf_err}")
            print(f"extract-text: Traceback: {traceback.format_exc()}")
            raise HTTPException(status_code=500, detail=f"Failed to extract text from PDF: {str(pdf_err)}")

        # Update the script with extracted text
        result = db_client.table("backlot_scripts").update({
            "text_content": text_content,
            "total_pages": page_count
        }).eq("id", script_id).execute()

        print(f"extract-text: Updated script {script_id} with {len(text_content)} chars")

        return {
            "success": True,
            "text_content": text_content,
            "page_count": page_count,
            "already_extracted": False,
            "message": f"Successfully extracted text from {page_count} pages ({len(text_content)} characters)"
        }

    except HTTPException:
        raise
    except Exception as e:
        import traceback
        print(f"Error extracting text from script: {e}")
        print(f"Traceback: {traceback.format_exc()}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# SCENES CRUD
# =====================================================

@router.get("/projects/{project_id}/scenes")
async def get_project_scenes(
    project_id: str,
    script_id: str = None,
    include_breakdown: bool = False,
    authorization: str = Header(None)
):
    """Get all scenes for a project, optionally filtered by script"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    # Convert Cognito user ID to profile ID
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    if not profile_id:
        raise HTTPException(status_code=403, detail="Profile not found")

    # Verify project access
    project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    is_owner = project_response.data[0]["owner_id"] == profile_id
    if not is_owner:
        member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id).execute()
        if not member_response.data:
            raise HTTPException(status_code=403, detail="Access denied - not a project member")

    try:
        query = client.table("backlot_scenes").select("*").eq("project_id", project_id).order("sequence")

        if script_id:
            query = query.eq("script_id", script_id)

        result = query.execute()
        scenes = result.data or []

        # Compute coverage_status from boolean fields for each scene
        for scene in scenes:
            is_shot = scene.get("is_shot", False)
            needs_pickup = scene.get("needs_pickup", False)
            is_scheduled = scene.get("is_scheduled", False)

            if is_shot:
                scene["coverage_status"] = "shot"
            elif needs_pickup:
                scene["coverage_status"] = "needs_pickup"
            elif is_scheduled:
                scene["coverage_status"] = "scheduled"
            else:
                scene["coverage_status"] = "not_scheduled"

        # Debug: Log scene count and status distribution
        status_counts = {}
        for s in scenes:
            status = s.get("coverage_status", "unknown")
            status_counts[status] = status_counts.get(status, 0) + 1
        print(f"Scenes endpoint: {len(scenes)} scenes, status distribution: {status_counts}")

        # Optionally include breakdown summary for each scene
        if include_breakdown and scenes:
            for scene in scenes:
                breakdown_result = client.table("backlot_scene_breakdown_items").select("type, label").eq("scene_id", scene["id"]).execute()

                # Group by type
                breakdown_summary = {}
                for item in breakdown_result.data or []:
                    item_type = item["type"]
                    if item_type not in breakdown_summary:
                        breakdown_summary[item_type] = []
                    breakdown_summary[item_type].append(item["label"])

                scene["breakdown_summary"] = breakdown_summary

        return {"scenes": scenes}

    except Exception as e:
        print(f"Error fetching scenes: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/scenes")
async def create_scene(
    project_id: str,
    scene: SceneInput,
    authorization: str = Header(None)
):
    """Create a new scene"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    # Verify project edit access
    project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)
    if not is_owner:
        member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
        if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin", "editor"]:
            raise HTTPException(status_code=403, detail="You don't have permission to create scenes")

    try:
        # Get next sequence number
        seq_result = client.table("backlot_scenes").select("sequence").eq("project_id", project_id).order("sequence", desc=True).limit(1).execute()
        next_sequence = (seq_result.data[0]["sequence"] + 1) if seq_result.data else 1

        scene_data = {
            "project_id": project_id,
            "scene_number": scene.scene_number,
            "slugline": scene.slugline,
            "description": scene.description,
            "page_length": scene.page_length or 0,
            "page_start": scene.page_start,
            "page_end": scene.page_end,
            "location_hint": scene.location_hint,
            "int_ext": scene.int_ext,
            "time_of_day": scene.time_of_day,
            "location_id": scene.location_id,
            "director_notes": scene.director_notes,
            "ad_notes": scene.ad_notes,
            "sequence": next_sequence
        }

        result = client.table("backlot_scenes").insert(scene_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create scene")

        return {"success": True, "scene": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating scene: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/scenes/{scene_id}")
async def get_scene(
    scene_id: str,
    include_breakdown: bool = True,
    authorization: str = Header(None)
):
    """Get a single scene with optional breakdown items"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        result = client.table("backlot_scenes").select("*").eq("id", scene_id).single().execute()

        if not result.data:
            raise HTTPException(status_code=404, detail="Scene not found")

        scene = result.data

        # Verify access
        project_response = client.table("backlot_projects").select("owner_id").eq("id", scene["project_id"]).execute()
        if not project_response.data:
            raise HTTPException(status_code=404, detail="Project not found")

        is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", scene["project_id"]).eq("user_id", user_id).execute()
            if not member_response.data:
                raise HTTPException(status_code=403, detail="Access denied - not a project member")

        # Get breakdown items
        if include_breakdown:
            breakdown_result = client.table("backlot_scene_breakdown_items").select("*").eq("scene_id", scene_id).order("type").execute()
            scene["breakdown_items"] = breakdown_result.data or []

        # Get linked location if any
        if scene.get("location_id"):
            loc_result = client.table("backlot_locations").select("id, name, address, city, state").eq("id", scene["location_id"]).execute()
            scene["location"] = loc_result.data[0] if loc_result.data else None

        return {"scene": scene}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching scene: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/scenes/{scene_id}")
async def update_scene(
    scene_id: str,
    scene: SceneInput,
    authorization: str = Header(None)
):
    """Update a scene"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    # Convert Cognito ID to profile ID for permission checks
    profile_id = get_profile_id_from_cognito_id(cognito_user_id) or cognito_user_id

    try:
        # Get scene and verify access
        existing = client.table("backlot_scenes").select("project_id").eq("id", scene_id).single().execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Scene not found")

        project_id = existing.data["project_id"]
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()

        is_owner = project_response.data[0]["owner_id"] == profile_id
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin", "editor"]:
                raise HTTPException(status_code=403, detail="You don't have permission to edit scenes")

        # Only include fields that are actually provided (not None)
        update_data = {}
        if scene.scene_number is not None:
            update_data["scene_number"] = scene.scene_number
        if scene.slugline is not None:
            update_data["slugline"] = scene.slugline
        if scene.description is not None:
            update_data["description"] = scene.description
        if scene.page_length is not None:
            update_data["page_length"] = scene.page_length
        if scene.page_start is not None:
            update_data["page_start"] = scene.page_start
        if scene.page_end is not None:
            update_data["page_end"] = scene.page_end
        if scene.int_ext is not None:
            update_data["int_ext"] = scene.int_ext
        if scene.time_of_day is not None:
            update_data["time_of_day"] = scene.time_of_day
        if scene.location_id is not None:
            update_data["location_id"] = scene.location_id
        if scene.director_notes is not None:
            update_data["director_notes"] = scene.director_notes
        if scene.ad_notes is not None:
            update_data["ad_notes"] = scene.ad_notes

        # Handle coverage_status -> convert to boolean fields
        if scene.coverage_status:
            if scene.coverage_status == "not_scheduled":
                update_data["is_scheduled"] = False
                update_data["is_shot"] = False
                update_data["needs_pickup"] = False
            elif scene.coverage_status == "scheduled":
                update_data["is_scheduled"] = True
                update_data["is_shot"] = False
                update_data["needs_pickup"] = False
            elif scene.coverage_status == "shot":
                update_data["is_shot"] = True
                update_data["needs_pickup"] = False
            elif scene.coverage_status == "needs_pickup":
                update_data["needs_pickup"] = True
                update_data["is_shot"] = False

        result = client.table("backlot_scenes").update(update_data).eq("id", scene_id).execute()
        return {"success": True, "scene": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating scene: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/scenes/{scene_id}/coverage")
async def update_scene_coverage(
    scene_id: str,
    coverage: SceneCoverageUpdate,
    authorization: str = Header(None)
):
    """Update scene coverage status (scheduled, shot, pickup needed)"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get scene and verify access
        existing = client.table("backlot_scenes").select("project_id").eq("id", scene_id).single().execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Scene not found")

        project_id = existing.data["project_id"]
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()

        is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin", "editor"]:
                raise HTTPException(status_code=403, detail="You don't have permission to update coverage")

        update_data = {}
        if coverage.is_scheduled is not None:
            update_data["is_scheduled"] = coverage.is_scheduled
        if coverage.is_shot is not None:
            update_data["is_shot"] = coverage.is_shot
        if coverage.needs_pickup is not None:
            update_data["needs_pickup"] = coverage.needs_pickup
        if coverage.pickup_notes is not None:
            update_data["pickup_notes"] = coverage.pickup_notes
        if coverage.scheduled_day_id is not None:
            update_data["scheduled_day_id"] = coverage.scheduled_day_id
        if coverage.shot_day_id is not None:
            update_data["shot_day_id"] = coverage.shot_day_id

        if update_data:
            result = client.table("backlot_scenes").update(update_data).eq("id", scene_id).execute()
            return {"success": True, "scene": result.data[0] if result.data else None}

        return {"success": True, "message": "No changes made"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating scene coverage: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/scenes/reorder")
async def reorder_scenes(
    project_id: str,
    scene_ids: List[str] = Body(...),
    authorization: str = Header(None)
):
    """Reorder scenes by providing new sequence"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    # Verify project edit access
    project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)
    if not is_owner:
        member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
        if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin", "editor"]:
            raise HTTPException(status_code=403, detail="You don't have permission to reorder scenes")

    try:
        for idx, scene_id in enumerate(scene_ids):
            client.table("backlot_scenes").update({"sequence": idx + 1}).eq("id", scene_id).eq("project_id", project_id).execute()

        return {"success": True, "message": f"Reordered {len(scene_ids)} scenes"}

    except Exception as e:
        print(f"Error reordering scenes: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/scenes/{scene_id}")
async def delete_scene(
    scene_id: str,
    authorization: str = Header(None)
):
    """Delete a scene and its breakdown items"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get scene and verify access
        existing = client.table("backlot_scenes").select("project_id").eq("id", scene_id).single().execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Scene not found")

        project_id = existing.data["project_id"]
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()

        is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin", "editor"]:
                raise HTTPException(status_code=403, detail="You don't have permission to delete scenes")

        # Delete scene (cascades to breakdown items)
        client.table("backlot_scenes").delete().eq("id", scene_id).execute()
        return {"success": True, "message": "Scene deleted"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting scene: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/scenes/recalculate-page-lengths")
async def recalculate_scene_page_lengths(
    project_id: str,
    authorization: str = Header(None)
):
    """
    Recalculate page_length for all scenes in a project based on page_start values.

    This is useful for scenes that were imported before page_length calculation was added.
    Scene N's length = Scene N+1's page_start - Scene N's page_start
    """
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    if not profile_id:
        raise HTTPException(status_code=403, detail="Profile not found")

    client = get_client()

    try:
        # Verify project access
        await verify_project_access(client, project_id, profile_id, require_edit=True)

        # Get all scenes for the project, ordered by page_start and sequence
        scenes_result = client.table("backlot_scenes").select(
            "id, scene_number, page_start, page_length, sequence"
        ).eq("project_id", project_id).order("page_start", nullsfirst=False).order("sequence").execute()

        scenes = scenes_result.data or []
        if not scenes:
            return {"success": True, "message": "No scenes found", "updated": 0}

        # Calculate page_length from sequential page_start values
        updated_count = 0
        for i, scene in enumerate(scenes):
            if scene.get("page_start") is not None:
                # Get next scene's page_start to calculate length
                if i + 1 < len(scenes) and scenes[i + 1].get("page_start") is not None:
                    next_page_start = scenes[i + 1]["page_start"]
                    calculated_length = float(next_page_start - scene["page_start"])
                    new_page_length = max(0.125, calculated_length)  # Minimum 1/8 page
                else:
                    # Last scene - estimate 1 page if no next scene info
                    new_page_length = 1.0
            else:
                new_page_length = 1.0  # Default if no page_start info

            # Only update if page_length is null/0 or different from calculated
            current_page_length = scene.get("page_length")
            if current_page_length is None or current_page_length == 0 or abs(current_page_length - new_page_length) > 0.01:
                client.table("backlot_scenes").update({
                    "page_length": new_page_length
                }).eq("id", scene["id"]).execute()
                updated_count += 1

        return {
            "success": True,
            "message": f"Recalculated page lengths for {updated_count} scenes",
            "updated": updated_count,
            "total_scenes": len(scenes)
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error recalculating scene page lengths: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# BREAKDOWN ITEMS CRUD
# =====================================================

@router.get("/scenes/{scene_id}/breakdown")
async def get_scene_breakdown(
    scene_id: str,
    authorization: str = Header(None)
):
    """Get all breakdown items for a scene"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Verify access via scene
        scene = client.table("backlot_scenes").select("project_id").eq("id", scene_id).single().execute()
        if not scene.data:
            raise HTTPException(status_code=404, detail="Scene not found")

        project_response = client.table("backlot_projects").select("owner_id").eq("id", scene.data["project_id"]).execute()
        is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", scene.data["project_id"]).eq("user_id", user_id).execute()
            if not member_response.data:
                raise HTTPException(status_code=403, detail="Access denied - not a project member")

        result = client.table("backlot_scene_breakdown_items").select("*").eq("scene_id", scene_id).order("type").execute()

        # Group by type
        grouped = {}
        for item in result.data or []:
            item_type = item["type"]
            if item_type not in grouped:
                grouped[item_type] = []
            grouped[item_type].append(item)

        return {"breakdown_items": result.data or [], "grouped": grouped}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching breakdown items: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/scenes/{scene_id}/breakdown")
async def create_breakdown_item(
    scene_id: str,
    item: BreakdownItemInput,
    authorization: str = Header(None)
):
    """Create a breakdown item for a scene"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Verify access via scene
        scene = client.table("backlot_scenes").select("project_id").eq("id", scene_id).single().execute()
        if not scene.data:
            raise HTTPException(status_code=404, detail="Scene not found")

        project_id = scene.data["project_id"]
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()

        is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin", "editor"]:
                raise HTTPException(status_code=403, detail="You don't have permission to add breakdown items")

        item_data = {
            "scene_id": scene_id,
            "type": item.type,
            "label": item.label,
            "quantity": item.quantity or 1,
            "notes": item.notes,
            "linked_entity_id": item.linked_entity_id,
            "linked_entity_type": item.linked_entity_type,
            "department": item.department,
            "stripboard_day": item.stripboard_day
        }

        result = client.table("backlot_scene_breakdown_items").insert(item_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create breakdown item")

        return {"success": True, "item": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating breakdown item: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/breakdown-items/{item_id}")
async def update_breakdown_item(
    item_id: str,
    item: BreakdownItemInput,
    authorization: str = Header(None)
):
    """Update a breakdown item"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get item and verify access
        existing = client.table("backlot_scene_breakdown_items").select("scene_id").eq("id", item_id).single().execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Breakdown item not found")

        scene = client.table("backlot_scenes").select("project_id").eq("id", existing.data["scene_id"]).single().execute()
        project_id = scene.data["project_id"]

        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin", "editor"]:
                raise HTTPException(status_code=403, detail="You don't have permission to edit breakdown items")

        update_data = {
            "type": item.type,
            "label": item.label,
            "quantity": item.quantity,
            "notes": item.notes,
            "linked_entity_id": item.linked_entity_id,
            "linked_entity_type": item.linked_entity_type,
            "department": item.department,
            "stripboard_day": item.stripboard_day
        }

        # If scene_id is provided, verify access to new scene and update
        if item.scene_id:
            # Verify the new scene belongs to the same project
            new_scene = client.table("backlot_scenes").select("project_id").eq("id", item.scene_id).single().execute()
            if not new_scene.data:
                raise HTTPException(status_code=404, detail="Target scene not found")
            if new_scene.data["project_id"] != project_id:
                raise HTTPException(status_code=403, detail="Cannot move item to a scene in a different project")
            update_data["scene_id"] = item.scene_id

        result = client.table("backlot_scene_breakdown_items").update(update_data).eq("id", item_id).execute()
        return {"success": True, "item": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating breakdown item: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/breakdown-items/{item_id}")
async def delete_breakdown_item(
    item_id: str,
    authorization: str = Header(None)
):
    """Delete a breakdown item"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get item and verify access
        existing = client.table("backlot_scene_breakdown_items").select("scene_id").eq("id", item_id).single().execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Breakdown item not found")

        scene = client.table("backlot_scenes").select("project_id").eq("id", existing.data["scene_id"]).single().execute()
        project_id = scene.data["project_id"]

        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin", "editor"]:
                raise HTTPException(status_code=403, detail="You don't have permission to delete breakdown items")

        # Delete any highlights that are linked to this breakdown item
        client.table("backlot_script_highlight_breakdowns").delete().eq("breakdown_item_id", item_id).execute()

        # Delete the breakdown item
        client.table("backlot_scene_breakdown_items").delete().eq("id", item_id).execute()
        return {"success": True, "message": "Breakdown item deleted"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting breakdown item: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# SCENE COVERAGE & DASHBOARD
# =====================================================

@router.get("/projects/{project_id}/script/coverage")
async def get_project_coverage(
    project_id: str,
    authorization: str = Header(None)
):
    """Get scene coverage statistics for a project"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    # Verify project access
    project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)
    if not is_owner:
        member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
        if not member_response.data:
            raise HTTPException(status_code=403, detail="Access denied - not a project member")

    try:
        # Get all scenes
        scenes = client.table("backlot_scenes").select("id, scene_number, slugline, page_length, is_scheduled, is_shot, needs_pickup").eq("project_id", project_id).execute()

        all_scenes = scenes.data or []

        total_scenes = len(all_scenes)
        total_pages = sum(s.get("page_length", 0) or 0 for s in all_scenes)

        scheduled = [s for s in all_scenes if s.get("is_scheduled")]
        shot = [s for s in all_scenes if s.get("is_shot")]
        pickup = [s for s in all_scenes if s.get("needs_pickup")]
        remaining = [s for s in all_scenes if not s.get("is_shot") and not s.get("needs_pickup")]

        return {
            "coverage": {
                "total_scenes": total_scenes,
                "total_pages": float(total_pages),
                "scenes_scheduled": len(scheduled),
                "pages_scheduled": sum(s.get("page_length", 0) or 0 for s in scheduled),
                "scenes_shot": len(shot),
                "pages_shot": sum(s.get("page_length", 0) or 0 for s in shot),
                "scenes_pickup": len(pickup),
                "pages_pickup": sum(s.get("page_length", 0) or 0 for s in pickup),
                "scenes_remaining": len(remaining),
                "pages_remaining": sum(s.get("page_length", 0) or 0 for s in remaining),
                "percent_complete": round((len(shot) / total_scenes * 100) if total_scenes > 0 else 0, 1)
            }
        }

    except Exception as e:
        print(f"Error fetching coverage: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/script/location-needs")
async def get_location_needs(
    project_id: str,
    authorization: str = Header(None)
):
    """Get location needs grouped by location hint"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    # Convert Cognito user ID to profile ID
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    if not profile_id:
        raise HTTPException(status_code=403, detail="Profile not found")

    # Verify project access
    project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    is_owner = project_response.data[0]["owner_id"] == profile_id
    if not is_owner:
        member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id).execute()
        if not member_response.data:
            raise HTTPException(status_code=403, detail="Access denied - not a project member")

    try:
        # Get all scenes with location info
        scenes = client.table("backlot_scenes").select("id, scene_number, slugline, location_hint, page_length, location_id, sequence").eq("project_id", project_id).order("sequence").execute()

        # Group by location_hint
        location_groups = {}
        for scene in scenes.data or []:
            hint = scene.get("location_hint") or "UNSPECIFIED"
            if hint not in location_groups:
                location_groups[hint] = {
                    "location_hint": hint,
                    "int_ext": scene.get("int_ext"),
                    "day_night_options": set(),
                    "scenes": [],
                    "total_pages": 0,
                    "linked_location_id": scene.get("location_id")
                }

            location_groups[hint]["scenes"].append({
                "id": scene["id"],
                "scene_number": scene["scene_number"],
                "slugline": scene.get("slugline"),
                "page_length": scene.get("page_length", 0)
            })
            location_groups[hint]["total_pages"] += scene.get("page_length", 0) or 0
            if scene.get("time_of_day"):
                location_groups[hint]["day_night_options"].add(scene["time_of_day"])

        # Convert sets to lists and add location info
        result = []
        for hint, group in location_groups.items():
            group["day_night_options"] = list(group["day_night_options"])
            group["scene_count"] = len(group["scenes"])

            # Get linked location name if any
            if group["linked_location_id"]:
                loc = client.table("backlot_locations").select("name, address, city").eq("id", group["linked_location_id"]).execute()
                if loc.data:
                    group["linked_location"] = loc.data[0]

            result.append(group)

        # Sort by scene count descending
        result.sort(key=lambda x: x["scene_count"], reverse=True)

        return {"location_needs": result}

    except Exception as e:
        print(f"Error fetching location needs: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# TASK GENERATION FROM BREAKDOWN
# =====================================================

class GenerateTasksInput(BaseModel):
    scene_ids: Optional[List[str]] = None
    item_types: Optional[List[str]] = None
    regenerate: bool = False


class ProposedTask(BaseModel):
    """A proposed task for preview before creation"""
    breakdown_item_id: str
    scene_id: str
    scene_number: str
    title: str
    description: str
    department: str
    priority: str = "medium"
    item_type: str
    item_label: str
    quantity: int = 1


class PreviewTasksResponse(BaseModel):
    success: bool
    proposed_tasks: List[ProposedTask]
    message: str


class CreateTasksFromPreviewInput(BaseModel):
    """Input for creating tasks from preview"""
    tasks: List[dict]  # List of task objects with title, description, department, priority, breakdown_item_id


@router.post("/projects/{project_id}/script/preview-tasks")
async def preview_tasks_from_breakdown(
    project_id: str,
    input_data: GenerateTasksInput = Body(default=GenerateTasksInput()),
    authorization: str = Header(None)
):
    """Preview tasks that would be generated from breakdown items (without creating them)"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    # Verify project access
    project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)
    if not is_owner:
        member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
        if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin", "editor"]:
            raise HTTPException(status_code=403, detail="You don't have permission to preview tasks")

    # Map breakdown types to departments
    type_to_department = {
        "cast": "Casting",
        "background": "Casting",
        "stunt": "Stunts",
        "location": "Locations",
        "prop": "Art/Props",
        "set_dressing": "Art/Set Dec",
        "wardrobe": "Wardrobe",
        "makeup": "Makeup/Hair",
        "sfx": "SFX",
        "vfx": "VFX",
        "vehicle": "Transportation",
        "animal": "Animals",
        "greenery": "Art/Greens",
        "special_equipment": "Grip/Electric",
        "sound": "Sound",
        "music": "Music"
    }

    try:
        # Get scenes (all or filtered)
        query = client.table("backlot_scenes").select("id, scene_number, slugline").eq("project_id", project_id)
        if input_data.scene_ids:
            query = query.in_("id", input_data.scene_ids)
        scenes = query.execute()

        if not scenes.data:
            return {"success": True, "proposed_tasks": [], "message": "No scenes found"}

        scene_map = {s["id"]: s for s in scenes.data}
        scene_id_list = list(scene_map.keys())

        # Get breakdown items
        breakdown_query = client.table("backlot_scene_breakdown_items").select("*").in_("scene_id", scene_id_list)
        if not input_data.regenerate:
            breakdown_query = breakdown_query.eq("task_generated", False)

        items = breakdown_query.execute()

        proposed_tasks = []
        for item in items.data or []:
            scene = scene_map.get(item["scene_id"])
            if not scene:
                continue

            department = type_to_department.get(item["type"], "Production")

            task_title = f"[Sc {scene['scene_number']}] {item['type'].replace('_', ' ').title()}: {item['label']}"
            if item.get("quantity", 1) > 1:
                task_title += f" (x{item['quantity']})"

            task_description = f"From breakdown: {item.get('notes', '')}".strip() or f"Breakdown item for Scene {scene['scene_number']}"

            proposed_tasks.append({
                "breakdown_item_id": item["id"],
                "scene_id": item["scene_id"],
                "scene_number": scene["scene_number"],
                "title": task_title,
                "description": task_description,
                "department": department,
                "priority": "medium",
                "item_type": item["type"],
                "item_label": item["label"],
                "quantity": item.get("quantity", 1)
            })

        return {
            "success": True,
            "proposed_tasks": proposed_tasks,
            "message": f"Found {len(proposed_tasks)} breakdown items to create tasks from"
        }

    except Exception as e:
        print(f"Error previewing tasks: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/script/create-tasks-from-preview")
async def create_tasks_from_preview(
    project_id: str,
    input_data: CreateTasksFromPreviewInput = Body(...),
    authorization: str = Header(None)
):
    """Create tasks from a preview list (user-modified tasks)"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    # Verify project access
    project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)
    if not is_owner:
        member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
        if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin", "editor"]:
            raise HTTPException(status_code=403, detail="You don't have permission to create tasks")

    try:
        tasks_created = 0
        for task in input_data.tasks:
            task_data = {
                "project_id": project_id,
                "title": task.get("title", "Untitled Task"),
                "description": task.get("description", ""),
                "status": "todo",
                "priority": task.get("priority", "medium"),
                "department": task.get("department", "Production"),
                "created_by_user_id": user_id
            }

            task_result = client.table("backlot_tasks").insert(task_data).execute()

            if task_result.data:
                # Mark breakdown item as having task generated if breakdown_item_id provided
                breakdown_item_id = task.get("breakdown_item_id")
                if breakdown_item_id:
                    client.table("backlot_scene_breakdown_items").update({
                        "task_generated": True,
                        "task_id": task_result.data[0]["id"]
                    }).eq("id", breakdown_item_id).execute()

                tasks_created += 1

        return {
            "success": True,
            "tasks_created": tasks_created,
            "message": f"Created {tasks_created} tasks"
        }

    except Exception as e:
        print(f"Error creating tasks from preview: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/script/generate-tasks")
async def generate_tasks_from_breakdown(
    project_id: str,
    input_data: GenerateTasksInput = Body(default=GenerateTasksInput()),
    authorization: str = Header(None)
):
    """Generate departmental tasks from breakdown items"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    # Verify project edit access
    project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)
    if not is_owner:
        member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
        if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin", "editor"]:
            raise HTTPException(status_code=403, detail="You don't have permission to generate tasks")

    # Map breakdown types to departments
    type_to_department = {
        "cast": "Casting",
        "background": "Casting",
        "stunt": "Stunts",
        "location": "Locations",
        "prop": "Art/Props",
        "set_dressing": "Art/Set Dec",
        "wardrobe": "Wardrobe",
        "makeup": "Makeup/Hair",
        "sfx": "SFX",
        "vfx": "VFX",
        "vehicle": "Transportation",
        "animal": "Animals",
        "greenery": "Art/Greens",
        "special_equipment": "Grip/Electric",
        "sound": "Sound",
        "music": "Music"
    }

    try:
        # Get scenes (all or filtered)
        query = client.table("backlot_scenes").select("id, scene_number, slugline").eq("project_id", project_id)
        if input_data.scene_ids:
            query = query.in_("id", input_data.scene_ids)
        scenes = query.execute()

        if not scenes.data:
            return {"success": True, "tasks_created": 0, "message": "No scenes found"}

        scene_map = {s["id"]: s for s in scenes.data}
        scene_id_list = list(scene_map.keys())

        # Get breakdown items
        breakdown_query = client.table("backlot_scene_breakdown_items").select("*").in_("scene_id", scene_id_list)
        if not input_data.regenerate:
            breakdown_query = breakdown_query.eq("task_generated", False)

        items = breakdown_query.execute()

        tasks_created = 0
        for item in items.data or []:
            scene = scene_map.get(item["scene_id"])
            if not scene:
                continue

            department = type_to_department.get(item["type"], "Production")

            task_title = f"[Sc {scene['scene_number']}] {item['type'].replace('_', ' ').title()}: {item['label']}"
            if item.get("quantity", 1) > 1:
                task_title += f" (x{item['quantity']})"

            task_data = {
                "project_id": project_id,
                "title": task_title,
                "description": f"From breakdown: {item.get('notes', '')}".strip() or f"Breakdown item for Scene {scene['scene_number']}",
                "status": "todo",
                "priority": "medium",
                "department": department,
                "created_by_user_id": user_id
            }

            task_result = client.table("backlot_tasks").insert(task_data).execute()

            if task_result.data:
                # Mark breakdown item as having task generated
                client.table("backlot_scene_breakdown_items").update({
                    "task_generated": True,
                    "task_id": task_result.data[0]["id"]
                }).eq("id", item["id"]).execute()

                tasks_created += 1

        return {
            "success": True,
            "tasks_created": tasks_created,
            "message": f"Generated {tasks_created} tasks from breakdown items"
        }

    except Exception as e:
        print(f"Error generating tasks: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# BUDGET SUGGESTIONS FROM BREAKDOWN
# =====================================================

@router.post("/projects/{project_id}/script/generate-budget-suggestions")
async def generate_budget_suggestions(
    project_id: str,
    scene_ids: List[str] = Body(None),
    authorization: str = Header(None)
):
    """Generate budget suggestions from breakdown items"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    # Verify project edit access
    project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)
    if not is_owner:
        member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
        if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin", "editor"]:
            raise HTTPException(status_code=403, detail="You don't have permission to generate budget suggestions")

    # Map breakdown types to budget suggestion types and departments
    type_mapping = {
        "prop": {"type": "prop", "department": "Art"},
        "set_dressing": {"type": "set_dressing", "department": "Art"},
        "wardrobe": {"type": "wardrobe", "department": "Wardrobe"},
        "makeup": {"type": "makeup", "department": "Makeup/Hair"},
        "sfx": {"type": "sfx", "department": "SFX"},
        "vfx": {"type": "vfx", "department": "VFX"},
        "vehicle": {"type": "vehicle", "department": "Transportation"},
        "animal": {"type": "animal", "department": "Animals"},
        "special_equipment": {"type": "equipment", "department": "Grip/Electric"},
        "background": {"type": "extra_crew", "department": "Casting"},
        "stunt": {"type": "stunt", "department": "Stunts"}
    }

    try:
        # Get scenes
        query = client.table("backlot_scenes").select("id, scene_number").eq("project_id", project_id)
        if scene_ids:
            query = query.in_("id", scene_ids)
        scenes = query.execute()

        if not scenes.data:
            return {"success": True, "suggestions_created": 0}

        scene_map = {s["id"]: s for s in scenes.data}
        scene_id_list = list(scene_map.keys())

        # Get breakdown items that map to budget items
        items = client.table("backlot_scene_breakdown_items").select("*").in_("scene_id", scene_id_list).in_("type", list(type_mapping.keys())).execute()

        suggestions_created = 0
        for item in items.data or []:
            scene = scene_map.get(item["scene_id"])
            mapping = type_mapping.get(item["type"])
            if not scene or not mapping:
                continue

            # Check if suggestion already exists
            existing = client.table("backlot_budget_suggestions").select("id").eq("breakdown_item_id", item["id"]).execute()
            if existing.data:
                continue

            suggestion_data = {
                "project_id": project_id,
                "scene_id": item["scene_id"],
                "breakdown_item_id": item["id"],
                "suggestion_type": mapping["type"],
                "department": mapping["department"],
                "description": f"Scene {scene['scene_number']}: {item['label']}" + (f" (x{item['quantity']})" if item.get("quantity", 1) > 1 else ""),
                "notes": item.get("notes"),
                "status": "pending",
                "created_by_user_id": user_id
            }

            client.table("backlot_budget_suggestions").insert(suggestion_data).execute()
            suggestions_created += 1

        return {
            "success": True,
            "suggestions_created": suggestions_created,
            "message": f"Generated {suggestions_created} budget suggestions"
        }

    except Exception as e:
        print(f"Error generating budget suggestions: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/budget-suggestions")
async def get_budget_suggestions(
    project_id: str,
    status: str = None,
    authorization: str = Header(None)
):
    """Get budget suggestions for a project"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    # Verify project access
    project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)
    if not is_owner:
        member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
        if not member_response.data:
            raise HTTPException(status_code=403, detail="Access denied - not a project member")

    try:
        query = client.table("backlot_budget_suggestions").select("*").eq("project_id", project_id).order("created_at", desc=True)
        if status:
            query = query.eq("status", status)

        result = query.execute()
        return {"suggestions": result.data or []}

    except Exception as e:
        print(f"Error fetching budget suggestions: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/budget-suggestions/{suggestion_id}")
async def update_budget_suggestion(
    suggestion_id: str,
    status: str = Body(...),
    linked_budget_line_id: str = Body(None),
    authorization: str = Header(None)
):
    """Update a budget suggestion status"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get suggestion and verify access
        existing = client.table("backlot_budget_suggestions").select("project_id").eq("id", suggestion_id).single().execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Suggestion not found")

        project_id = existing.data["project_id"]
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()

        is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin", "editor"]:
                raise HTTPException(status_code=403, detail="You don't have permission to update suggestions")

        update_data = {"status": status}
        if linked_budget_line_id:
            update_data["linked_budget_line_id"] = linked_budget_line_id

        result = client.table("backlot_budget_suggestions").update(update_data).eq("id", suggestion_id).execute()
        return {"success": True, "suggestion": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating budget suggestion: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# CALL SHEET SCENE LINKS
# =====================================================

@router.get("/call-sheets/{call_sheet_id}/linked-scenes")
async def get_call_sheet_linked_scenes(
    call_sheet_id: str,
    authorization: str = Header(None)
):
    """Get scenes linked to a call sheet"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user["id"]

    # Resolve Cognito ID to profile ID
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    if not profile_id:
        raise HTTPException(status_code=404, detail="Profile not found")

    client = get_client()

    try:
        # Verify access via call sheet
        cs = client.table("backlot_call_sheets").select("project_id").eq("id", call_sheet_id).single().execute()
        if not cs.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        project_response = client.table("backlot_projects").select("owner_id").eq("id", cs.data["project_id"]).execute()
        is_owner = str(project_response.data[0]["owner_id"]) == profile_id
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", cs.data["project_id"]).eq("user_id", profile_id).execute()
            if not member_response.data:
                raise HTTPException(status_code=403, detail="Access denied - not a project member")

        # Get linked scenes with full scene data
        links = client.table("backlot_call_sheet_scene_links").select("*").eq("call_sheet_id", call_sheet_id).order("sequence").execute()

        if not links.data:
            return {"linked_scenes": [], "total_pages": 0}

        scene_ids = [l["scene_id"] for l in links.data]
        scenes = client.table("backlot_scenes").select("*").in_("id", scene_ids).execute()
        scene_map = {s["id"]: s for s in scenes.data or []}

        result = []
        total_pages = 0
        for link in links.data:
            scene = scene_map.get(link["scene_id"])
            if scene:
                result.append({
                    **link,
                    "scene": scene
                })
                total_pages += scene.get("page_length", 0) or 0

        return {"linked_scenes": result, "total_pages": total_pages}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching linked scenes: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/call-sheets/{call_sheet_id}/linked-scenes")
async def link_scene_to_call_sheet(
    call_sheet_id: str,
    link: CallSheetSceneLinkInput,
    authorization: str = Header(None)
):
    """Link a scene to a call sheet"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user["id"]

    # Resolve Cognito ID to profile ID
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    if not profile_id:
        raise HTTPException(status_code=404, detail="Profile not found")

    client = get_client()

    try:
        # Verify access
        cs = client.table("backlot_call_sheets").select("project_id, production_day_id").eq("id", call_sheet_id).single().execute()
        if not cs.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        project_id = cs.data["project_id"]
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()

        is_owner = str(project_response.data[0]["owner_id"]) == profile_id
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin", "editor"]:
                raise HTTPException(status_code=403, detail="You don't have permission to link scenes")

        # Check if already linked
        existing = client.table("backlot_call_sheet_scene_links").select("id").eq("call_sheet_id", call_sheet_id).eq("scene_id", link.scene_id).execute()
        if existing.data:
            return {"success": True, "message": "Scene already linked", "link": existing.data[0]}

        # Get next sequence
        seq_result = client.table("backlot_call_sheet_scene_links").select("sequence").eq("call_sheet_id", call_sheet_id).order("sequence", desc=True).limit(1).execute()
        next_seq = (seq_result.data[0]["sequence"] + 1) if seq_result.data else 1

        link_data = {
            "call_sheet_id": call_sheet_id,
            "scene_id": link.scene_id,
            "sequence": link.sequence if link.sequence else next_seq,
            "estimated_time_minutes": link.estimated_time_minutes,
            "notes": link.notes
        }

        result = client.table("backlot_call_sheet_scene_links").insert(link_data).execute()

        # Mark scene as scheduled
        client.table("backlot_scenes").update({
            "is_scheduled": True,
            "scheduled_day_id": cs.data.get("production_day_id")
        }).eq("id", link.scene_id).execute()

        return {"success": True, "link": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error linking scene: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/call-sheets/{call_sheet_id}/linked-scenes/{scene_id}")
async def unlink_scene_from_call_sheet(
    call_sheet_id: str,
    scene_id: str,
    authorization: str = Header(None)
):
    """Unlink a scene from a call sheet"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user["id"]

    # Resolve Cognito ID to profile ID
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    if not profile_id:
        raise HTTPException(status_code=404, detail="Profile not found")

    client = get_client()

    try:
        # Verify access
        cs = client.table("backlot_call_sheets").select("project_id").eq("id", call_sheet_id).single().execute()
        if not cs.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        project_id = cs.data["project_id"]
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()

        is_owner = str(project_response.data[0]["owner_id"]) == profile_id
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin", "editor"]:
                raise HTTPException(status_code=403, detail="You don't have permission to unlink scenes")

        # Delete link
        client.table("backlot_call_sheet_scene_links").delete().eq("call_sheet_id", call_sheet_id).eq("scene_id", scene_id).execute()

        # Check if scene is linked to any other call sheets
        other_links = client.table("backlot_call_sheet_scene_links").select("id").eq("scene_id", scene_id).execute()
        if not other_links.data:
            # Unmark scene as scheduled
            client.table("backlot_scenes").update({
                "is_scheduled": False,
                "scheduled_day_id": None
            }).eq("id", scene_id).execute()

        return {"success": True, "message": "Scene unlinked from call sheet"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error unlinking scene: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/call-sheet-scene-links/{link_id}")
async def delete_call_sheet_scene_link(
    link_id: str,
    authorization: str = Header(None)
):
    """Delete a call sheet scene link by its ID"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get the link to find associated call sheet and scene
        link = client.table("backlot_call_sheet_scene_links").select("*").eq("id", link_id).single().execute()
        if not link.data:
            raise HTTPException(status_code=404, detail="Scene link not found")

        call_sheet_id = link.data["call_sheet_id"]
        scene_id = link.data["scene_id"]

        # Verify access via call sheet
        cs = client.table("backlot_call_sheets").select("project_id").eq("id", call_sheet_id).single().execute()
        if not cs.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        project_id = cs.data["project_id"]
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()

        is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin", "editor"]:
                raise HTTPException(status_code=403, detail="You don't have permission to delete scene links")

        # Delete link
        client.table("backlot_call_sheet_scene_links").delete().eq("id", link_id).execute()

        # Check if scene is linked to any other call sheets
        other_links = client.table("backlot_call_sheet_scene_links").select("id").eq("scene_id", scene_id).execute()
        if not other_links.data:
            # Unmark scene as scheduled
            client.table("backlot_scenes").update({
                "is_scheduled": False,
                "scheduled_day_id": None
            }).eq("id", scene_id).execute()

        return {"success": True, "message": "Scene link deleted"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting scene link: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# SCRIPT PAGE NOTES - Acrobat-style annotations
# =====================================================

class ScriptPageNoteInput(BaseModel):
    page_number: int
    position_x: Optional[float] = None
    position_y: Optional[float] = None
    note_text: str
    note_type: Optional[str] = "general"
    scene_id: Optional[str] = None

class ScriptPageNoteUpdate(BaseModel):
    note_text: Optional[str] = None
    note_type: Optional[str] = None
    position_x: Optional[float] = None
    position_y: Optional[float] = None
    scene_id: Optional[str] = None
    resolved: Optional[bool] = None


@router.get("/scripts/{script_id}/notes")
async def get_script_page_notes(
    script_id: str,
    page_number: Optional[int] = None,
    note_type: Optional[str] = None,
    resolved: Optional[bool] = None,
    authorization: str = Header(None)
):
    """Get all notes for a script, optionally filtered by page, type, or resolved status"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    try:
        # Convert Cognito ID to profile ID
        profile_id = get_profile_id_from_cognito_id(cognito_user_id)

        # Verify script access
        script_result = client.table("backlot_scripts").select("project_id").eq("id", script_id).single().execute()
        if not script_result.data:
            raise HTTPException(status_code=404, detail="Script not found")

        project_id = script_result.data["project_id"]

        # Verify project access
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        if not project_response.data:
            raise HTTPException(status_code=404, detail="Project not found")

        is_owner = project_response.data[0]["owner_id"] == profile_id
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id).execute()
            if not member_response.data:
                raise HTTPException(status_code=403, detail="Access denied - not a project member")

        # Build query - don't use relationship, just select the base columns
        query = client.table("backlot_script_page_notes").select("*").eq("script_id", script_id)

        if page_number is not None:
            query = query.eq("page_number", page_number)
        if note_type is not None:
            query = query.eq("note_type", note_type)
        if resolved is not None:
            query = query.eq("resolved", resolved)

        query = query.order("page_number").order("created_at")
        result = query.execute()

        return {"notes": result.data or []}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching script notes: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/scripts/{script_id}/notes/summary")
async def get_script_notes_summary(
    script_id: str,
    authorization: str = Header(None)
):
    """Get summary of notes per page for a script"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    try:
        # Convert Cognito ID to profile ID
        profile_id = get_profile_id_from_cognito_id(cognito_user_id)

        # Verify script access - page_count might not exist, use total_pages instead
        script_result = client.table("backlot_scripts").select("project_id, total_pages").eq("id", script_id).single().execute()
        if not script_result.data:
            raise HTTPException(status_code=404, detail="Script not found")

        project_id = script_result.data["project_id"]
        page_count = script_result.data.get("total_pages")

        # Verify project access
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        if not project_response.data:
            raise HTTPException(status_code=404, detail="Project not found")

        is_owner = project_response.data[0]["owner_id"] == profile_id
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id).execute()
            if not member_response.data:
                raise HTTPException(status_code=403, detail="Access denied - not a project member")

        # Get notes grouped by page
        notes_result = client.table("backlot_script_page_notes").select("page_number, note_type, resolved").eq("script_id", script_id).execute()

        # Build summary
        page_summary = {}
        for note in notes_result.data or []:
            pg = note["page_number"]
            if pg not in page_summary:
                page_summary[pg] = {
                    "page_number": pg,
                    "total_count": 0,
                    "unresolved_count": 0,
                    "note_types": []
                }
            page_summary[pg]["total_count"] += 1
            if not note.get("resolved"):
                page_summary[pg]["unresolved_count"] += 1
            if note["note_type"] not in page_summary[pg]["note_types"]:
                page_summary[pg]["note_types"].append(note["note_type"])

        return {
            "page_count": page_count,
            "pages_with_notes": list(page_summary.values())
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching notes summary: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/scripts/{script_id}/notes")
async def create_script_page_note(
    script_id: str,
    note: ScriptPageNoteInput,
    authorization: str = Header(None)
):
    """Create a new note on a script page"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    try:
        # Convert Cognito ID to profile ID
        profile_id = get_profile_id_from_cognito_id(cognito_user_id)

        # Verify script access
        script_result = client.table("backlot_scripts").select("project_id").eq("id", script_id).single().execute()
        if not script_result.data:
            raise HTTPException(status_code=404, detail="Script not found")

        project_id = script_result.data["project_id"]

        # Verify project membership (any member can add notes)
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        if not project_response.data:
            raise HTTPException(status_code=404, detail="Project not found")

        is_owner = project_response.data[0]["owner_id"] == profile_id
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id).execute()
            if not member_response.data:
                raise HTTPException(status_code=403, detail="Access denied - not a project member")

        # Validate note_type
        valid_types = ["general", "direction", "production", "character", "blocking", "camera", "continuity", "sound", "vfx", "prop", "wardrobe", "makeup", "location", "safety", "other"]
        if note.note_type and note.note_type not in valid_types:
            raise HTTPException(status_code=400, detail=f"Invalid note type. Must be one of: {', '.join(valid_types)}")

        # Create note
        note_data = {
            "script_id": script_id,
            "project_id": project_id,
            "page_number": note.page_number,
            "position_x": note.position_x,
            "position_y": note.position_y,
            "note_text": note.note_text,
            "note_type": note.note_type or "general",
            "scene_id": note.scene_id,
            "author_user_id": profile_id,
            "resolved": False
        }

        result = client.table("backlot_script_page_notes").insert(note_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create note")

        # Return the created note - fetch author profile separately if needed
        created_note = result.data[0]

        # Try to fetch author profile
        try:
            author_profile = client.table("profiles").select("id, full_name, avatar_url").eq("id", profile_id).single().execute()
            if author_profile.data:
                created_note["author"] = author_profile.data
        except Exception:
            created_note["author"] = None

        return {"success": True, "note": created_note}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating script note: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/scripts/{script_id}/notes/{note_id}")
async def update_script_page_note(
    script_id: str,
    note_id: str,
    note_update: ScriptPageNoteUpdate,
    authorization: str = Header(None)
):
    """Update a script page note"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    try:
        # Convert Cognito ID to profile ID
        profile_id = get_profile_id_from_cognito_id(cognito_user_id)

        # Get note
        note_result = client.table("backlot_script_page_notes").select("*").eq("id", note_id).eq("script_id", script_id).single().execute()

        if not note_result.data:
            raise HTTPException(status_code=404, detail="Note not found")

        note_data = note_result.data

        # Get project_id from script
        script_result = client.table("backlot_scripts").select("project_id").eq("id", script_id).single().execute()
        if not script_result.data:
            raise HTTPException(status_code=404, detail="Script not found")

        project_id = script_result.data["project_id"]
        is_author = note_data["author_user_id"] == profile_id

        # Check if user can edit (author or editor role)
        can_edit = is_author
        if not can_edit:
            project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
            is_owner = project_response.data[0]["owner_id"] == profile_id
            if is_owner:
                can_edit = True
            else:
                member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id).execute()
                if member_response.data and member_response.data[0]["role"] in ["owner", "admin", "editor"]:
                    can_edit = True

        if not can_edit:
            raise HTTPException(status_code=403, detail="You don't have permission to edit this note")

        # Build update data
        update_data = {}
        if note_update.note_text is not None:
            update_data["note_text"] = note_update.note_text
        if note_update.note_type is not None:
            valid_types = ["general", "direction", "production", "character", "blocking", "camera", "continuity", "sound", "vfx", "prop", "wardrobe", "makeup", "location", "safety", "other"]
            if note_update.note_type not in valid_types:
                raise HTTPException(status_code=400, detail=f"Invalid note type")
            update_data["note_type"] = note_update.note_type
        if note_update.position_x is not None:
            update_data["position_x"] = note_update.position_x
        if note_update.position_y is not None:
            update_data["position_y"] = note_update.position_y
        if note_update.scene_id is not None:
            update_data["scene_id"] = note_update.scene_id if note_update.scene_id else None
        if note_update.resolved is not None:
            update_data["resolved"] = note_update.resolved
            if note_update.resolved:
                update_data["resolved_at"] = datetime.utcnow().isoformat()
                update_data["resolved_by_user_id"] = profile_id
            else:
                update_data["resolved_at"] = None
                update_data["resolved_by_user_id"] = None

        if not update_data:
            raise HTTPException(status_code=400, detail="No update data provided")

        result = client.table("backlot_script_page_notes").update(update_data).eq("id", note_id).execute()

        # Fetch updated note
        updated_note = client.table("backlot_script_page_notes").select("*").eq("id", note_id).single().execute()
        note_data = updated_note.data

        # Try to fetch author profile separately
        if note_data and note_data.get("author_user_id"):
            try:
                author_profile = client.table("profiles").select("id, full_name, avatar_url").eq("id", note_data["author_user_id"]).single().execute()
                if author_profile.data:
                    note_data["author"] = author_profile.data
            except Exception:
                note_data["author"] = None

        return {"success": True, "note": note_data}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating script note: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/scripts/{script_id}/notes/{note_id}")
async def delete_script_page_note(
    script_id: str,
    note_id: str,
    authorization: str = Header(None)
):
    """Delete a script page note"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    try:
        # Convert Cognito ID to profile ID
        profile_id = get_profile_id_from_cognito_id(cognito_user_id)

        # Get note and verify ownership/permissions
        note_result = client.table("backlot_script_page_notes").select("*").eq("id", note_id).eq("script_id", script_id).single().execute()

        if not note_result.data:
            raise HTTPException(status_code=404, detail="Note not found")

        note_data = note_result.data

        # Fetch script to get project_id
        script_result = client.table("backlot_scripts").select("project_id").eq("id", script_id).single().execute()
        if not script_result.data:
            raise HTTPException(status_code=404, detail="Script not found")
        project_id = script_result.data["project_id"]

        is_author = note_data["author_user_id"] == profile_id

        # Check if user can delete (author or editor role)
        can_delete = is_author
        if not can_delete:
            project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
            is_owner = project_response.data[0]["owner_id"] == profile_id
            if is_owner:
                can_delete = True
            else:
                member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id).execute()
                if member_response.data and member_response.data[0]["role"] in ["owner", "admin"]:
                    can_delete = True

        if not can_delete:
            raise HTTPException(status_code=403, detail="You don't have permission to delete this note")

        # Delete note
        client.table("backlot_script_page_notes").delete().eq("id", note_id).execute()

        return {"success": True, "message": "Note deleted"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting script note: {e}")
        raise HTTPException(status_code=500, detail=str(e))


class NoteResolveInput(BaseModel):
    """Input for toggling note resolved status"""
    resolved: bool


@router.patch("/scripts/{script_id}/notes/{note_id}/resolve")
async def toggle_note_resolved(
    script_id: str,
    note_id: str,
    body: NoteResolveInput,
    authorization: str = Header(None)
):
    """Toggle the resolved status of a note"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    try:
        # Convert Cognito ID to profile ID
        profile_id = get_profile_id_from_cognito_id(cognito_user_id)

        # Get note and verify access
        note_result = client.table("backlot_script_page_notes").select("*").eq("id", note_id).eq("script_id", script_id).single().execute()

        if not note_result.data:
            raise HTTPException(status_code=404, detail="Note not found")

        # Fetch script to get project_id
        script_result = client.table("backlot_scripts").select("project_id").eq("id", script_id).single().execute()
        if not script_result.data:
            raise HTTPException(status_code=404, detail="Script not found")
        project_id = script_result.data["project_id"]

        # Any project member can resolve/unresolve
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = project_response.data[0]["owner_id"] == profile_id
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id).execute()
            if not member_response.data:
                raise HTTPException(status_code=403, detail="Access denied - not a project member")

        # Update resolved status
        update_data = {"resolved": body.resolved}
        if body.resolved:
            update_data["resolved_at"] = datetime.utcnow().isoformat()
            update_data["resolved_by_user_id"] = profile_id
        else:
            update_data["resolved_at"] = None
            update_data["resolved_by_user_id"] = None

        result = client.table("backlot_script_page_notes").update(update_data).eq("id", note_id).execute()

        return {"success": True, "resolved": body.resolved}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error toggling note resolved: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Script Highlight Endpoints (Breakdown from text selection)
# =====================================================

class ScriptHighlightInput(BaseModel):
    """Input for creating a script highlight"""
    scene_id: Optional[str] = None
    page_number: Optional[int] = None  # Optional for text-based viewer
    start_offset: int
    end_offset: int
    highlighted_text: Optional[str] = None  # The selected text
    text: Optional[str] = None  # Alias for highlighted_text (from text viewer)
    rect_x: Optional[float] = None
    rect_y: Optional[float] = None
    rect_width: Optional[float] = None
    rect_height: Optional[float] = None
    category: str  # breakdown item type
    department: Optional[str] = None  # department for filtering (auto-set based on category if not provided)
    color: Optional[str] = None
    suggested_label: Optional[str] = None
    status: Optional[str] = None  # 'pending' or 'confirmed'
    # Scene detection from text-based viewer (used to find scene_id)
    scene_number: Optional[str] = None
    scene_slugline: Optional[str] = None

    @property
    def get_highlighted_text(self) -> str:
        """Get the highlighted text from either field"""
        return self.highlighted_text or self.text or ""


# Default department mapping for breakdown types
TYPE_TO_DEPARTMENT = {
    'cast': 'cast',
    'background': 'background',
    'stunt': 'stunts',
    'location': 'locations',
    'prop': 'props',
    'set_dressing': 'props',
    'wardrobe': 'wardrobe',
    'makeup': 'makeup',
    'sfx': 'sfx',
    'vfx': 'vfx',
    'vehicle': 'props',
    'animal': 'props',
    'greenery': 'props',
    'special_equipment': 'camera',
    'sound': 'sound',
    'music': 'sound',
    'other': 'props',
}


class ScriptHighlightUpdate(BaseModel):
    """Input for updating a highlight"""
    scene_id: Optional[str] = None
    category: Optional[str] = None
    department: Optional[str] = None
    color: Optional[str] = None
    suggested_label: Optional[str] = None
    breakdown_item_id: Optional[str] = None
    status: Optional[str] = None  # pending, confirmed, rejected


@router.get("/scripts/{script_id}/highlights")
async def get_script_highlights(
    script_id: str,
    page_number: Optional[int] = None,
    scene_id: Optional[str] = None,
    category: Optional[str] = None,
    status: Optional[str] = None,
    authorization: str = Header(None)
):
    """Get highlights for a script with optional filtering"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    try:
        # Convert Cognito ID to profile ID
        profile_id = get_profile_id_from_cognito_id(cognito_user_id)

        # Verify script access
        script_result = client.table("backlot_scripts").select("project_id").eq("id", script_id).single().execute()
        if not script_result.data:
            raise HTTPException(status_code=404, detail="Script not found")

        project_id = script_result.data["project_id"]

        # Check project membership
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = project_response.data and project_response.data[0]["owner_id"] == profile_id
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id).execute()
            if not member_response.data:
                raise HTTPException(status_code=403, detail="Access denied - not a project member")

        # Build query - don't use nested relationships that don't exist
        query = client.table("backlot_script_highlight_breakdowns").select("*").eq("script_id", script_id)

        if page_number is not None:
            query = query.eq("page_number", page_number)
        if scene_id:
            query = query.eq("scene_id", scene_id)
        if category:
            query = query.eq("category", category)
        if status:
            query = query.eq("status", status)

        result = query.order("page_number").order("start_offset").execute()

        return {"highlights": result.data or []}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting script highlights: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/scripts/{script_id}/highlights/summary")
async def get_script_highlight_summary(
    script_id: str,
    authorization: str = Header(None)
):
    """Get summary of highlights by category"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    try:
        # Convert Cognito ID to profile ID
        profile_id = get_profile_id_from_cognito_id(cognito_user_id)

        # Verify script access
        script_result = client.table("backlot_scripts").select("project_id").eq("id", script_id).single().execute()
        if not script_result.data:
            raise HTTPException(status_code=404, detail="Script not found")

        project_id = script_result.data["project_id"]

        # Check project membership
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = project_response.data and project_response.data[0]["owner_id"] == profile_id
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id).execute()
            if not member_response.data:
                raise HTTPException(status_code=403, detail="Access denied - not a project member")

        # Get all highlights for this script
        result = client.table("backlot_script_highlight_breakdowns").select(
            "category, status, suggested_label"
        ).eq("script_id", script_id).execute()

        highlights = result.data or []

        # Group by category
        summary = {}
        for h in highlights:
            cat = h["category"]
            if cat not in summary:
                summary[cat] = {
                    "category": cat,
                    "total_count": 0,
                    "pending_count": 0,
                    "confirmed_count": 0,
                    "labels": set()
                }
            summary[cat]["total_count"] += 1
            if h["status"] == "pending":
                summary[cat]["pending_count"] += 1
            elif h["status"] == "confirmed":
                summary[cat]["confirmed_count"] += 1
            if h.get("suggested_label"):
                summary[cat]["labels"].add(h["suggested_label"])

        # Convert sets to lists
        for cat in summary:
            summary[cat]["labels"] = list(summary[cat]["labels"])

        return {"summary": list(summary.values())}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting highlight summary: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/scripts/{script_id}/highlights")
async def create_script_highlight(
    script_id: str,
    input: ScriptHighlightInput,
    authorization: str = Header(None)
):
    """Create a new highlight (text selection for breakdown)"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    try:
        # Convert Cognito ID to profile ID
        profile_id = get_profile_id_from_cognito_id(cognito_user_id)

        # Verify script access and get project_id
        script_result = client.table("backlot_scripts").select("project_id").eq("id", script_id).single().execute()
        if not script_result.data:
            raise HTTPException(status_code=404, detail="Script not found")

        project_id = script_result.data["project_id"]

        # Check project membership - need edit rights
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = project_response.data and project_response.data[0]["owner_id"] == profile_id
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id).execute()
            if not member_response.data:
                raise HTTPException(status_code=403, detail="Access denied - not a project member")
            role = member_response.data[0]["role"]
            if role not in ["admin", "editor", "coordinator"]:
                raise HTTPException(status_code=403, detail="Insufficient permissions to create highlights")

        # Determine default color based on category (synced with frontend BREAKDOWN_HIGHLIGHT_COLORS)
        default_colors = {
            "cast": "#FF0000",           # Red
            "background": "#00FF00",     # Green
            "stunt": "#FFA500",          # Orange
            "location": "#8B4513",       # Brown
            "prop": "#800080",           # Purple
            "set_dressing": "#00FFFF",   # Cyan
            "wardrobe": "#0000FF",       # Blue
            "makeup": "#FF69B4",         # Pink
            "sfx": "#FFFF00",            # Yellow
            "vfx": "#FF00FF",            # Magenta
            "vehicle": "#A52A2A",        # Brown
            "animal": "#32CD32",         # Lime green
            "greenery": "#228B22",       # Forest green
            "special_equipment": "#4B0082", # Indigo
            "sound": "#87CEEB",          # Sky blue
            "music": "#DA70D6",          # Orchid
            "extra": "#FFA07A",          # Light salmon
            "hair": "#D2691E",           # Chocolate
            "livestock": "#8B4513",      # Saddle brown
            "security": "#DC143C",       # Crimson
            "other": "#808080",          # Gray
        }
        color = input.color or default_colors.get(input.category, "#808080")

        # Get the highlighted text (supports both 'highlighted_text' and 'text' fields)
        highlighted_text = input.get_highlighted_text
        if not highlighted_text:
            raise HTTPException(status_code=400, detail="Missing highlighted text")

        # Determine scene_id from scene_number, page number, or mapping
        scene_id = input.scene_id
        print(f"DEBUG: Input scene_id from frontend: {scene_id}")
        print(f"DEBUG: Input page_number: {input.page_number}")
        print(f"DEBUG: Input scene_number: {input.scene_number}")
        print(f"DEBUG: Input scene_slugline: {input.scene_slugline}")

        if not scene_id and input.scene_number:
            # Try to find scene by scene_number (from text-based viewer scene detection)
            scene_by_number = client.table("backlot_scenes").select(
                "id"
            ).eq("project_id", project_id).eq("scene_number", input.scene_number).execute()

            if scene_by_number.data:
                scene_id = scene_by_number.data[0]["id"]
                print(f"DEBUG: Found scene_id from scene_number: {scene_id}")
            else:
                # Scene doesn't exist - create it automatically
                # Determine sequence: PROLOGUE gets 0, others get next available
                if input.scene_number == "PROLOGUE":
                    sequence = 0
                    slugline = input.scene_slugline or "PROLOGUE / COLD OPEN"
                else:
                    # Get next sequence number
                    max_seq_result = client.table("backlot_scenes").select(
                        "sequence"
                    ).eq("project_id", project_id).order("sequence", desc=True).limit(1).execute()
                    sequence = (max_seq_result.data[0]["sequence"] + 1) if max_seq_result.data else 1
                    slugline = input.scene_slugline or f"Scene {input.scene_number}"

                new_scene_data = {
                    "id": str(uuid.uuid4()),
                    "project_id": project_id,
                    "script_id": script_id,
                    "scene_number": input.scene_number,
                    "slugline": slugline,
                    "sequence": sequence,
                    "int_ext": None,
                    "time_of_day": None,
                    "is_omitted": False,
                    "is_shot": False,
                    "is_scheduled": False,
                    "needs_pickup": False,
                }
                new_scene_result = client.table("backlot_scenes").insert(new_scene_data).execute()
                if new_scene_result.data:
                    scene_id = new_scene_result.data[0]["id"]
                    print(f"DEBUG: Created new scene '{input.scene_number}' with id: {scene_id}")

        if not scene_id and input.page_number:
            # Try to find scene from page mapping table first
            mapping_result = client.table("backlot_scene_page_mappings").select(
                "scene_id"
            ).eq("script_id", script_id).lte("page_start", input.page_number).gte("page_end", input.page_number).execute()

            if mapping_result.data:
                scene_id = mapping_result.data[0]["scene_id"]
            elif input.page_number:
                # Fallback: find scene based on page_start or calculate from page_length
                scenes_result = client.table("backlot_scenes").select(
                    "id, page_start, page_end, page_length, sequence"
                ).eq("project_id", project_id).order("sequence").execute()

                scenes_list = scenes_result.data or []
                page_num = float(input.page_number)

                # Check if any scene has page_start set
                has_page_start = any(s.get("page_start") is not None for s in scenes_list)

                if has_page_start:
                    # Use existing page_start values
                    for i, scene in enumerate(scenes_list):
                        page_start = scene.get("page_start")
                        page_end = scene.get("page_end")

                        if page_start is None:
                            continue

                        page_start = float(page_start)

                        if page_end is not None:
                            page_end = float(page_end)
                            if page_start <= page_num <= page_end:
                                scene_id = scene["id"]
                                break
                        else:
                            if page_num >= page_start:
                                if i + 1 < len(scenes_list):
                                    next_page_start = scenes_list[i + 1].get("page_start")
                                    if next_page_start is not None and page_num < float(next_page_start):
                                        scene_id = scene["id"]
                                        break
                                else:
                                    scene_id = scene["id"]
                                    break
                else:
                    # Calculate page ranges from page_length
                    cumulative_page = 1.0
                    for i, scene in enumerate(scenes_list):
                        page_length = scene.get("page_length") or 1.0
                        try:
                            page_length = float(page_length)
                        except (ValueError, TypeError):
                            page_length = 1.0

                        scene_start = cumulative_page
                        scene_end = cumulative_page + page_length - 0.001  # Slight offset to avoid overlap

                        if scene_start <= page_num <= scene_end + 1:  # +1 for rounding
                            scene_id = scene["id"]
                            break

                        cumulative_page += page_length

        print(f"DEBUG: Final scene_id for original highlight: {scene_id}")

        highlight_id = str(uuid.uuid4())
        breakdown_item_ids = []
        label = input.suggested_label or highlighted_text

        # Get script file URL to scan for all occurrences
        script_file_result = client.table("backlot_scripts").select("file_url").eq("id", script_id).single().execute()
        script_file_url = script_file_result.data.get("file_url") if script_file_result.data else None

        # Get all scenes with their page ranges
        all_scenes_result = client.table("backlot_scenes").select(
            "id, scene_number, page_start, page_end, page_length, sequence"
        ).eq("project_id", project_id).order("sequence").execute()
        all_scenes_raw = all_scenes_result.data or []

        # Deduplicate scenes by scene_number (keep first occurrence)
        seen_scene_numbers = set()
        all_scenes = []
        for scene in all_scenes_raw:
            sn = scene.get("scene_number")
            if sn not in seen_scene_numbers:
                seen_scene_numbers.add(sn)
                all_scenes.append(scene)

        print(f"DEBUG: Raw scenes: {len(all_scenes_raw)}, after dedup: {len(all_scenes)}")

        # Check if any scene has page_start set
        scenes_have_page_start = any(s.get("page_start") is not None for s in all_scenes)

        # If no page_start values, calculate cumulative page ranges from page_length
        print(f"DEBUG: scenes_have_page_start={scenes_have_page_start}, total scenes={len(all_scenes)}")
        if not scenes_have_page_start:
            cumulative = 1.0
            for scene in all_scenes:
                page_length = scene.get("page_length") or 1.0
                try:
                    page_length = float(page_length)
                except (ValueError, TypeError):
                    page_length = 1.0
                scene["_calc_page_start"] = cumulative
                scene["_calc_page_end"] = cumulative + page_length
                print(f"DEBUG: Scene {scene.get('scene_number')}: pages {cumulative:.1f} - {cumulative + page_length:.1f}")
                cumulative += page_length
        else:
            for scene in all_scenes:
                print(f"DEBUG: Scene {scene.get('scene_number')}: page_start={scene.get('page_start')}, page_end={scene.get('page_end')}")

        # Find all pages where the highlighted text appears
        pages_with_text = set()
        print(f"DEBUG: Scanning for '{label}' in PDF at {script_file_url[:100] if script_file_url else 'None'}...")
        if script_file_url:
            try:
                # Download PDF to temp file
                pdf_response = requests.get(script_file_url, timeout=30)
                print(f"DEBUG: PDF download status: {pdf_response.status_code}, size: {len(pdf_response.content)} bytes")
                if pdf_response.status_code == 200:
                    with tempfile.NamedTemporaryFile(suffix='.pdf', delete=False) as tmp_file:
                        tmp_file.write(pdf_response.content)
                        tmp_file_path = tmp_file.name

                    # Extract text from each page and search for the highlighted text
                    reader = PdfReader(tmp_file_path)
                    print(f"DEBUG: PDF has {len(reader.pages)} pages")
                    search_text = label.lower()
                    # Create regex for word boundary matching (allows suffixes like 's, 's)
                    search_pattern = re.compile(r'\b' + re.escape(search_text) + r"(?:'?s?)?\b", re.IGNORECASE)
                    print(f"DEBUG: Searching for pattern: {search_pattern.pattern}")

                    for page_num, page in enumerate(reader.pages, start=1):
                        try:
                            page_text = page.extract_text() or ""
                            matches = search_pattern.findall(page_text)
                            if matches:
                                pages_with_text.add(page_num)
                                print(f"DEBUG: Found {len(matches)} matches on page {page_num}: {matches[:3]}")
                        except Exception as ex:
                            print(f"DEBUG: Error extracting text from page {page_num}: {ex}")

                    # Clean up temp file
                    try:
                        os.unlink(tmp_file_path)
                    except Exception:
                        pass
            except Exception as e:
                # If PDF scanning fails, fall back to just the current page
                print(f"PDF scanning failed: {e}")
                if input.page_number:
                    pages_with_text.add(input.page_number)

        # If no pages found, at least use the current page if available
        if not pages_with_text and input.page_number:
            pages_with_text.add(input.page_number)

        print(f"DEBUG: Total pages with text found: {len(pages_with_text)} - pages: {sorted(pages_with_text)}")

        # Map pages to scenes
        def get_scene_for_page(page_num: int) -> Optional[str]:
            """Find which scene a page belongs to - returns first scene on that page"""
            for i, scene in enumerate(all_scenes):
                # Use calculated page ranges if available, otherwise use stored values
                if "_calc_page_start" in scene:
                    # Using calculated ranges from page_length
                    if scene["_calc_page_start"] <= page_num < scene["_calc_page_end"] + 0.5:
                        return scene["id"]
                else:
                    # Using stored page_start values
                    page_start = scene.get("page_start")
                    if page_start is None:
                        continue
                    page_start = float(page_start)

                    # If this scene starts on or before current page, it's a candidate
                    if page_start <= page_num:
                        # Find next scene that starts on a DIFFERENT page
                        next_different_page_start = None
                        for j in range(i + 1, len(all_scenes)):
                            next_ps = all_scenes[j].get("page_start")
                            if next_ps is not None:
                                next_ps = float(next_ps)
                                if next_ps > page_start:
                                    next_different_page_start = next_ps
                                    break

                        # Check if current page is before the next different page starts
                        if next_different_page_start is None or page_num < next_different_page_start:
                            return scene["id"]
            return None

        # Get all scenes where the text appears (allow multiple breakdown items per scene)
        # IMPORTANT: For the original page, use the user-selected scene_id, not PDF scanning
        scenes_with_text = []
        original_page = input.page_number

        for page_num in sorted(pages_with_text):
            if page_num == original_page:
                # For the original highlight page, use the user-selected scene_id
                scene_for_page = scene_id  # This is the user-selected scene
                scene_name = None
                for s in all_scenes:
                    if s["id"] == scene_for_page:
                        scene_name = s.get("scene_number")
                        break
                print(f"DEBUG: Page {page_num} (ORIGINAL) -> Using user-selected Scene {scene_name} (id: {scene_for_page})")
            else:
                # For other pages, use PDF scanning to determine the scene
                scene_for_page = get_scene_for_page(page_num)
                scene_name = None
                if scene_for_page:
                    for s in all_scenes:
                        if s["id"] == scene_for_page:
                            scene_name = s.get("scene_number")
                            break
                print(f"DEBUG: Page {page_num} -> Scene {scene_name} (id: {scene_for_page})")

            if scene_for_page:
                scenes_with_text.append({"id": scene_for_page, "page": page_num, "is_original": page_num == original_page})

        print(f"DEBUG: Creating breakdown items for {len(scenes_with_text)} scene instances")

        # Create breakdown items for each scene where the text was found
        # Put the original page's breakdown item FIRST so it gets linked to the highlight
        scenes_with_text.sort(key=lambda x: (0 if x.get("is_original") else 1, x["page"]))

        for scene_info in scenes_with_text:
            breakdown_item_data = {
                "id": str(uuid.uuid4()),
                "scene_id": scene_info["id"],
                "type": input.category,
                "label": label,
                "quantity": 1,
                "notes": f"Found on page {scene_info['page']}" + (" (original highlight)" if scene_info.get("is_original") else ""),
                "created_at": datetime.utcnow().isoformat(),
                "updated_at": datetime.utcnow().isoformat(),
            }
            breakdown_result = client.table("backlot_scene_breakdown_items").insert(breakdown_item_data).execute()
            if breakdown_result.data:
                breakdown_item_ids.append(breakdown_result.data[0]["id"])

        # Use the first breakdown item id for the highlight link
        breakdown_item_id = breakdown_item_ids[0] if breakdown_item_ids else None

        # Auto-set department based on category if not provided
        department = input.department or TYPE_TO_DEPARTMENT.get(input.category, 'props')

        highlight_data = {
            "id": highlight_id,
            "script_id": script_id,
            "scene_id": scene_id,
            "page_number": input.page_number,  # May be None for text-based viewer
            "start_offset": input.start_offset,
            "end_offset": input.end_offset,
            "highlighted_text": highlighted_text,
            "rect_x": input.rect_x,
            "rect_y": input.rect_y,
            "rect_width": input.rect_width,
            "rect_height": input.rect_height,
            "category": input.category,
            "department": department,
            "color": color,
            "suggested_label": label,
            "breakdown_item_id": breakdown_item_id,
            "status": input.status if input.status else ("confirmed" if breakdown_item_id else "pending"),
            "created_by_user_id": profile_id,
            "created_at": datetime.utcnow().isoformat(),
            "updated_at": datetime.utcnow().isoformat(),
        }

        result = client.table("backlot_script_highlight_breakdowns").insert(highlight_data).execute()

        return {
            "success": True,
            "highlight": result.data[0] if result.data else highlight_data,
            "breakdown_item_ids": breakdown_item_ids,
            "scenes_added": len(scenes_with_text),
            "scene_id": scene_id
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating script highlight: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/scripts/{script_id}/highlights/{highlight_id}")
async def update_script_highlight(
    script_id: str,
    highlight_id: str,
    input: ScriptHighlightUpdate,
    authorization: str = Header(None)
):
    """Update a highlight"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    try:
        # Convert Cognito ID to profile ID
        profile_id = get_profile_id_from_cognito_id(cognito_user_id)

        # Verify highlight exists
        highlight_result = client.table("backlot_script_highlight_breakdowns").select(
            "id, script_id, category, scene_id, suggested_label, breakdown_item_id"
        ).eq("id", highlight_id).eq("script_id", script_id).single().execute()

        if not highlight_result.data:
            raise HTTPException(status_code=404, detail="Highlight not found")

        # Get project_id from script
        script_result = client.table("backlot_scripts").select("project_id").eq("id", script_id).single().execute()
        if not script_result.data:
            raise HTTPException(status_code=404, detail="Script not found")

        project_id = script_result.data["project_id"]

        # Check project membership
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = project_response.data and project_response.data[0]["owner_id"] == profile_id
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id).execute()
            if not member_response.data:
                raise HTTPException(status_code=403, detail="Access denied - not a project member")
            role = member_response.data[0]["role"]
            if role not in ["admin", "editor", "coordinator"]:
                raise HTTPException(status_code=403, detail="Insufficient permissions")

        # Build update data
        update_data = {"updated_at": datetime.utcnow().isoformat()}
        if input.scene_id is not None:
            # Convert empty string to None for proper null handling
            update_data["scene_id"] = input.scene_id if input.scene_id else None
        if input.category is not None:
            update_data["category"] = input.category
            # Auto-update department if category changes and no explicit department provided
            if input.department is None:
                update_data["department"] = TYPE_TO_DEPARTMENT.get(input.category, 'props')
        if input.department is not None:
            update_data["department"] = input.department
        if input.color is not None:
            update_data["color"] = input.color
        if input.suggested_label is not None:
            update_data["suggested_label"] = input.suggested_label
        if input.breakdown_item_id is not None:
            update_data["breakdown_item_id"] = input.breakdown_item_id
        if input.status is not None:
            update_data["status"] = input.status

        result = client.table("backlot_script_highlight_breakdowns").update(update_data).eq("id", highlight_id).execute()

        # If category changed and there's a linked breakdown item, update it too
        highlight_data = highlight_result.data
        breakdown_item_id = highlight_data.get("breakdown_item_id")
        if input.category is not None and breakdown_item_id:
            breakdown_update = {"type": input.category, "updated_at": datetime.utcnow().isoformat()}
            # Also update department on breakdown item if provided
            if input.department is not None:
                breakdown_update["department"] = input.department
            elif input.category is not None:
                breakdown_update["department"] = TYPE_TO_DEPARTMENT.get(input.category, 'props')
            # Also update label if provided
            if input.suggested_label is not None:
                breakdown_update["label"] = input.suggested_label
            client.table("backlot_scene_breakdown_items").update(breakdown_update).eq("id", breakdown_item_id).execute()

        return {"success": True, "highlight": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating script highlight: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/scripts/{script_id}/highlights/{highlight_id}/confirm")
async def confirm_script_highlight(
    script_id: str,
    highlight_id: str,
    create_breakdown: bool = True,
    authorization: str = Header(None)
):
    """Confirm a highlight and optionally create a breakdown item from it"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    try:
        # Convert Cognito ID to profile ID
        profile_id = get_profile_id_from_cognito_id(cognito_user_id)

        # Verify highlight exists
        highlight_result = client.table("backlot_script_highlight_breakdowns").select(
            "*"
        ).eq("id", highlight_id).eq("script_id", script_id).single().execute()

        if not highlight_result.data:
            raise HTTPException(status_code=404, detail="Highlight not found")

        highlight = highlight_result.data

        # Get project_id from script
        script_result = client.table("backlot_scripts").select("project_id").eq("id", script_id).single().execute()
        if not script_result.data:
            raise HTTPException(status_code=404, detail="Script not found")

        project_id = script_result.data["project_id"]

        # Check project membership
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = project_response.data and project_response.data[0]["owner_id"] == profile_id
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id).execute()
            if not member_response.data:
                raise HTTPException(status_code=403, detail="Access denied - not a project member")

        breakdown_item_id = highlight.get("breakdown_item_id")

        # Create breakdown item if requested and doesn't exist
        if create_breakdown and not breakdown_item_id and highlight.get("scene_id"):
            # Create notes with page reference if available
            page_num = highlight.get('page_number')
            notes = f"Found on page {page_num}" if page_num else "Created from script highlight"

            breakdown_data = {
                "id": str(uuid.uuid4()),
                "scene_id": highlight["scene_id"],
                "type": highlight["category"],
                "label": highlight.get("suggested_label") or highlight["highlighted_text"],
                "notes": notes,
                "created_at": datetime.utcnow().isoformat(),
                "updated_at": datetime.utcnow().isoformat(),
            }
            breakdown_result = client.table("backlot_scene_breakdown_items").insert(breakdown_data).execute()
            if breakdown_result.data:
                breakdown_item_id = breakdown_result.data[0]["id"]

        # Update highlight status
        update_data = {
            "status": "confirmed",
            "updated_at": datetime.utcnow().isoformat(),
        }
        if breakdown_item_id:
            update_data["breakdown_item_id"] = breakdown_item_id

        client.table("backlot_script_highlight_breakdowns").update(update_data).eq("id", highlight_id).execute()

        return {
            "success": True,
            "status": "confirmed",
            "breakdown_item_id": breakdown_item_id
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error confirming script highlight: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/scripts/{script_id}/highlights/{highlight_id}/reject")
async def reject_script_highlight(
    script_id: str,
    highlight_id: str,
    authorization: str = Header(None)
):
    """Reject/dismiss a highlight"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    try:
        # Convert Cognito ID to profile ID
        profile_id = get_profile_id_from_cognito_id(cognito_user_id)

        # Verify highlight exists
        highlight_result = client.table("backlot_script_highlight_breakdowns").select(
            "id, script_id"
        ).eq("id", highlight_id).eq("script_id", script_id).single().execute()

        if not highlight_result.data:
            raise HTTPException(status_code=404, detail="Highlight not found")

        # Get project_id from script
        script_result = client.table("backlot_scripts").select("project_id").eq("id", script_id).single().execute()
        if not script_result.data:
            raise HTTPException(status_code=404, detail="Script not found")

        project_id = script_result.data["project_id"]

        # Check project membership
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = project_response.data and project_response.data[0]["owner_id"] == profile_id
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id).execute()
            if not member_response.data:
                raise HTTPException(status_code=403, detail="Access denied - not a project member")

        # Update highlight status
        client.table("backlot_script_highlight_breakdowns").update({
            "status": "rejected",
            "updated_at": datetime.utcnow().isoformat(),
        }).eq("id", highlight_id).execute()

        return {"success": True, "status": "rejected"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error rejecting script highlight: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/scripts/{script_id}/highlights/{highlight_id}")
async def delete_script_highlight(
    script_id: str,
    highlight_id: str,
    authorization: str = Header(None)
):
    """Delete a highlight and its associated breakdown item"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    try:
        # Convert Cognito ID to profile ID
        profile_id = get_profile_id_from_cognito_id(cognito_user_id)

        # Verify highlight exists
        highlight_result = client.table("backlot_script_highlight_breakdowns").select(
            "id, script_id, breakdown_item_id"
        ).eq("id", highlight_id).eq("script_id", script_id).single().execute()

        if not highlight_result.data:
            raise HTTPException(status_code=404, detail="Highlight not found")

        # Get project_id from script
        script_result = client.table("backlot_scripts").select("project_id").eq("id", script_id).single().execute()
        if not script_result.data:
            raise HTTPException(status_code=404, detail="Script not found")

        project_id = script_result.data["project_id"]

        # Check project membership
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = project_response.data and str(project_response.data[0]["owner_id"]) == str(profile_id)
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", str(profile_id)).execute()
            if not member_response.data:
                raise HTTPException(status_code=403, detail="Access denied - not a project member")
            role = member_response.data[0]["role"]
            if role not in ["admin", "editor", "coordinator"]:
                raise HTTPException(status_code=403, detail="Insufficient permissions")

        # Delete associated breakdown item if exists
        breakdown_item_id = highlight_result.data.get("breakdown_item_id")
        if breakdown_item_id:
            client.table("backlot_scene_breakdown_items").delete().eq("id", breakdown_item_id).execute()

        # Delete highlight
        client.table("backlot_script_highlight_breakdowns").delete().eq("id", highlight_id).execute()

        return {"success": True, "message": "Highlight and breakdown item deleted"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting script highlight: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# HIGHLIGHT INTERNAL NOTES
# =====================================================

class HighlightNoteInput(BaseModel):
    """Input for creating a highlight note"""
    content: str


@router.get("/scripts/{script_id}/highlights/{highlight_id}/notes")
async def get_highlight_notes(
    script_id: str,
    highlight_id: str,
    authorization: str = Header(None)
):
    """Get all notes for a highlight"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    try:
        profile_id = get_profile_id_from_cognito_id(cognito_user_id)

        # Verify highlight exists
        highlight_result = client.table("backlot_script_highlight_breakdowns").select(
            "id"
        ).eq("id", highlight_id).eq("script_id", script_id).single().execute()

        if not highlight_result.data:
            raise HTTPException(status_code=404, detail="Highlight not found")

        # Get project_id from script
        script_result = client.table("backlot_scripts").select("project_id").eq("id", script_id).single().execute()
        if not script_result.data:
            raise HTTPException(status_code=404, detail="Script not found")

        project_id = script_result.data["project_id"]

        # Check project membership
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = project_response.data and str(project_response.data[0]["owner_id"]) == str(profile_id)
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", str(profile_id)).execute()
            if not member_response.data:
                raise HTTPException(status_code=403, detail="Access denied - not a project member")

        # Get notes with author info
        notes_result = client.table("backlot_highlight_notes").select(
            "*, profiles(id, full_name, display_name, avatar_url)"
        ).eq("highlight_id", highlight_id).order("created_at", desc=False).execute()

        return notes_result.data or []

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting highlight notes: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/scripts/{script_id}/highlights/{highlight_id}/notes")
async def create_highlight_note(
    script_id: str,
    highlight_id: str,
    input: HighlightNoteInput,
    authorization: str = Header(None)
):
    """Create a note on a highlight"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    try:
        profile_id = get_profile_id_from_cognito_id(cognito_user_id)

        # Verify highlight exists
        highlight_result = client.table("backlot_script_highlight_breakdowns").select(
            "id"
        ).eq("id", highlight_id).eq("script_id", script_id).single().execute()

        if not highlight_result.data:
            raise HTTPException(status_code=404, detail="Highlight not found")

        # Get project_id from script
        script_result = client.table("backlot_scripts").select("project_id").eq("id", script_id).single().execute()
        if not script_result.data:
            raise HTTPException(status_code=404, detail="Script not found")

        project_id = script_result.data["project_id"]

        # Check project membership
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = project_response.data and str(project_response.data[0]["owner_id"]) == str(profile_id)
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", str(profile_id)).execute()
            if not member_response.data:
                raise HTTPException(status_code=403, detail="Access denied - not a project member")

        # Create note
        note_data = {
            "id": str(uuid.uuid4()),
            "highlight_id": highlight_id,
            "author_user_id": str(profile_id),
            "content": input.content,
            "created_at": datetime.utcnow().isoformat(),
            "updated_at": datetime.utcnow().isoformat(),
        }

        result = client.table("backlot_highlight_notes").insert(note_data).execute()

        # Fetch the note with author info
        if result.data:
            note_with_author = client.table("backlot_highlight_notes").select(
                "*, profiles(id, full_name, display_name, avatar_url)"
            ).eq("id", result.data[0]["id"]).single().execute()
            return note_with_author.data

        return result.data[0] if result.data else note_data

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating highlight note: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/scripts/{script_id}/highlights/{highlight_id}/notes/{note_id}")
async def delete_highlight_note(
    script_id: str,
    highlight_id: str,
    note_id: str,
    authorization: str = Header(None)
):
    """Delete a highlight note (only author or admin can delete)"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    try:
        profile_id = get_profile_id_from_cognito_id(cognito_user_id)

        # Verify note exists
        note_result = client.table("backlot_highlight_notes").select(
            "id, author_user_id, highlight_id"
        ).eq("id", note_id).eq("highlight_id", highlight_id).single().execute()

        if not note_result.data:
            raise HTTPException(status_code=404, detail="Note not found")

        # Check if user is author
        is_author = str(note_result.data["author_user_id"]) == str(profile_id)

        if not is_author:
            # Check if user is admin of the project
            highlight_result = client.table("backlot_script_highlight_breakdowns").select(
                "script_id"
            ).eq("id", highlight_id).single().execute()

            if highlight_result.data:
                # Get project_id from script
                script_result = client.table("backlot_scripts").select("project_id").eq("id", highlight_result.data["script_id"]).single().execute()
                if script_result.data:
                    project_id = script_result.data["project_id"]
                    project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
                    is_owner = project_response.data and str(project_response.data[0]["owner_id"]) == str(profile_id)

                    if not is_owner:
                        member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", str(profile_id)).execute()
                        if not member_response.data or member_response.data[0]["role"] != "admin":
                            raise HTTPException(status_code=403, detail="Only note author or project admin can delete notes")

        # Delete note
        client.table("backlot_highlight_notes").delete().eq("id", note_id).execute()

        return {"success": True, "message": "Note deleted"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting highlight note: {e}")
        raise HTTPException(status_code=500, detail=str(e))


class HighlightRelocateResult(BaseModel):
    """Result of relocating a single highlight"""
    highlight_id: str
    status: str  # 'relocated', 'stale', 'unchanged'
    new_start_offset: Optional[int] = None
    new_end_offset: Optional[int] = None


@router.post("/scripts/{script_id}/highlights/relocate")
async def relocate_script_highlights(
    script_id: str,
    authorization: str = Header(None)
):
    """
    Relocate all highlights for a script based on current text content.

    This is called after script text is edited to update highlight positions.
    Uses fuzzy text matching to find the highlighted_text in the new content.
    Marks highlights as 'stale' if the text can no longer be found.

    Returns:
        List of relocate results showing what happened to each highlight
    """
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    try:
        # Convert Cognito ID to profile ID
        profile_id = get_profile_id_from_cognito_id(cognito_user_id)

        # Get script with text content
        script_result = client.table("backlot_scripts").select(
            "id, project_id, text_content"
        ).eq("id", script_id).single().execute()

        if not script_result.data:
            raise HTTPException(status_code=404, detail="Script not found")

        script = script_result.data
        project_id = script["project_id"]
        text_content = script.get("text_content") or ""

        # Check project membership
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = project_response.data and project_response.data[0]["owner_id"] == profile_id
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id).execute()
            if not member_response.data:
                raise HTTPException(status_code=403, detail="Access denied - not a project member")

        # Get all highlights for this script
        highlights_result = client.table("backlot_script_highlight_breakdowns").select(
            "id, highlighted_text, start_offset, end_offset, status"
        ).eq("script_id", script_id).execute()

        highlights = highlights_result.data or []
        results = []
        updates_to_make = []

        for highlight in highlights:
            highlight_id = highlight["id"]
            highlighted_text = highlight.get("highlighted_text", "")
            old_start = highlight.get("start_offset", 0)
            old_end = highlight.get("end_offset", 0)
            current_status = highlight.get("status", "pending")

            if not highlighted_text:
                results.append({
                    "highlight_id": highlight_id,
                    "status": "unchanged",
                    "reason": "No highlighted text stored"
                })
                continue

            # Try exact match first
            new_start = text_content.find(highlighted_text)

            if new_start >= 0:
                new_end = new_start + len(highlighted_text)

                # Check if position changed
                if new_start == old_start and new_end == old_end:
                    results.append({
                        "highlight_id": highlight_id,
                        "status": "unchanged"
                    })
                else:
                    # Position changed - update it
                    updates_to_make.append({
                        "id": highlight_id,
                        "start_offset": new_start,
                        "end_offset": new_end,
                        "status": "confirmed" if current_status == "stale" else current_status
                    })
                    results.append({
                        "highlight_id": highlight_id,
                        "status": "relocated",
                        "new_start_offset": new_start,
                        "new_end_offset": new_end
                    })
            else:
                # Text not found - try fuzzy match with some flexibility
                # Look for partial match (at least 80% of text)
                min_match_len = max(10, int(len(highlighted_text) * 0.8))
                found_fuzzy = False

                # Try matching with start of the text
                if len(highlighted_text) > 20:
                    start_text = highlighted_text[:min_match_len]
                    fuzzy_start = text_content.find(start_text)
                    if fuzzy_start >= 0:
                        # Found partial match - estimate end
                        new_start = fuzzy_start
                        new_end = fuzzy_start + len(highlighted_text)
                        found_fuzzy = True
                        updates_to_make.append({
                            "id": highlight_id,
                            "start_offset": new_start,
                            "end_offset": min(new_end, len(text_content)),
                            "status": current_status  # Keep status, might be slightly off
                        })
                        results.append({
                            "highlight_id": highlight_id,
                            "status": "relocated",
                            "new_start_offset": new_start,
                            "new_end_offset": min(new_end, len(text_content)),
                            "note": "fuzzy_match"
                        })

                if not found_fuzzy:
                    # Mark as stale if not already
                    if current_status != "stale":
                        updates_to_make.append({
                            "id": highlight_id,
                            "status": "stale"
                        })
                    results.append({
                        "highlight_id": highlight_id,
                        "status": "stale",
                        "reason": "Text not found in script"
                    })

        # Batch update highlights
        updated_count = 0
        stale_count = 0
        for update in updates_to_make:
            highlight_id = update.pop("id")
            update["updated_at"] = datetime.utcnow().isoformat()
            try:
                client.table("backlot_script_highlight_breakdowns").update(
                    update
                ).eq("id", highlight_id).execute()
                if update.get("status") == "stale":
                    stale_count += 1
                else:
                    updated_count += 1
            except Exception as e:
                print(f"Error updating highlight {highlight_id}: {e}")

        return {
            "success": True,
            "total_highlights": len(highlights),
            "relocated": updated_count,
            "stale": stale_count,
            "unchanged": len(highlights) - updated_count - stale_count,
            "results": results
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error relocating highlights: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/scripts/{script_id}/export-with-highlights")
async def export_script_with_highlights(
    script_id: str,
    include_highlights: bool = True,
    include_notes: bool = True,
    include_addendums: bool = True,
    authorization: str = Header(None)
):
    """
    Export script PDF with highlights overlaid and notes addendum.

    Args:
        include_highlights: Include highlight overlays on pages and highlights addendum
        include_notes: Include note markers on pages and notes addendum
        include_addendums: Include addendum pages at the end

    Returns a PDF with:
    - Original script pages with colored highlight overlays (if include_highlights)
    - Note markers on pages (if include_notes)
    - Addendum page(s) listing all notes with page references (if include_addendums)
    - Addendum page(s) listing all highlights by category (if include_addendums)
    """
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    try:
        from pypdf import PdfReader, PdfWriter
        from reportlab.lib.pagesizes import letter
        from reportlab.pdfgen import canvas
        from reportlab.lib.colors import Color
        from reportlab.lib.units import inch
        from reportlab.pdfbase import pdfmetrics
        from reportlab.pdfbase.ttfonts import TTFont
        from io import BytesIO
        import requests

        profile_id = get_profile_id_from_cognito_id(cognito_user_id)

        # Get script and verify access (include text_content for highlight offset matching)
        script_result = client.table("backlot_scripts").select(
            "id, title, file_url, project_id, text_content"
        ).eq("id", script_id).single().execute()

        if not script_result.data:
            raise HTTPException(status_code=404, detail="Script not found")

        script = script_result.data
        project_id = script["project_id"]

        # Verify project access
        project_response = client.table("backlot_projects").select("owner_id, title").eq("id", project_id).execute()
        if not project_response.data:
            raise HTTPException(status_code=404, detail="Project not found")

        project = project_response.data[0]
        is_owner = str(project["owner_id"]) == str(profile_id)
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", str(profile_id)).execute()
            if not member_response.data:
                raise HTTPException(status_code=403, detail="You don't have access to this project")

        # Get scenes for the project to map page numbers to scenes
        # Include page_start and page_end directly from scenes table
        scenes_result = client.table("backlot_scenes").select(
            "id, scene_number, int_ext, location_hint, set_name, page_start, page_end"
        ).eq("project_id", project_id).execute()
        scenes_list = scenes_result.data or []
        print(f"[EXPORT DEBUG] Found {len(scenes_list)} scenes for project {project_id}")

        # Build page -> scene info map AND export scene mappings for PDF bookmarks
        # Use page_start directly from scenes table (not the separate mappings table)
        scene_map = {}  # page_number -> "  Scene X - INT/EXT LOCATION"
        export_scene_mappings = []  # For PDF bookmarks and frontend navigation
        for scene in scenes_list:
            # page_start might be stored as decimal string like "4.00", convert to int
            raw_page_start = scene.get("page_start")
            raw_page_end = scene.get("page_end")

            if raw_page_start is None:
                print(f"[EXPORT DEBUG] Scene {scene.get('scene_number')} has no page_start, skipping")
                continue  # Skip scenes without page mapping

            try:
                start_page = int(float(raw_page_start))
                end_page = int(float(raw_page_end)) if raw_page_end else start_page
                print(f"[EXPORT DEBUG] Scene {scene.get('scene_number')} -> page {start_page}")
            except (ValueError, TypeError) as e:
                print(f"[EXPORT DEBUG] Scene {scene.get('scene_number')} page conversion failed: {e}")
                continue

            int_ext = (scene.get("int_ext") or "").upper()
            # Use location_hint or set_name for location display
            location = scene.get("location_hint") or scene.get("set_name") or ""
            scene_info = f"  Scene {scene.get('scene_number', '?')}"
            bookmark_title = f"Scene {scene.get('scene_number', '?')}"
            if int_ext or location:
                scene_info += f" - {int_ext} {location}".strip()
                bookmark_title += f" - {int_ext} {location}".strip()

            # Build page -> scene map for addendum display
            for page in range(start_page, end_page + 1):
                scene_map[page] = scene_info

            # Build export scene mapping for bookmarks (one entry per scene)
            export_scene_mappings.append({
                "scene_number": scene.get("scene_number"),
                "scene_id": str(scene.get("id")),
                "page_number": start_page,
                "bookmark_title": bookmark_title
            })

        # Sort scene mappings by page number
        export_scene_mappings.sort(key=lambda x: x.get("page_number", 0))
        print(f"[EXPORT DEBUG] Final export_scene_mappings has {len(export_scene_mappings)} entries")

        # Get all highlights for the script
        highlights_result = client.table("backlot_script_highlight_breakdowns").select(
            "id, page_number, rect_x, rect_y, rect_width, rect_height, category, color, highlighted_text, suggested_label, status, start_offset, end_offset"
        ).eq("script_id", script_id).order("page_number").execute()
        highlights = highlights_result.data or []

        # Get all script page notes (ordered by document position: page first, then y position)
        notes_result = client.table("backlot_script_page_notes").select(
            "id, page_number, position_x, position_y, note_text, note_type, resolved, created_at, author_user_id"
        ).eq("script_id", script_id).order("page_number").order("position_y").execute()
        notes = notes_result.data or []

        # Get author names for notes
        author_ids = list(set([n.get("author_user_id") for n in notes if n.get("author_user_id")]))
        author_map = {}
        if author_ids:
            authors_result = client.table("profiles").select("id, full_name, display_name, username").in_("id", author_ids).execute()
            for author in (authors_result.data or []):
                author_map[str(author["id"])] = author

        # Attach author info to notes
        for note in notes:
            aid = note.get("author_user_id")
            if aid and str(aid) in author_map:
                note["author"] = author_map[str(aid)]
            else:
                note["author"] = None

        # Get highlight notes
        highlight_notes_result = client.table("backlot_highlight_notes").select(
            "id, highlight_id, content, created_at, author_user_id"
        ).execute()

        # Get author names for highlight notes
        hn_author_ids = list(set([hn.get("author_user_id") for hn in (highlight_notes_result.data or []) if hn.get("author_user_id")]))
        for aid in hn_author_ids:
            if str(aid) not in author_map:
                # Fetch additional authors not already fetched
                pass
        if hn_author_ids:
            hn_authors_result = client.table("profiles").select("id, full_name, display_name, username").in_("id", hn_author_ids).execute()
            for author in (hn_authors_result.data or []):
                author_map[str(author["id"])] = author

        highlight_notes_map = {}
        for hn in (highlight_notes_result.data or []):
            hid = hn.get("highlight_id")
            # Attach author info
            aid = hn.get("author_user_id")
            if aid and str(aid) in author_map:
                hn["author"] = author_map[str(aid)]
            else:
                hn["author"] = None
            if hid not in highlight_notes_map:
                highlight_notes_map[hid] = []
            highlight_notes_map[hid].append(hn)

        # Download original PDF from S3
        if not script.get("file_url"):
            raise HTTPException(status_code=400, detail="Script has no PDF file")

        file_url = script["file_url"]

        # Handle S3 URIs (s3://bucket/key) vs HTTPS URLs
        if file_url.startswith("s3://"):
            pdf_content = download_from_s3_uri(file_url)
        else:
            # Fallback for HTTPS URLs
            pdf_response = requests.get(file_url, timeout=60)
            if pdf_response.status_code != 200:
                raise HTTPException(status_code=500, detail="Failed to download script PDF")
            pdf_content = pdf_response.content

        # Read original PDF (strict=False for maximum compatibility with various PDF generators)
        try:
            original_pdf = PdfReader(BytesIO(pdf_content), strict=False)
            num_pages = len(original_pdf.pages)
        except Exception as e:
            print(f"[EXPORT] Failed to parse PDF: {e}")
            raise HTTPException(status_code=400, detail=f"Could not read script PDF: {str(e)}")

        # Use pdfplumber to extract text positions for highlight rect calculation
        try:
            import pdfplumber
            plumber_doc = pdfplumber.open(BytesIO(pdf_content))
        except Exception as e:
            plumber_doc = None
            print(f"[EXPORT] pdfplumber not available  skipping text position extraction: {e}")

        # Helper: search for text on a pdfplumber page, return list of bbox dicts
        def plumber_search_for(plumber_page, search_text, case_sensitive=False):
            """Search for text on a pdfplumber page. Returns list of dicts with x0,y0,x1,y1 (top coords)."""
            if not plumber_page or not search_text:
                return []
            try:
                words = plumber_page.extract_words(keep_blank_chars=True, x_tolerance=3, y_tolerance=3)
            except Exception:
                return []
            if not words:
                return []

            # Build lines by grouping words with similar top values
            lines = []
            current_line = []
            current_top = None
            for w in sorted(words, key=lambda w: (round(w["top"], 1), w["x0"])):
                if current_top is None or abs(w["top"] - current_top) < 4:
                    current_line.append(w)
                    current_top = w["top"] if current_top is None else current_top
                else:
                    if current_line:
                        lines.append(current_line)
                    current_line = [w]
                    current_top = w["top"]
            if current_line:
                lines.append(current_line)

            results = []
            target = search_text if case_sensitive else search_text.lower()

            for line_words in lines:
                # Build the full line text and track character positions
                line_text = ""
                char_map = []  # maps char index -> (word_idx, char_in_word)
                for wi, w in enumerate(line_words):
                    if line_text and not line_text.endswith(" "):
                        line_text += " "
                        char_map.append((-1, -1))  # space between words
                    start = len(line_text)
                    line_text += w["text"]
                    for ci in range(len(w["text"])):
                        char_map.append((wi, ci))

                compare_text = line_text if case_sensitive else line_text.lower()
                search_start = 0
                while True:
                    pos = compare_text.find(target, search_start)
                    if pos == -1:
                        break
                    end_pos = pos + len(target) - 1

                    # Find bounding box from the words that contain the match
                    match_x0 = None
                    match_x1 = None
                    match_top = None
                    match_bottom = None

                    for ci in range(pos, min(end_pos + 1, len(char_map))):
                        wi, char_in_word = char_map[ci]
                        if wi < 0:
                            continue  # skip inter-word spaces
                        w = line_words[wi]
                        wx0 = w["x0"]
                        wx1 = w["x1"]
                        # Approximate char position within word
                        word_len = max(len(w["text"]), 1)
                        char_width = (wx1 - wx0) / word_len
                        cx0 = wx0 + char_in_word * char_width
                        cx1 = cx0 + char_width

                        if match_x0 is None or cx0 < match_x0:
                            match_x0 = cx0
                        if match_x1 is None or cx1 > match_x1:
                            match_x1 = cx1
                        if match_top is None or w["top"] < match_top:
                            match_top = w["top"]
                        if match_bottom is None or w["bottom"] > match_bottom:
                            match_bottom = w["bottom"]

                    if match_x0 is not None:
                        results.append({
                            "x0": match_x0,
                            "y0": match_top,
                            "x1": match_x1,
                            "y1": match_bottom
                        })
                    search_start = pos + 1

            return results

        # Find Y positions of scene headings for scroll-to-top functionality
        for scene_mapping in (export_scene_mappings if plumber_doc else []):
            page_num = scene_mapping.get("page_number", 1)
            if page_num < 1 or page_num > len(plumber_doc.pages):
                continue

            plumber_page = plumber_doc.pages[page_num - 1]  # 0-indexed

            # Build search patterns for scene heading
            bookmark_title = scene_mapping.get("bookmark_title", "")
            # Extract just the INT/EXT LOCATION part (after "Scene X - ")
            search_patterns = []
            if " - " in bookmark_title:
                # Get the INT/EXT LOCATION part
                location_part = bookmark_title.split(" - ", 1)[1].strip()
                if location_part:
                    search_patterns.append(location_part)
                    # Also try without the INT/EXT prefix
                    for prefix in ["INT ", "EXT ", "INT. ", "EXT. ", "I/E ", "I/E. "]:
                        if location_part.upper().startswith(prefix):
                            search_patterns.append(location_part[len(prefix):].strip())
                            break

            # Search for scene heading on the page
            best_y = None
            for pattern in search_patterns:
                if not pattern:
                    continue
                # Case insensitive search
                text_instances = plumber_search_for(plumber_page, pattern)
                if text_instances:
                    # Get the topmost occurrence (smallest y0)
                    topmost = min(text_instances, key=lambda r: r["y0"])
                    y_from_top = topmost["y0"]
                    if best_y is None or y_from_top < best_y:
                        best_y = y_from_top
                    break  # Found it, stop searching

            if best_y is not None:
                # Store scroll position - subtract some padding to show context above
                scroll_y = max(0, best_y - 20)  # 20 points padding above
                scene_mapping["scroll_y"] = round(scroll_y)
                print(f"[EXPORT DEBUG] Scene {scene_mapping.get('scene_number')} scroll_y={scroll_y:.0f}")

        def find_text_rects_on_page(page_num, search_text):
            """Find all occurrences of text on a page and return their rects as percentages"""
            if page_num < 1 or page_num > len(plumber_doc.pages):
                return [], page_num

            plumber_page = plumber_doc.pages[page_num - 1]  # 0-indexed
            page_width = plumber_page.width
            page_height = plumber_page.height

            # Search for the text
            text_instances = plumber_search_for(plumber_page, search_text, case_sensitive=True)

            rects = []
            for inst in text_instances:
                # Convert to percentages (0-1 range)
                rect_x = inst["x0"] / page_width
                rect_y = inst["y0"] / page_height
                rect_width = (inst["x1"] - inst["x0"]) / page_width
                rect_height = (inst["y1"] - inst["y0"]) / page_height
                rects.append({
                    "rect_x": rect_x,
                    "rect_y": rect_y,
                    "rect_width": rect_width,
                    "rect_height": rect_height
                })
            return rects, page_num

        def find_text_in_document(search_text, preferred_page=None):
            """Find text in document, checking preferred page first, then all pages"""
            # Try preferred page first
            if preferred_page:
                rects, found_page = find_text_rects_on_page(preferred_page, search_text)
                if rects:
                    return rects, found_page

            # Search all pages
            for page_idx in range(len(plumber_doc.pages)):
                page_num = page_idx + 1
                plumber_page = plumber_doc.pages[page_idx]
                page_width = plumber_page.width
                page_height = plumber_page.height

                text_instances = plumber_search_for(plumber_page, search_text, case_sensitive=True)
                if text_instances:
                    rects = []
                    for inst in text_instances:
                        rect_x = inst["x0"] / page_width
                        rect_y = inst["y0"] / page_height
                        rect_width = (inst["x1"] - inst["x0"]) / page_width
                        rect_height = (inst["y1"] - inst["y0"]) / page_height
                        rects.append({
                            "rect_x": rect_x,
                            "rect_y": rect_y,
                            "rect_width": rect_width,
                            "rect_height": rect_height
                        })
                    return rects, page_num

            return [], None

        def find_text_by_offset(start_offset, end_offset, search_text, hint_page=None):
            """Find text position using character offsets and context from script's text_content.

            Uses surrounding context (BEFORE and AFTER) from text_content to find the exact match in PDF.
            Searches ALL pages and returns the best global match, not just the first match.
            """
            script_text = script.get("text_content") or ""

            if not script_text:
                print(f"[EXPORT DEBUG] No text_content available for offset matching")
                return None, None

            # Find the text in text_content at the given offset
            search_start = max(0, start_offset - 50)
            search_end = min(len(script_text), start_offset + len(search_text) + 100)
            window = script_text[search_start:search_end]

            text_pos = window.find(search_text)
            if text_pos == -1:
                print(f"[EXPORT DEBUG] Could not find '{search_text}' near offset {start_offset} in text_content")
                return None, None

            actual_pos = search_start + text_pos
            print(f"[EXPORT DEBUG] Found '{search_text}' at offset {actual_pos} in text_content")

            # Get context BEFORE the target text (last 4 words before)
            before_text = script_text[max(0, actual_pos - 100):actual_pos]
            before_words = ' '.join(before_text.split()[-4:])  # Last 4 words before
            print(f"[EXPORT DEBUG] Context before '{search_text}': '{before_words}'")

            # Get context AFTER the target text (first 6 words after)
            after_text = script_text[actual_pos + len(search_text):actual_pos + len(search_text) + 100]
            after_words = ' '.join(after_text.split()[:6])  # First 6 words after
            print(f"[EXPORT DEBUG] Context after '{search_text}': '{after_words}'")

            def count_consecutive_matches(expected_words, actual_words):
                """Count consecutive matching words from the start."""
                if not expected_words or not actual_words:
                    return 0
                exp_list = expected_words.lower().split()
                act_list = actual_words.lower().split()
                count = 0
                for i in range(min(len(exp_list), len(act_list))):
                    if exp_list[i] == act_list[i]:
                        count += 1
                    else:
                        break
                return count

            def search_page_for_match(page_idx):
                """Search a single page for the text with matching context. Returns (rect, page_num, score)."""
                page_num = page_idx + 1
                plumber_page = plumber_doc.pages[page_idx]
                page_width = plumber_page.width
                page_height = plumber_page.height

                # Case-sensitive search
                text_instances = plumber_search_for(plumber_page, search_text, case_sensitive=True)
                if not text_instances:
                    return None, None, 0

                page_text = plumber_page.extract_text() or ""

                search_pos = 0
                best_match = None
                best_match_score = 0

                for inst_idx, inst in enumerate(text_instances):
                    found_pos = page_text.find(search_text, search_pos)
                    if found_pos == -1:
                        continue

                    # Get context BEFORE this instance in PDF
                    pdf_before = page_text[max(0, found_pos - 100):found_pos]
                    pdf_before_words = ' '.join(pdf_before.split()[-4:])

                    # Get context AFTER this instance in PDF
                    pdf_after = page_text[found_pos + len(search_text):found_pos + len(search_text) + 100]
                    pdf_after_words = ' '.join(pdf_after.split()[:6])

                    # Score = before matches + after matches
                    before_score = count_consecutive_matches(before_words, pdf_before_words)
                    after_score = count_consecutive_matches(after_words, pdf_after_words)
                    total_score = before_score + after_score

                    print(f"[EXPORT DEBUG] PDF page {page_num} instance {inst_idx}: before='{pdf_before_words}' after='{pdf_after_words}' score={before_score}+{after_score}={total_score}")

                    # Keep the best match on this page
                    if total_score > best_match_score:
                        best_match_score = total_score
                        best_match = {
                            "rect": {
                                "rect_x": inst["x0"] / page_width,
                                "rect_y": inst["y0"] / page_height,
                                "rect_width": (inst["x1"] - inst["x0"]) / page_width,
                                "rect_height": (inst["y1"] - inst["y0"]) / page_height
                            },
                            "page_num": page_num
                        }

                    search_pos = found_pos + 1

                if best_match:
                    return best_match["rect"], best_match["page_num"], best_match_score

                return None, None, 0

            # Search ALL pages and find the BEST global match
            best_global_match = None
            best_global_page = None
            best_global_score = 0

            # Search hint page first (if provided)
            if hint_page is not None and 1 <= hint_page <= len(plumber_doc.pages):
                print(f"[EXPORT DEBUG] Searching hint page {hint_page} first")
                rect, page_num, score = search_page_for_match(hint_page - 1)
                if rect and score > best_global_score:
                    best_global_match = rect
                    best_global_page = page_num
                    best_global_score = score

            # Search all other pages
            for page_idx in range(len(plumber_doc.pages)):
                if hint_page and page_idx == hint_page - 1:
                    continue  # Already searched
                rect, page_num, score = search_page_for_match(page_idx)
                if rect and score > best_global_score:
                    best_global_match = rect
                    best_global_page = page_num
                    best_global_score = score

            # Require minimum score of 3 (e.g., 1 before + 2 after, or 0 before + 3 after)
            if best_global_match and best_global_score >= 3:
                print(f"[EXPORT DEBUG] Best GLOBAL match: page {best_global_page} with score {best_global_score}")
                return best_global_match, best_global_page

            # Fallback: return first instance on hint page or first page with matches
            print(f"[EXPORT DEBUG] No strong context match (score={best_global_score}), using first instance")
            pages_to_check = [hint_page - 1] if hint_page else []
            pages_to_check.extend(range(len(plumber_doc.pages)))

            for page_idx in pages_to_check:
                if page_idx < 0 or page_idx >= len(plumber_doc.pages):
                    continue
                plumber_page = plumber_doc.pages[page_idx]
                text_instances = plumber_search_for(plumber_page, search_text, case_sensitive=True)
                if text_instances:
                    inst = text_instances[0]
                    return {
                        "rect_x": inst["x0"] / plumber_page.width,
                        "rect_y": inst["y0"] / plumber_page.height,
                        "rect_width": (inst["x1"] - inst["x0"]) / plumber_page.width,
                        "rect_height": (inst["y1"] - inst["y0"]) / plumber_page.height
                    }, page_idx + 1

            return None, None

        # Calculate missing rect coordinates for highlights (requires pdfplumber)
        print(f"[EXPORT DEBUG] Processing {len(highlights)} highlights (pdfplumber={'available' if plumber_doc else 'unavailable'})")
        for highlight in (highlights if plumber_doc else []):
            # Skip if already has rect coordinates
            if highlight.get("rect_x") is not None and highlight.get("rect_y") is not None:
                print(f"[EXPORT DEBUG] Highlight already has rects: {highlight.get('suggested_label')}")
                continue

            # Need highlighted_text to calculate rect
            search_text = highlight.get("highlighted_text") or highlight.get("suggested_label")
            start_offset = highlight.get("start_offset")
            end_offset = highlight.get("end_offset")
            page_num = highlight.get("page_number")

            if not search_text:
                print(f"[EXPORT DEBUG] Skipping highlight - no search_text")
                continue

            # If we have start_offset, use it to find the exact instance
            if start_offset is not None and end_offset is not None:
                print(f"[EXPORT DEBUG] Using offset search for '{search_text}' (offset {start_offset}-{end_offset}, hint page {page_num})")
                rect, found_page = find_text_by_offset(start_offset, end_offset, search_text, hint_page=page_num)
                if rect and found_page:
                    highlight["page_number"] = found_page
                    highlight["rect_x"] = rect["rect_x"]
                    highlight["rect_y"] = rect["rect_y"]
                    highlight["rect_width"] = rect["rect_width"]
                    highlight["rect_height"] = rect["rect_height"]
                    print(f"[EXPORT DEBUG] Set rect via offset: page={found_page}, x={rect['rect_x']:.4f}, y={rect['rect_y']:.4f}")
                    continue

            # Fallback: Find text in document (searches preferred page first if given, then all pages)
            print(f"[EXPORT DEBUG] Fallback search for '{search_text}' starting on page {page_num or 'any'}")
            rects, found_page = find_text_in_document(search_text, page_num)
            print(f"[EXPORT DEBUG] Found {len(rects)} matches on page {found_page}")

            if rects and found_page:
                # Update page_number if text was found on a different page or if page_num was missing
                if found_page != page_num or page_num is None:
                    print(f"[EXPORT DEBUG] Text found on page {found_page} (was {page_num}), updating highlight")
                    highlight["page_number"] = found_page

                # Use the first match
                highlight["rect_x"] = rects[0]["rect_x"]
                highlight["rect_y"] = rects[0]["rect_y"]
                highlight["rect_width"] = rects[0]["rect_width"]
                highlight["rect_height"] = rects[0]["rect_height"]
                print(f"[EXPORT DEBUG] Set rect: x={rects[0]['rect_x']:.4f}, y={rects[0]['rect_y']:.4f}, w={rects[0]['rect_width']:.4f}, h={rects[0]['rect_height']:.4f}")

        # Category colors mapping
        CATEGORY_COLORS = {
            "cast": "#3B82F6",      # Blue
            "background": "#8B5CF6", # Purple
            "prop": "#F59E0B",       # Amber
            "vehicle": "#EF4444",    # Red
            "sfx": "#10B981",        # Green
            "vfx": "#EC4899",        # Pink
            "wardrobe": "#F97316",   # Orange
            "makeup": "#14B8A6",     # Teal
            "location": "#6366F1",   # Indigo
            "stunt": "#DC2626",      # Dark Red
            "animal": "#84CC16",     # Lime
            "other": "#6B7280",      # Gray
        }

        def hex_to_rgb(hex_color):
            """Convert hex color to RGB tuple (0-1 range)"""
            hex_color = hex_color.lstrip('#')
            return tuple(int(hex_color[i:i+2], 16) / 255 for i in (0, 2, 4))

        # Create output PDF
        output = PdfWriter()

        # Create note index map (note_id -> serial number)
        note_index_map = {note.get("id"): idx for idx, note in enumerate(notes, 1)}

        # Process each page and add highlight overlays and note markers
        for page_num in range(num_pages):
            original_page = original_pdf.pages[page_num]

            try:
                page_width = float(original_page.mediabox.width)
                page_height = float(original_page.mediabox.height)
            except Exception as e:
                print(f"[EXPORT] Warning: Could not read page {page_num + 1} dimensions: {e}, using defaults")
                output.add_page(original_page)
                continue

            # Get highlights for this page (only if highlights are included)
            page_highlights = [h for h in highlights if h.get("page_number") == page_num + 1] if include_highlights else []
            # Get notes for this page (only if notes are included)
            page_notes = [n for n in notes if n.get("page_number") == page_num + 1] if include_notes else []

            if page_highlights or page_notes:
                try:
                    # Create overlay for this page
                    overlay_buffer = BytesIO()
                    c = canvas.Canvas(overlay_buffer, pagesize=(page_width, page_height))

                    # Draw highlight rectangles (if highlights are included)
                    if include_highlights:
                        print(f"[EXPORT DEBUG] Drawing {len(page_highlights)} highlights on page {page_num + 1}")
                        for highlight in page_highlights:
                            # Skip highlights without rect coordinates
                            if highlight.get("rect_x") is None or highlight.get("rect_y") is None:
                                print(f"[EXPORT DEBUG] Skipping highlight without rects: {highlight.get('suggested_label')}")
                                continue

                            # Get color
                            color_hex = highlight.get("color") or CATEGORY_COLORS.get(highlight.get("category"), "#FFFF00")
                            r, g, b = hex_to_rgb(color_hex)

                            # Calculate position (rect values are 0-1 percentages)
                            # Convert Decimal to float for math operations
                            rect_x = float(highlight.get("rect_x") or 0)
                            rect_y = float(highlight.get("rect_y") or 0)
                            rect_w = float(highlight.get("rect_width") or 0.1)
                            rect_h = float(highlight.get("rect_height") or 0.02)

                            x = rect_x * page_width
                            # PDF coordinates are from bottom, so invert y
                            y = page_height - (rect_y * page_height) - (rect_h * page_height)
                            w = rect_w * page_width
                            h = rect_h * page_height

                            print(f"[EXPORT DEBUG] Drawing highlight '{highlight.get('suggested_label')}' at x={x:.1f}, y={y:.1f}, w={w:.1f}, h={h:.1f}")

                            # Draw semi-transparent highlight rectangle
                            c.setFillColor(Color(r, g, b, alpha=0.3))
                            c.setStrokeColor(Color(r, g, b, alpha=0.8))
                            c.setLineWidth(0.5)
                            c.rect(x, y, w, h, fill=True, stroke=True)

                    # Draw note markers (circled numbers) - if notes are included
                    if include_notes:
                        for note in page_notes:
                            note_num = note_index_map.get(note.get("id"), 0)
                            if note_num == 0:
                                continue

                            # Get note position (0-100 percentages)
                            pos_x = float(note.get("position_x") or 0) / 100.0  # Convert 0-100 to 0-1
                            pos_y = float(note.get("position_y") or 0) / 100.0  # Convert 0-100 to 0-1

                            # Convert to PDF coordinates
                            marker_x = pos_x * page_width
                            marker_y = page_height - (pos_y * page_height)

                            # Draw marker - red circle with white number
                            marker_radius = 8
                            c.setFillColor(Color(0.9, 0.2, 0.2, alpha=0.9))  # Red
                            c.setStrokeColor(Color(1, 1, 1, alpha=1))  # White border
                            c.setLineWidth(1)
                            c.circle(marker_x, marker_y, marker_radius, fill=True, stroke=True)

                            # Draw number in white
                            c.setFillColor(Color(1, 1, 1, alpha=1))
                            c.setFont("Helvetica-Bold", 7)
                            # Center the text in the circle
                            text_width = c.stringWidth(str(note_num), "Helvetica-Bold", 7)
                            c.drawString(marker_x - text_width/2, marker_y - 2.5, str(note_num))

                    c.save()
                    overlay_buffer.seek(0)

                    # Merge overlay with original page
                    overlay_pdf = PdfReader(overlay_buffer)
                    original_page.merge_page(overlay_pdf.pages[0])
                except Exception as e:
                    print(f"[EXPORT] Warning: Failed to overlay page {page_num + 1}: {e}, using original")

            output.add_page(original_page)

        # Create notes addendum page(s)
        def create_notes_addendum():
            """Create addendum pages with all notes listed"""
            buffer = BytesIO()
            c = canvas.Canvas(buffer, pagesize=letter)
            page_width, page_height = letter

            # Title
            y_position = page_height - 1 * inch

            c.setFont("Helvetica-Bold", 16)
            c.drawString(1 * inch, y_position, f"Script Notes - {script.get('title', 'Untitled')}")
            y_position -= 0.3 * inch

            c.setFont("Helvetica", 10)
            c.setFillColor(Color(0.4, 0.4, 0.4))
            c.drawString(1 * inch, y_position, f"Project: {project.get('title', 'Unknown')}")
            y_position -= 0.2 * inch
            c.drawString(1 * inch, y_position, f"Generated: {datetime.utcnow().strftime('%B %d, %Y at %H:%M UTC')}")
            y_position -= 0.4 * inch

            c.setFillColor(Color(0, 0, 0))

            # Section: Script Page Notes
            if notes:
                c.setFont("Helvetica-Bold", 14)
                c.drawString(1 * inch, y_position, "Script Page Notes")
                y_position -= 0.3 * inch

                c.setFont("Helvetica", 9)

                note_type_labels = {
                    "general": "General",
                    "technical": "Technical",
                    "creative": "Creative",
                    "continuity": "Continuity",
                    "vfx": "VFX",
                    "sound": "Sound",
                    "production": "Production",
                }

                for i, note in enumerate(notes, 1):
                    if y_position < 1.5 * inch:
                        c.showPage()
                        y_position = page_height - 1 * inch
                        c.setFont("Helvetica", 9)

                    # Note header
                    c.setFont("Helvetica-Bold", 9)
                    note_type = note_type_labels.get(note.get("note_type"), note.get("note_type", "Note"))
                    page_num = note.get("page_number", 0)
                    page_ref = f"Page {page_num}"
                    scene_info = scene_map.get(page_num, "")
                    author_info = note.get("author") or {}
                    author_name = author_info.get("display_name") or author_info.get("full_name") or author_info.get("username") or "Unknown"
                    resolved_marker = " [RESOLVED]" if note.get("resolved") else ""

                    header_text = f"[{i}] {note_type} - {page_ref}{scene_info} - by {author_name}{resolved_marker}"
                    c.drawString(1 * inch, y_position, header_text)
                    y_position -= 0.15 * inch

                    # Note text (wrap long text)
                    c.setFont("Helvetica", 9)
                    note_text = note.get("note_text", "")
                    max_width = page_width - 2 * inch
                    words = note_text.split()
                    line = ""
                    for word in words:
                        test_line = f"{line} {word}".strip()
                        if c.stringWidth(test_line, "Helvetica", 9) < max_width:
                            line = test_line
                        else:
                            c.drawString(1.2 * inch, y_position, line)
                            y_position -= 0.15 * inch
                            line = word
                            if y_position < 1.5 * inch:
                                c.showPage()
                                y_position = page_height - 1 * inch
                                c.setFont("Helvetica", 9)
                    if line:
                        c.drawString(1.2 * inch, y_position, line)
                        y_position -= 0.25 * inch

            # Section: Breakdown Highlights with Notes
            highlights_with_notes = [h for h in highlights if h.get("id") in highlight_notes_map]
            if highlights_with_notes:
                y_position -= 0.3 * inch
                if y_position < 2 * inch:
                    c.showPage()
                    y_position = page_height - 1 * inch

                c.setFont("Helvetica-Bold", 14)
                c.drawString(1 * inch, y_position, "Breakdown Highlight Notes")
                y_position -= 0.3 * inch

                for highlight in highlights_with_notes:
                    if y_position < 1.5 * inch:
                        c.showPage()
                        y_position = page_height - 1 * inch

                    # Highlight info
                    c.setFont("Helvetica-Bold", 9)
                    label = highlight.get("suggested_label") or highlight.get("highlighted_text", "")
                    category = highlight.get("category", "other").capitalize()
                    hl_page_num = highlight.get("page_number", 0)
                    page_ref = f"Page {hl_page_num}"
                    hl_scene_info = scene_map.get(hl_page_num, "")
                    c.drawString(1 * inch, y_position, f"{category}: \"{label}\" - {page_ref}{hl_scene_info}")
                    y_position -= 0.15 * inch

                    # Notes for this highlight
                    c.setFont("Helvetica", 9)
                    for hn in highlight_notes_map.get(highlight.get("id"), []):
                        if y_position < 1.5 * inch:
                            c.showPage()
                            y_position = page_height - 1 * inch
                            c.setFont("Helvetica", 9)

                        hn_author = hn.get("author") or {}
                        hn_author_name = hn_author.get("display_name") or hn_author.get("full_name") or hn_author.get("username") or "Unknown"
                        content = hn.get("content", "")

                        c.drawString(1.2 * inch, y_position, f" {hn_author_name}: {content[:80]}{'...' if len(content) > 80 else ''}")
                        y_position -= 0.15 * inch

                    y_position -= 0.15 * inch

            # Summary section
            y_position -= 0.3 * inch
            if y_position < 2 * inch:
                c.showPage()
                y_position = page_height - 1 * inch

            c.setFont("Helvetica-Bold", 12)
            c.drawString(1 * inch, y_position, "Summary")
            y_position -= 0.25 * inch

            c.setFont("Helvetica", 10)
            c.drawString(1 * inch, y_position, f"Total Highlights: {len(highlights)}")
            y_position -= 0.15 * inch
            c.drawString(1 * inch, y_position, f"Total Script Notes: {len(notes)}")
            y_position -= 0.15 * inch
            c.drawString(1 * inch, y_position, f"Unresolved Notes: {len([n for n in notes if not n.get('resolved')])}")

            c.save()
            buffer.seek(0)
            return buffer

        # Create highlights addendum page(s)
        def create_highlights_addendum():
            """Create addendum pages listing all highlights with scene info, grouped by category"""
            buffer = BytesIO()
            c = canvas.Canvas(buffer, pagesize=letter)
            page_width, page_height = letter

            y_position = page_height - 1 * inch

            # Title
            c.setFont("Helvetica-Bold", 16)
            c.drawString(1 * inch, y_position, f"Breakdown Highlights - {script.get('title', 'Untitled')}")
            y_position -= 0.3 * inch

            c.setFont("Helvetica", 10)
            c.setFillColor(Color(0.4, 0.4, 0.4))
            c.drawString(1 * inch, y_position, f"Project: {project.get('title', 'Unknown')}")
            y_position -= 0.2 * inch
            c.drawString(1 * inch, y_position, f"Generated: {datetime.utcnow().strftime('%B %d, %Y at %H:%M UTC')}")
            y_position -= 0.4 * inch
            c.setFillColor(Color(0, 0, 0))

            # Group highlights by category
            highlights_by_category = {}
            for h in highlights:
                cat = h.get("category", "other")
                if cat not in highlights_by_category:
                    highlights_by_category[cat] = []
                highlights_by_category[cat].append(h)

            for category, cat_highlights in sorted(highlights_by_category.items()):
                if y_position < 1.5 * inch:
                    c.showPage()
                    y_position = page_height - 1 * inch

                # Category header with color swatch - use highlight's actual color if available
                # Get color from first highlight in category, or fall back to CATEGORY_COLORS
                first_highlight_color = cat_highlights[0].get("color") if cat_highlights else None
                color_hex = first_highlight_color or CATEGORY_COLORS.get(category, "#6B7280")
                r, g, b = hex_to_rgb(color_hex)
                c.setFillColor(Color(r, g, b, alpha=1))
                c.rect(1 * inch, y_position - 0.05 * inch, 0.15 * inch, 0.15 * inch, fill=True)
                c.setFillColor(Color(0, 0, 0))
                c.setFont("Helvetica-Bold", 12)
                c.drawString(1.25 * inch, y_position, f"{category.upper()} ({len(cat_highlights)})")
                y_position -= 0.25 * inch

                c.setFont("Helvetica", 9)
                for h in sorted(cat_highlights, key=lambda x: (x.get("page_number") or 0, float(x.get("rect_y") or 0))):
                    if y_position < 1.5 * inch:
                        c.showPage()
                        y_position = page_height - 1 * inch
                        c.setFont("Helvetica", 9)

                    label = h.get("suggested_label") or (h.get("highlighted_text") or "")[:50]
                    hl_page = h.get("page_number", 0)
                    hl_scene = scene_map.get(hl_page, "")

                    c.drawString(1.2 * inch, y_position, f" \"{label}\" - Page {hl_page}{hl_scene}")
                    y_position -= 0.15 * inch

                y_position -= 0.15 * inch

            # Summary at the end
            y_position -= 0.2 * inch
            if y_position < 1.5 * inch:
                c.showPage()
                y_position = page_height - 1 * inch

            c.setFont("Helvetica-Bold", 12)
            c.drawString(1 * inch, y_position, "Summary")
            y_position -= 0.25 * inch

            c.setFont("Helvetica", 10)
            c.drawString(1 * inch, y_position, f"Total Highlights: {len(highlights)}")
            y_position -= 0.15 * inch

            # Category breakdown
            for cat, cat_items in sorted(highlights_by_category.items()):
                # Use actual highlight color if available
                first_item_color = cat_items[0].get("color") if cat_items else None
                color_hex = first_item_color or CATEGORY_COLORS.get(cat, "#6B7280")
                r, g, b = hex_to_rgb(color_hex)
                c.setFillColor(Color(r, g, b, alpha=1))
                c.rect(1 * inch, y_position - 0.03 * inch, 0.1 * inch, 0.1 * inch, fill=True)
                c.setFillColor(Color(0, 0, 0))
                c.drawString(1.15 * inch, y_position, f"{cat.capitalize()}: {len(cat_items)}")
                y_position -= 0.15 * inch

            c.save()
            buffer.seek(0)
            return buffer

        # Add notes addendum if there are notes and notes are included in export
        notes_addendum_page_start = None
        if include_addendums and include_notes and (notes or any(h.get("id") in highlight_notes_map for h in highlights)):
            notes_addendum_page_start = len(output.pages) + 1  # 1-indexed for frontend
            addendum_buffer = create_notes_addendum()
            addendum_pdf = PdfReader(addendum_buffer)
            for page in addendum_pdf.pages:
                output.add_page(page)

        # Add highlights addendum if there are highlights and highlights are included in export
        highlights_addendum_page_start = None
        if include_addendums and include_highlights and highlights:
            highlights_addendum_page_start = len(output.pages) + 1  # 1-indexed for frontend
            highlights_addendum_buffer = create_highlights_addendum()
            highlights_addendum_pdf = PdfReader(highlights_addendum_buffer)
            for page in highlights_addendum_pdf.pages:
                output.add_page(page)

        # Add PDF bookmarks for scene navigation (wrapped in try/except  some PDFs
        # have structures that cause pypdf to throw "Sequence index out of range" during write)
        addendums_info = {}
        try:
            for scene_mapping in export_scene_mappings:
                page_num = scene_mapping.get("page_number", 1) - 1  # 0-indexed for pypdf
                if 0 <= page_num < len(output.pages):
                    output.add_outline_item(
                        title=scene_mapping.get("bookmark_title", f"Scene {scene_mapping.get('scene_number')}"),
                        page_number=page_num
                    )

            # Add addendum bookmarks
            if notes_addendum_page_start:
                output.add_outline_item(title="Notes Addendum", page_number=notes_addendum_page_start - 1)
                addendums_info["notes"] = {"page_number": notes_addendum_page_start, "title": "Notes Addendum"}
            if highlights_addendum_page_start:
                output.add_outline_item(title="Highlights Addendum", page_number=highlights_addendum_page_start - 1)
                addendums_info["highlights"] = {"page_number": highlights_addendum_page_start, "title": "Highlights Addendum"}
        except Exception as e:
            print(f"[EXPORT] Warning: Failed to add bookmarks: {e}, continuing without them")

        # Build final scene mappings JSON for response header
        scene_mappings_json = json.dumps({
            "scenes": export_scene_mappings,
            "addendums": addendums_info
        })

        # Write final PDF to buffer
        final_buffer = BytesIO()
        try:
            output.write(final_buffer)
        except Exception as write_err:
            # If writing merged PDF fails (e.g. "Sequence index out of range"),
            # fall back to returning the original unmodified PDF
            print(f"[EXPORT] Warning: Failed to write merged PDF: {write_err}, returning original")
            final_buffer = BytesIO(pdf_content)
        final_buffer.seek(0)

        # Close pdfplumber document
        if plumber_doc:
            plumber_doc.close()

        # Generate filename
        script_title = script.get("title", "script").replace(" ", "_")[:30]
        filename = f"{script_title}_with_highlights.pdf"

        return Response(
            content=final_buffer.getvalue(),
            media_type="application/pdf",
            headers={
                "Content-Disposition": f'attachment; filename="{filename}"',
                "X-Scene-Mappings": scene_mappings_json,
                "Access-Control-Expose-Headers": "X-Scene-Mappings"
            }
        )

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error exporting script with highlights: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/scripts/{script_id}/export")
async def export_script_multi_format(
    script_id: str,
    format: str = Query("fountain", description="Export format: fdx, fountain, or celtx"),
    include_highlights: bool = Query(False, description="Include breakdown highlights"),
    include_notes: bool = Query(False, description="Include script notes"),
    authorization: str = Header(None)
):
    """
    Export script in multiple formats (FDX, Fountain, Celtx).

    Parameters:
    - format: Export format - 'fdx' (Final Draft), 'fountain' (plain text), or 'celtx'
    - include_highlights: Include breakdown highlights as annotations
    - include_notes: Include script notes

    Returns the script content in the requested format.
    """
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    try:
        from app.utils.script_exporter import export_script, get_content_type, get_file_extension

        profile_id = get_profile_id_from_cognito_id(cognito_user_id)

        # Get script and verify access
        script_result = client.table("backlot_scripts").select(
            "*, project:backlot_projects!inner(id, title, owner_id)"
        ).eq("id", script_id).single().execute()

        if not script_result.data:
            raise HTTPException(status_code=404, detail="Script not found")

        script = script_result.data
        project = script.get("project", {})

        # Verify user has access to the project
        team_result = client.table("backlot_project_team").select("*").eq(
            "project_id", project.get("id")
        ).eq("user_id", profile_id).execute()

        is_owner = project.get("owner_id") == profile_id
        is_team_member = bool(team_result.data)

        if not is_owner and not is_team_member:
            raise HTTPException(status_code=403, detail="Access denied")

        # Get text content
        text_content = script.get("text_content", "")
        if not text_content:
            raise HTTPException(
                status_code=400,
                detail="Script has no text content to export. Please edit the script first."
            )

        # Get highlights if requested
        highlights = []
        if include_highlights:
            highlights_result = client.table("backlot_script_highlight_breakdowns").select(
                "*"
            ).eq("script_id", script_id).execute()
            highlights = highlights_result.data or []

        # Get notes if requested
        notes = []
        if include_notes:
            notes_result = client.table("backlot_script_notes").select(
                "*, author:profiles(id, full_name, display_name, username)"
            ).eq("script_id", script_id).order("page_number").execute()
            notes = notes_result.data or []

        # Export to requested format
        script_title = script.get("title", "Untitled Script")
        exported_content = export_script(
            format=format,
            script_title=script_title,
            text_content=text_content,
            highlights=highlights,
            notes=notes,
            include_highlights=include_highlights,
            include_notes=include_notes,
        )

        # Generate filename
        safe_title = script_title.replace(" ", "_")[:30]
        suffix = "_marked" if include_highlights else ""
        extension = get_file_extension(format)
        filename = f"{safe_title}{suffix}{extension}"

        return Response(
            content=exported_content.encode('utf-8'),
            media_type=get_content_type(format),
            headers={
                "Content-Disposition": f'attachment; filename="{filename}"'
            }
        )

    except HTTPException:
        raise
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        print(f"Error exporting script: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# CONTINUITY PDF EXPORTS
# =====================================================

class ContinuityExportInput(BaseModel):
    """Input for creating a continuity export"""
    script_id: Optional[str] = None
    export_type: str = "script"  # 'script', 'breakdown', 'sides', etc.
    content_type: Optional[str] = None  # 'clean', 'highlights', 'notes', 'both'
    version_label: Optional[str] = None


@router.post("/projects/{project_id}/continuity/exports")
async def save_continuity_export(
    project_id: str,
    file: UploadFile = File(...),
    script_id: Optional[str] = Form(None),
    export_type: str = Form("script"),
    content_type: Optional[str] = Form(None),
    version_label: Optional[str] = Form(None),
    scene_mappings: Optional[str] = Form(None),  # JSON string with scene-to-page mappings
    authorization: Optional[str] = Header(None)
):
    """Save an exported PDF to continuity storage for version history"""
    try:
        # Get current user
        current_user = await get_user_from_token(authorization)
        if not current_user:
            raise HTTPException(status_code=401, detail="Unauthorized")

        client = get_client()

        # Verify project access
        project = client.table("backlot_projects").select("id, title").eq("id", project_id).single().execute()
        if not project.data:
            raise HTTPException(status_code=404, detail="Project not found")

        # Get user profile ID (current_user from socketio_app returns 'user_id' not 'sub')
        from app.api.users import get_profile_id_from_cognito_id
        profile_id = get_profile_id_from_cognito_id(current_user["user_id"])

        # Read file content
        file_content = await file.read()
        file_size = len(file_content)

        # Generate unique filename for S3
        timestamp = datetime.now(timezone.utc).strftime("%Y%m%d_%H%M%S")
        safe_title = project.data.get("title", "export")[:30].replace(" ", "_")
        s3_key = f"continuity/{project_id}/{timestamp}_{safe_title}.pdf"

        # Upload to S3
        import boto3
        s3_client = boto3.client("s3")
        s3_client.put_object(
            Bucket=BACKLOT_FILES_BUCKET,
            Key=s3_key,
            Body=file_content,
            ContentType="application/pdf"
        )

        s3_uri = f"s3://{BACKLOT_FILES_BUCKET}/{s3_key}"

        # Get next version number
        version_result = execute_single(
            """
            SELECT COALESCE(MAX(version_number), 0) + 1 as next_version
            FROM backlot_continuity_exports
            WHERE project_id = :project_id
            """,
            {"project_id": project_id}
        )
        next_version = version_result["next_version"] if version_result else 1

        # Mark all previous exports as not current
        client.table("backlot_continuity_exports").update(
            {"is_current": False}
        ).eq("project_id", project_id).execute()

        # Get page count from PDF
        page_count = None
        try:
            import io
            from pypdf import PdfReader
            pdf_reader = PdfReader(io.BytesIO(file_content))
            page_count = len(pdf_reader.pages)
        except Exception:
            pass  # Page count is optional

        # Parse scene_mappings JSON if provided
        parsed_scene_mappings = None
        if scene_mappings:
            try:
                parsed_scene_mappings = json.loads(scene_mappings)
            except json.JSONDecodeError:
                pass  # Ignore invalid JSON, will auto-generate below

        # Auto-generate scene_mappings from project scenes if not provided
        if not parsed_scene_mappings or not parsed_scene_mappings.get("scenes"):
            scenes_result = client.table("backlot_scenes").select(
                "id, scene_number, int_ext, location_hint, set_name, page_start, page_end"
            ).eq("project_id", project_id).execute()
            scenes_list = scenes_result.data or []

            auto_scene_mappings = []
            for scene in scenes_list:
                raw_page_start = scene.get("page_start")
                if raw_page_start is None:
                    continue  # Skip scenes without page mapping

                try:
                    start_page = int(float(raw_page_start))
                except (ValueError, TypeError):
                    continue

                int_ext = (scene.get("int_ext") or "").upper()
                location = scene.get("location_hint") or scene.get("set_name") or ""
                bookmark_title = f"Scene {scene.get('scene_number', '?')}"
                if int_ext or location:
                    bookmark_title += f" - {int_ext} {location}".strip()

                auto_scene_mappings.append({
                    "scene_number": scene.get("scene_number"),
                    "scene_id": str(scene.get("id")),
                    "page_number": start_page,
                    "bookmark_title": bookmark_title
                })

            # Sort by page number
            auto_scene_mappings.sort(key=lambda x: x.get("page_number", 0))

            if auto_scene_mappings:
                parsed_scene_mappings = {"scenes": auto_scene_mappings}
                print(f"[IMPORT] Auto-generated scene_mappings with {len(auto_scene_mappings)} scenes from database for project {project_id}")

        # If still no scene mappings and this is a script PDF, parse the PDF directly
        if (not parsed_scene_mappings or not parsed_scene_mappings.get("scenes")) and export_type == "script":
            try:
                from app.utils.script_parser import parse_pdf
                parse_result = parse_pdf(file_content)
                if parse_result.scenes:
                    pdf_scene_mappings = []
                    for scene in parse_result.scenes:
                        bookmark_title = f"Scene {scene.scene_number}"
                        if scene.int_ext or scene.location_hint:
                            bookmark_title += f" - {(scene.int_ext or '').upper()} {scene.location_hint or ''}".strip()
                        pdf_scene_mappings.append({
                            "scene_number": scene.scene_number,
                            "scene_id": None,  # No database scene ID yet
                            "page_number": scene.page_start or 1,
                            "bookmark_title": bookmark_title
                        })
                    pdf_scene_mappings.sort(key=lambda x: x.get("page_number", 0))
                    parsed_scene_mappings = {"scenes": pdf_scene_mappings}
                    print(f"[IMPORT] Auto-generated scene_mappings with {len(pdf_scene_mappings)} scenes from PDF parsing for project {project_id}")
            except Exception as e:
                print(f"[IMPORT] Could not parse PDF for scene mappings: {e}")

        # Insert new export record
        export_data = {
            "id": str(uuid.uuid4()),
            "project_id": project_id,
            "script_id": script_id,
            "file_url": s3_uri,
            "file_name": file.filename or f"{safe_title}.pdf",
            "file_size": file_size,
            "export_type": export_type,
            "content_type": content_type,
            "page_count": page_count,
            "version_number": next_version,
            "version_label": version_label,
            "created_by": profile_id,
            "is_current": True,
            "scene_mappings": parsed_scene_mappings,
        }

        result = client.table("backlot_continuity_exports").insert(export_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to save export")

        # Add signed URL for response
        export_record = result.data[0]
        # Parse S3 URI (s3://bucket/path) to get bucket and path for signed URL
        export_record["signed_url"] = get_signed_url(BACKLOT_FILES_BUCKET, s3_key)

        return export_record

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error saving continuity export: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/continuity/exports")
async def list_continuity_exports(
    project_id: str,
    authorization: Optional[str] = Header(None)
):
    """List all continuity PDF exports for a project (version history)"""
    from app.services.feature_gates import enforce_project_feature
    enforce_project_feature(project_id, "CONTINUITY")

    try:
        # Get current user
        current_user = await get_user_from_token(authorization)
        if not current_user:
            raise HTTPException(status_code=401, detail="Unauthorized")

        client = get_client()

        # Fetch exports ordered by created_at DESC
        result = client.table("backlot_continuity_exports").select(
            "*, created_by_profile:profiles!created_by(id, full_name, display_name, avatar_url)"
        ).eq("project_id", project_id).order("created_at", desc=True).execute()

        exports = result.data or []

        # Add signed URLs to each export
        for export in exports:
            if export.get("file_url"):
                # Parse S3 URI (s3://bucket/path) to extract path
                file_url = export["file_url"]
                if file_url.startswith("s3://"):
                    parts = file_url[5:].split("/", 1)  # Remove s3:// and split bucket/path
                    if len(parts) == 2:
                        export["signed_url"] = get_signed_url(parts[0], parts[1])

        return exports

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error listing continuity exports: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/continuity/exports/{export_id}")
async def get_continuity_export(
    project_id: str,
    export_id: str,
    authorization: Optional[str] = Header(None)
):
    """Get a specific continuity export with signed URL"""
    try:
        # Get current user
        current_user = await get_user_from_token(authorization)
        if not current_user:
            raise HTTPException(status_code=401, detail="Unauthorized")

        client = get_client()

        result = client.table("backlot_continuity_exports").select(
            "*, created_by_profile:profiles!created_by(id, full_name, display_name, avatar_url)"
        ).eq("id", export_id).eq("project_id", project_id).single().execute()

        if not result.data:
            raise HTTPException(status_code=404, detail="Export not found")

        export = result.data
        if export.get("file_url"):
            # Parse S3 URI (s3://bucket/path) to extract path
            file_url = export["file_url"]
            if file_url.startswith("s3://"):
                parts = file_url[5:].split("/", 1)  # Remove s3:// and split bucket/path
                if len(parts) == 2:
                    export["signed_url"] = get_signed_url(parts[0], parts[1])

        return export

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting continuity export: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/projects/{project_id}/continuity/exports/{export_id}")
async def delete_continuity_export(
    project_id: str,
    export_id: str,
    authorization: Optional[str] = Header(None)
):
    """Delete a continuity export"""
    try:
        # Get current user
        current_user = await get_user_from_token(authorization)
        if not current_user:
            raise HTTPException(status_code=401, detail="Unauthorized")

        client = get_client()

        # Check if export exists
        existing = client.table("backlot_continuity_exports").select(
            "id, file_url, is_current"
        ).eq("id", export_id).eq("project_id", project_id).single().execute()

        if not existing.data:
            raise HTTPException(status_code=404, detail="Export not found")

        was_current = existing.data.get("is_current", False)

        # Delete the record
        client.table("backlot_continuity_exports").delete().eq("id", export_id).execute()

        # If we deleted the current export, mark the next most recent as current
        if was_current:
            latest = client.table("backlot_continuity_exports").select("id").eq(
                "project_id", project_id
            ).order("created_at", desc=True).limit(1).execute()

            if latest.data:
                client.table("backlot_continuity_exports").update(
                    {"is_current": True}
                ).eq("id", latest.data[0]["id"]).execute()

        # Optionally delete from S3 (commented out to preserve files)
        # s3_uri = existing.data.get("file_url")
        # if s3_uri and s3_uri.startswith("s3://"):
        #     ... delete from S3 ...

        return {"success": True, "message": "Export deleted"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting continuity export: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/projects/{project_id}/continuity/exports/{export_id}")
async def update_continuity_export(
    project_id: str,
    export_id: str,
    version_label: Optional[str] = Body(None, embed=True),
    is_current: Optional[bool] = Body(None, embed=True),
    authorization: Optional[str] = Header(None)
):
    """Update a continuity export (label or set as current)"""
    try:
        # Get current user
        current_user = await get_user_from_token(authorization)
        if not current_user:
            raise HTTPException(status_code=401, detail="Unauthorized")

        client = get_client()

        # Check if export exists
        existing = client.table("backlot_continuity_exports").select(
            "id"
        ).eq("id", export_id).eq("project_id", project_id).single().execute()

        if not existing.data:
            raise HTTPException(status_code=404, detail="Export not found")

        update_data = {}
        if version_label is not None:
            update_data["version_label"] = version_label

        if is_current is True:
            # Unset current from all others first
            client.table("backlot_continuity_exports").update(
                {"is_current": False}
            ).eq("project_id", project_id).execute()
            update_data["is_current"] = True

        if update_data:
            result = client.table("backlot_continuity_exports").update(
                update_data
            ).eq("id", export_id).execute()

            if result.data:
                export = result.data[0]
                if export.get("file_url"):
                    export["signed_url"] = get_signed_url(export["file_url"])
                return export

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating continuity export: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# CONTINUITY EXPORT ANNOTATIONS (Version-Specific)
# =====================================================

# --- Highlights CRUD ---

@router.get("/projects/{project_id}/continuity/exports/{export_id}/highlights")
async def get_export_highlights(
    project_id: str,
    export_id: str,
    page_number: Optional[int] = None,
    authorization: Optional[str] = Header(None)
):
    """Get all highlights for a continuity export, optionally filtered by page"""
    try:
        current_user = await get_user_from_token(authorization)
        if not current_user:
            raise HTTPException(status_code=401, detail="Unauthorized")

        client = get_client()

        # Verify export belongs to project
        export = client.table("backlot_continuity_exports").select("id").eq(
            "id", export_id
        ).eq("project_id", project_id).single().execute()
        if not export.data:
            raise HTTPException(status_code=404, detail="Export not found")

        query = client.table("backlot_continuity_export_highlights").select(
            "*, created_by_profile:profiles!created_by(id, full_name, display_name, avatar_url)"
        ).eq("export_id", export_id)

        if page_number is not None:
            query = query.eq("page_number", page_number)

        result = query.order("created_at").execute()
        return result.data or []

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting export highlights: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/continuity/exports/{export_id}/highlights")
async def create_export_highlight(
    project_id: str,
    export_id: str,
    page_number: int = Body(...),
    x: float = Body(...),
    y: float = Body(...),
    width: float = Body(...),
    height: float = Body(...),
    color: str = Body("yellow"),
    opacity: float = Body(0.3),
    text_content: Optional[str] = Body(None),
    authorization: Optional[str] = Header(None)
):
    """Create a new highlight on a continuity export"""
    try:
        current_user = await get_user_from_token(authorization)
        if not current_user:
            raise HTTPException(status_code=401, detail="Unauthorized")

        client = get_client()

        # Verify export belongs to project
        export = client.table("backlot_continuity_exports").select("id").eq(
            "id", export_id
        ).eq("project_id", project_id).single().execute()
        if not export.data:
            raise HTTPException(status_code=404, detail="Export not found")

        # Get user profile ID
        from app.api.users import get_profile_id_from_cognito_id
        profile_id = get_profile_id_from_cognito_id(current_user["user_id"])

        highlight_data = {
            "id": str(uuid.uuid4()),
            "export_id": export_id,
            "page_number": page_number,
            "x": x,
            "y": y,
            "width": width,
            "height": height,
            "color": color,
            "opacity": opacity,
            "text_content": text_content,
            "created_by": profile_id,
        }

        result = client.table("backlot_continuity_export_highlights").insert(highlight_data).execute()
        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create highlight")

        return result.data[0]

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating export highlight: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/continuity/export-highlights/{highlight_id}")
async def update_export_highlight(
    highlight_id: str,
    x: Optional[float] = Body(None),
    y: Optional[float] = Body(None),
    width: Optional[float] = Body(None),
    height: Optional[float] = Body(None),
    color: Optional[str] = Body(None),
    opacity: Optional[float] = Body(None),
    text_content: Optional[str] = Body(None),
    authorization: Optional[str] = Header(None)
):
    """Update an existing highlight"""
    try:
        current_user = await get_user_from_token(authorization)
        if not current_user:
            raise HTTPException(status_code=401, detail="Unauthorized")

        client = get_client()

        update_data = {"updated_at": datetime.now(timezone.utc).isoformat()}
        if x is not None:
            update_data["x"] = x
        if y is not None:
            update_data["y"] = y
        if width is not None:
            update_data["width"] = width
        if height is not None:
            update_data["height"] = height
        if color is not None:
            update_data["color"] = color
        if opacity is not None:
            update_data["opacity"] = opacity
        if text_content is not None:
            update_data["text_content"] = text_content

        result = client.table("backlot_continuity_export_highlights").update(
            update_data
        ).eq("id", highlight_id).execute()

        if not result.data:
            raise HTTPException(status_code=404, detail="Highlight not found")

        return result.data[0]

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating export highlight: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/continuity/export-highlights/{highlight_id}")
async def delete_export_highlight(
    highlight_id: str,
    authorization: Optional[str] = Header(None)
):
    """Delete a highlight"""
    try:
        current_user = await get_user_from_token(authorization)
        if not current_user:
            raise HTTPException(status_code=401, detail="Unauthorized")

        client = get_client()
        result = client.table("backlot_continuity_export_highlights").delete().eq(
            "id", highlight_id
        ).execute()

        return {"success": True, "message": "Highlight deleted"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting export highlight: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# --- Notes CRUD ---

@router.get("/projects/{project_id}/continuity/exports/{export_id}/notes")
async def get_export_notes(
    project_id: str,
    export_id: str,
    page_number: Optional[int] = None,
    authorization: Optional[str] = Header(None)
):
    """Get all notes for a continuity export, optionally filtered by page"""
    try:
        current_user = await get_user_from_token(authorization)
        if not current_user:
            raise HTTPException(status_code=401, detail="Unauthorized")

        client = get_client()

        # Verify export belongs to project
        export = client.table("backlot_continuity_exports").select("id").eq(
            "id", export_id
        ).eq("project_id", project_id).single().execute()
        if not export.data:
            raise HTTPException(status_code=404, detail="Export not found")

        query = client.table("backlot_continuity_export_notes").select(
            "*, created_by_profile:profiles!created_by(id, full_name, display_name, avatar_url)"
        ).eq("export_id", export_id)

        if page_number is not None:
            query = query.eq("page_number", page_number)

        result = query.order("created_at").execute()
        return result.data or []

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting export notes: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/continuity/exports/{export_id}/notes")
async def create_export_note(
    project_id: str,
    export_id: str,
    page_number: int = Body(...),
    anchor_x: float = Body(...),
    anchor_y: float = Body(...),
    note_text: str = Body(...),
    note_category: str = Body("general"),
    is_critical: bool = Body(False),
    authorization: Optional[str] = Header(None)
):
    """Create a new note on a continuity export"""
    try:
        current_user = await get_user_from_token(authorization)
        if not current_user:
            raise HTTPException(status_code=401, detail="Unauthorized")

        client = get_client()

        # Verify export belongs to project
        export = client.table("backlot_continuity_exports").select("id").eq(
            "id", export_id
        ).eq("project_id", project_id).single().execute()
        if not export.data:
            raise HTTPException(status_code=404, detail="Export not found")

        # Get user profile ID
        from app.api.users import get_profile_id_from_cognito_id
        profile_id = get_profile_id_from_cognito_id(current_user["user_id"])

        note_data = {
            "id": str(uuid.uuid4()),
            "export_id": export_id,
            "page_number": page_number,
            "anchor_x": anchor_x,
            "anchor_y": anchor_y,
            "note_text": note_text,
            "note_category": note_category,
            "is_critical": is_critical,
            "created_by": profile_id,
        }

        result = client.table("backlot_continuity_export_notes").insert(note_data).execute()
        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create note")

        return result.data[0]

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating export note: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/continuity/export-notes/{note_id}")
async def update_export_note(
    note_id: str,
    anchor_x: Optional[float] = Body(None),
    anchor_y: Optional[float] = Body(None),
    note_text: Optional[str] = Body(None),
    note_category: Optional[str] = Body(None),
    is_critical: Optional[bool] = Body(None),
    authorization: Optional[str] = Header(None)
):
    """Update an existing note"""
    try:
        current_user = await get_user_from_token(authorization)
        if not current_user:
            raise HTTPException(status_code=401, detail="Unauthorized")

        client = get_client()

        update_data = {"updated_at": datetime.now(timezone.utc).isoformat()}
        if anchor_x is not None:
            update_data["anchor_x"] = anchor_x
        if anchor_y is not None:
            update_data["anchor_y"] = anchor_y
        if note_text is not None:
            update_data["note_text"] = note_text
        if note_category is not None:
            update_data["note_category"] = note_category
        if is_critical is not None:
            update_data["is_critical"] = is_critical

        result = client.table("backlot_continuity_export_notes").update(
            update_data
        ).eq("id", note_id).execute()

        if not result.data:
            raise HTTPException(status_code=404, detail="Note not found")

        return result.data[0]

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating export note: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/continuity/export-notes/{note_id}")
async def delete_export_note(
    note_id: str,
    authorization: Optional[str] = Header(None)
):
    """Delete a note"""
    try:
        current_user = await get_user_from_token(authorization)
        if not current_user:
            raise HTTPException(status_code=401, detail="Unauthorized")

        client = get_client()
        result = client.table("backlot_continuity_export_notes").delete().eq(
            "id", note_id
        ).execute()

        return {"success": True, "message": "Note deleted"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting export note: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# --- Drawings CRUD ---

@router.get("/projects/{project_id}/continuity/exports/{export_id}/drawings")
async def get_export_drawings(
    project_id: str,
    export_id: str,
    page_number: Optional[int] = None,
    authorization: Optional[str] = Header(None)
):
    """Get all drawings for a continuity export, optionally filtered by page"""
    try:
        current_user = await get_user_from_token(authorization)
        if not current_user:
            raise HTTPException(status_code=401, detail="Unauthorized")

        client = get_client()

        # Verify export belongs to project
        export = client.table("backlot_continuity_exports").select("id").eq(
            "id", export_id
        ).eq("project_id", project_id).single().execute()
        if not export.data:
            raise HTTPException(status_code=404, detail="Export not found")

        query = client.table("backlot_continuity_export_drawings").select(
            "*, created_by_profile:profiles!created_by(id, full_name, display_name, avatar_url)"
        ).eq("export_id", export_id)

        if page_number is not None:
            query = query.eq("page_number", page_number)

        result = query.order("created_at").execute()
        return result.data or []

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting export drawings: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/continuity/exports/{export_id}/drawings")
async def create_export_drawing(
    project_id: str,
    export_id: str,
    page_number: int = Body(...),
    tool_type: str = Body(...),
    path_data: dict = Body(...),
    stroke_color: str = Body("#FF0000"),
    stroke_width: float = Body(2),
    fill_color: Optional[str] = Body(None),
    opacity: float = Body(1.0),
    text_content: Optional[str] = Body(None),
    font_size: float = Body(12),
    authorization: Optional[str] = Header(None)
):
    """Create a new drawing on a continuity export"""
    try:
        current_user = await get_user_from_token(authorization)
        if not current_user:
            raise HTTPException(status_code=401, detail="Unauthorized")

        client = get_client()

        # Verify export belongs to project
        export = client.table("backlot_continuity_exports").select("id").eq(
            "id", export_id
        ).eq("project_id", project_id).single().execute()
        if not export.data:
            raise HTTPException(status_code=404, detail="Export not found")

        # Get user profile ID
        from app.api.users import get_profile_id_from_cognito_id
        profile_id = get_profile_id_from_cognito_id(current_user["user_id"])

        drawing_data = {
            "id": str(uuid.uuid4()),
            "export_id": export_id,
            "page_number": page_number,
            "tool_type": tool_type,
            "path_data": path_data,
            "stroke_color": stroke_color,
            "stroke_width": stroke_width,
            "fill_color": fill_color,
            "opacity": opacity,
            "text_content": text_content,
            "font_size": font_size,
            "created_by": profile_id,
        }

        result = client.table("backlot_continuity_export_drawings").insert(drawing_data).execute()
        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create drawing")

        return result.data[0]

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating export drawing: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/continuity/export-drawings/{drawing_id}")
async def update_export_drawing(
    drawing_id: str,
    path_data: Optional[dict] = Body(None),
    stroke_color: Optional[str] = Body(None),
    stroke_width: Optional[float] = Body(None),
    fill_color: Optional[str] = Body(None),
    opacity: Optional[float] = Body(None),
    text_content: Optional[str] = Body(None),
    font_size: Optional[float] = Body(None),
    authorization: Optional[str] = Header(None)
):
    """Update an existing drawing"""
    try:
        current_user = await get_user_from_token(authorization)
        if not current_user:
            raise HTTPException(status_code=401, detail="Unauthorized")

        client = get_client()

        update_data = {"updated_at": datetime.now(timezone.utc).isoformat()}
        if path_data is not None:
            update_data["path_data"] = path_data
        if stroke_color is not None:
            update_data["stroke_color"] = stroke_color
        if stroke_width is not None:
            update_data["stroke_width"] = stroke_width
        if fill_color is not None:
            update_data["fill_color"] = fill_color
        if opacity is not None:
            update_data["opacity"] = opacity
        if text_content is not None:
            update_data["text_content"] = text_content
        if font_size is not None:
            update_data["font_size"] = font_size

        result = client.table("backlot_continuity_export_drawings").update(
            update_data
        ).eq("id", drawing_id).execute()

        if not result.data:
            raise HTTPException(status_code=404, detail="Drawing not found")

        return result.data[0]

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating export drawing: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/continuity/export-drawings/{drawing_id}")
async def delete_export_drawing(
    drawing_id: str,
    authorization: Optional[str] = Header(None)
):
    """Delete a drawing"""
    try:
        current_user = await get_user_from_token(authorization)
        if not current_user:
            raise HTTPException(status_code=401, detail="Unauthorized")

        client = get_client()
        result = client.table("backlot_continuity_export_drawings").delete().eq(
            "id", drawing_id
        ).execute()

        return {"success": True, "message": "Drawing deleted"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting export drawing: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# SCRIPT SIDES
# =====================================================

@router.get("/projects/{project_id}/script-sides")
async def list_script_sides(
    project_id: str,
    production_day_id: Optional[str] = None,
    call_sheet_id: Optional[str] = None,
    status: Optional[str] = None,
    authorization: Optional[str] = Header(None)
):
    """
    List all script sides exports for a project.
    Can filter by production_day_id, call_sheet_id, or status.
    Returns grouped by production day with scene counts.
    """
    try:
        current_user = await get_user_from_token(authorization)
        if not current_user:
            raise HTTPException(status_code=401, detail="Unauthorized")

        client = get_client()

        # Build query for sides exports
        query = client.table("backlot_continuity_exports").select(
            "*, production_day:backlot_production_days!production_day_id(id, day_number, date, title)"
        ).eq("project_id", project_id).eq("export_type", "sides")

        if production_day_id:
            query = query.eq("production_day_id", production_day_id)
        if call_sheet_id:
            query = query.eq("call_sheet_id", call_sheet_id)
        if status:
            query = query.eq("status", status)

        query = query.order("created_at", desc=True)
        result = query.execute()

        sides = result.data or []

        # Generate signed URLs for each
        for side in sides:
            if side.get("file_url"):
                side["signed_url"] = generate_signed_url(side["file_url"])
            # Parse scene count from extracted_scene_ids
            if side.get("extracted_scene_ids"):
                if isinstance(side["extracted_scene_ids"], list):
                    side["scene_count"] = len(side["extracted_scene_ids"])
                else:
                    side["scene_count"] = 0
            else:
                side["scene_count"] = 0

        return {"exports": sides}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error listing script sides: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/script-sides/check-outdated")
async def check_outdated_sides(
    project_id: str,
    authorization: Optional[str] = Header(None)
):
    """
    Check which script sides packets are outdated based on
    comparing their extracted_scene_ids with current call sheet/day scenes.
    """
    try:
        current_user = await get_user_from_token(authorization)
        if not current_user:
            raise HTTPException(status_code=401, detail="Unauthorized")

        client = get_client()
        outdated = []

        # Get all sides packets
        sides_result = client.table("backlot_continuity_exports").select(
            "id, file_name, production_day_id, call_sheet_id, extracted_scene_ids"
        ).eq("project_id", project_id).eq("export_type", "sides").execute()

        for side in sides_result.data or []:
            is_outdated = False
            current_scene_ids = []

            # Check production day scenes
            if side.get("production_day_id"):
                day_scenes = client.table("backlot_production_day_scenes").select(
                    "scene_id"
                ).eq("production_day_id", side["production_day_id"]).execute()
                current_scene_ids = [s["scene_id"] for s in (day_scenes.data or [])]

            # Check call sheet scenes
            elif side.get("call_sheet_id"):
                cs_scenes = client.table("backlot_call_sheet_scene_links").select(
                    "scene_id"
                ).eq("call_sheet_id", side["call_sheet_id"]).execute()
                current_scene_ids = [s["scene_id"] for s in (cs_scenes.data or [])]

            # Compare with extracted_scene_ids
            extracted = side.get("extracted_scene_ids") or []
            if set(extracted) != set(current_scene_ids) and current_scene_ids:
                is_outdated = True

            if is_outdated:
                outdated.append({
                    "export_id": side["id"],
                    "file_name": side["file_name"],
                    "production_day_id": side.get("production_day_id"),
                    "call_sheet_id": side.get("call_sheet_id"),
                    "extracted_scene_ids": extracted,
                    "current_scene_ids": current_scene_ids,
                    "missing_scenes": list(set(current_scene_ids) - set(extracted)),
                    "extra_scenes": list(set(extracted) - set(current_scene_ids))
                })

        return {"outdated": outdated}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error checking outdated sides: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/script-sides/{export_id}")
async def get_script_side(
    project_id: str,
    export_id: str,
    authorization: Optional[str] = Header(None)
):
    """Get a single script sides export with signed URL"""
    try:
        current_user = await get_user_from_token(authorization)
        if not current_user:
            raise HTTPException(status_code=401, detail="Unauthorized")

        client = get_client()
        result = client.table("backlot_continuity_exports").select(
            "*, production_day:backlot_production_days!production_day_id(id, day_number, date, title), "
            "call_sheet:backlot_call_sheets!call_sheet_id(id, title, date), "
            "source_export:backlot_continuity_exports!source_export_id(id, file_name, version_label)"
        ).eq("id", export_id).eq("project_id", project_id).single().execute()

        if not result.data:
            raise HTTPException(status_code=404, detail="Script sides not found")

        side = result.data
        if side.get("file_url"):
            side["signed_url"] = generate_signed_url(side["file_url"])

        return side

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting script side: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/script-sides/generate")
async def generate_script_sides(
    project_id: str,
    scene_ids: List[str] = Body(...),
    production_day_id: Optional[str] = Body(None),
    call_sheet_id: Optional[str] = Body(None),
    title: Optional[str] = Body(None),
    authorization: Optional[str] = Header(None)
):
    """
    Generate script sides PDF by extracting pages from master script.
    Requires scene_ids and optionally links to production_day or call_sheet.
    """
    try:
        current_user = await get_user_from_token(authorization)
        if not current_user:
            raise HTTPException(status_code=401, detail="Unauthorized")

        if not scene_ids:
            raise HTTPException(status_code=400, detail="scene_ids required")

        client = get_client()

        # Find the current master script export
        master_result = client.table("backlot_continuity_exports").select("*").eq(
            "project_id", project_id
        ).eq("export_type", "script").eq("is_current", True).single().execute()

        if not master_result.data:
            raise HTTPException(
                status_code=400,
                detail="No master script found. Please upload a script in the Continuity tab first."
            )

        master_export = master_result.data
        scene_mappings = master_export.get("scene_mappings", {})

        # Auto-generate scene_mappings from project scenes if not present
        if not scene_mappings or not scene_mappings.get("scenes"):
            scenes_result = client.table("backlot_scenes").select(
                "id, scene_number, int_ext, location_hint, set_name, page_start, page_end"
            ).eq("project_id", project_id).execute()
            scenes_list = scenes_result.data or []

            auto_scene_mappings = []
            for scene in scenes_list:
                raw_page_start = scene.get("page_start")
                if raw_page_start is None:
                    continue

                try:
                    start_page = int(float(raw_page_start))
                except (ValueError, TypeError):
                    continue

                int_ext = (scene.get("int_ext") or "").upper()
                location = scene.get("location_hint") or scene.get("set_name") or ""
                bookmark_title = f"Scene {scene.get('scene_number', '?')}"
                if int_ext or location:
                    bookmark_title += f" - {int_ext} {location}".strip()

                auto_scene_mappings.append({
                    "scene_number": scene.get("scene_number"),
                    "scene_id": str(scene.get("id")),
                    "page_number": start_page,
                    "bookmark_title": bookmark_title
                })

            auto_scene_mappings.sort(key=lambda x: x.get("page_number", 0))

            if auto_scene_mappings:
                scene_mappings = {"scenes": auto_scene_mappings}
                # Update the export record with auto-generated mappings
                client.table("backlot_continuity_exports").update({
                    "scene_mappings": scene_mappings
                }).eq("id", master_export["id"]).execute()
                print(f"[SCRIPT SIDES] Auto-generated scene_mappings with {len(auto_scene_mappings)} scenes from database")
            else:
                # Fallback: Parse the master PDF directly to extract scene mappings
                try:
                    import boto3
                    from io import BytesIO
                    from app.utils.script_parser import parse_pdf

                    # Download the master PDF
                    s3_client = boto3.client("s3")
                    file_url = master_export.get("file_url", "")
                    if file_url.startswith("s3://"):
                        parts = file_url[5:].split("/", 1)
                        bucket = parts[0]
                        key = parts[1]
                        response = s3_client.get_object(Bucket=bucket, Key=key)
                        pdf_content = response["Body"].read()

                        # Parse the PDF for scenes
                        parse_result = parse_pdf(pdf_content)
                        if parse_result.scenes:
                            pdf_scene_mappings = []
                            for scene in parse_result.scenes:
                                bookmark_title = f"Scene {scene.scene_number}"
                                if scene.int_ext or scene.location_hint:
                                    bookmark_title += f" - {(scene.int_ext or '').upper()} {scene.location_hint or ''}".strip()
                                pdf_scene_mappings.append({
                                    "scene_number": scene.scene_number,
                                    "scene_id": None,
                                    "page_number": scene.page_start or 1,
                                    "bookmark_title": bookmark_title
                                })
                            pdf_scene_mappings.sort(key=lambda x: x.get("page_number", 0))
                            scene_mappings = {"scenes": pdf_scene_mappings}
                            # Update the export record
                            client.table("backlot_continuity_exports").update({
                                "scene_mappings": scene_mappings
                            }).eq("id", master_export["id"]).execute()
                            print(f"[SCRIPT SIDES] Auto-generated scene_mappings with {len(pdf_scene_mappings)} scenes from PDF parsing")
                        else:
                            raise HTTPException(
                                status_code=400,
                                detail="Could not detect scenes in the master script PDF."
                            )
                    else:
                        raise HTTPException(
                            status_code=400,
                            detail="Master script file not found in storage."
                        )
                except HTTPException:
                    raise
                except Exception as e:
                    print(f"[SCRIPT SIDES] PDF parsing fallback failed: {e}")
                    raise HTTPException(
                        status_code=400,
                        detail="No scenes with page mappings found and could not parse PDF."
                    )

        # Find page ranges for requested scenes
        pages_to_extract = []
        scene_mapping_list = scene_mappings.get("scenes", [])

        # Build maps for both scene_id and scene_number lookups
        scene_id_to_pages = {}
        scene_number_to_pages = {}
        for i, mapping in enumerate(scene_mapping_list):
            scene_id = mapping.get("scene_id")
            scene_number = str(mapping.get("scene_number", ""))
            start_page = mapping.get("page_number", 1)

            # Calculate end page (next scene's start - 1, or use last page)
            if i + 1 < len(scene_mapping_list):
                end_page = scene_mapping_list[i + 1].get("page_number", start_page) - 1
            else:
                end_page = master_export.get("page_count", start_page)

            if end_page < start_page:
                end_page = start_page

            page_info = {
                "start_page": start_page,
                "end_page": end_page,
                "scene_number": scene_number
            }

            if scene_id:
                scene_id_to_pages[scene_id] = page_info
            if scene_number:
                scene_number_to_pages[scene_number] = page_info

        # Get scene numbers for requested scene_ids (for fallback matching)
        requested_scene_numbers = {}
        if scene_ids:
            scenes_result = client.table("backlot_scenes").select("id, scene_number").in_("id", scene_ids).execute()
            for scene in (scenes_result.data or []):
                requested_scene_numbers[str(scene["id"])] = str(scene.get("scene_number", ""))

        # Collect pages for requested scenes (try scene_id first, then scene_number)
        for scene_id in scene_ids:
            page_info = None
            if scene_id in scene_id_to_pages:
                page_info = scene_id_to_pages[scene_id]
            elif scene_id in requested_scene_numbers:
                scene_num = requested_scene_numbers[scene_id]
                if scene_num in scene_number_to_pages:
                    page_info = scene_number_to_pages[scene_num]

            if page_info:
                for page in range(page_info["start_page"], page_info["end_page"] + 1):
                    if page not in pages_to_extract:
                        pages_to_extract.append(page)

        pages_to_extract.sort()

        if not pages_to_extract:
            raise HTTPException(
                status_code=400,
                detail="No pages found for the requested scenes. Scene mappings may not match database scenes."
            )

        # Download master PDF from S3
        import boto3
        from io import BytesIO

        s3_client = boto3.client("s3")
        master_url = master_export["file_url"]

        # Parse S3 URI
        if master_url.startswith("s3://"):
            parts = master_url[5:].split("/", 1)
            bucket = parts[0]
            key = parts[1]
        else:
            raise HTTPException(status_code=500, detail="Invalid master PDF URL format")

        # Download the master PDF
        response = s3_client.get_object(Bucket=bucket, Key=key)
        master_pdf_bytes = response["Body"].read()

        # Extract pages using PyPDF2
        try:
            from PyPDF2 import PdfReader, PdfWriter
        except ImportError:
            raise HTTPException(
                status_code=500,
                detail="PyPDF2 not installed. Please install it to enable PDF extraction."
            )

        reader = PdfReader(BytesIO(master_pdf_bytes))
        writer = PdfWriter()

        for page_num in pages_to_extract:
            # PyPDF2 uses 0-based indexing
            if 0 <= page_num - 1 < len(reader.pages):
                writer.add_page(reader.pages[page_num - 1])

        # Write extracted PDF to bytes
        output = BytesIO()
        writer.write(output)
        extracted_pdf_bytes = output.getvalue()

        # Generate file name
        day_label = ""
        if production_day_id:
            day_result = client.table("backlot_production_days").select(
                "day_number, date"
            ).eq("id", production_day_id).single().execute()
            if day_result.data:
                day_label = f"Day{day_result.data['day_number']}_"

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        file_name = f"sides_{day_label}{timestamp}.pdf"

        # Upload to S3
        sides_key = f"projects/{project_id}/sides/{file_name}"
        s3_bucket = os.environ.get("AWS_S3_BACKLOT_BUCKET", "swn-backlot-517220555400")

        s3_client.put_object(
            Bucket=s3_bucket,
            Key=sides_key,
            Body=extracted_pdf_bytes,
            ContentType="application/pdf"
        )

        s3_uri = f"s3://{s3_bucket}/{sides_key}"

        # Get next version number
        version_result = client.table("backlot_continuity_exports").select(
            "version_number"
        ).eq("project_id", project_id).eq("export_type", "sides").order(
            "version_number", desc=True
        ).limit(1).execute()

        next_version = 1
        if version_result.data:
            next_version = (version_result.data[0].get("version_number", 0) or 0) + 1

        # Create the sides export record
        # Use execute_insert for proper JSONB handling
        import json
        new_sides = execute_insert(
            """INSERT INTO backlot_continuity_exports
               (project_id, file_url, file_name, file_size, export_type, page_count,
                version_number, version_label, production_day_id, call_sheet_id,
                source_export_id, extracted_scene_ids, status, created_by, is_current)
               VALUES (:project_id, :file_url, :file_name, :file_size, :export_type, :page_count,
                       :version_number, :version_label, :production_day_id, :call_sheet_id,
                       :source_export_id, CAST(:extracted_scene_ids AS jsonb), :status, :created_by, :is_current)
               RETURNING *""",
            {
                "project_id": project_id,
                "file_url": s3_uri,
                "file_name": title or file_name,
                "file_size": len(extracted_pdf_bytes),
                "export_type": "sides",
                "page_count": len(pages_to_extract),
                "version_number": next_version,
                "version_label": title,
                "production_day_id": production_day_id,
                "call_sheet_id": call_sheet_id,
                "source_export_id": master_export["id"],
                "extracted_scene_ids": json.dumps(scene_ids),
                "status": "draft",
                "created_by": current_user.get("profile_id") or current_user.get("user_id"),
                "is_current": False
            }
        )

        if not new_sides:
            raise HTTPException(status_code=500, detail="Failed to create sides record")
        new_sides["signed_url"] = generate_signed_url(s3_uri)
        new_sides["scene_count"] = len(scene_ids)

        return new_sides

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error generating script sides: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/script-sides/{export_id}/regenerate")
async def regenerate_script_sides(
    project_id: str,
    export_id: str,
    scene_ids: Optional[List[str]] = Body(None),
    authorization: Optional[str] = Header(None)
):
    """
    Regenerate script sides PDF with updated scenes.
    If scene_ids not provided, uses the existing scene_ids from the export.
    """
    try:
        current_user = await get_user_from_token(authorization)
        if not current_user:
            raise HTTPException(status_code=401, detail="Unauthorized")

        client = get_client()

        # Get the existing sides export
        existing_result = client.table("backlot_continuity_exports").select("*").eq(
            "id", export_id
        ).eq("project_id", project_id).single().execute()

        if not existing_result.data:
            raise HTTPException(status_code=404, detail="Script sides not found")

        existing = existing_result.data

        # Use existing scene_ids if not provided
        if scene_ids is None:
            scene_ids = existing.get("extracted_scene_ids", [])

        if not scene_ids:
            raise HTTPException(status_code=400, detail="No scene_ids to regenerate")

        # Delete old file from S3
        if existing.get("file_url"):
            try:
                import boto3
                s3_client = boto3.client("s3")
                old_url = existing["file_url"]
                if old_url.startswith("s3://"):
                    parts = old_url[5:].split("/", 1)
                    bucket = parts[0]
                    key = parts[1]
                    s3_client.delete_object(Bucket=bucket, Key=key)
            except Exception as e:
                print(f"Warning: Could not delete old sides file: {e}")

        # Generate new sides using the generate endpoint logic
        # (reusing the generation logic inline)
        master_result = client.table("backlot_continuity_exports").select("*").eq(
            "project_id", project_id
        ).eq("export_type", "script").eq("is_current", True).single().execute()

        if not master_result.data:
            raise HTTPException(status_code=400, detail="No master script found")

        master_export = master_result.data
        scene_mappings = master_export.get("scene_mappings", {})

        # Auto-generate scene_mappings from project scenes if not present
        if not scene_mappings or not scene_mappings.get("scenes"):
            scenes_result = client.table("backlot_scenes").select(
                "id, scene_number, int_ext, location_hint, set_name, page_start, page_end"
            ).eq("project_id", project_id).execute()
            scenes_list = scenes_result.data or []

            auto_scene_mappings = []
            for scene in scenes_list:
                raw_page_start = scene.get("page_start")
                if raw_page_start is None:
                    continue

                try:
                    start_page = int(float(raw_page_start))
                except (ValueError, TypeError):
                    continue

                int_ext = (scene.get("int_ext") or "").upper()
                location = scene.get("location_hint") or scene.get("set_name") or ""
                bookmark_title = f"Scene {scene.get('scene_number', '?')}"
                if int_ext or location:
                    bookmark_title += f" - {int_ext} {location}".strip()

                auto_scene_mappings.append({
                    "scene_number": scene.get("scene_number"),
                    "scene_id": str(scene.get("id")),
                    "page_number": start_page,
                    "bookmark_title": bookmark_title
                })

            auto_scene_mappings.sort(key=lambda x: x.get("page_number", 0))

            if auto_scene_mappings:
                scene_mappings = {"scenes": auto_scene_mappings}
                client.table("backlot_continuity_exports").update({
                    "scene_mappings": scene_mappings
                }).eq("id", master_export["id"]).execute()
                print(f"[REGENERATE SIDES] Auto-generated scene_mappings with {len(auto_scene_mappings)} scenes from database")
            else:
                # Fallback: Parse the master PDF directly
                try:
                    import boto3
                    from io import BytesIO
                    from app.utils.script_parser import parse_pdf

                    s3_client = boto3.client("s3")
                    file_url = master_export.get("file_url", "")
                    if file_url.startswith("s3://"):
                        parts = file_url[5:].split("/", 1)
                        bucket = parts[0]
                        key = parts[1]
                        response = s3_client.get_object(Bucket=bucket, Key=key)
                        pdf_content = response["Body"].read()

                        parse_result = parse_pdf(pdf_content)
                        if parse_result.scenes:
                            pdf_scene_mappings = []
                            for scene in parse_result.scenes:
                                bookmark_title = f"Scene {scene.scene_number}"
                                if scene.int_ext or scene.location_hint:
                                    bookmark_title += f" - {(scene.int_ext or '').upper()} {scene.location_hint or ''}".strip()
                                pdf_scene_mappings.append({
                                    "scene_number": scene.scene_number,
                                    "scene_id": None,
                                    "page_number": scene.page_start or 1,
                                    "bookmark_title": bookmark_title
                                })
                            pdf_scene_mappings.sort(key=lambda x: x.get("page_number", 0))
                            scene_mappings = {"scenes": pdf_scene_mappings}
                            client.table("backlot_continuity_exports").update({
                                "scene_mappings": scene_mappings
                            }).eq("id", master_export["id"]).execute()
                            print(f"[REGENERATE SIDES] Auto-generated scene_mappings with {len(pdf_scene_mappings)} scenes from PDF parsing")
                        else:
                            raise HTTPException(status_code=400, detail="Could not detect scenes in master script PDF.")
                    else:
                        raise HTTPException(status_code=400, detail="Master script file not found.")
                except HTTPException:
                    raise
                except Exception as e:
                    print(f"[REGENERATE SIDES] PDF parsing fallback failed: {e}")
                    raise HTTPException(status_code=400, detail="No scenes with page mappings found and could not parse PDF.")

        # Find page ranges
        pages_to_extract = []
        scene_mapping_list = scene_mappings.get("scenes", [])
        scene_id_to_pages = {}
        scene_number_to_pages = {}

        for i, mapping in enumerate(scene_mapping_list):
            scene_id = mapping.get("scene_id")
            scene_number = str(mapping.get("scene_number", ""))
            start_page = mapping.get("page_number", 1)
            if i + 1 < len(scene_mapping_list):
                end_page = scene_mapping_list[i + 1].get("page_number", start_page) - 1
            else:
                end_page = master_export.get("page_count", start_page)
            if end_page < start_page:
                end_page = start_page
            page_info = {"start_page": start_page, "end_page": end_page, "scene_number": scene_number}
            if scene_id:
                scene_id_to_pages[scene_id] = page_info
            if scene_number:
                scene_number_to_pages[scene_number] = page_info

        # Get scene numbers for requested scene_ids (for fallback matching)
        requested_scene_numbers = {}
        if scene_ids:
            scenes_result = client.table("backlot_scenes").select("id, scene_number").in_("id", scene_ids).execute()
            for scene in (scenes_result.data or []):
                requested_scene_numbers[str(scene["id"])] = str(scene.get("scene_number", ""))

        for scene_id in scene_ids:
            page_info = None
            if scene_id in scene_id_to_pages:
                page_info = scene_id_to_pages[scene_id]
            elif scene_id in requested_scene_numbers:
                scene_num = requested_scene_numbers[scene_id]
                if scene_num in scene_number_to_pages:
                    page_info = scene_number_to_pages[scene_num]

            if page_info:
                for page in range(page_info["start_page"], page_info["end_page"] + 1):
                    if page not in pages_to_extract:
                        pages_to_extract.append(page)

        pages_to_extract.sort()

        if not pages_to_extract:
            raise HTTPException(status_code=400, detail="No pages found for scenes")

        # Download and extract
        import boto3
        from io import BytesIO

        s3_client = boto3.client("s3")
        master_url = master_export["file_url"]
        parts = master_url[5:].split("/", 1)
        bucket = parts[0]
        key = parts[1]

        response = s3_client.get_object(Bucket=bucket, Key=key)
        master_pdf_bytes = response["Body"].read()

        from PyPDF2 import PdfReader, PdfWriter
        reader = PdfReader(BytesIO(master_pdf_bytes))
        writer = PdfWriter()

        for page_num in pages_to_extract:
            if 0 <= page_num - 1 < len(reader.pages):
                writer.add_page(reader.pages[page_num - 1])

        output = BytesIO()
        writer.write(output)
        extracted_pdf_bytes = output.getvalue()

        # Upload new file
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        file_name = f"sides_regenerated_{timestamp}.pdf"
        sides_key = f"projects/{project_id}/sides/{file_name}"
        s3_bucket = os.environ.get("AWS_S3_BACKLOT_BUCKET", "swn-backlot-517220555400")

        s3_client.put_object(
            Bucket=s3_bucket,
            Key=sides_key,
            Body=extracted_pdf_bytes,
            ContentType="application/pdf"
        )

        s3_uri = f"s3://{s3_bucket}/{sides_key}"

        # Update the record using raw SQL for proper JSONB handling
        import json
        updated = execute_insert(
            """UPDATE backlot_continuity_exports
               SET file_url = :file_url,
                   file_size = :file_size,
                   page_count = :page_count,
                   extracted_scene_ids = CAST(:extracted_scene_ids AS jsonb),
                   source_export_id = :source_export_id,
                   updated_at = NOW()
               WHERE id = :export_id
               RETURNING *""",
            {
                "file_url": s3_uri,
                "file_size": len(extracted_pdf_bytes),
                "page_count": len(pages_to_extract),
                "extracted_scene_ids": json.dumps(scene_ids),
                "source_export_id": master_export["id"],
                "export_id": export_id
            }
        )

        if not updated:
            raise HTTPException(status_code=500, detail="Failed to update sides record")
        updated["signed_url"] = generate_signed_url(s3_uri)
        updated["scene_count"] = len(scene_ids)

        return updated

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error regenerating script sides: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/projects/{project_id}/script-sides/{export_id}")
async def update_script_side(
    project_id: str,
    export_id: str,
    title: Optional[str] = Body(None, embed=True),
    status: Optional[str] = Body(None, embed=True),
    authorization: Optional[str] = Header(None)
):
    """Update script sides metadata (title, status)"""
    try:
        current_user = await get_user_from_token(authorization)
        if not current_user:
            raise HTTPException(status_code=401, detail="Unauthorized")

        client = get_client()
        update_data = {}

        if title is not None:
            update_data["version_label"] = title
            update_data["file_name"] = title
        if status is not None:
            if status not in ["draft", "published", "sent"]:
                raise HTTPException(status_code=400, detail="Invalid status")
            update_data["status"] = status

        if not update_data:
            raise HTTPException(status_code=400, detail="No fields to update")

        result = client.table("backlot_continuity_exports").update(
            update_data
        ).eq("id", export_id).eq("project_id", project_id).execute()

        if not result.data:
            raise HTTPException(status_code=404, detail="Script sides not found")

        return result.data[0]

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating script side: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/projects/{project_id}/script-sides/{export_id}")
async def delete_script_side(
    project_id: str,
    export_id: str,
    authorization: Optional[str] = Header(None)
):
    """Delete a script sides export"""
    try:
        current_user = await get_user_from_token(authorization)
        if not current_user:
            raise HTTPException(status_code=401, detail="Unauthorized")

        client = get_client()

        # Get the export to find file URL
        existing = client.table("backlot_continuity_exports").select(
            "file_url"
        ).eq("id", export_id).eq("project_id", project_id).single().execute()

        if not existing.data:
            raise HTTPException(status_code=404, detail="Script sides not found")

        # Delete from S3
        if existing.data.get("file_url"):
            try:
                import boto3
                s3_client = boto3.client("s3")
                file_url = existing.data["file_url"]
                if file_url.startswith("s3://"):
                    parts = file_url[5:].split("/", 1)
                    bucket = parts[0]
                    key = parts[1]
                    s3_client.delete_object(Bucket=bucket, Key=key)
            except Exception as e:
                print(f"Warning: Could not delete S3 file: {e}")

        # Delete the record
        client.table("backlot_continuity_exports").delete().eq(
            "id", export_id
        ).execute()

        return {"success": True, "message": "Script sides deleted"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting script side: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# CASTING & CREW HIRING PIPELINE
# =====================================================

# =====================================================
# Pydantic Models for Casting & Crew
# =====================================================

class ProjectRoleInput(BaseModel):
    """Input for creating/updating a project role"""
    type: Literal["cast", "crew"]
    title: str
    description: Optional[str] = None
    department: Optional[str] = None
    character_name: Optional[str] = None
    character_description: Optional[str] = None
    age_range: Optional[str] = None
    gender_requirement: Optional[str] = None
    cast_position_type_id: Optional[str] = None
    location: Optional[str] = None
    start_date: Optional[str] = None
    end_date: Optional[str] = None
    days_estimated: Optional[float] = None
    paid: bool = False
    rate_description: Optional[str] = None
    rate_amount_cents: Optional[int] = None
    rate_type: Optional[Literal["flat", "daily", "weekly", "hourly"]] = None
    is_order_only: bool = False
    is_featured: bool = False
    status: Optional[Literal["draft", "open", "closed", "booked", "cancelled"]] = "open"
    requires_reel: bool = False
    requires_headshot: bool = False
    requires_self_tape: bool = False
    tape_instructions: Optional[str] = None
    tape_format_preferences: Optional[str] = None
    tape_workflow: Optional[Literal["upfront", "after_shortlist"]] = "upfront"
    application_deadline: Optional[str] = None
    max_applications: Optional[int] = None


class RoleApplicationInput(BaseModel):
    """Input for creating a role application"""
    elevator_pitch: Optional[str] = Field(None, max_length=100)
    cover_note: Optional[str] = None
    availability_notes: Optional[str] = None
    rate_expectation: Optional[str] = None
    reel_url: Optional[str] = None
    headshot_url: Optional[str] = None
    resume_url: Optional[str] = None
    selected_credit_ids: Optional[List[str]] = None
    template_id: Optional[str] = None
    local_hire_confirmed: Optional[bool] = None
    is_promoted: bool = False
    save_as_template: bool = False
    template_name: Optional[str] = None
    # Cast-specific fields
    demo_reel_url: Optional[str] = None
    self_tape_url: Optional[str] = None
    special_skills: Optional[List[str]] = None


class ApplicationStatusUpdate(BaseModel):
    """Input for updating application status"""
    status: Literal["applied", "viewed", "shortlisted", "interview", "offered", "booked", "rejected", "withdrawn"]
    internal_notes: Optional[str] = None
    rating: Optional[int] = Field(None, ge=1, le=5)


class UserAvailabilityInput(BaseModel):
    """Input for setting user availability"""
    date: str
    status: Literal["available", "unavailable", "hold", "booked", "tentative"]
    notes: Optional[str] = None
    project_id: Optional[str] = None


class BulkAvailabilityInput(BaseModel):
    """Input for setting availability for a date range"""
    start_date: str
    end_date: str
    status: Literal["available", "unavailable", "hold", "tentative"]
    notes: Optional[str] = None


class CrewRateInput(BaseModel):
    """Input for creating/updating crew rates"""
    user_id: Optional[str] = None
    role_id: Optional[str] = None
    rate_type: Literal["hourly", "daily", "weekly", "flat"]
    rate_amount: float
    overtime_multiplier: Optional[float] = 1.5
    double_time_multiplier: Optional[float] = 2.0
    kit_rental_rate: Optional[float] = None
    car_allowance: Optional[float] = None
    phone_allowance: Optional[float] = None
    effective_start: Optional[str] = None
    effective_end: Optional[str] = None
    notes: Optional[str] = None


# =====================================================
# Deal Memo Models
# =====================================================

class DealMemoInput(BaseModel):
    """Input for creating/updating deal memos"""
    role_id: Optional[str] = None
    user_id: str
    position_title: str
    rate_type: Literal["hourly", "daily", "weekly", "flat"]
    rate_amount: float
    overtime_multiplier: Optional[float] = 1.5
    double_time_multiplier: Optional[float] = 2.0
    kit_rental_rate: Optional[float] = None
    car_allowance: Optional[float] = None
    phone_allowance: Optional[float] = None
    per_diem_rate: Optional[float] = None
    start_date: Optional[str] = None
    end_date: Optional[str] = None
    additional_terms: Optional[Dict[str, Any]] = Field(default_factory=dict)
    notes: Optional[str] = None


class DealMemoSendRequest(BaseModel):
    """Request to send a deal memo for signature"""
    signer_email: str
    signer_name: str
    email_subject: Optional[str] = None
    email_body: Optional[str] = None


# =====================================================
# Credit Preference Models
# =====================================================

class CreditPreferenceInput(BaseModel):
    """Input for creating/updating credit preferences"""
    project_id: Optional[str] = None
    role_id: Optional[str] = None
    display_name: Optional[str] = None
    role_title_preference: Optional[str] = None
    department_preference: Optional[str] = None
    endorsement_note: Optional[str] = None
    imdb_id: Optional[str] = None
    use_as_default: Optional[bool] = False
    is_public: Optional[bool] = True


# =====================================================
# DocuSign Webhook Models
# =====================================================

class DocuSignWebhookPayload(BaseModel):
    """DocuSign Connect webhook payload"""
    event: str
    apiVersion: Optional[str] = None
    uri: Optional[str] = None
    retryCount: Optional[int] = None
    configurationId: Optional[int] = None
    generatedDateTime: Optional[str] = None
    data: Optional[Dict[str, Any]] = None


# =====================================================
# Helper: Check Order Membership
# =====================================================

async def check_is_order_member(client, user_id: str) -> bool:
    """Check if a user is an active Order member"""
    try:
        result = client.table("order_member_profiles").select("status").eq("user_id", user_id).execute()
        if result.data:
            return result.data[0]["status"] in ("active", "probationary")
        return False
    except:
        return False


async def get_user_profile_snapshot(client, user_id: str) -> Dict[str, Any]:
    """Get a snapshot of user profile for application"""
    try:
        # Get base profile
        profile_result = client.table("profiles").select("full_name, username, avatar_url").eq("id", user_id).execute()
        profile = profile_result.data[0] if profile_result.data else {}

        # Get filmmaker profile if exists
        filmmaker_result = client.table("filmmaker_profiles").select(
            "department, location, portfolio_url, reel_url"
        ).eq("user_id", user_id).execute()
        filmmaker = filmmaker_result.data[0] if filmmaker_result.data else {}

        # Get order profile if exists
        order_result = client.table("order_member_profiles").select(
            "primary_track, city, portfolio_url, years_experience, status"
        ).eq("user_id", user_id).execute()
        order_profile = order_result.data[0] if order_result.data else {}

        # Get recent credits count
        credits_result = client.table("backlot_project_credits").select("id").eq("user_id", user_id).limit(10).execute()
        credits_count = len(credits_result.data) if credits_result.data else 0

        return {
            "name": profile.get("full_name") or profile.get("username") or "Unknown",
            "avatar_url": profile.get("avatar_url"),
            "primary_role": filmmaker.get("department") or order_profile.get("primary_track") or "Unknown",
            "department": filmmaker.get("department") or order_profile.get("primary_track"),
            "city": filmmaker.get("location") or order_profile.get("city"),
            "portfolio_url": filmmaker.get("portfolio_url") or order_profile.get("portfolio_url"),
            "reel_url": filmmaker.get("reel_url"),
            "years_experience": order_profile.get("years_experience"),
            "is_order_member": order_profile.get("status") in ("active", "probationary") if order_profile else False,
            "credits_count": credits_count
        }
    except Exception as e:
        print(f"Error getting profile snapshot: {e}")
        return {"name": "Unknown", "is_order_member": False}


# =====================================================
# Project Roles Endpoints
# =====================================================

@router.get("/projects/{project_id}/roles")
async def get_project_roles(
    project_id: str,
    type: Optional[str] = None,
    status: Optional[str] = None,
    include_applications: bool = False,
    authorization: str = Header(None)
):
    """Get all roles for a project"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]  # This is now the profile ID
    client = get_client()

    # Verify project access
    project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)
    if not is_owner:
        member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
        if not member_response.data:
            raise HTTPException(status_code=403, detail="Access denied - not a project member")

    try:
        query = client.table("backlot_project_roles").select("*").eq("project_id", project_id).order("created_at", desc=True)

        if type:
            query = query.eq("type", type)
        if status:
            query = query.eq("status", status)

        result = query.execute()
        roles = result.data or []

        # Optionally include application counts
        if include_applications and roles:
            for role in roles:
                app_result = client.table("backlot_project_role_applications").select("id, status").eq("role_id", role["id"]).execute()
                apps = app_result.data or []
                role["application_count"] = len(apps)
                role["shortlisted_count"] = len([a for a in apps if a["status"] == "shortlisted"])
                role["booked_count"] = len([a for a in apps if a["status"] == "booked"])

        # Get booked user info if any
        for role in roles:
            if role.get("booked_user_id"):
                user_result = client.table("profiles").select("id, full_name, username, avatar_url").eq("id", role["booked_user_id"]).execute()
                role["booked_user"] = user_result.data[0] if user_result.data else None

        return {"success": True, "roles": roles, "count": len(roles)}

    except Exception as e:
        print(f"Error fetching project roles: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/roles")
async def create_project_role(
    project_id: str,
    role_input: ProjectRoleInput,
    authorization: str = Header(None)
):
    """Create a new role posting for a project"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    # Verify project edit access
    project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)
    if not is_owner:
        member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
        if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin", "editor"]:
            raise HTTPException(status_code=403, detail="You don't have permission to create roles")

    try:
        role_data = {
            "project_id": project_id,
            "created_by_user_id": user_id,
            "type": role_input.type,
            "title": role_input.title,
            "description": role_input.description,
            "department": role_input.department,
            "character_name": role_input.character_name,
            "character_description": role_input.character_description,
            "age_range": role_input.age_range,
            "gender_requirement": role_input.gender_requirement,
            "cast_position_type_id": role_input.cast_position_type_id,
            "location": role_input.location,
            "start_date": role_input.start_date,
            "end_date": role_input.end_date,
            "days_estimated": role_input.days_estimated,
            "paid": role_input.paid,
            "rate_description": role_input.rate_description,
            "rate_amount_cents": role_input.rate_amount_cents,
            "rate_type": role_input.rate_type,
            "is_order_only": role_input.is_order_only,
            "is_featured": role_input.is_featured,
            "status": role_input.status or "open",
            "requires_reel": role_input.requires_reel,
            "requires_headshot": role_input.requires_headshot,
            "application_deadline": role_input.application_deadline,
            "max_applications": role_input.max_applications,
        }

        result = client.table("backlot_project_roles").insert(role_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create role")

        return {"success": True, "role": result.data[0], "message": "Role created successfully"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating project role: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/roles/{role_id}")
async def get_role(
    role_id: str,
    include_applications: bool = False,
    authorization: str = Header(None)
):
    """Get a single role with optional applications"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        result = client.table("backlot_project_roles").select("*").eq("id", role_id).single().execute()

        if not result.data:
            raise HTTPException(status_code=404, detail="Role not found")

        role = result.data

        # Check access
        project_response = client.table("backlot_projects").select("owner_id, title").eq("id", role["project_id"]).execute()
        if not project_response.data:
            raise HTTPException(status_code=404, detail="Project not found")

        project = project_response.data[0]
        is_owner = str(project["owner_id"]) == str(user_id)

        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", role["project_id"]).eq("user_id", user_id).execute()
            is_member = bool(member_response.data)

            # Check if role is Order-only and user is not an Order member
            if role["is_order_only"] and not is_member:
                is_order_member = await check_is_order_member(client, user_id)
                if not is_order_member:
                    raise HTTPException(status_code=403, detail="This role is only visible to Order members")
            elif role["status"] != "open" and not is_member:
                raise HTTPException(status_code=403, detail="Access denied")

        role["project_title"] = project["title"]

        # Get booked user info
        if role.get("booked_user_id"):
            user_result = client.table("profiles").select("id, full_name, username, avatar_url").eq("id", role["booked_user_id"]).execute()
            role["booked_user"] = user_result.data[0] if user_result.data else None

        # Include applications for project admins
        if include_applications and (is_owner or (member_response.data and member_response.data[0]["role"] in ["owner", "admin", "editor"])):
            app_result = client.table("backlot_project_role_applications").select("*").eq("role_id", role_id).order("created_at", desc=True).execute()
            role["applications"] = app_result.data or []

        return {"success": True, "role": role}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching role: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/roles/{role_id}")
async def update_role(
    role_id: str,
    role_input: ProjectRoleInput,
    authorization: str = Header(None)
):
    """Update a role"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get existing role
        existing = client.table("backlot_project_roles").select("project_id").eq("id", role_id).single().execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Role not found")

        project_id = existing.data["project_id"]

        # Verify edit access
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)

        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin", "editor"]:
                raise HTTPException(status_code=403, detail="You don't have permission to edit roles")

        update_data = {
            "type": role_input.type,
            "title": role_input.title,
            "description": role_input.description,
            "department": role_input.department,
            "character_name": role_input.character_name,
            "character_description": role_input.character_description,
            "age_range": role_input.age_range,
            "gender_requirement": role_input.gender_requirement,
            "cast_position_type_id": role_input.cast_position_type_id,
            "location": role_input.location,
            "start_date": role_input.start_date,
            "end_date": role_input.end_date,
            "days_estimated": role_input.days_estimated,
            "paid": role_input.paid,
            "rate_description": role_input.rate_description,
            "rate_amount_cents": role_input.rate_amount_cents,
            "rate_type": role_input.rate_type,
            "is_order_only": role_input.is_order_only,
            "is_featured": role_input.is_featured,
            "status": role_input.status,
            "requires_reel": role_input.requires_reel,
            "requires_headshot": role_input.requires_headshot,
            "application_deadline": role_input.application_deadline,
            "max_applications": role_input.max_applications,
            "updated_at": datetime.utcnow().isoformat(),
        }

        result = client.table("backlot_project_roles").update(update_data).eq("id", role_id).execute()

        return {"success": True, "role": result.data[0] if result.data else None, "message": "Role updated"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating role: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/roles/{role_id}")
async def delete_role(
    role_id: str,
    authorization: str = Header(None)
):
    """Delete a role"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get existing role
        existing = client.table("backlot_project_roles").select("project_id").eq("id", role_id).single().execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Role not found")

        project_id = existing.data["project_id"]

        # Verify delete access
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)

        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin"]:
                raise HTTPException(status_code=403, detail="You don't have permission to delete roles")

        client.table("backlot_project_roles").delete().eq("id", role_id).execute()

        return {"success": True, "message": "Role deleted"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting role: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/roles/{role_id}/book")
async def book_role(
    role_id: str,
    user_id_to_book: str = Body(..., embed=True),
    authorization: str = Header(None)
):
    """Book a user for a role (from shortlist or directly)"""
    user = await get_current_user_from_token(authorization)
    current_user_id = user["id"]
    client = get_client()

    try:
        # Get role
        role_result = client.table("backlot_project_roles").select("*").eq("id", role_id).single().execute()
        if not role_result.data:
            raise HTTPException(status_code=404, detail="Role not found")

        role = role_result.data

        # Verify admin access
        project_response = client.table("backlot_projects").select("owner_id").eq("id", role["project_id"]).execute()
        is_owner = project_response.data[0]["owner_id"] == current_user_id

        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", role["project_id"]).eq("user_id", current_user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin"]:
                raise HTTPException(status_code=403, detail="You don't have permission to book roles")

        # Update role
        client.table("backlot_project_roles").update({
            "status": "booked",
            "booked_user_id": user_id_to_book,
            "booked_at": datetime.utcnow().isoformat(),
            "updated_at": datetime.utcnow().isoformat(),
        }).eq("id", role_id).execute()

        # Update application status if exists
        client.table("backlot_project_role_applications").update({
            "status": "booked",
            "status_changed_at": datetime.utcnow().isoformat(),
            "status_changed_by_user_id": current_user_id,
            "updated_at": datetime.utcnow().isoformat(),
        }).eq("role_id", role_id).eq("applicant_user_id", user_id_to_book).execute()

        # Optionally add as project member if not already
        existing_member = client.table("backlot_project_members").select("id").eq("project_id", role["project_id"]).eq("user_id", user_id_to_book).execute()

        if not existing_member.data:
            # Get user profile for name/email
            profile = client.table("profiles").select("full_name, email").eq("id", user_id_to_book).execute()
            profile_data = profile.data[0] if profile.data else {}

            client.table("backlot_project_members").insert({
                "project_id": role["project_id"],
                "user_id": user_id_to_book,
                "role": "viewer",  # Basic access
                "production_role": role["title"],
                "department": role.get("department"),
                "invited_by": current_user_id,
            }).execute()

        # Auto-create crew rate from deal memo if one exists
        deal_memo_result = client.table("backlot_deal_memos").select("*").eq("role_id", role_id).eq("user_id", user_id_to_book).execute()
        if deal_memo_result.data:
            deal_memo = deal_memo_result.data[0]
            # Check if crew rate already exists for this deal memo
            existing_rate = client.table("backlot_crew_rates").select("id").eq("deal_memo_id", deal_memo["id"]).execute()
            if not existing_rate.data:
                # Create crew rate from deal memo
                client.table("backlot_crew_rates").insert({
                    "project_id": role["project_id"],
                    "user_id": user_id_to_book,
                    "role_title": deal_memo["position_title"],
                    "department": role.get("department"),
                    "rate_type": deal_memo["rate_type"],
                    "rate_amount": deal_memo["rate_amount"],
                    "kit_rental_rate": deal_memo.get("kit_rental_rate"),
                    "car_allowance": deal_memo.get("car_allowance"),
                    "phone_allowance": deal_memo.get("phone_allowance"),
                    "per_diem_rate": deal_memo.get("per_diem_rate"),
                    "overtime_multiplier": deal_memo.get("overtime_multiplier", 1.5),
                    "double_time_multiplier": deal_memo.get("double_time_multiplier", 2.0),
                    "deal_memo_id": deal_memo["id"],
                    "source": "deal_memo",
                    "start_date": deal_memo.get("start_date"),
                    "end_date": deal_memo.get("end_date"),
                }).execute()

        # Auto-create credit from credit preferences or defaults
        credit_pref_result = client.table("backlot_credit_preferences").select("*").eq("user_id", user_id_to_book).eq("role_id", role_id).execute()
        credit_pref = credit_pref_result.data[0] if credit_pref_result.data else None

        # Fall back to default preferences if no role-specific ones
        if not credit_pref:
            default_pref_result = client.table("backlot_credit_preferences").select("*").eq("user_id", user_id_to_book).eq("use_as_default", True).execute()
            credit_pref = default_pref_result.data[0] if default_pref_result.data else None

        # Get user profile for credit name fallback
        user_profile = client.table("profiles").select("full_name, display_name").eq("id", user_id_to_book).execute()
        user_name = ""
        if user_profile.data:
            user_name = user_profile.data[0].get("display_name") or user_profile.data[0].get("full_name") or ""

        # Check if credit already exists for this user/role
        existing_credit = client.table("backlot_project_credits").select("id").eq("project_id", role["project_id"]).eq("user_id", user_id_to_book).eq("source_role_id", role_id).execute()
        if not existing_credit.data:
            credit_data = {
                "project_id": role["project_id"],
                "user_id": user_id_to_book,
                "department": credit_pref.get("department_preference") if credit_pref else role.get("department"),
                "credit_role": credit_pref.get("role_title_preference") if credit_pref else role["title"],
                "name": credit_pref.get("display_name") if credit_pref and credit_pref.get("display_name") else user_name,
                "endorsement_note": credit_pref.get("endorsement_note") if credit_pref else None,
                "imdb_id": credit_pref.get("imdb_id") if credit_pref else None,
                "is_primary": False,
                "is_public": credit_pref.get("is_public", True) if credit_pref else True,
                "credit_preference_id": credit_pref["id"] if credit_pref else None,
                "auto_created": True,
                "source_role_id": role_id,
            }
            client.table("backlot_project_credits").insert(credit_data).execute()

        return {"success": True, "message": f"User booked for {role['title']}"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error booking role: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Open/Public Roles Listing (for Community/Order)
# =====================================================

@router.get("/open-roles")
async def get_open_roles(
    type: Optional[str] = None,
    location: Optional[str] = None,
    paid_only: bool = False,
    order_only: bool = False,
    limit: int = 50,
    offset: int = 0,
    authorization: str = Header(None)
):
    """Get all open roles (public listing for job board)"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Check if user is Order member
        is_order_member = await check_is_order_member(client, user_id)

        # Base query for open roles
        query = client.table("backlot_project_roles").select(
            "*, backlot_projects(id, title, slug, cover_image_url, owner_id)"
        ).eq("status", "open")

        # Filter Order-only roles if user is not an Order member
        if not is_order_member:
            query = query.eq("is_order_only", False)
        elif order_only:
            query = query.eq("is_order_only", True)

        if type:
            query = query.eq("type", type)
        if location:
            query = query.ilike("location", f"%{location}%")
        if paid_only:
            query = query.eq("paid", True)

        query = query.order("created_at", desc=True).range(offset, offset + limit - 1)

        result = query.execute()
        roles = result.data or []

        # Get application counts
        for role in roles:
            app_count = client.table("backlot_project_role_applications").select("id", count="exact").eq("role_id", role["id"]).execute()
            role["application_count"] = app_count.count if app_count.count else 0

            # Check if current user has applied
            user_app = client.table("backlot_project_role_applications").select("id, status").eq("role_id", role["id"]).eq("applicant_user_id", user_id).execute()
            role["user_has_applied"] = bool(user_app.data)
            role["user_application_status"] = user_app.data[0]["status"] if user_app.data else None

        return {"success": True, "roles": roles, "count": len(roles), "is_order_member": is_order_member}

    except Exception as e:
        print(f"Error fetching open roles: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Role to Community Endpoints
# =====================================================

@router.post("/roles/{role_id}/post-to-community")
async def post_role_to_community(
    role_id: str,
    authorization: str = Header(None)
):
    """Post a role to the community job board"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get role
        role_result = client.table("backlot_project_roles").select("*").eq("id", role_id).single().execute()
        if not role_result.data:
            raise HTTPException(status_code=404, detail="Role not found")

        role = role_result.data
        project_id = role.get("project_id")

        # Get project details
        project_result = client.table("backlot_projects").select("id, title, owner_id").eq("id", project_id).single().execute()
        project = project_result.data if project_result.data else {}

        # Check admin access
        is_owner = str(project.get("owner_id")) == str(user_id)
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin"]:
                raise HTTPException(status_code=403, detail="Access denied")

        # Check if already posted
        if role.get("community_job_id"):
            raise HTTPException(status_code=400, detail="Role is already posted to community")

        # Create community collab
        collab_data = {
            "user_id": user_id,
            "title": f"{role.get('title')} - {project.get('title', 'Project')}",
            "type": role.get("type", "crew"),  # cast or crew
            "description": role.get("description") or f"We're looking for a {role.get('title')} for our production.",
            "location": role.get("location"),
            "budget_range": role.get("rate_description"),
            "compensation_type": "paid" if role.get("paid") else "unpaid",
            "is_active": True,
            "is_order_only": role.get("is_order_only", False),
            "start_date": role.get("start_date"),
            "end_date": role.get("end_date"),
            "source_role_id": role_id,
            "source_project_id": project_id,
        }

        collab_result = client.table("community_collabs").insert(collab_data).execute()
        if not collab_result.data:
            raise HTTPException(status_code=500, detail="Failed to create community collab")

        community_job_id = collab_result.data[0]["id"]

        # Update role with community job reference
        client.table("backlot_project_roles").update({
            "community_job_id": community_job_id,
            "posted_to_community_at": datetime.utcnow().isoformat(),
            "updated_at": datetime.utcnow().isoformat(),
        }).eq("id", role_id).execute()

        return {
            "success": True,
            "community_job_id": community_job_id,
            "message": "Role posted to community"
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error posting role to community: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/roles/{role_id}/remove-from-community")
async def remove_role_from_community(
    role_id: str,
    authorization: str = Header(None)
):
    """Remove a role from the community job board"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get role
        role_result = client.table("backlot_project_roles").select("community_job_id, project_id").eq("id", role_id).single().execute()
        if not role_result.data:
            raise HTTPException(status_code=404, detail="Role not found")

        role = role_result.data
        project_id = role.get("project_id")

        # Get project details for owner check
        project_result = client.table("backlot_projects").select("id, owner_id").eq("id", project_id).single().execute()
        project = project_result.data if project_result.data else {}

        # Check admin access
        is_owner = str(project.get("owner_id")) == str(user_id)
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin"]:
                raise HTTPException(status_code=403, detail="Access denied")

        community_job_id = role.get("community_job_id")
        if not community_job_id:
            raise HTTPException(status_code=400, detail="Role is not posted to community")

        # Deactivate community collab (don't delete, preserve history)
        client.table("community_collabs").update({
            "is_active": False,
            "updated_at": datetime.utcnow().isoformat(),
        }).eq("id", community_job_id).execute()

        # Remove community reference from role
        client.table("backlot_project_roles").update({
            "community_job_id": None,
            "updated_at": datetime.utcnow().isoformat(),
        }).eq("id", role_id).execute()

        return {
            "success": True,
            "message": "Role removed from community"
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error removing role from community: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Role Applications Endpoints
# =====================================================

@router.get("/roles/{role_id}/applications")
async def get_role_applications(
    role_id: str,
    status: Optional[str] = None,
    authorization: str = Header(None)
):
    """Get all applications for a role (project admin only)"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get role and verify admin access
        role_result = client.table("backlot_project_roles").select("project_id").eq("id", role_id).single().execute()
        if not role_result.data:
            raise HTTPException(status_code=404, detail="Role not found")

        project_id = role_result.data["project_id"]

        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)

        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin", "editor"]:
                raise HTTPException(status_code=403, detail="Access denied")

        query = client.table("backlot_project_role_applications").select("*").eq("role_id", role_id).order("created_at", desc=True)

        if status:
            query = query.eq("status", status)

        result = query.execute()
        applications = result.data or []

        # Group by status for board view
        applications_by_status = {
            "applied": [],
            "viewed": [],
            "shortlisted": [],
            "interview": [],
            "offered": [],
            "booked": [],
            "rejected": [],
            "withdrawn": [],
        }

        for app in applications:
            if app["status"] in applications_by_status:
                applications_by_status[app["status"]].append(app)

        return {
            "success": True,
            "applications": applications,
            "applications_by_status": applications_by_status,
            "count": len(applications)
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching applications: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/roles/{role_id}/apply")
async def apply_to_role(
    role_id: str,
    application: RoleApplicationInput,
    authorization: str = Header(None)
):
    """Apply to a role"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get role
        role_result = client.table("backlot_project_roles").select("*").eq("id", role_id).single().execute()
        if not role_result.data:
            raise HTTPException(status_code=404, detail="Role not found")

        role = role_result.data

        # Check if role is open
        if role["status"] != "open":
            raise HTTPException(status_code=400, detail="This role is no longer accepting applications")

        # Check if Order-only
        if role["is_order_only"]:
            is_order_member = await check_is_order_member(client, user_id)
            if not is_order_member:
                raise HTTPException(status_code=403, detail="This role is only open to Order members")

        # Check application deadline
        if role.get("application_deadline"):
            deadline = datetime.fromisoformat(role["application_deadline"])
            if datetime.utcnow() > deadline:
                raise HTTPException(status_code=400, detail="Application deadline has passed")

        # Check max applications
        if role.get("max_applications"):
            current_count = client.table("backlot_project_role_applications").select("id", count="exact").eq("role_id", role_id).execute()
            if current_count.count and current_count.count >= role["max_applications"]:
                raise HTTPException(status_code=400, detail="Maximum applications reached for this role")

        # Check for existing application
        existing = client.table("backlot_project_role_applications").select("id").eq("role_id", role_id).eq("applicant_user_id", user_id).execute()
        if existing.data:
            raise HTTPException(status_code=400, detail="You have already applied to this role")

        # Check role requirements
        if role.get("requires_local_hire") and application.local_hire_confirmed is None:
            raise HTTPException(status_code=400, detail="Please confirm if you can work as a local hire")

        if role.get("requires_reel") and not application.reel_url:
            raise HTTPException(status_code=400, detail="A reel URL is required for this role")

        if role.get("requires_headshot") and not application.headshot_url:
            raise HTTPException(status_code=400, detail="A headshot is required for this role")

        if role.get("requires_resume") and not application.resume_url:
            raise HTTPException(status_code=400, detail="A resume is required for this role")

        # Check self-tape requirement (only required upfront if tape_workflow is 'upfront')
        if role.get("requires_self_tape") and role.get("tape_workflow", "upfront") == "upfront":
            if not application.self_tape_url:
                raise HTTPException(status_code=400, detail="A self-tape is required for this role")

        # Get profile snapshot
        profile_snapshot = await get_user_profile_snapshot(client, user_id)

        application_data = {
            "role_id": role_id,
            "applicant_user_id": user_id,
            "applicant_profile_snapshot": profile_snapshot,
            "elevator_pitch": application.elevator_pitch,
            "cover_note": application.cover_note,
            "availability_notes": application.availability_notes,
            "rate_expectation": application.rate_expectation,
            "reel_url": application.reel_url,
            "headshot_url": application.headshot_url,
            "resume_url": application.resume_url,
            "selected_credit_ids": application.selected_credit_ids or [],
            "template_id": application.template_id,
            "local_hire_confirmed": application.local_hire_confirmed,
            "is_promoted": application.is_promoted,
            "status": "applied",
            # Cast-specific fields
            "demo_reel_url": application.demo_reel_url,
            "self_tape_url": application.self_tape_url,
            "special_skills": application.special_skills or [],
        }

        result = client.table("backlot_project_role_applications").insert(application_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to submit application")

        app_result = result.data[0]

        # If save_as_template is True, create a template
        if application.save_as_template and application.template_name:
            template_data = {
                "user_id": user_id,
                "name": application.template_name,
                "cover_letter": application.cover_note,
                "elevator_pitch": application.elevator_pitch,
                "rate_expectation": application.rate_expectation,
                "availability_notes": application.availability_notes,
                "default_reel_url": application.reel_url,
                "default_headshot_url": application.headshot_url,
                "default_resume_url": application.resume_url,
                "default_credit_ids": application.selected_credit_ids or [],
            }
            client.table("application_templates").insert(template_data).execute()

        # If template_id was provided, record usage
        if application.template_id:
            existing_template = client.table("application_templates").select("use_count").eq(
                "id", application.template_id
            ).eq("user_id", user_id).single().execute()

            if existing_template.data:
                new_count = (existing_template.data.get("use_count") or 0) + 1
                client.table("application_templates").update({
                    "use_count": new_count,
                    "last_used_at": datetime.utcnow().isoformat()
                }).eq("id", application.template_id).execute()

        # --- Send notifications to project owner and casting team ---
        try:
            # Get applicant name
            applicant_name = profile_snapshot.get("full_name") or profile_snapshot.get("username") or "Someone"
            role_title = role.get("title", "a role")
            project_id = role.get("project_id")

            # Get project owner
            project_result = client.table("backlot_projects").select("owner_id, title").eq("id", project_id).single().execute()
            project = project_result.data if project_result.data else {}
            project_title = project.get("title", "your project")
            owner_id = project.get("owner_id")

            # Get project members who should receive casting notifications (admins, editors)
            members_result = client.table("backlot_project_members").select(
                "user_id, role, production_role"
            ).eq("project_id", project_id).in_("role", ["owner", "admin", "editor"]).execute()

            notify_user_ids = set()
            if owner_id:
                notify_user_ids.add(owner_id)
            if members_result.data:
                for member in members_result.data:
                    # Include admins/editors with casting-related production roles
                    prod_role = (member.get("production_role") or "").lower()
                    if member["role"] in ["owner", "admin"] or "cast" in prod_role or "producer" in prod_role:
                        notify_user_ids.add(member["user_id"])

            # Don't notify the applicant themselves
            notify_user_ids.discard(user_id)

            # Create notifications
            notification_data = {
                "type": "role_application",
                "title": f"New application for {role_title}",
                "message": f"{applicant_name} has applied for {role_title} on {project_title}",
                "data": {
                    "application_id": app_result["id"],
                    "role_id": role_id,
                    "project_id": project_id,
                    "applicant_user_id": user_id,
                    "applicant_name": applicant_name,
                    "role_title": role_title,
                    "project_title": project_title,
                },
                "is_read": False,
            }

            for notify_id in notify_user_ids:
                client.table("notifications").insert({
                    **notification_data,
                    "user_id": notify_id,
                }).execute()

        except Exception as notify_err:
            # Don't fail the application if notification fails
            print(f"Warning: Failed to send application notification: {notify_err}")

        return {"success": True, "application": app_result, "message": "Application submitted successfully"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error submitting application: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/applications/{application_id}/status")
async def update_application_status(
    application_id: str,
    status_update: ApplicationStatusUpdate,
    authorization: str = Header(None)
):
    """Update application status (project admin) or withdraw (applicant)"""
    from app.api.users import get_profile_id_from_cognito_id

    user = await get_current_user_from_token(authorization)
    cognito_id = user["id"]

    # Convert Cognito ID to profile UUID
    user_id = get_profile_id_from_cognito_id(cognito_id)
    if not user_id:
        raise HTTPException(status_code=401, detail="Profile not found")

    client = get_client()

    try:
        # Get application
        app_result = client.table("backlot_project_role_applications").select(
            "*, backlot_project_roles(project_id)"
        ).eq("id", application_id).single().execute()

        if not app_result.data:
            raise HTTPException(status_code=404, detail="Application not found")

        application = app_result.data
        project_id = application["backlot_project_roles"]["project_id"]

        # Check permissions
        is_applicant = application["applicant_user_id"] == user_id

        if is_applicant:
            # Applicant can only withdraw
            if status_update.status != "withdrawn":
                raise HTTPException(status_code=403, detail="You can only withdraw your application")
        else:
            # Must be project admin
            project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
            is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)

            if not is_owner:
                member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
                if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin", "editor"]:
                    raise HTTPException(status_code=403, detail="Access denied")

        update_data = {
            "status": status_update.status,
            "status_changed_at": datetime.utcnow().isoformat(),
            "status_changed_by_user_id": user_id,
            "updated_at": datetime.utcnow().isoformat(),
        }

        if status_update.internal_notes is not None:
            update_data["internal_notes"] = status_update.internal_notes
        if status_update.rating is not None:
            update_data["rating"] = status_update.rating

        result = client.table("backlot_project_role_applications").update(update_data).eq("id", application_id).execute()

        # If booking, also update the role
        if status_update.status == "booked":
            client.table("backlot_project_roles").update({
                "status": "booked",
                "booked_user_id": application["applicant_user_id"],
                "booked_at": datetime.utcnow().isoformat(),
                "updated_at": datetime.utcnow().isoformat(),
            }).eq("id", application["role_id"]).execute()

        # --- Send notification to applicant for status changes ---
        try:
            applicant_id = application["applicant_user_id"]
            new_status = status_update.status

            # Get role and project info
            role_result = client.table("backlot_project_roles").select(
                "title, project_id, backlot_projects(title)"
            ).eq("id", application["role_id"]).single().execute()
            role_data = role_result.data if role_result.data else {}
            role_title = role_data.get("title", "a role")
            project_title = role_data.get("backlot_projects", {}).get("title", "the project")

            # Only notify for meaningful status changes
            status_notifications = {
                "shortlisted": {
                    "title": f"You've been shortlisted for {role_title}",
                    "message": f"Great news! You've been shortlisted for {role_title} on {project_title}.",
                    "type": "application_shortlisted",
                },
                "interview": {
                    "title": f"Interview requested for {role_title}",
                    "message": f"The team at {project_title} would like to interview you for {role_title}.",
                    "type": "application_interview",
                },
                "offered": {
                    "title": f"Offer for {role_title}!",
                    "message": f"Congratulations! You've received an offer for {role_title} on {project_title}.",
                    "type": "application_offered",
                },
                "booked": {
                    "title": f"You're booked for {role_title}!",
                    "message": f"Welcome to the team! You've been booked for {role_title} on {project_title}.",
                    "type": "application_booked",
                },
                "rejected": {
                    "title": f"Update on your application for {role_title}",
                    "message": f"Unfortunately, the team has decided to go in a different direction for {role_title} on {project_title}.",
                    "type": "application_rejected",
                },
            }

            if new_status in status_notifications:
                notif = status_notifications[new_status]
                client.table("notifications").insert({
                    "user_id": applicant_id,
                    "type": notif["type"],
                    "title": notif["title"],
                    "message": notif["message"],
                    "data": {
                        "application_id": application_id,
                        "role_id": application["role_id"],
                        "project_id": project_id,
                        "role_title": role_title,
                        "project_title": project_title,
                        "status": new_status,
                    },
                    "is_read": False,
                }).execute()

        except Exception as notify_err:
            # Don't fail the status update if notification fails
            print(f"Warning: Failed to send status change notification: {notify_err}")

        return {"success": True, "application": result.data[0] if result.data else None, "message": f"Application {status_update.status}"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating application: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/applications/{application_id}/promote")
async def promote_role_application(
    application_id: str,
    authorization: str = Header(None)
):
    """Promote a role application (boost visibility)"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get application and verify ownership
        app_result = client.table("backlot_project_role_applications").select("*").eq(
            "id", application_id
        ).eq("applicant_user_id", user_id).single().execute()

        if not app_result.data:
            raise HTTPException(status_code=404, detail="Application not found")

        if app_result.data.get("is_promoted"):
            raise HTTPException(status_code=400, detail="Application is already promoted")

        # Check if user is Order member (free promotion)
        profile = client.table("profiles").select("is_order_member").eq(
            "id", user_id
        ).single().execute()

        is_order_member = profile.data.get("is_order_member", False) if profile.data else False

        if not is_order_member:
            # Non-Order members must pay $9.99 to promote
            from app.core.config import settings
            import stripe
            stripe.api_key = settings.STRIPE_SECRET_KEY

            if not stripe.api_key:
                raise HTTPException(status_code=500, detail="Stripe not configured")

            # Get or create Stripe customer
            customer_id = profile.data.get("stripe_customer_id") if profile.data else None
            if not customer_id:
                customer = stripe.Customer.create(metadata={"user_id": user_id})
                customer_id = customer.id
                client.table("profiles").update({"stripe_customer_id": customer_id}).eq("id", user_id).execute()

            base_url = settings.FRONTEND_URL
            session = stripe.checkout.Session.create(
                customer=customer_id,
                payment_method_types=["card"],
                line_items=[{
                    "price_data": {
                        "currency": "usd",
                        "product_data": {
                            "name": "Featured Role Application",
                            "description": "7-day featured placement for your role application",
                        },
                        "unit_amount": 999,
                    },
                    "quantity": 1,
                }],
                mode="payment",
                success_url=f"{base_url}/backlot?promotion=success",
                cancel_url=f"{base_url}/backlot?promotion=cancelled",
                metadata={
                    "type": "featured_post",
                    "post_type": "role_application",
                    "post_id": application_id,
                    "user_id": user_id,
                },
            )

            return {
                "success": True,
                "requires_payment": True,
                "checkout_url": session.url,
                "message": "Redirecting to payment",
            }

        # Order members get free promotion
        result = client.table("backlot_project_role_applications").update({
            "is_promoted": True,
            "promoted_at": datetime.utcnow().isoformat(),
            "updated_at": datetime.utcnow().isoformat(),
        }).eq("id", application_id).execute()

        return {
            "success": True,
            "is_free": True,
            "message": "Application promoted successfully (free for Order members)",
            "application": result.data[0] if result.data else None
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error promoting application: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/applications/{application_id}/request-tape")
async def request_tape_from_applicant(
    application_id: str,
    authorization: str = Header(None)
):
    """Request a self-tape from a shortlisted applicant (for after_shortlist workflow)"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get application with role
        app_result = client.table("backlot_project_role_applications").select(
            "*, backlot_project_roles(project_id, title, tape_workflow, backlot_projects(title, owner_id))"
        ).eq("id", application_id).single().execute()

        if not app_result.data:
            raise HTTPException(status_code=404, detail="Application not found")

        application = app_result.data
        role = application.get("backlot_project_roles", {})
        project = role.get("backlot_projects", {})
        project_id = role.get("project_id")

        # Must be shortlisted or later to request tape
        if application["status"] not in ["shortlisted", "interview", "offered"]:
            raise HTTPException(status_code=400, detail="Applicant must be shortlisted before requesting tape")

        # Check permissions - must be project owner or admin
        is_owner = str(project.get("owner_id")) == str(user_id)
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq(
                "project_id", project_id
            ).eq("user_id", user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin", "editor"]:
                raise HTTPException(status_code=403, detail="Access denied")

        # Check if tape already requested
        if application.get("tape_requested_at"):
            raise HTTPException(status_code=400, detail="Tape has already been requested from this applicant")

        # Update application with tape request
        result = client.table("backlot_project_role_applications").update({
            "tape_requested_at": datetime.utcnow().isoformat(),
            "updated_at": datetime.utcnow().isoformat(),
        }).eq("id", application_id).execute()

        # Send notification to applicant
        try:
            applicant_id = application["applicant_user_id"]
            role_title = role.get("title", "a role")
            project_title = project.get("title", "the project")

            client.table("notifications").insert({
                "user_id": applicant_id,
                "type": "tape_requested",
                "title": f"Self-tape requested for {role_title}",
                "message": f"The casting team for {project_title} has requested a self-tape for your application to {role_title}.",
                "data": {
                    "application_id": application_id,
                    "role_id": application["role_id"],
                    "project_id": project_id,
                    "role_title": role_title,
                    "project_title": project_title,
                },
                "is_read": False,
            }).execute()
        except Exception as notify_err:
            print(f"Warning: Failed to send tape request notification: {notify_err}")

        return {
            "success": True,
            "message": "Tape request sent to applicant",
            "application": result.data[0] if result.data else None
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error requesting tape: {e}")
        raise HTTPException(status_code=500, detail=str(e))


class TapeSubmissionInput(BaseModel):
    """Input for submitting a tape"""
    self_tape_url: str


@router.post("/applications/{application_id}/submit-tape")
async def submit_tape_for_application(
    application_id: str,
    tape_input: TapeSubmissionInput,
    authorization: str = Header(None)
):
    """Submit a self-tape for an application (after tape has been requested)"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get application
        app_result = client.table("backlot_project_role_applications").select(
            "*, backlot_project_roles(project_id, title, backlot_projects(title, owner_id))"
        ).eq("id", application_id).single().execute()

        if not app_result.data:
            raise HTTPException(status_code=404, detail="Application not found")

        application = app_result.data

        # Must be the applicant
        if application["applicant_user_id"] != user_id:
            raise HTTPException(status_code=403, detail="You can only submit tape for your own application")

        # Check if tape was requested (for after_shortlist workflow)
        if not application.get("tape_requested_at"):
            raise HTTPException(status_code=400, detail="No tape has been requested for this application")

        # Check if tape already submitted
        if application.get("tape_submitted_at"):
            raise HTTPException(status_code=400, detail="Tape has already been submitted")

        # Update application with tape
        result = client.table("backlot_project_role_applications").update({
            "self_tape_url": tape_input.self_tape_url,
            "tape_submitted_at": datetime.utcnow().isoformat(),
            "updated_at": datetime.utcnow().isoformat(),
        }).eq("id", application_id).execute()

        # Send notification to casting team (project owner)
        try:
            role = application.get("backlot_project_roles", {})
            project = role.get("backlot_projects", {})
            owner_id = project.get("owner_id")
            role_title = role.get("title", "a role")
            project_title = project.get("title", "the project")

            # Get applicant name
            profile = client.table("profiles").select("full_name, username").eq("id", user_id).single().execute()
            applicant_name = profile.data.get("full_name") or profile.data.get("username") or "An applicant"

            if owner_id:
                client.table("notifications").insert({
                    "user_id": owner_id,
                    "type": "tape_submitted",
                    "title": f"Tape received for {role_title}",
                    "message": f"{applicant_name} has submitted their self-tape for {role_title} on {project_title}.",
                    "data": {
                        "application_id": application_id,
                        "role_id": application["role_id"],
                        "project_id": role.get("project_id"),
                        "role_title": role_title,
                        "project_title": project_title,
                        "applicant_id": user_id,
                    },
                    "is_read": False,
                }).execute()
        except Exception as notify_err:
            print(f"Warning: Failed to send tape submission notification: {notify_err}")

        return {
            "success": True,
            "message": "Tape submitted successfully",
            "application": result.data[0] if result.data else None
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error submitting tape: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/my-applications")
async def get_my_applications(
    status: Optional[str] = None,
    authorization: str = Header(None)
):
    """Get current user's applications"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        query = client.table("backlot_project_role_applications").select(
            "*, backlot_project_roles(*, backlot_projects(id, title, slug, cover_image_url))"
        ).eq("applicant_user_id", user_id).order("created_at", desc=True)

        if status:
            query = query.eq("status", status)

        result = query.execute()
        applications = result.data or []

        return {"success": True, "applications": applications, "count": len(applications)}

    except Exception as e:
        print(f"Error fetching my applications: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/applications-received")
async def get_applications_received(
    status: Optional[str] = None,
    project_id: Optional[str] = None,
    authorization: str = Header(None)
):
    """Get all applications received for roles on projects where user is owner/admin"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get all projects where user is owner
        owned_projects = client.table("backlot_projects").select("id, title").eq("owner_id", user_id).execute()
        owned_project_ids = [p["id"] for p in (owned_projects.data or [])]

        # Get all projects where user is admin/editor
        member_projects = client.table("backlot_project_members").select(
            "project_id, backlot_projects(id, title)"
        ).eq("user_id", user_id).in_("role", ["owner", "admin", "editor"]).execute()
        member_project_ids = [m["project_id"] for m in (member_projects.data or [])]

        # Combine and dedupe project IDs
        all_project_ids = list(set(owned_project_ids + member_project_ids))

        if not all_project_ids:
            return {"success": True, "applications": [], "count": 0}

        # Filter by specific project if requested
        if project_id and project_id in all_project_ids:
            all_project_ids = [project_id]
        elif project_id:
            raise HTTPException(status_code=403, detail="Access denied to this project")

        # Get all roles for these projects
        roles_result = client.table("backlot_project_roles").select(
            "id, title, type, project_id"
        ).in_("project_id", all_project_ids).execute()
        roles = roles_result.data or []
        role_ids = [r["id"] for r in roles]

        if not role_ids:
            return {"success": True, "applications": [], "count": 0}

        # Get all applications for these roles with applicant info
        query = client.table("backlot_project_role_applications").select(
            "*, backlot_project_roles(id, title, type, project_id, backlot_projects(id, title, slug, cover_image_url))"
        ).in_("role_id", role_ids).order("created_at", desc=True)

        if status:
            query = query.eq("status", status)

        result = query.execute()
        applications = result.data or []

        # Group by project for easier frontend display
        by_project = {}
        for app in applications:
            role_data = app.get("backlot_project_roles", {})
            proj_data = role_data.get("backlot_projects", {})
            proj_id = proj_data.get("id") if proj_data else None
            if proj_id:
                if proj_id not in by_project:
                    by_project[proj_id] = {
                        "project": proj_data,
                        "applications": []
                    }
                by_project[proj_id]["applications"].append(app)

        return {
            "success": True,
            "applications": applications,
            "by_project": by_project,
            "count": len(applications)
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching applications received: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# User Availability Endpoints
# =====================================================

@router.get("/users/{target_user_id}/availability")
async def get_user_availability(
    target_user_id: str,
    start_date: Optional[str] = None,
    end_date: Optional[str] = None,
    authorization: str = Header(None)
):
    """Get user's availability (own or project members)"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Users can view their own availability or project members' availability
        is_self = target_user_id == user_id

        if not is_self:
            # Check if they share any project
            shared_projects = client.rpc("shared_projects", {"user_a": user_id, "user_b": target_user_id}).execute()
            # For now, allow viewing if they're authenticated (simplified)
            pass

        query = client.table("backlot_user_availability").select(
            "*, backlot_projects(id, title)"
        ).eq("user_id", target_user_id).order("date")

        if start_date:
            query = query.gte("date", start_date)
        if end_date:
            query = query.lte("date", end_date)

        result = query.execute()
        availability = result.data or []

        return {"success": True, "availability": availability, "count": len(availability)}

    except Exception as e:
        print(f"Error fetching availability: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/my-availability")
async def get_my_availability(
    start_date: Optional[str] = None,
    end_date: Optional[str] = None,
    authorization: str = Header(None)
):
    """Get current user's availability"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        query = client.table("backlot_user_availability").select(
            "*, backlot_projects(id, title), backlot_project_roles(id, title, type)"
        ).eq("user_id", user_id).order("date")

        if start_date:
            query = query.gte("date", start_date)
        if end_date:
            query = query.lte("date", end_date)

        result = query.execute()
        availability = result.data or []

        return {"success": True, "availability": availability, "count": len(availability)}

    except Exception as e:
        print(f"Error fetching my availability: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/my-availability")
async def set_my_availability(
    availability_input: UserAvailabilityInput,
    authorization: str = Header(None)
):
    """Set availability for a single date"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        data = {
            "user_id": user_id,
            "date": availability_input.date,
            "status": availability_input.status,
            "notes": availability_input.notes,
            "project_id": availability_input.project_id,
        }

        # Upsert (insert or update)
        result = client.table("backlot_user_availability").upsert(
            data,
            on_conflict="user_id,date"
        ).execute()

        return {"success": True, "availability": result.data[0] if result.data else None}

    except Exception as e:
        print(f"Error setting availability: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/my-availability/bulk")
async def set_bulk_availability(
    bulk_input: BulkAvailabilityInput,
    authorization: str = Header(None)
):
    """Set availability for a date range"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        from datetime import datetime, timedelta

        start = datetime.fromisoformat(bulk_input.start_date)
        end = datetime.fromisoformat(bulk_input.end_date)

        if end < start:
            raise HTTPException(status_code=400, detail="End date must be after start date")

        if (end - start).days > 365:
            raise HTTPException(status_code=400, detail="Date range cannot exceed 1 year")

        entries = []
        current = start
        while current <= end:
            entries.append({
                "user_id": user_id,
                "date": current.strftime("%Y-%m-%d"),
                "status": bulk_input.status,
                "notes": bulk_input.notes,
            })
            current += timedelta(days=1)

        # Upsert all entries
        result = client.table("backlot_user_availability").upsert(
            entries,
            on_conflict="user_id,date"
        ).execute()

        return {"success": True, "entries_set": len(entries), "message": f"Availability set for {len(entries)} days"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error setting bulk availability: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/my-availability/{date}")
async def delete_my_availability(
    date: str,
    authorization: str = Header(None)
):
    """Remove availability entry for a date"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        client.table("backlot_user_availability").delete().eq("user_id", user_id).eq("date", date).execute()

        return {"success": True, "message": "Availability entry removed"}

    except Exception as e:
        print(f"Error deleting availability: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Booked Cast/Crew for Call Sheets
# =====================================================

@router.get("/projects/{project_id}/booked-people")
async def get_booked_people(
    project_id: str,
    type: Optional[str] = None,
    authorization: str = Header(None)
):
    """Get all booked cast/crew for a project (for call sheet integration)"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]  # This is now the profile ID
    client = get_client()

    # Verify project access
    project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)
    if not is_owner:
        member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
        if not member_response.data:
            raise HTTPException(status_code=403, detail="Access denied")

    try:
        # Fetch booked roles without the join (foreign key may not be configured)
        query = client.table("backlot_project_roles").select("*").eq(
            "project_id", project_id
        ).eq("status", "booked")

        if type:
            query = query.eq("type", type)

        result = query.execute()
        # Filter out roles without booked users
        booked_roles = [r for r in (result.data or []) if r.get("booked_user_id")]

        # Fetch profile data for all booked users
        booked_user_ids = list(set([r["booked_user_id"] for r in booked_roles]))
        profiles_map = {}
        if booked_user_ids:
            profiles_result = client.table("profiles").select(
                "id, full_name, username, avatar_url, email"
            ).in_("id", booked_user_ids).execute()
            for p in (profiles_result.data or []):
                profiles_map[str(p["id"])] = p

        # Fetch booking rates from collab applications if source_collab_application_id exists
        application_ids = [r.get("source_collab_application_id") for r in booked_roles if r.get("source_collab_application_id")]
        applications_map = {}
        if application_ids:
            apps_result = client.table("community_collab_applications").select(
                "id, booking_rate"
            ).in_("id", application_ids).execute()
            for app in (apps_result.data or []):
                applications_map[str(app["id"])] = app

        # Format for call sheet use
        booked_people = []
        for role in booked_roles:
            profile = profiles_map.get(str(role["booked_user_id"]), {})
            application = applications_map.get(str(role.get("source_collab_application_id")), {}) if role.get("source_collab_application_id") else {}

            booked_people.append({
                "role_id": role["id"],
                "role_title": role["title"],
                "role_type": role["type"],
                "department": role.get("department"),
                "character_name": role.get("character_name"),
                "user_id": role["booked_user_id"],
                "name": profile.get("full_name") or profile.get("username") or "Unknown",
                "avatar_url": profile.get("avatar_url"),
                "email": profile.get("email"),
                "start_date": role.get("start_date"),
                "end_date": role.get("end_date"),
                "booking_rate": application.get("booking_rate"),  # e.g., "$500/daily"
            })

        return {"success": True, "booked_people": booked_people, "count": len(booked_people)}

    except Exception as e:
        print(f"Error fetching booked people: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Availability Conflicts Check
# =====================================================

@router.post("/check-availability-conflicts")
async def check_availability_conflicts(
    user_ids: List[str] = Body(...),
    start_date: str = Body(...),
    end_date: str = Body(...),
    authorization: str = Header(None)
):
    """Check for availability conflicts for multiple users"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        conflicts = {}

        for uid in user_ids:
            result = client.table("backlot_user_availability").select(
                "date, status, notes, backlot_projects(title)"
            ).eq("user_id", uid).gte("date", start_date).lte("date", end_date).in_("status", ["unavailable", "booked"]).execute()

            if result.data:
                conflicts[uid] = result.data

        return {
            "success": True,
            "conflicts": conflicts,
            "has_conflicts": len(conflicts) > 0
        }

    except Exception as e:
        print(f"Error checking conflicts: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =============================================================================
# CLEARANCES, RELEASES, AND CONTRACTS
# =============================================================================

class ClearanceItemInput(BaseModel):
    type: str  # talent_release, location_release, appearance_release, nda, music_license, stock_license, other_contract
    title: str
    description: Optional[str] = None
    related_person_id: Optional[str] = None
    related_person_name: Optional[str] = None
    related_location_id: Optional[str] = None
    related_project_location_id: Optional[str] = None
    related_asset_label: Optional[str] = None
    file_url: Optional[str] = None
    file_name: Optional[str] = None
    file_is_sensitive: Optional[bool] = False
    status: Optional[str] = "not_started"
    requested_date: Optional[str] = None
    signed_date: Optional[str] = None
    expiration_date: Optional[str] = None
    notes: Optional[str] = None
    contact_email: Optional[str] = None
    contact_phone: Optional[str] = None


CLEARANCE_TYPES = [
    "talent_release",
    "location_release",
    "appearance_release",
    "nda",
    "music_license",
    "stock_license",
    "other_contract"
]

CLEARANCE_STATUSES = [
    "not_started",
    "requested",
    "signed",
    "expired",
    "rejected"
]


@router.get("/projects/{project_id}/clearances")
async def get_project_clearances(
    project_id: str,
    type: Optional[str] = None,
    status: Optional[str] = None,
    authorization: str = Header(None)
):
    """Get all clearance items for a project with optional filtering"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    # Verify project access using helper function
    await verify_project_access(client, project_id, user_id)

    try:
        query = client.table("backlot_clearance_items").select("*").eq("project_id", project_id)

        if type:
            query = query.eq("type", type)
        if status:
            query = query.eq("status", status)

        result = query.order("created_at", desc=True).execute()
        clearances = result.data or []

        # Generate pre-signed URLs for clearance documents
        for clearance in clearances:
            if clearance.get("file_url"):
                file_url = clearance["file_url"]
                # Handle both https:// and s3:// formats
                if file_url.startswith("https://swn-backlot-files-517220555400.s3"):
                    # Extract s3_key from https URL
                    s3_key = file_url.split(".amazonaws.com/", 1)[-1] if ".amazonaws.com/" in file_url else None
                    if s3_key:
                        clearance["file_url"] = get_signed_url('backlot-files', s3_key, expires_in=86400)
                elif file_url.startswith("s3://"):
                    # Handle s3:// format
                    s3_uri = file_url[5:]
                    parts = s3_uri.split("/", 1)
                    if len(parts) == 2:
                        _, s3_key = parts
                        clearance["file_url"] = get_signed_url('backlot-files', s3_key, expires_in=86400)

        # Compute summary in Python instead of using RPC
        summary = {"total": len(clearances), "by_status": {}, "by_type": {}}
        for c in clearances:
            c_status = c.get("status", "pending")
            c_type = c.get("type", "other")
            summary["by_status"][c_status] = summary["by_status"].get(c_status, 0) + 1
            summary["by_type"][c_type] = summary["by_type"].get(c_type, 0) + 1

        return {
            "success": True,
            "clearances": clearances,
            "count": len(clearances),
            "summary": summary
        }

    except Exception as e:
        print(f"Error fetching clearances: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/clearances")
async def create_clearance_item(
    project_id: str,
    item: ClearanceItemInput,
    authorization: str = Header(None)
):
    """Create a new clearance item"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    # Verify project edit access
    project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)
    if not is_owner:
        member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
        if not member_response.data or member_response.data[0]["role"] not in ["admin", "editor"]:
            raise HTTPException(status_code=403, detail="You don't have permission to create clearances")

    # Validate type
    if item.type not in CLEARANCE_TYPES:
        raise HTTPException(status_code=400, detail=f"Invalid clearance type. Must be one of: {CLEARANCE_TYPES}")

    # Validate status
    if item.status and item.status not in CLEARANCE_STATUSES:
        raise HTTPException(status_code=400, detail=f"Invalid status. Must be one of: {CLEARANCE_STATUSES}")

    try:
        # Helper to convert empty strings to None for UUID/date fields
        def empty_to_none(val):
            return None if val == "" else val

        clearance_data = {
            "project_id": project_id,
            "type": item.type,
            "title": item.title,
            "description": item.description or None,
            "related_person_id": empty_to_none(item.related_person_id),
            "related_person_name": item.related_person_name or None,
            "related_location_id": empty_to_none(item.related_location_id),
            "related_project_location_id": empty_to_none(item.related_project_location_id),
            "related_asset_label": item.related_asset_label or None,
            "file_url": empty_to_none(item.file_url),
            "file_name": item.file_name or None,
            "file_is_sensitive": item.file_is_sensitive or False,
            "status": item.status or "not_started",
            "requested_date": empty_to_none(item.requested_date),
            "signed_date": empty_to_none(item.signed_date),
            "expiration_date": empty_to_none(item.expiration_date),
            "notes": item.notes or None,
            "contact_email": item.contact_email or None,
            "contact_phone": item.contact_phone or None,
            "created_by_user_id": user_id,
        }

        result = client.table("backlot_clearance_items").insert(clearance_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create clearance item")

        return {"success": True, "clearance": result.data[0], "message": "Clearance item created"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating clearance: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/clearances/{clearance_id}")
async def get_clearance_item(
    clearance_id: str,
    authorization: str = Header(None)
):
    """Get a single clearance item"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        result = client.table("backlot_clearance_items").select("*").eq("id", clearance_id).single().execute()

        if not result.data:
            raise HTTPException(status_code=404, detail="Clearance item not found")

        # Verify access
        project_id = result.data["project_id"]
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = project_response.data and str(project_response.data[0]["owner_id"]) == str(user_id)

        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
            if not member_response.data:
                raise HTTPException(status_code=403, detail="Access denied")

        # Generate pre-signed URL for clearance document
        clearance = result.data
        if clearance.get("file_url"):
            file_url = clearance["file_url"]
            # Handle both https:// and s3:// formats
            if file_url.startswith("https://swn-backlot-files-517220555400.s3"):
                s3_key = file_url.split(".amazonaws.com/", 1)[-1] if ".amazonaws.com/" in file_url else None
                if s3_key:
                    clearance["file_url"] = get_signed_url('backlot-files', s3_key, expires_in=86400)
            elif file_url.startswith("s3://"):
                s3_uri = file_url[5:]
                parts = s3_uri.split("/", 1)
                if len(parts) == 2:
                    _, s3_key = parts
                    clearance["file_url"] = get_signed_url('backlot-files', s3_key, expires_in=86400)

        return {"success": True, "clearance": clearance}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching clearance: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/clearances/{clearance_id}")
async def update_clearance_item(
    clearance_id: str,
    item: ClearanceItemInput,
    authorization: str = Header(None)
):
    """Update a clearance item"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get existing clearance
        existing = client.table("backlot_clearance_items").select("project_id").eq("id", clearance_id).single().execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Clearance item not found")

        project_id = existing.data["project_id"]

        # Verify edit access
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = project_response.data and str(project_response.data[0]["owner_id"]) == str(user_id)

        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["admin", "editor"]:
                raise HTTPException(status_code=403, detail="You don't have permission to update clearances")

        # Validate type and status
        if item.type and item.type not in CLEARANCE_TYPES:
            raise HTTPException(status_code=400, detail=f"Invalid clearance type")
        if item.status and item.status not in CLEARANCE_STATUSES:
            raise HTTPException(status_code=400, detail=f"Invalid status")

        update_data = {
            "type": item.type,
            "title": item.title,
            "description": item.description,
            "related_person_id": item.related_person_id,
            "related_person_name": item.related_person_name,
            "related_location_id": item.related_location_id,
            "related_project_location_id": item.related_project_location_id,
            "related_asset_label": item.related_asset_label,
            "file_url": item.file_url,
            "file_name": item.file_name,
            "file_is_sensitive": item.file_is_sensitive,
            "status": item.status,
            "requested_date": item.requested_date,
            "signed_date": item.signed_date,
            "expiration_date": item.expiration_date,
            "notes": item.notes,
            "contact_email": item.contact_email,
            "contact_phone": item.contact_phone,
        }

        result = client.table("backlot_clearance_items").update(update_data).eq("id", clearance_id).execute()

        return {"success": True, "clearance": result.data[0] if result.data else None, "message": "Clearance updated"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating clearance: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/clearances/{clearance_id}")
async def delete_clearance_item(
    clearance_id: str,
    authorization: str = Header(None)
):
    """Delete a clearance item"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get existing clearance
        existing = client.table("backlot_clearance_items").select("project_id").eq("id", clearance_id).single().execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Clearance item not found")

        project_id = existing.data["project_id"]

        # Verify delete access (admin only)
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = project_response.data and str(project_response.data[0]["owner_id"]) == str(user_id)

        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
            if not member_response.data or member_response.data[0]["role"] != "admin":
                raise HTTPException(status_code=403, detail="Only admins can delete clearances")

        client.table("backlot_clearance_items").delete().eq("id", clearance_id).execute()

        return {"success": True, "message": "Clearance deleted"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting clearance: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/clearances/{clearance_id}/status")
async def update_clearance_status(
    clearance_id: str,
    status: str = Body(..., embed=True),
    authorization: str = Header(None)
):
    """Quick update of clearance status"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    if status not in CLEARANCE_STATUSES:
        raise HTTPException(status_code=400, detail=f"Invalid status. Must be one of: {CLEARANCE_STATUSES}")

    try:
        # Get existing clearance
        existing = client.table("backlot_clearance_items").select("project_id").eq("id", clearance_id).single().execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Clearance item not found")

        project_id = existing.data["project_id"]

        # Verify edit access
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = project_response.data and str(project_response.data[0]["owner_id"]) == str(user_id)

        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["admin", "editor"]:
                raise HTTPException(status_code=403, detail="You don't have permission to update clearances")

        update_data = {"status": status}

        # Auto-set signed_date when marking as signed
        if status == "signed":
            update_data["signed_date"] = datetime.utcnow().strftime("%Y-%m-%d")

        result = client.table("backlot_clearance_items").update(update_data).eq("id", clearance_id).execute()

        return {"success": True, "clearance": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating clearance status: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =============================================================================
# CLEARANCE STATUS LOOKUPS (for Call Sheets and Locations)
# =============================================================================

@router.get("/projects/{project_id}/clearances/location/{location_id}")
async def get_location_clearances(
    project_id: str,
    location_id: str,
    authorization: str = Header(None)
):
    """Get all clearances for a specific location"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        result = client.table("backlot_clearance_items").select("*").eq("project_id", project_id).eq("type", "location_release").or_(f"related_location_id.eq.{location_id},related_project_location_id.eq.{location_id}").execute()

        # Get the best status
        status = "missing"
        if result.data:
            for item in result.data:
                if item["status"] == "signed":
                    # Check if not expired
                    exp_date = item.get("expiration_date")
                    if not exp_date or exp_date >= datetime.utcnow().strftime("%Y-%m-%d"):
                        status = "signed"
                        break
                elif item["status"] == "requested" and status != "signed":
                    status = "requested"
                elif item["status"] == "not_started" and status not in ["signed", "requested"]:
                    status = "not_started"

        return {
            "success": True,
            "clearances": result.data or [],
            "release_status": status,
            "has_signed_release": status == "signed"
        }

    except Exception as e:
        print(f"Error fetching location clearances: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/clearances/person/{person_id}")
async def get_person_clearances(
    project_id: str,
    person_id: str,
    release_type: Optional[str] = "talent_release",
    authorization: str = Header(None)
):
    """Get all clearances for a specific person"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        query = client.table("backlot_clearance_items").select("*").eq("project_id", project_id).eq("related_person_id", person_id)

        if release_type:
            query = query.eq("type", release_type)

        result = query.execute()

        # Get the best status
        status = "missing"
        if result.data:
            for item in result.data:
                if item["status"] == "signed":
                    exp_date = item.get("expiration_date")
                    if not exp_date or exp_date >= datetime.utcnow().strftime("%Y-%m-%d"):
                        status = "signed"
                        break
                elif item["status"] == "requested" and status != "signed":
                    status = "requested"
                elif item["status"] == "not_started" and status not in ["signed", "requested"]:
                    status = "not_started"

        return {
            "success": True,
            "clearances": result.data or [],
            "release_status": status,
            "has_signed_release": status == "signed"
        }

    except Exception as e:
        print(f"Error fetching person clearances: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/clearances/person/{person_id}/detailed")
async def get_person_clearances_detailed(
    project_id: str,
    person_id: str,
    authorization: str = Header(None)
):
    """
    Get all clearances for a person WITH recipient and signature details.
    Used by Casting & Crew tab to show full clearance info per person.
    """
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get all clearances for this person (any type)
        clearances_result = client.table("backlot_clearance_items").select("*").eq("project_id", project_id).eq("related_person_id", person_id).order("created_at", desc=True).execute()

        clearances = clearances_result.data or []

        # For each clearance, fetch recipients
        for clearance in clearances:
            recipients_result = client.table("backlot_clearance_recipients").select("*").eq("clearance_id", clearance["id"]).execute()
            recipients_data = recipients_result.data or []

            # Resolve recipient names/emails
            resolved_recipients = []
            for r in recipients_data:
                name = r.get("manual_name") or ""
                email = r.get("manual_email") or ""
                recipient_type = "manual"

                if r.get("project_contact_id"):
                    contact = client.table("backlot_project_contacts").select("name, email").eq("id", r["project_contact_id"]).single().execute()
                    if contact.data:
                        name = contact.data.get("name", "")
                        email = contact.data.get("email", "")
                        recipient_type = "contact"
                elif r.get("project_member_user_id"):
                    profile = client.table("profiles").select("full_name, email").eq("id", r["project_member_user_id"]).single().execute()
                    if profile.data:
                        name = profile.data.get("full_name", "")
                        email = profile.data.get("email", "")
                        recipient_type = "member"

                resolved_recipients.append({
                    "id": r["id"],
                    "name": name,
                    "email": email,
                    "recipient_type": recipient_type,
                    "requires_signature": r.get("requires_signature", False),
                    "signature_status": r.get("signature_status", "not_required"),
                    "signed_at": r.get("signed_at"),
                    "viewed_at": r.get("viewed_at"),
                    "last_email_sent_at": r.get("last_email_sent_at"),
                    "email_send_count": r.get("email_send_count", 0),
                })

            clearance["recipients"] = resolved_recipients

        # Calculate summary
        total = len(clearances)
        signed = sum(1 for c in clearances if c.get("status") == "signed")
        pending = sum(1 for c in clearances if c.get("status") in ["requested", "pending", "not_started"])
        missing = 0  # We could track expected vs actual clearances here

        return {
            "clearances": clearances,
            "summary": {
                "total": total,
                "signed": signed,
                "pending": pending,
                "missing": missing,
            }
        }

    except Exception as e:
        print(f"Error fetching detailed person clearances: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/clearances/bulk-status")
async def get_bulk_clearance_status(
    project_id: str,
    location_ids: Optional[List[str]] = Body(default=[]),
    person_ids: Optional[List[str]] = Body(default=[]),
    authorization: str = Header(None)
):
    """Get clearance status for multiple locations and people at once (for call sheets)"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        result = {
            "locations": {},
            "people": {}
        }

        # Get location clearances
        if location_ids:
            for loc_id in location_ids:
                loc_result = client.table("backlot_clearance_items").select("status, expiration_date").eq("project_id", project_id).eq("type", "location_release").or_(f"related_location_id.eq.{loc_id},related_project_location_id.eq.{loc_id}").execute()

                status = "missing"
                if loc_result.data:
                    for item in loc_result.data:
                        if item["status"] == "signed":
                            exp_date = item.get("expiration_date")
                            if not exp_date or exp_date >= datetime.utcnow().strftime("%Y-%m-%d"):
                                status = "signed"
                                break
                        elif item["status"] == "requested" and status != "signed":
                            status = "requested"
                        elif status == "missing":
                            status = item["status"]

                result["locations"][loc_id] = status

        # Get person clearances (talent releases)
        if person_ids:
            for person_id in person_ids:
                person_result = client.table("backlot_clearance_items").select("status, expiration_date").eq("project_id", project_id).eq("related_person_id", person_id).in_("type", ["talent_release", "appearance_release"]).execute()

                status = "missing"
                if person_result.data:
                    for item in person_result.data:
                        if item["status"] == "signed":
                            exp_date = item.get("expiration_date")
                            if not exp_date or exp_date >= datetime.utcnow().strftime("%Y-%m-%d"):
                                status = "signed"
                                break
                        elif item["status"] == "requested" and status != "signed":
                            status = "requested"
                        elif status == "missing":
                            status = item["status"]

                result["people"][person_id] = status

        return {"success": True, **result}

    except Exception as e:
        print(f"Error fetching bulk clearance status: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =============================================================================
# CLEARANCE REPORT GENERATION
# =============================================================================

@router.get("/projects/{project_id}/clearances/report")
async def generate_clearance_report(
    project_id: str,
    format: Optional[str] = "json",  # json or csv
    authorization: str = Header(None)
):
    """Generate a comprehensive clearance report for delivery/sales"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    # Verify access
    project_response = client.table("backlot_projects").select("*").eq("id", project_id).single().execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    project = project_response.data
    is_owner = str(project["owner_id"]) == str(user_id)

    if not is_owner:
        member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
        if not member_response.data:
            raise HTTPException(status_code=403, detail="Access denied")

    try:
        # Get all clearances
        clearances_result = client.table("backlot_clearance_items").select("*").eq("project_id", project_id).order("type").order("status").execute()
        clearances = clearances_result.data or []

        # Organize by type
        by_type = {}
        for c in clearances:
            t = c["type"]
            if t not in by_type:
                by_type[t] = []
            by_type[t].append(c)

        # Calculate statistics
        stats = {
            "total": len(clearances),
            "signed": len([c for c in clearances if c["status"] == "signed"]),
            "requested": len([c for c in clearances if c["status"] == "requested"]),
            "not_started": len([c for c in clearances if c["status"] == "not_started"]),
            "expired": len([c for c in clearances if c["status"] == "expired"]),
            "rejected": len([c for c in clearances if c["status"] == "rejected"]),
        }

        # Type-specific stats
        type_stats = {}
        for t in CLEARANCE_TYPES:
            items = by_type.get(t, [])
            type_stats[t] = {
                "total": len(items),
                "signed": len([c for c in items if c["status"] == "signed"]),
                "requested": len([c for c in items if c["status"] == "requested"]),
                "not_started": len([c for c in items if c["status"] == "not_started"]),
                "expired": len([c for c in items if c["status"] == "expired"]),
                "completion_rate": round(len([c for c in items if c["status"] == "signed"]) / len(items) * 100, 1) if items else 0
            }

        # Expiring soon (within 30 days)
        today = datetime.utcnow().strftime("%Y-%m-%d")
        thirty_days = (datetime.utcnow() + timedelta(days=30)).strftime("%Y-%m-%d")
        expiring_soon = [
            c for c in clearances
            if c["status"] == "signed"
            and c.get("expiration_date")
            and c["expiration_date"] <= thirty_days
            and c["expiration_date"] >= today
        ]

        report = {
            "project": {
                "id": project["id"],
                "title": project["title"],
                "status": project["status"],
            },
            "generated_at": datetime.utcnow().isoformat(),
            "generated_by": user_id,
            "summary": {
                "overall_stats": stats,
                "completion_rate": round(stats["signed"] / stats["total"] * 100, 1) if stats["total"] > 0 else 0,
                "by_type": type_stats,
                "expiring_soon_count": len(expiring_soon),
            },
            "clearances_by_type": by_type,
            "expiring_soon": expiring_soon,
            "issues": {
                "missing_files": [c for c in clearances if c["status"] == "signed" and not c.get("file_url")],
                "expired": [c for c in clearances if c["status"] == "expired"],
                "rejected": [c for c in clearances if c["status"] == "rejected"]
            }
        }

        if format == "csv":
            # Generate CSV format
            import csv
            import io

            output = io.StringIO()
            writer = csv.writer(output)

            # Header
            writer.writerow([
                "Type", "Title", "Status", "Related Person", "Related Location",
                "Asset Label", "Requested Date", "Signed Date", "Expiration Date",
                "Has File", "Notes"
            ])

            # Data rows
            for c in clearances:
                writer.writerow([
                    c["type"],
                    c["title"],
                    c["status"],
                    c.get("related_person_name", ""),
                    c.get("related_location_id", ""),
                    c.get("related_asset_label", ""),
                    c.get("requested_date", ""),
                    c.get("signed_date", ""),
                    c.get("expiration_date", ""),
                    "Yes" if c.get("file_url") else "No",
                    c.get("notes", "")
                ])

            return Response(
                content=output.getvalue(),
                media_type="text/csv",
                headers={"Content-Disposition": f"attachment; filename=clearance_report_{project_id}.csv"}
            )

        return {"success": True, "report": report}

    except Exception as e:
        print(f"Error generating clearance report: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =============================================================================
# CLEARANCE TEMPLATES
# =============================================================================

@router.get("/clearance-templates")
async def get_clearance_templates(
    type: Optional[str] = None,
    authorization: str = Header(None)
):
    """Get available clearance templates (system + user's own)"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        query = client.table("backlot_clearance_templates").select("*").or_(f"owner_user_id.is.null,owner_user_id.eq.{user_id}").eq("is_active", True)

        if type:
            query = query.eq("type", type)

        result = query.order("name").execute()

        return {"success": True, "templates": result.data or []}

    except Exception as e:
        print(f"Error fetching clearance templates: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =============================================================================
# CLEARANCE DOCUMENT UPLOAD
# =============================================================================

class ClearanceDocumentUpload(BaseModel):
    """Input for uploading a document to a clearance"""
    file_name: str
    content_type: str
    file_size: int


@router.post("/clearances/{clearance_id}/upload-url")
async def get_clearance_upload_url(
    clearance_id: str,
    data: ClearanceDocumentUpload,
    authorization: str = Header(None)
):
    """Get a presigned URL for uploading a clearance document to S3"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get existing clearance and verify access
        existing = client.table("backlot_clearance_items").select("project_id").eq("id", clearance_id).single().execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Clearance not found")

        project_id = existing.data["project_id"]

        # Verify user has edit access to project
        membership = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).single().execute()
        owner_check = client.table("backlot_projects").select("owner_id").eq("id", project_id).eq("owner_id", user_id).execute()

        if not membership.data and not owner_check.data:
            raise HTTPException(status_code=403, detail="You don't have permission to upload clearance documents")

        if membership.data and membership.data.get("role") not in ["admin", "editor"]:
            raise HTTPException(status_code=403, detail="Only admins and editors can upload clearance documents")

        # Org-level storage enforcement
        _enforce_org_storage(project_id, data.file_size)

        # Generate S3 key for the file
        import uuid
        file_ext = data.file_name.split(".")[-1] if "." in data.file_name else "pdf"
        s3_key = f"clearances/{project_id}/{clearance_id}/{uuid.uuid4()}.{file_ext}"

        # Generate presigned upload URL
        import boto3
        s3_client = boto3.client("s3", region_name="us-east-1")
        presigned_url = s3_client.generate_presigned_url(
            "put_object",
            Params={
                "Bucket": "swn-backlot-files-517220555400",
                "Key": s3_key,
                "ContentType": data.content_type,
            },
            ExpiresIn=3600  # 1 hour
        )

        # Generate the final file URL (for after upload)
        file_url = f"https://swn-backlot-files-517220555400.s3.us-east-1.amazonaws.com/{s3_key}"

        return {
            "success": True,
            "upload_url": presigned_url,
            "file_url": file_url,
            "s3_key": s3_key
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error generating clearance upload URL: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/clearances/{clearance_id}/document")
async def update_clearance_document(
    clearance_id: str,
    data: dict,
    authorization: str = Header(None)
):
    """Update clearance with uploaded document info and create version record"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    user_name = user.get("full_name") or user.get("email", "Unknown")
    client = get_client()

    try:
        # Get existing clearance
        existing = client.table("backlot_clearance_items").select("project_id, file_url").eq("id", clearance_id).single().execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Clearance not found")

        project_id = existing.data["project_id"]
        old_file_url = existing.data.get("file_url")

        # Verify access
        membership = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).single().execute()
        owner_check = client.table("backlot_projects").select("owner_id").eq("id", project_id).eq("owner_id", user_id).execute()

        if not membership.data and not owner_check.data:
            raise HTTPException(status_code=403, detail="You don't have permission to update clearance documents")

        # Get next version number
        versions_result = client.table("backlot_clearance_document_versions").select("version_number").eq("clearance_id", clearance_id).order("version_number", desc=True).limit(1).execute()
        next_version = (versions_result.data[0]["version_number"] + 1) if versions_result.data else 1

        # Mark all previous versions as not current
        client.table("backlot_clearance_document_versions").update({"is_current": False}).eq("clearance_id", clearance_id).execute()

        # Create new version record
        version_data = {
            "clearance_id": clearance_id,
            "version_number": next_version,
            "file_url": data.get("file_url"),
            "file_name": data.get("file_name"),
            "file_size": data.get("file_size"),
            "content_type": data.get("content_type"),
            "uploaded_by_user_id": user_id,
            "uploaded_by_name": user_name,
            "notes": data.get("notes"),
            "is_current": True
        }
        client.table("backlot_clearance_document_versions").insert(version_data).execute()

        # Update clearance with file info
        update_data = {
            "file_url": data.get("file_url"),
            "file_name": data.get("file_name"),
            "updated_at": "now()"
        }

        client.table("backlot_clearance_items").update(update_data).eq("id", clearance_id).execute()

        # Record history
        history_action = "file_uploaded" if not old_file_url else "file_uploaded"
        client.table("backlot_clearance_history").insert({
            "clearance_id": clearance_id,
            "action": history_action,
            "user_id": user_id,
            "user_name": user_name,
            "notes": f"Uploaded document: {data.get('file_name')} (v{next_version})",
            "metadata": {"file_url": data.get("file_url"), "file_name": data.get("file_name"), "version": next_version}
        }).execute()

        return {"success": True, "message": "Document uploaded successfully", "version": next_version}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating clearance document: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/clearances/{clearance_id}/document")
async def remove_clearance_document(
    clearance_id: str,
    authorization: str = Header(None)
):
    """Remove document from a clearance"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    user_name = user.get("full_name") or user.get("email", "Unknown")
    client = get_client()

    try:
        # Get existing clearance
        existing = client.table("backlot_clearance_items").select("project_id, file_url, file_name").eq("id", clearance_id).single().execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Clearance not found")

        project_id = existing.data["project_id"]
        old_file_name = existing.data.get("file_name")

        # Verify access - only admins
        membership = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).single().execute()
        owner_check = client.table("backlot_projects").select("owner_id").eq("id", project_id).eq("owner_id", user_id).execute()

        if not owner_check.data and (not membership.data or membership.data.get("role") != "admin"):
            raise HTTPException(status_code=403, detail="Only owners and admins can remove clearance documents")

        # Clear file fields
        client.table("backlot_clearance_items").update({
            "file_url": None,
            "file_name": None,
            "updated_at": "now()"
        }).eq("id", clearance_id).execute()

        # Record history
        client.table("backlot_clearance_history").insert({
            "clearance_id": clearance_id,
            "action": "file_removed",
            "user_id": user_id,
            "user_name": user_name,
            "notes": f"Removed document: {old_file_name}",
            "metadata": {}
        }).execute()

        return {"success": True, "message": "Document removed"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error removing clearance document: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =============================================================================
# CLEARANCE DOCUMENT VERSIONS
# =============================================================================

@router.get("/clearances/{clearance_id}/versions")
async def get_clearance_document_versions(
    clearance_id: str,
    authorization: str = Header(None)
):
    """Get all document versions for a clearance"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get clearance and verify access
        existing = client.table("backlot_clearance_items").select("project_id").eq("id", clearance_id).single().execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Clearance not found")

        project_id = existing.data["project_id"]

        # Verify user has access to project
        membership = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).single().execute()
        owner_check = client.table("backlot_projects").select("owner_id").eq("id", project_id).eq("owner_id", user_id).execute()

        if not membership.data and not owner_check.data:
            raise HTTPException(status_code=403, detail="You don't have permission to view this clearance")

        # Get all versions
        versions = client.table("backlot_clearance_document_versions").select("*").eq("clearance_id", clearance_id).order("version_number", desc=True).execute()

        # Generate pre-signed URLs for version documents
        for version in versions.data or []:
            if version.get("file_url"):
                file_url = version["file_url"]
                # Handle both https:// and s3:// formats
                if file_url.startswith("https://swn-backlot-files-517220555400.s3"):
                    s3_key = file_url.split(".amazonaws.com/", 1)[-1] if ".amazonaws.com/" in file_url else None
                    if s3_key:
                        version["file_url"] = get_signed_url('backlot-files', s3_key, expires_in=86400)
                elif file_url.startswith("s3://"):
                    s3_uri = file_url[5:]
                    parts = s3_uri.split("/", 1)
                    if len(parts) == 2:
                        _, s3_key = parts
                        version["file_url"] = get_signed_url('backlot-files', s3_key, expires_in=86400)

        return versions.data

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting clearance versions: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/clearances/{clearance_id}/versions/{version_id}/restore")
async def restore_clearance_document_version(
    clearance_id: str,
    version_id: str,
    authorization: str = Header(None)
):
    """Restore an old document version (creates a new version from the old one)"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    user_name = user.get("full_name") or user.get("email", "Unknown")
    client = get_client()

    try:
        # Get clearance and verify access
        existing = client.table("backlot_clearance_items").select("project_id").eq("id", clearance_id).single().execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Clearance not found")

        project_id = existing.data["project_id"]

        # Verify user has edit access
        membership = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).single().execute()
        owner_check = client.table("backlot_projects").select("owner_id").eq("id", project_id).eq("owner_id", user_id).execute()

        if not membership.data and not owner_check.data:
            raise HTTPException(status_code=403, detail="You don't have permission to restore document versions")

        if membership.data and membership.data.get("role") not in ["admin", "editor"]:
            raise HTTPException(status_code=403, detail="Only admins and editors can restore document versions")

        # Get the version to restore
        old_version = client.table("backlot_clearance_document_versions").select("*").eq("id", version_id).eq("clearance_id", clearance_id).single().execute()
        if not old_version.data:
            raise HTTPException(status_code=404, detail="Version not found")

        # Get next version number
        versions_result = client.table("backlot_clearance_document_versions").select("version_number").eq("clearance_id", clearance_id).order("version_number", desc=True).limit(1).execute()
        next_version = versions_result.data[0]["version_number"] + 1 if versions_result.data else 1

        # Mark all previous versions as not current
        client.table("backlot_clearance_document_versions").update({"is_current": False}).eq("clearance_id", clearance_id).execute()

        # Create new version from old version
        new_version_data = {
            "clearance_id": clearance_id,
            "version_number": next_version,
            "file_url": old_version.data["file_url"],
            "file_name": old_version.data["file_name"],
            "file_size": old_version.data.get("file_size"),
            "content_type": old_version.data.get("content_type"),
            "uploaded_by_user_id": user_id,
            "uploaded_by_name": user_name,
            "notes": f"Restored from v{old_version.data['version_number']}",
            "is_current": True
        }
        client.table("backlot_clearance_document_versions").insert(new_version_data).execute()

        # Update clearance with restored file info
        client.table("backlot_clearance_items").update({
            "file_url": old_version.data["file_url"],
            "file_name": old_version.data["file_name"],
            "updated_at": "now()"
        }).eq("id", clearance_id).execute()

        # Record history
        client.table("backlot_clearance_history").insert({
            "clearance_id": clearance_id,
            "action": "file_uploaded",
            "user_id": user_id,
            "user_name": user_name,
            "notes": f"Restored document: {old_version.data['file_name']} (v{old_version.data['version_number']}  v{next_version})",
            "metadata": {"restored_from_version": old_version.data["version_number"], "new_version": next_version}
        }).execute()

        return {"success": True, "message": "Version restored successfully", "new_version": next_version}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error restoring clearance version: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =============================================================================
# CLEARANCE WORKFLOW (ASSIGNMENT, STATUS WITH HISTORY)
# =============================================================================

class ClearanceAssignInput(BaseModel):
    """Input for assigning a clearance to a team member"""
    user_id: str
    notes: Optional[str] = None


@router.post("/clearances/{clearance_id}/assign")
async def assign_clearance(
    clearance_id: str,
    data: ClearanceAssignInput,
    authorization: str = Header(None)
):
    """Assign a clearance to a team member"""
    user = await get_current_user_from_token(authorization)
    assigner_id = user["id"]
    assigner_name = user.get("full_name") or user.get("email", "Unknown")
    client = get_client()

    try:
        # Get existing clearance
        existing = client.table("backlot_clearance_items").select("project_id, assigned_to_user_id, title").eq("id", clearance_id).single().execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Clearance not found")

        project_id = existing.data["project_id"]
        clearance_title = existing.data.get("title", "Clearance")

        # Verify assigner has permission
        membership = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", assigner_id).single().execute()
        owner_check = client.table("backlot_projects").select("owner_id").eq("id", project_id).eq("owner_id", assigner_id).execute()

        if not membership.data and not owner_check.data:
            raise HTTPException(status_code=403, detail="You don't have permission to assign clearances")

        if membership.data and membership.data.get("role") not in ["admin", "editor"]:
            raise HTTPException(status_code=403, detail="Only admins and editors can assign clearances")

        # Verify assignee is a project member
        assignee_check = client.table("backlot_project_members").select("id").eq("project_id", project_id).eq("user_id", data.user_id).execute()
        assignee_owner = client.table("backlot_projects").select("id").eq("id", project_id).eq("owner_id", data.user_id).execute()

        if not assignee_check.data and not assignee_owner.data:
            raise HTTPException(status_code=400, detail="User is not a member of this project")

        # Get assignee name
        assignee_profile = client.table("profiles").select("full_name, email").eq("id", data.user_id).single().execute()
        assignee_name = assignee_profile.data.get("full_name") or assignee_profile.data.get("email", "Unknown") if assignee_profile.data else "Unknown"

        # Update clearance
        client.table("backlot_clearance_items").update({
            "assigned_to_user_id": data.user_id,
            "assigned_at": "now()",
            "assigned_by_user_id": assigner_id,
            "updated_at": "now()"
        }).eq("id", clearance_id).execute()

        # Record history
        client.table("backlot_clearance_history").insert({
            "clearance_id": clearance_id,
            "action": "assigned",
            "user_id": assigner_id,
            "user_name": assigner_name,
            "notes": data.notes or f"Assigned to {assignee_name}",
            "metadata": {"assigned_to_user_id": data.user_id, "assigned_to_name": assignee_name}
        }).execute()

        # Create notification for assignee
        try:
            client.table("notifications").insert({
                "user_id": data.user_id,
                "type": "clearance_assigned",
                "title": "Clearance Assigned to You",
                "message": f"You've been assigned to handle: {clearance_title}",
                "data": {
                    "clearance_id": clearance_id,
                    "project_id": project_id,
                    "assigned_by": assigner_name
                }
            }).execute()
        except:
            pass  # Notification is non-critical

        return {"success": True, "message": f"Clearance assigned to {assignee_name}"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error assigning clearance: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/clearances/{clearance_id}/unassign")
async def unassign_clearance(
    clearance_id: str,
    authorization: str = Header(None)
):
    """Remove assignment from a clearance"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    user_name = user.get("full_name") or user.get("email", "Unknown")
    client = get_client()

    try:
        # Get existing clearance
        existing = client.table("backlot_clearance_items").select("project_id, assigned_to_user_id").eq("id", clearance_id).single().execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Clearance not found")

        project_id = existing.data["project_id"]

        # Verify access
        membership = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).single().execute()
        owner_check = client.table("backlot_projects").select("owner_id").eq("id", project_id).eq("owner_id", user_id).execute()

        if not membership.data and not owner_check.data:
            raise HTTPException(status_code=403, detail="You don't have permission to unassign clearances")

        # Clear assignment
        client.table("backlot_clearance_items").update({
            "assigned_to_user_id": None,
            "assigned_at": None,
            "assigned_by_user_id": None,
            "updated_at": "now()"
        }).eq("id", clearance_id).execute()

        # Record history
        client.table("backlot_clearance_history").insert({
            "clearance_id": clearance_id,
            "action": "unassigned",
            "user_id": user_id,
            "user_name": user_name,
            "notes": "Assignment removed",
            "metadata": {}
        }).execute()

        return {"success": True, "message": "Assignment removed"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error unassigning clearance: {e}")
        raise HTTPException(status_code=500, detail=str(e))


class ClearanceStatusUpdateInput(BaseModel):
    """Input for updating clearance status with rejection support"""
    status: str
    rejection_reason: Optional[str] = None
    notes: Optional[str] = None


@router.patch("/clearances/{clearance_id}/workflow-status")
async def update_clearance_workflow_status(
    clearance_id: str,
    data: ClearanceStatusUpdateInput,
    authorization: str = Header(None)
):
    """Update clearance status with full workflow tracking (history, rejection, signed_date)"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    user_name = user.get("full_name") or user.get("email", "Unknown")
    client = get_client()

    VALID_STATUSES = ["not_started", "requested", "pending", "signed", "rejected", "expired"]

    try:
        if data.status not in VALID_STATUSES:
            raise HTTPException(status_code=400, detail=f"Invalid status. Must be one of: {VALID_STATUSES}")

        # Get existing clearance
        existing = client.table("backlot_clearance_items").select("project_id, status").eq("id", clearance_id).single().execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Clearance not found")

        project_id = existing.data["project_id"]
        old_status = existing.data.get("status")

        # Verify access
        membership = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).single().execute()
        owner_check = client.table("backlot_projects").select("owner_id").eq("id", project_id).eq("owner_id", user_id).execute()

        if not membership.data and not owner_check.data:
            raise HTTPException(status_code=403, detail="You don't have permission to update clearance status")

        # Build update data
        update_data = {
            "status": data.status,
            "updated_at": "now()"
        }

        # Auto-set signed_date when status becomes signed
        if data.status == "signed" and old_status != "signed":
            from datetime import date
            update_data["signed_date"] = date.today().isoformat()

        # Handle rejection
        if data.status == "rejected":
            update_data["rejection_reason"] = data.rejection_reason
            update_data["rejected_at"] = "now()"
            update_data["rejected_by_user_id"] = user_id

        # Clear rejection if no longer rejected
        if data.status != "rejected" and old_status == "rejected":
            update_data["rejection_reason"] = None
            update_data["rejected_at"] = None
            update_data["rejected_by_user_id"] = None

        client.table("backlot_clearance_items").update(update_data).eq("id", clearance_id).execute()

        # Determine history action
        history_action = "rejected" if data.status == "rejected" else "status_changed"

        # Record history
        client.table("backlot_clearance_history").insert({
            "clearance_id": clearance_id,
            "action": history_action,
            "old_status": old_status,
            "new_status": data.status,
            "user_id": user_id,
            "user_name": user_name,
            "notes": data.notes or data.rejection_reason or f"Status changed from {old_status} to {data.status}",
            "metadata": {"rejection_reason": data.rejection_reason} if data.rejection_reason else {}
        }).execute()

        return {"success": True, "message": f"Status updated to {data.status}"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating clearance workflow status: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =============================================================================
# CLEARANCE HISTORY
# =============================================================================

@router.get("/clearances/{clearance_id}/history")
async def get_clearance_history(
    clearance_id: str,
    authorization: str = Header(None)
):
    """Get audit history for a clearance"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get clearance and verify access
        existing = client.table("backlot_clearance_items").select("project_id").eq("id", clearance_id).single().execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Clearance not found")

        project_id = existing.data["project_id"]

        # Verify access
        membership = client.table("backlot_project_members").select("id").eq("project_id", project_id).eq("user_id", user_id).execute()
        owner_check = client.table("backlot_projects").select("id").eq("id", project_id).eq("owner_id", user_id).execute()

        if not membership.data and not owner_check.data:
            raise HTTPException(status_code=403, detail="You don't have access to this clearance")

        # Get history
        result = client.table("backlot_clearance_history").select("*").eq("clearance_id", clearance_id).order("created_at", desc=True).execute()

        return {"success": True, "history": result.data or []}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching clearance history: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =============================================================================
# E&O REQUIREMENTS
# =============================================================================

@router.get("/projects/{project_id}/eo-requirements")
async def get_eo_requirements(
    project_id: str,
    authorization: str = Header(None)
):
    """Get E&O requirements checklist for a project"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Verify access
        membership = client.table("backlot_project_members").select("id").eq("project_id", project_id).eq("user_id", user_id).execute()
        owner_check = client.table("backlot_projects").select("id").eq("id", project_id).eq("owner_id", user_id).execute()

        if not membership.data and not owner_check.data:
            raise HTTPException(status_code=403, detail="You don't have access to this project")

        # Get requirements with linked clearance info
        result = client.table("backlot_eo_requirements").select(
            "*, linked_clearance:backlot_clearance_items(id, title, status, file_url)"
        ).eq("project_id", project_id).order("sort_order").execute()

        return {"success": True, "requirements": result.data or []}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching E&O requirements: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/eo-requirements/initialize")
async def initialize_eo_requirements(
    project_id: str,
    authorization: str = Header(None)
):
    """Initialize E&O requirements from templates for a project"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Verify ownership/admin
        owner_check = client.table("backlot_projects").select("id").eq("id", project_id).eq("owner_id", user_id).execute()
        membership = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).single().execute()

        if not owner_check.data and (not membership.data or membership.data.get("role") != "admin"):
            raise HTTPException(status_code=403, detail="Only owners and admins can initialize E&O requirements")

        # Call database function
        result = client.rpc("initialize_eo_requirements", {"p_project_id": project_id, "p_user_id": user_id}).execute()
        inserted_count = result.data if result.data else 0

        return {"success": True, "message": f"Initialized {inserted_count} E&O requirements", "count": inserted_count}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error initializing E&O requirements: {e}")
        raise HTTPException(status_code=500, detail=str(e))


class EORequirementUpdate(BaseModel):
    """Input for updating an E&O requirement"""
    status: Optional[str] = None
    linked_clearance_id: Optional[str] = None
    waived_reason: Optional[str] = None


@router.patch("/eo-requirements/{requirement_id}")
async def update_eo_requirement(
    requirement_id: str,
    data: EORequirementUpdate,
    authorization: str = Header(None)
):
    """Update an E&O requirement (link clearance, change status, waive)"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    VALID_STATUSES = ["missing", "partial", "complete", "waived"]

    try:
        if data.status and data.status not in VALID_STATUSES:
            raise HTTPException(status_code=400, detail=f"Invalid status. Must be one of: {VALID_STATUSES}")

        # Get requirement
        existing = client.table("backlot_eo_requirements").select("project_id").eq("id", requirement_id).single().execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="E&O requirement not found")

        project_id = existing.data["project_id"]

        # Verify access
        owner_check = client.table("backlot_projects").select("id").eq("id", project_id).eq("owner_id", user_id).execute()
        membership = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).single().execute()

        if not owner_check.data and (not membership.data or membership.data.get("role") not in ["admin", "editor"]):
            raise HTTPException(status_code=403, detail="Only owners, admins, and editors can update E&O requirements")

        # Build update
        update_data = {"updated_at": "now()"}

        if data.status:
            update_data["status"] = data.status

        if data.linked_clearance_id is not None:
            update_data["linked_clearance_id"] = data.linked_clearance_id if data.linked_clearance_id else None

        if data.status == "waived":
            update_data["waived_reason"] = data.waived_reason
            update_data["waived_by_user_id"] = user_id
            update_data["waived_at"] = "now()"
        elif data.status and data.status != "waived":
            update_data["waived_reason"] = None
            update_data["waived_by_user_id"] = None
            update_data["waived_at"] = None

        client.table("backlot_eo_requirements").update(update_data).eq("id", requirement_id).execute()

        return {"success": True, "message": "E&O requirement updated"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating E&O requirement: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/eo-summary")
async def get_eo_summary(
    project_id: str,
    authorization: str = Header(None)
):
    """Get E&O readiness summary for a project"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Verify access
        membership = client.table("backlot_project_members").select("id").eq("project_id", project_id).eq("user_id", user_id).execute()
        owner_check = client.table("backlot_projects").select("id").eq("id", project_id).eq("owner_id", user_id).execute()

        if not membership.data and not owner_check.data:
            raise HTTPException(status_code=403, detail="You don't have access to this project")

        # Call database function
        result = client.rpc("get_project_eo_summary", {"p_project_id": project_id}).execute()

        return {"success": True, "summary": result.data if result.data else {}}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching E&O summary: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =============================================================================
# EXPIRING CLEARANCES
# =============================================================================

@router.get("/projects/{project_id}/clearances/expiring")
async def get_expiring_clearances(
    project_id: str,
    days: int = 90,
    authorization: str = Header(None)
):
    """Get clearances expiring within the specified number of days"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Verify access
        membership = client.table("backlot_project_members").select("id").eq("project_id", project_id).eq("user_id", user_id).execute()
        owner_check = client.table("backlot_projects").select("id").eq("id", project_id).eq("owner_id", user_id).execute()

        if not membership.data and not owner_check.data:
            raise HTTPException(status_code=403, detail="You don't have access to this project")

        # Call database function
        result = client.rpc("get_expiring_clearances", {"p_project_id": project_id, "p_days_ahead": days}).execute()

        return {"success": True, "expiring_clearances": result.data or []}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching expiring clearances: {e}")
        raise HTTPException(status_code=500, detail=str(e))


class BulkClearanceStatusInput(BaseModel):
    """Input for bulk updating clearance statuses"""
    clearance_ids: List[str]
    status: str
    notes: Optional[str] = None


@router.patch("/projects/{project_id}/clearances/bulk-update")
async def bulk_update_clearances(
    project_id: str,
    data: BulkClearanceStatusInput,
    authorization: str = Header(None)
):
    """Update status of multiple clearances at once"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    user_name = user.get("full_name") or user.get("email", "Unknown")
    client = get_client()

    VALID_STATUSES = ["not_started", "requested", "pending", "signed", "rejected", "expired"]

    try:
        if data.status not in VALID_STATUSES:
            raise HTTPException(status_code=400, detail=f"Invalid status. Must be one of: {VALID_STATUSES}")

        # Verify access
        owner_check = client.table("backlot_projects").select("id").eq("id", project_id).eq("owner_id", user_id).execute()
        membership = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).single().execute()

        if not owner_check.data and (not membership.data or membership.data.get("role") not in ["admin", "editor"]):
            raise HTTPException(status_code=403, detail="Only owners, admins, and editors can bulk update clearances")

        updated_count = 0
        for clearance_id in data.clearance_ids:
            # Get current status
            existing = client.table("backlot_clearance_items").select("status").eq("id", clearance_id).eq("project_id", project_id).single().execute()
            if not existing.data:
                continue

            old_status = existing.data.get("status")

            # Update
            update_data = {"status": data.status, "updated_at": "now()"}
            if data.status == "signed" and old_status != "signed":
                from datetime import date
                update_data["signed_date"] = date.today().isoformat()

            client.table("backlot_clearance_items").update(update_data).eq("id", clearance_id).execute()

            # Record history
            client.table("backlot_clearance_history").insert({
                "clearance_id": clearance_id,
                "action": "status_changed",
                "old_status": old_status,
                "new_status": data.status,
                "user_id": user_id,
                "user_name": user_name,
                "notes": data.notes or f"Bulk update: {old_status}  {data.status}",
                "metadata": {"bulk_update": True}
            }).execute()

            updated_count += 1

        return {"success": True, "message": f"Updated {updated_count} clearances", "count": updated_count}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error bulk updating clearances: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =============================================================================
# CLEARANCE RECIPIENTS - MODELS & ENDPOINTS
# =============================================================================

class ClearanceRecipientInput(BaseModel):
    """Input for adding a recipient to a clearance"""
    project_contact_id: Optional[str] = None
    project_member_user_id: Optional[str] = None
    manual_email: Optional[str] = None
    manual_name: Optional[str] = None
    requires_signature: bool = False


class ClearanceRecipientUpdate(BaseModel):
    """Input for updating a recipient"""
    requires_signature: Optional[bool] = None


@router.get("/clearances/{clearance_id}/recipients")
async def get_clearance_recipients(
    clearance_id: str,
    authorization: str = Header(None)
):
    """Get all recipients for a clearance with resolved names and emails"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Verify clearance exists and user has access
        clearance = client.table("backlot_clearance_items").select("project_id").eq("id", clearance_id).single().execute()
        if not clearance.data:
            raise HTTPException(status_code=404, detail="Clearance not found")

        project_id = clearance.data["project_id"]
        await verify_project_access(client, project_id, user_id)

        # Get recipients
        recipients = client.table("backlot_clearance_recipients").select("*").eq("clearance_id", clearance_id).order("created_at").execute()

        # Resolve names and emails for each recipient
        resolved_recipients = []
        for r in recipients.data or []:
            resolved = {**r}

            if r.get("project_contact_id"):
                # Get contact info
                contact = client.table("backlot_project_contacts").select("name, email, phone, contact_type").eq("id", r["project_contact_id"]).single().execute()
                if contact.data:
                    resolved["name"] = contact.data.get("name", "Unknown")
                    resolved["email"] = contact.data.get("email")
                    resolved["phone"] = contact.data.get("phone")
                    resolved["recipient_type"] = "contact"
                    resolved["contact"] = contact.data
                else:
                    resolved["name"] = "Deleted Contact"
                    resolved["email"] = None
                    resolved["recipient_type"] = "contact"

            elif r.get("project_member_user_id"):
                # Get team member info
                member = client.table("profiles").select("id, full_name, email, avatar_url, username").eq("id", r["project_member_user_id"]).single().execute()
                if member.data:
                    resolved["name"] = member.data.get("full_name") or member.data.get("username") or "Unknown"
                    resolved["email"] = member.data.get("email")
                    resolved["recipient_type"] = "member"
                    resolved["member"] = member.data
                else:
                    resolved["name"] = "Deleted User"
                    resolved["email"] = None
                    resolved["recipient_type"] = "member"

            else:
                # Manual entry
                resolved["name"] = r.get("manual_name") or r.get("manual_email") or "Unknown"
                resolved["email"] = r.get("manual_email")
                resolved["recipient_type"] = "manual"

            resolved_recipients.append(resolved)

        return {"success": True, "recipients": resolved_recipients, "count": len(resolved_recipients)}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching clearance recipients: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/clearances/{clearance_id}/recipients")
async def add_clearance_recipient(
    clearance_id: str,
    input: ClearanceRecipientInput,
    authorization: str = Header(None)
):
    """Add a recipient to a clearance"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Verify clearance exists and user has edit access
        clearance = client.table("backlot_clearance_items").select("project_id").eq("id", clearance_id).single().execute()
        if not clearance.data:
            raise HTTPException(status_code=404, detail="Clearance not found")

        project_id = clearance.data["project_id"]
        await verify_project_access(client, project_id, user_id, require_edit=True)

        # Validate that at least one identifier is provided
        if not input.project_contact_id and not input.project_member_user_id and not input.manual_email:
            raise HTTPException(status_code=400, detail="Must provide contact_id, member_user_id, or manual_email")

        # Validate email format if manual
        if input.manual_email:
            import re
            if not re.match(r"[^@]+@[^@]+\.[^@]+", input.manual_email):
                raise HTTPException(status_code=400, detail="Invalid email format")

        # Generate access token for external viewing
        import secrets
        access_token = secrets.token_urlsafe(32)
        from datetime import timedelta
        expires_at = datetime.now(timezone.utc) + timedelta(days=30)

        # Determine initial signature status
        signature_status = "pending" if input.requires_signature else "not_required"

        recipient_data = {
            "clearance_id": clearance_id,
            "project_contact_id": input.project_contact_id or None,
            "project_member_user_id": input.project_member_user_id or None,
            "manual_email": input.manual_email or None,
            "manual_name": input.manual_name or None,
            "requires_signature": input.requires_signature,
            "signature_status": signature_status,
            "access_token": access_token,
            "access_token_expires_at": expires_at.isoformat(),
            "added_by_user_id": user_id,
        }

        result = client.table("backlot_clearance_recipients").insert(recipient_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to add recipient")

        return {"success": True, "recipient": result.data[0], "message": "Recipient added"}

    except HTTPException:
        raise
    except Exception as e:
        error_msg = str(e)
        if "unique" in error_msg.lower() or "duplicate" in error_msg.lower():
            raise HTTPException(status_code=400, detail="This recipient is already added to the clearance")
        print(f"Error adding clearance recipient: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/clearances/{clearance_id}/recipients/{recipient_id}")
async def update_clearance_recipient(
    clearance_id: str,
    recipient_id: str,
    input: ClearanceRecipientUpdate,
    authorization: str = Header(None)
):
    """Update a clearance recipient (e.g., toggle requires_signature)"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Verify clearance exists and user has edit access
        clearance = client.table("backlot_clearance_items").select("project_id").eq("id", clearance_id).single().execute()
        if not clearance.data:
            raise HTTPException(status_code=404, detail="Clearance not found")

        project_id = clearance.data["project_id"]
        await verify_project_access(client, project_id, user_id, require_edit=True)

        # Verify recipient exists and belongs to this clearance
        recipient = client.table("backlot_clearance_recipients").select("*").eq("id", recipient_id).eq("clearance_id", clearance_id).single().execute()
        if not recipient.data:
            raise HTTPException(status_code=404, detail="Recipient not found")

        update_data = {}

        if input.requires_signature is not None:
            update_data["requires_signature"] = input.requires_signature
            # Update signature status based on requires_signature change
            if input.requires_signature:
                # Only set to pending if not already signed
                if recipient.data.get("signature_status") in ["not_required", None]:
                    update_data["signature_status"] = "pending"
            else:
                # If turning off signature requirement, set to not_required
                # unless already signed (preserve that status)
                if recipient.data.get("signature_status") != "signed":
                    update_data["signature_status"] = "not_required"

        if not update_data:
            return {"success": True, "message": "No changes to apply"}

        result = client.table("backlot_clearance_recipients").update(update_data).eq("id", recipient_id).execute()

        return {"success": True, "recipient": result.data[0] if result.data else None, "message": "Recipient updated"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating clearance recipient: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/clearances/{clearance_id}/recipients/{recipient_id}")
async def remove_clearance_recipient(
    clearance_id: str,
    recipient_id: str,
    authorization: str = Header(None)
):
    """Remove a recipient from a clearance"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Verify clearance exists and user has edit access
        clearance = client.table("backlot_clearance_items").select("project_id").eq("id", clearance_id).single().execute()
        if not clearance.data:
            raise HTTPException(status_code=404, detail="Clearance not found")

        project_id = clearance.data["project_id"]
        await verify_project_access(client, project_id, user_id, require_edit=True)

        # Delete the recipient
        result = client.table("backlot_clearance_recipients").delete().eq("id", recipient_id).eq("clearance_id", clearance_id).execute()

        if not result.data:
            raise HTTPException(status_code=404, detail="Recipient not found")

        return {"success": True, "message": "Recipient removed"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error removing clearance recipient: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =============================================================================
# CLEARANCE SEND EMAIL ENDPOINT
# =============================================================================

class ClearanceSendEmailRequest(BaseModel):
    """Request to send clearance document to recipients"""
    recipient_ids: List[str]
    send_type: str  # 'link' or 'pdf_attachment'
    message: Optional[str] = None
    subject_override: Optional[str] = None


@router.post("/clearances/{clearance_id}/send")
async def send_clearance_email(
    clearance_id: str,
    request: ClearanceSendEmailRequest,
    authorization: str = Header(None)
):
    """Send clearance document to selected recipients via email"""
    from app.services.email_service import (
        EmailService,
        generate_clearance_email_html,
        generate_clearance_email_text
    )
    from app.core.config import settings

    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    user_name = user.get("full_name") or user.get("email", "Unknown")
    client = get_client()

    try:
        # Validate send_type
        if request.send_type not in ['link', 'pdf_attachment']:
            raise HTTPException(status_code=400, detail="send_type must be 'link' or 'pdf_attachment'")

        # Verify clearance exists and user has edit access
        clearance = client.table("backlot_clearance_items").select("*").eq("id", clearance_id).single().execute()
        if not clearance.data:
            raise HTTPException(status_code=404, detail="Clearance not found")

        project_id = clearance.data["project_id"]
        await verify_project_access(client, project_id, user_id, require_edit=True)

        # Verify clearance has a document
        if not clearance.data.get("file_url"):
            raise HTTPException(status_code=400, detail="Clearance has no document attached")

        # Get project info for email
        project = client.table("backlot_projects").select("title").eq("id", project_id).single().execute()
        project_title = project.data.get("title", "Untitled Project") if project.data else "Untitled Project"

        # Get the recipients to send to
        recipients = client.table("backlot_clearance_recipients").select("*").in_("id", request.recipient_ids).eq("clearance_id", clearance_id).execute()

        if not recipients.data:
            raise HTTPException(status_code=400, detail="No valid recipients found")

        # Resolve email addresses for each recipient
        emails_to_send = []
        for r in recipients.data:
            email = None
            name = "Recipient"

            if r.get("project_contact_id"):
                contact = client.table("backlot_project_contacts").select("name, email").eq("id", r["project_contact_id"]).single().execute()
                if contact.data:
                    email = contact.data.get("email")
                    name = contact.data.get("name", "Recipient")

            elif r.get("project_member_user_id"):
                member = client.table("profiles").select("full_name, email").eq("id", r["project_member_user_id"]).single().execute()
                if member.data:
                    email = member.data.get("email")
                    name = member.data.get("full_name", "Recipient")

            else:
                email = r.get("manual_email")
                name = r.get("manual_name") or email or "Recipient"

            if email:
                emails_to_send.append({
                    "recipient_id": r["id"],
                    "email": email,
                    "name": name,
                    "requires_signature": r.get("requires_signature", False),
                    "access_token": r.get("access_token")
                })

        if not emails_to_send:
            raise HTTPException(status_code=400, detail="No recipients have valid email addresses")

        # Download PDF if sending as attachment
        pdf_content = None
        pdf_filename = None
        if request.send_type == 'pdf_attachment':
            import boto3
            try:
                file_url = clearance.data["file_url"]
                # Extract S3 key from URL
                if "amazonaws.com/" in file_url:
                    s3_key = file_url.split("amazonaws.com/", 1)[-1]
                    # Remove query params if present
                    if "?" in s3_key:
                        s3_key = s3_key.split("?")[0]

                    s3_client = boto3.client("s3", region_name="us-east-1")
                    response = s3_client.get_object(Bucket="swn-backlot-files-517220555400", Key=s3_key)
                    pdf_content = response['Body'].read()
                    pdf_filename = clearance.data.get("file_name") or f"{clearance.data['title']}.pdf"
            except Exception as e:
                print(f"Error downloading PDF for attachment: {e}")
                # Fall back to link-only
                pdf_content = None

        # Send emails
        email_service = EmailService()
        emails_sent = 0
        emails_failed = 0
        email_addresses = []
        error_details = []

        for recipient in emails_to_send:
            try:
                # Build view URL with access token
                view_url = f"{settings.FRONTEND_URL}/clearance/view/{recipient['access_token']}"

                # Generate email content
                html_content = generate_clearance_email_html(
                    project_title=project_title,
                    clearance_title=clearance.data.get("title", "Document"),
                    clearance_type=clearance.data.get("type", "other_contract"),
                    sender_name=user_name,
                    view_url=view_url,
                    sender_message=request.message,
                    requires_signature=recipient["requires_signature"],
                    expiration_date=clearance.data.get("expiration_date"),
                    has_attachment=pdf_content is not None
                )

                text_content = generate_clearance_email_text(
                    project_title=project_title,
                    clearance_title=clearance.data.get("title", "Document"),
                    clearance_type=clearance.data.get("type", "other_contract"),
                    sender_name=user_name,
                    view_url=view_url,
                    sender_message=request.message,
                    requires_signature=recipient["requires_signature"],
                    expiration_date=clearance.data.get("expiration_date"),
                    has_attachment=pdf_content is not None
                )

                # Build subject
                type_labels = {
                    'talent_release': 'Talent Release',
                    'appearance_release': 'Appearance Release',
                    'location_release': 'Location Release',
                    'music_license': 'Music License',
                    'stock_license': 'Stock License',
                    'nda': 'NDA',
                    'other_contract': 'Document',
                }
                type_label = type_labels.get(clearance.data.get("type", "other_contract"), "Document")
                action_word = "Review & Sign" if recipient["requires_signature"] else "Review"
                subject = request.subject_override or f"{action_word}: {clearance.data.get('title', type_label)} - {project_title}"

                # Prepare attachments
                attachments = None
                if pdf_content and pdf_filename:
                    import base64
                    attachments = [{
                        "filename": pdf_filename,
                        "content": base64.b64encode(pdf_content).decode('utf-8'),
                        "content_type": "application/pdf"
                    }]

                # Send email
                result = await email_service.send_email(
                    to_emails=[recipient["email"]],
                    subject=subject,
                    html_content=html_content,
                    text_content=text_content,
                    source_service="backlot",
                    source_action="clearance_send",
                    source_reference_id=clearance_id,
                )

                if result.get("success"):
                    emails_sent += 1
                    email_addresses.append(recipient["email"])

                    # Update recipient send tracking
                    client.table("backlot_clearance_recipients").update({
                        "last_email_sent_at": datetime.now(timezone.utc).isoformat(),
                        "email_send_count": (client.table("backlot_clearance_recipients")
                            .select("email_send_count")
                            .eq("id", recipient["recipient_id"])
                            .single().execute().data or {}).get("email_send_count", 0) + 1,
                        "last_email_type": request.send_type
                    }).eq("id", recipient["recipient_id"]).execute()
                else:
                    emails_failed += 1
                    error_details.append({"email": recipient["email"], "error": result.get("error", "Send failed")})

            except Exception as e:
                emails_failed += 1
                error_details.append({"email": recipient["email"], "error": str(e)})
                print(f"Error sending to {recipient['email']}: {e}")

        # Log to send history
        client.table("backlot_clearance_send_history").insert({
            "clearance_id": clearance_id,
            "sent_by_user_id": user_id,
            "sent_by_name": user_name,
            "send_type": request.send_type,
            "recipient_ids": request.recipient_ids,
            "email_addresses": email_addresses,
            "subject": subject if 'subject' in dir() else None,
            "message": request.message,
            "emails_sent": emails_sent,
            "emails_failed": emails_failed,
            "error_details": error_details if error_details else None
        }).execute()

        return {
            "success": emails_failed == 0,
            "emails_sent": emails_sent,
            "emails_failed": emails_failed,
            "message": f"Sent to {emails_sent} recipient(s)" + (f", {emails_failed} failed" if emails_failed else ""),
            "error_details": error_details if error_details else None
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error sending clearance email: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =============================================================================
# CLEARANCE PUBLIC VIEW/SIGN ENDPOINTS (No Auth Required)
# =============================================================================

@router.get("/clearances/view/{access_token}")
async def view_clearance_by_token(access_token: str):
    """
    Public endpoint: View a clearance document using access token.
    No authentication required - the token IS the authentication.
    """
    client = get_client()

    try:
        # Find the recipient by access token
        recipient = client.table("backlot_clearance_recipients").select("*").eq("access_token", access_token).single().execute()

        if not recipient.data:
            raise HTTPException(status_code=404, detail="Invalid or expired link")

        # Check if token is expired
        expires_at = recipient.data.get("access_token_expires_at")
        if expires_at:
            from dateutil import parser
            expiry_dt = parser.parse(expires_at)
            if datetime.now(timezone.utc) > expiry_dt:
                raise HTTPException(status_code=410, detail="This link has expired")

        clearance_id = recipient.data["clearance_id"]

        # Get the clearance
        clearance = client.table("backlot_clearance_items").select("*").eq("id", clearance_id).single().execute()

        if not clearance.data:
            raise HTTPException(status_code=404, detail="Document not found")

        # Get project title
        project = client.table("backlot_projects").select("title").eq("id", clearance.data["project_id"]).single().execute()
        project_title = project.data.get("title", "Untitled") if project.data else "Untitled"

        # Generate pre-signed URL for the document
        file_url = clearance.data.get("file_url")
        signed_file_url = None
        if file_url:
            if file_url.startswith("https://swn-backlot-files-517220555400.s3"):
                s3_key = file_url.split(".amazonaws.com/", 1)[-1] if ".amazonaws.com/" in file_url else None
                if s3_key:
                    signed_file_url = get_signed_url('backlot-files', s3_key, expires_in=86400)
            elif file_url.startswith("s3://"):
                s3_uri = file_url[5:]
                parts = s3_uri.split("/", 1)
                if len(parts) == 2:
                    _, s3_key = parts
                    signed_file_url = get_signed_url('backlot-files', s3_key, expires_in=86400)

        # Mark as viewed if first view
        if not recipient.data.get("viewed_at"):
            client.table("backlot_clearance_recipients").update({
                "viewed_at": datetime.now(timezone.utc).isoformat(),
                "signature_status": "viewed" if recipient.data.get("requires_signature") and recipient.data.get("signature_status") == "pending" else recipient.data.get("signature_status")
            }).eq("id", recipient.data["id"]).execute()

        return {
            "success": True,
            "clearance": {
                "id": clearance.data["id"],
                "title": clearance.data.get("title"),
                "type": clearance.data.get("type"),
                "description": clearance.data.get("description"),
                "file_url": signed_file_url,
                "file_name": clearance.data.get("file_name"),
                "expiration_date": clearance.data.get("expiration_date"),
            },
            "project_title": project_title,
            "recipient": {
                "id": recipient.data["id"],
                "requires_signature": recipient.data.get("requires_signature", False),
                "signature_status": recipient.data.get("signature_status"),
                "signed_at": recipient.data.get("signed_at"),
                "viewed_at": recipient.data.get("viewed_at") or datetime.now(timezone.utc).isoformat(),
            }
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error viewing clearance by token: {e}")
        raise HTTPException(status_code=500, detail=str(e))


class ClearanceSignatureInput(BaseModel):
    """Input for signing a clearance"""
    signature_data: str  # Base64 encoded signature image


@router.post("/clearances/sign/{access_token}")
async def sign_clearance_by_token(
    access_token: str,
    input: ClearanceSignatureInput,
    request: Request
):
    """
    Public endpoint: Sign a clearance document.
    No authentication required - the token IS the authentication.
    """
    client = get_client()

    try:
        # Find the recipient by access token
        recipient = client.table("backlot_clearance_recipients").select("*").eq("access_token", access_token).single().execute()

        if not recipient.data:
            raise HTTPException(status_code=404, detail="Invalid or expired link")

        # Check if token is expired
        expires_at = recipient.data.get("access_token_expires_at")
        if expires_at:
            from dateutil import parser
            expiry_dt = parser.parse(expires_at)
            if datetime.now(timezone.utc) > expiry_dt:
                raise HTTPException(status_code=410, detail="This link has expired")

        # Check if signature is required
        if not recipient.data.get("requires_signature"):
            raise HTTPException(status_code=400, detail="Signature not required for this document")

        # Check if already signed
        if recipient.data.get("signature_status") == "signed":
            raise HTTPException(status_code=400, detail="Document has already been signed")

        # Validate signature data (should be base64)
        import base64
        try:
            # Try to decode to verify it's valid base64
            base64.b64decode(input.signature_data)
        except Exception:
            raise HTTPException(status_code=400, detail="Invalid signature data format")

        # Get client IP
        client_ip = request.client.host if request.client else None

        # Update recipient with signature
        now = datetime.now(timezone.utc).isoformat()
        client.table("backlot_clearance_recipients").update({
            "signature_status": "signed",
            "signed_at": now,
            "signature_data": input.signature_data,
            "signature_ip": client_ip,
            "viewed_at": recipient.data.get("viewed_at") or now
        }).eq("id", recipient.data["id"]).execute()

        # Check if all required signatures are collected
        clearance_id = recipient.data["clearance_id"]
        all_recipients = client.table("backlot_clearance_recipients").select("requires_signature, signature_status").eq("clearance_id", clearance_id).execute()

        required_recipients = [r for r in (all_recipients.data or []) if r.get("requires_signature")]
        all_signed = all(r.get("signature_status") == "signed" for r in required_recipients) if required_recipients else False

        # If all required signatures collected, update clearance status to signed
        if all_signed and required_recipients:
            client.table("backlot_clearance_items").update({
                "status": "signed",
                "signed_date": datetime.now(timezone.utc).date().isoformat()
            }).eq("id", clearance_id).execute()

            # Record in history
            client.table("backlot_clearance_history").insert({
                "clearance_id": clearance_id,
                "action": "status_changed",
                "old_status": "requested",
                "new_status": "signed",
                "notes": "All required signatures collected",
                "metadata": {"auto_signed": True, "recipients_count": len(required_recipients)}
            }).execute()

        return {
            "success": True,
            "message": "Document signed successfully",
            "all_signatures_complete": all_signed
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error signing clearance: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =============================================================================
# SHOT LISTS & COVERAGE - MODELS
# =============================================================================

class SceneShotInput(BaseModel):
    """Input model for creating/updating a scene shot"""
    shot_number: str
    shot_type: str  # ECU, CU, MCU, MS, MLS, LS, WS, EWS, POV, OTS, INSERT, 2SHOT, GROUP, OTHER
    lens: Optional[str] = None
    camera_movement: Optional[str] = None
    description: Optional[str] = None
    est_time_minutes: Optional[float] = None
    priority: Optional[str] = None  # must_have, nice_to_have
    coverage_status: Optional[str] = "not_shot"
    notes: Optional[str] = None
    sort_order: Optional[int] = 0


class ShotImageInput(BaseModel):
    """Input model for shot images/storyboards"""
    image_url: str
    thumbnail_url: Optional[str] = None
    description: Optional[str] = None
    sort_order: Optional[int] = 0


class CoverageUpdateInput(BaseModel):
    """Input for updating coverage status"""
    coverage_status: str  # not_shot, shot, alt_needed, dropped


class BulkCoverageUpdateInput(BaseModel):
    """Input for bulk updating coverage status"""
    shot_ids: List[str]
    coverage_status: str


# =============================================================================
# SHOT LIST CRUD ENDPOINTS
# =============================================================================

@router.get("/projects/{project_id}/scenes/{scene_id}/shots")
async def get_scene_shots(
    project_id: str,
    scene_id: str,
    authorization: str = Header(None)
):
    """Get all shots for a scene"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify scene belongs to project
        scene_check = client.table("backlot_scenes").select("id").eq("id", scene_id).eq("project_id", project_id).execute()
        if not scene_check.data:
            raise HTTPException(status_code=404, detail="Scene not found in project")

        # Get shots with images
        shots_result = client.table("backlot_scene_shots").select("*").eq("scene_id", scene_id).order("sort_order").order("shot_number").execute()

        shots = shots_result.data or []

        # Get images for all shots
        if shots:
            shot_ids = [s["id"] for s in shots]
            images_result = client.table("backlot_scene_shot_images").select("*").in_("scene_shot_id", shot_ids).order("sort_order").execute()
            images_by_shot = {}
            for img in (images_result.data or []):
                shot_id = img["scene_shot_id"]
                if shot_id not in images_by_shot:
                    images_by_shot[shot_id] = []
                images_by_shot[shot_id].append(img)

            for shot in shots:
                shot["images"] = images_by_shot.get(shot["id"], [])

        return {"success": True, "shots": shots}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching scene shots: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/scenes/{scene_id}/shots")
async def create_scene_shot(
    project_id: str,
    scene_id: str,
    shot: SceneShotInput,
    authorization: str = Header(None)
):
    """Create a new shot for a scene"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Verify scene belongs to project
        scene_check = client.table("backlot_scenes").select("id").eq("id", scene_id).eq("project_id", project_id).execute()
        if not scene_check.data:
            raise HTTPException(status_code=404, detail="Scene not found in project")

        # Check for duplicate shot number
        existing = client.table("backlot_scene_shots").select("id").eq("scene_id", scene_id).eq("shot_number", shot.shot_number).execute()
        if existing.data:
            raise HTTPException(status_code=400, detail=f"Shot number {shot.shot_number} already exists in this scene")

        # Create shot
        result = client.table("backlot_scene_shots").insert({
            "project_id": project_id,
            "scene_id": scene_id,
            "shot_number": shot.shot_number,
            "shot_type": shot.shot_type,
            "lens": shot.lens,
            "camera_movement": shot.camera_movement,
            "description": shot.description,
            "est_time_minutes": shot.est_time_minutes,
            "priority": shot.priority,
            "coverage_status": shot.coverage_status or "not_shot",
            "notes": shot.notes,
            "sort_order": shot.sort_order or 0,
            "created_by_user_id": user_id
        }).select().execute()

        return {"success": True, "shot": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating scene shot: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/scene-shots/{shot_id}")
async def get_scene_shot(
    shot_id: str,
    authorization: str = Header(None)
):
    """Get a single scene shot by ID"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        result = client.table("backlot_scene_shots").select("*").eq("id", shot_id).execute()
        if not result.data:
            raise HTTPException(status_code=404, detail="Shot not found")

        shot = result.data[0]

        # Get images
        images_result = client.table("backlot_scene_shot_images").select("*").eq("scene_shot_id", shot_id).order("sort_order").execute()
        shot["images"] = images_result.data or []

        return {"success": True, "shot": shot}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching shot: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/scene-shots/{shot_id}")
async def update_scene_shot(
    shot_id: str,
    shot: SceneShotInput,
    authorization: str = Header(None)
):
    """Update a scene shot (from shot list coverage tracking)"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Check shot exists
        existing = client.table("backlot_scene_shots").select("id, scene_id").eq("id", shot_id).execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Shot not found")

        scene_id = existing.data[0]["scene_id"]

        # Check for duplicate shot number (if changed)
        dupe_check = client.table("backlot_scene_shots").select("id").eq("scene_id", scene_id).eq("shot_number", shot.shot_number).neq("id", shot_id).execute()
        if dupe_check.data:
            raise HTTPException(status_code=400, detail=f"Shot number {shot.shot_number} already exists in this scene")

        update_data = {
            "shot_number": shot.shot_number,
            "shot_type": shot.shot_type,
            "lens": shot.lens,
            "camera_movement": shot.camera_movement,
            "description": shot.description,
            "est_time_minutes": shot.est_time_minutes,
            "priority": shot.priority,
            "notes": shot.notes,
            "sort_order": shot.sort_order or 0,
        }

        # Only update coverage_status if provided
        if shot.coverage_status:
            update_data["coverage_status"] = shot.coverage_status

        result = client.table("backlot_scene_shots").update(update_data).eq("id", shot_id).select().execute()

        return {"success": True, "shot": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating shot: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/scene-shots/{shot_id}")
async def delete_scene_shot(
    shot_id: str,
    authorization: str = Header(None)
):
    """Delete a scene shot"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Check shot exists
        existing = client.table("backlot_scene_shots").select("id").eq("id", shot_id).execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Shot not found")

        # Delete (images will cascade)
        client.table("backlot_scene_shots").delete().eq("id", shot_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting shot: {e}")
        raise HTTPException(status_code=500, detail=str(e))


class CloneShotInput(BaseModel):
    """Input for cloning a shot"""
    destination_scene_id: Optional[str] = None


def generate_next_shot_number(existing_shot_number: str, existing_shots: list) -> str:
    """Generate next shot number for cloned shot.
    If shot_number is '1', tries '1A', '1B', etc.
    If shot_number is '1A', tries '1B', '1C', etc.
    """
    import re

    # Get all existing shot numbers in the scene
    existing_numbers = {s.get("shot_number", "").upper() for s in existing_shots}

    # Check if original has a letter suffix
    match = re.match(r'^(\d+)([A-Z])?$', existing_shot_number.upper())
    if not match:
        # Non-standard format, just append 'A'
        candidate = f"{existing_shot_number}A"
        counter = 0
        while candidate.upper() in existing_numbers and counter < 26:
            candidate = f"{existing_shot_number}{chr(65 + counter)}"
            counter += 1
        return candidate

    base_number = match.group(1)
    current_letter = match.group(2)

    if current_letter:
        # Already has letter, increment it
        start_ord = ord(current_letter)
    else:
        # No letter, start with 'A'
        start_ord = ord('A') - 1

    # Try letters A-Z
    for i in range(1, 27):
        next_letter = chr(start_ord + i)
        if next_letter > 'Z':
            next_letter = chr(ord('A') + (i - 1) % 26)
        candidate = f"{base_number}{next_letter}"
        if candidate.upper() not in existing_numbers:
            return candidate

    # Fallback: append number
    counter = 2
    while f"{existing_shot_number}-{counter}".upper() in existing_numbers:
        counter += 1
    return f"{existing_shot_number}-{counter}"


@router.post("/scene-shots/{shot_id}/clone")
async def clone_scene_shot(
    shot_id: str,
    input_data: CloneShotInput = Body(default=CloneShotInput()),
    authorization: str = Header(None)
):
    """Clone a scene shot, optionally to a different scene"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Fetch the original shot
        original = client.table("backlot_scene_shots").select("*").eq("id", shot_id).execute()
        if not original.data:
            raise HTTPException(status_code=404, detail="Shot not found")

        shot_data = original.data[0]
        destination_scene_id = input_data.destination_scene_id or shot_data["scene_id"]

        # Get existing shots in destination scene for shot number generation
        existing_shots = client.table("backlot_scene_shots").select("shot_number, sort_order").eq("scene_id", destination_scene_id).execute()

        # Generate new shot number
        new_shot_number = generate_next_shot_number(shot_data["shot_number"], existing_shots.data or [])

        # Get max sort_order in destination scene
        max_sort = max([s.get("sort_order", 0) for s in (existing_shots.data or [])], default=0)

        # Create cloned shot
        cloned_data = {
            "project_id": shot_data["project_id"],
            "scene_id": destination_scene_id,
            "shot_number": new_shot_number,
            "shot_type": shot_data.get("shot_type"),
            "lens": shot_data.get("lens"),
            "camera_movement": shot_data.get("camera_movement"),
            "description": shot_data.get("description"),
            "est_time_minutes": shot_data.get("est_time_minutes"),
            "priority": shot_data.get("priority"),
            "notes": shot_data.get("notes"),
            "sort_order": max_sort + 1,
            "coverage_status": "not_shot",  # Reset coverage
            "created_by_user_id": user["id"],
        }

        result = client.table("backlot_scene_shots").insert(cloned_data).select().execute()

        return {"success": True, "shot": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error cloning shot: {e}")
        raise HTTPException(status_code=500, detail=str(e))


class BulkCloneShotsInput(BaseModel):
    """Input for bulk cloning shots"""
    shot_ids: List[str]
    destination_scene_id: Optional[str] = None


@router.post("/projects/{project_id}/shots/bulk-clone")
async def bulk_clone_shots(
    project_id: str,
    input_data: BulkCloneShotsInput,
    authorization: str = Header(None)
):
    """Clone multiple shots, optionally to a different scene"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        if not input_data.shot_ids:
            raise HTTPException(status_code=400, detail="No shots to clone")

        # Fetch all original shots
        originals = client.table("backlot_scene_shots").select("*").in_("id", input_data.shot_ids).execute()
        if not originals.data:
            raise HTTPException(status_code=404, detail="No shots found")

        # Use first shot's scene as destination if not specified
        destination_scene_id = input_data.destination_scene_id or originals.data[0]["scene_id"]

        # Get existing shots in destination scene
        existing_shots = client.table("backlot_scene_shots").select("shot_number, sort_order").eq("scene_id", destination_scene_id).execute()
        existing_data = existing_shots.data or []

        # Get max sort_order
        max_sort = max([s.get("sort_order", 0) for s in existing_data], default=0)

        cloned_shots = []
        for shot_data in originals.data:
            # Generate new shot number (update existing_data after each to avoid duplicates)
            new_shot_number = generate_next_shot_number(shot_data["shot_number"], existing_data)
            existing_data.append({"shot_number": new_shot_number, "sort_order": max_sort + 1})

            max_sort += 1

            cloned_data = {
                "project_id": project_id,
                "scene_id": destination_scene_id,
                "shot_number": new_shot_number,
                "shot_type": shot_data.get("shot_type"),
                "lens": shot_data.get("lens"),
                "camera_movement": shot_data.get("camera_movement"),
                "description": shot_data.get("description"),
                "est_time_minutes": shot_data.get("est_time_minutes"),
                "priority": shot_data.get("priority"),
                "notes": shot_data.get("notes"),
                "sort_order": max_sort,
                "coverage_status": "not_shot",
                "created_by_user_id": user["id"],
            }
            cloned_shots.append(cloned_data)

        # Bulk insert
        result = client.table("backlot_scene_shots").insert(cloned_shots).select().execute()

        return {"success": True, "shots": result.data, "count": len(result.data)}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error bulk cloning shots: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/shots/{shot_id}/reorder")
async def reorder_shot(
    shot_id: str,
    new_sort_order: int = Body(..., embed=True),
    authorization: str = Header(None)
):
    """Update shot sort order"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        result = client.table("backlot_scene_shots").update({"sort_order": new_sort_order}).eq("id", shot_id).select().execute()
        if not result.data:
            raise HTTPException(status_code=404, detail="Shot not found")

        return {"success": True, "shot": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error reordering shot: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =============================================================================
# SHOT IMAGES (STORYBOARDS) ENDPOINTS
# =============================================================================

@router.get("/scene-shots/{shot_id}/images")
async def get_scene_shot_images(
    shot_id: str,
    authorization: str = Header(None)
):
    """Get all images for a scene shot"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        result = client.table("backlot_scene_shot_images").select("*").eq("scene_shot_id", shot_id).order("sort_order").execute()

        return {"success": True, "images": result.data or []}

    except Exception as e:
        print(f"Error fetching shot images: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/scene-shots/{shot_id}/images")
async def add_scene_shot_image(
    shot_id: str,
    image: ShotImageInput,
    authorization: str = Header(None)
):
    """Add an image to a scene shot"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify shot exists
        shot_check = client.table("backlot_scene_shots").select("id").eq("id", shot_id).execute()
        if not shot_check.data:
            raise HTTPException(status_code=404, detail="Shot not found")

        result = client.table("backlot_scene_shot_images").insert({
            "scene_shot_id": shot_id,
            "image_url": image.image_url,
            "thumbnail_url": image.thumbnail_url,
            "description": image.description,
            "sort_order": image.sort_order or 0
        }).select().execute()

        return {"success": True, "image": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error adding shot image: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/shot-images/{image_id}")
async def update_shot_image(
    image_id: str,
    image: ShotImageInput,
    authorization: str = Header(None)
):
    """Update a shot image"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        result = client.table("backlot_scene_shot_images").update({
            "image_url": image.image_url,
            "thumbnail_url": image.thumbnail_url,
            "description": image.description,
            "sort_order": image.sort_order or 0
        }).eq("id", image_id).select().execute()

        if not result.data:
            raise HTTPException(status_code=404, detail="Image not found")

        return {"success": True, "image": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating shot image: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/shot-images/{image_id}")
async def delete_shot_image(
    image_id: str,
    authorization: str = Header(None)
):
    """Delete a shot image"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        existing = client.table("backlot_scene_shot_images").select("id").eq("id", image_id).execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Image not found")

        client.table("backlot_scene_shot_images").delete().eq("id", image_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting shot image: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =============================================================================
# COVERAGE TRACKING ENDPOINTS
# =============================================================================

@router.patch("/scene-shots/{shot_id}/coverage")
async def update_scene_shot_coverage(
    shot_id: str,
    coverage: CoverageUpdateInput,
    authorization: str = Header(None)
):
    """Update coverage status for a scene shot"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        update_data = {
            "coverage_status": coverage.coverage_status,
        }

        # Set covered_at and covered_by when marking as shot
        if coverage.coverage_status == "shot":
            update_data["covered_at"] = datetime.utcnow().isoformat()
            update_data["covered_by_user_id"] = user_id
        elif coverage.coverage_status == "not_shot":
            update_data["covered_at"] = None
            update_data["covered_by_user_id"] = None

        result = client.table("backlot_scene_shots").update(update_data).eq("id", shot_id).select().execute()

        if not result.data:
            raise HTTPException(status_code=404, detail="Shot not found")

        return {"success": True, "shot": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating coverage: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/shots/bulk-coverage")
async def bulk_update_coverage(
    project_id: str,
    bulk_input: BulkCoverageUpdateInput,
    authorization: str = Header(None)
):
    """Bulk update coverage status for multiple shots"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        update_data = {
            "coverage_status": bulk_input.coverage_status,
        }

        if bulk_input.coverage_status == "shot":
            update_data["covered_at"] = datetime.utcnow().isoformat()
            update_data["covered_by_user_id"] = user_id
        elif bulk_input.coverage_status == "not_shot":
            update_data["covered_at"] = None
            update_data["covered_by_user_id"] = None

        # Update all shots
        for shot_id in bulk_input.shot_ids:
            client.table("backlot_scene_shots").update(update_data).eq("id", shot_id).eq("project_id", project_id).execute()

        return {"success": True, "updated_count": len(bulk_input.shot_ids)}

    except Exception as e:
        print(f"Error bulk updating coverage: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/shots")
async def get_project_shots(
    project_id: str,
    scene_id: Optional[str] = None,
    coverage_status: Optional[str] = None,
    priority: Optional[str] = None,
    authorization: str = Header(None)
):
    """Get all shots for a project, optionally filtered"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Fetch shots without join syntax (for AWS/SQLAlchemy compatibility)
        query = client.table("backlot_scene_shots").select("*").eq("project_id", project_id)

        if scene_id:
            query = query.eq("scene_id", scene_id)
        if coverage_status:
            query = query.eq("coverage_status", coverage_status)
        if priority:
            query = query.eq("priority", priority)

        result = query.order("scene_id").order("sort_order").order("shot_number").execute()

        shots = result.data or []

        # Fetch scene data separately and join manually
        if shots:
            scene_ids = list(set(s["scene_id"] for s in shots if s.get("scene_id")))
            if scene_ids:
                scenes_result = client.table("backlot_scenes").select("id, scene_number, slugline, description").in_("id", scene_ids).execute()
                scenes_map = {s["id"]: s for s in (scenes_result.data or [])}
                for shot in shots:
                    shot["scene"] = scenes_map.get(shot.get("scene_id"))

        # Get images for all shots
        if shots:
            shot_ids = [s["id"] for s in shots]
            images_result = client.table("backlot_scene_shot_images").select("*").in_("scene_shot_id", shot_ids).order("sort_order").execute()
            images_by_shot = {}
            for img in (images_result.data or []):
                shot_id = img["scene_shot_id"]
                if shot_id not in images_by_shot:
                    images_by_shot[shot_id] = []
                images_by_shot[shot_id].append(img)

            for shot in shots:
                shot["images"] = images_by_shot.get(shot["id"], [])

        return {"success": True, "shots": shots}

    except Exception as e:
        print(f"Error fetching project shots: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/coverage/summary")
async def get_coverage_summary(
    project_id: str,
    authorization: str = Header(None)
):
    """Get coverage summary for a project"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get shots from backlot_scene_shots (legacy coverage tracker)
        legacy_result = client.table("backlot_scene_shots").select("id, scene_id, coverage_status, priority, est_time_minutes").eq("project_id", project_id).execute()
        legacy_shots = legacy_result.data or []

        # Get shots from backlot_shots (Shot Lists) with scene_id
        sl_result = client.table("backlot_shots").select("id, scene_id, is_completed, est_time_minutes").eq("project_id", project_id).execute()
        # Filter in Python since Supabase neq(None) doesn't work correctly
        sl_shots = [s for s in (sl_result.data or []) if s.get("scene_id")]

        # Calculate legacy summary
        legacy_total = len(legacy_shots)
        legacy_shot = len([s for s in legacy_shots if s["coverage_status"] == "shot"])
        legacy_not_shot = len([s for s in legacy_shots if s["coverage_status"] == "not_shot"])
        legacy_alt_needed = len([s for s in legacy_shots if s["coverage_status"] == "alt_needed"])
        legacy_dropped = len([s for s in legacy_shots if s["coverage_status"] == "dropped"])
        must_have_total = len([s for s in legacy_shots if s["priority"] == "must_have"])
        must_have_shot = len([s for s in legacy_shots if s["priority"] == "must_have" and s["coverage_status"] == "shot"])
        legacy_est_total = sum([s["est_time_minutes"] or 0 for s in legacy_shots])
        legacy_est_remaining = sum([s["est_time_minutes"] or 0 for s in legacy_shots if s["coverage_status"] == "not_shot"])
        legacy_scenes = set([s["scene_id"] for s in legacy_shots])

        # Calculate shot list summary
        sl_total = len(sl_shots)
        sl_completed = len([s for s in sl_shots if s.get("is_completed")])
        sl_not_completed = sl_total - sl_completed
        sl_est_total = sum([s.get("est_time_minutes") or 0 for s in sl_shots])
        sl_est_remaining = sum([s.get("est_time_minutes") or 0 for s in sl_shots if not s.get("is_completed")])
        sl_scenes = set([s["scene_id"] for s in sl_shots])

        # Combined totals
        total_shots = legacy_total + sl_total
        shot_count = legacy_shot + sl_completed
        not_shot_count = legacy_not_shot + sl_not_completed
        unique_scenes = legacy_scenes.union(sl_scenes)

        summary = {
            "total_scenes": len(unique_scenes),
            "total_shots": total_shots,
            "shot": shot_count,
            "not_shot": not_shot_count,
            "alt_needed": legacy_alt_needed,
            "dropped": legacy_dropped,
            "coverage_percentage": round(100.0 * shot_count / total_shots, 1) if total_shots > 0 else 0,
            "must_have_total": must_have_total,
            "must_have_shot": must_have_shot,
            "must_have_coverage": round(100.0 * must_have_shot / must_have_total, 1) if must_have_total > 0 else 100,
            "est_total_minutes": legacy_est_total + sl_est_total,
            "est_remaining_minutes": legacy_est_remaining + sl_est_remaining,
        }

        return {"success": True, "summary": summary}

    except Exception as e:
        print(f"Error fetching coverage summary: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/coverage/by-scene")
async def get_coverage_by_scene(
    project_id: str,
    authorization: str = Header(None)
):
    """Get coverage breakdown by scene"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get scenes with shot counts
        scenes_result = client.table("backlot_scenes").select("id, scene_number, slugline, description").eq("project_id", project_id).order("scene_number").execute()
        scenes = scenes_result.data or []

        # Get shots from backlot_scene_shots (legacy coverage tracker)
        scene_shots_result = client.table("backlot_scene_shots").select("id, scene_id, coverage_status, priority").eq("project_id", project_id).execute()
        scene_shots = scene_shots_result.data or []

        # Get shots from backlot_shots (Shot Lists) - these have scene_id
        shot_list_shots_result = client.table("backlot_shots").select("id, scene_id, is_completed").eq("project_id", project_id).execute()
        # Filter in Python since Supabase neq(None) doesn't work correctly
        shot_list_shots = [s for s in (shot_list_shots_result.data or []) if s.get("scene_id")]
        print(f"[COVERAGE] Found {len(shot_list_shots_result.data or [])} total shots, {len(shot_list_shots)} with scene_id")

        # Group shots by scene (combining both tables)
        shots_by_scene = {}

        # Add legacy scene shots
        for shot in scene_shots:
            scene_id = shot["scene_id"]
            if scene_id not in shots_by_scene:
                shots_by_scene[scene_id] = {"legacy": [], "shot_list": []}
            shots_by_scene[scene_id]["legacy"].append(shot)

        # Add shot list shots
        for shot in shot_list_shots:
            scene_id = shot["scene_id"]
            if scene_id not in shots_by_scene:
                shots_by_scene[scene_id] = {"legacy": [], "shot_list": []}
            shots_by_scene[scene_id]["shot_list"].append(shot)

        # Build scene coverage data
        scene_coverage = []
        for scene in scenes:
            scene_data = shots_by_scene.get(scene["id"], {"legacy": [], "shot_list": []})
            legacy_shots = scene_data["legacy"]
            sl_shots = scene_data["shot_list"]

            # Count from legacy shots
            legacy_total = len(legacy_shots)
            legacy_shot_count = len([s for s in legacy_shots if s["coverage_status"] == "shot"])
            legacy_not_shot = len([s for s in legacy_shots if s["coverage_status"] == "not_shot"])
            legacy_alt_needed = len([s for s in legacy_shots if s["coverage_status"] == "alt_needed"])

            # Count from shot list shots (is_completed = covered)
            sl_total = len(sl_shots)
            sl_completed = len([s for s in sl_shots if s.get("is_completed")])
            sl_not_completed = sl_total - sl_completed

            # Combined totals
            total = legacy_total + sl_total
            shot_count = legacy_shot_count + sl_completed
            not_shot_count = legacy_not_shot + sl_not_completed
            alt_needed_count = legacy_alt_needed

            scene_coverage.append({
                "scene_id": scene["id"],
                "scene_number": scene["scene_number"],
                "scene_heading": scene.get("slugline"),
                "total_shots": total,
                "shot": shot_count,
                "not_shot": not_shot_count,
                "alt_needed": alt_needed_count,
                "dropped": 0,
                "coverage_percentage": round(100.0 * shot_count / total, 1) if total > 0 else 0,
            })

        # Log shots found for debugging
        scenes_with_shots = [s for s in scene_coverage if s["total_shots"] > 0]
        print(f"[COVERAGE] Returning {len(scene_coverage)} scenes, {len(scenes_with_shots)} with shots")
        for s in scenes_with_shots[:3]:
            print(f"[COVERAGE]   Scene {s['scene_number']}: {s['total_shots']} shots")

        return {"success": True, "scenes": scene_coverage}

    except Exception as e:
        print(f"Error fetching coverage by scene: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/coverage/report")
async def get_coverage_report(
    project_id: str,
    format: str = "json",
    authorization: str = Header(None)
):
    """Generate a coverage report for the project"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get scenes
        scenes_result = client.table("backlot_scenes").select("id, scene_number, slugline, description").eq("project_id", project_id).order("scene_number").execute()
        scenes = scenes_result.data or []
        scenes_map = {s["id"]: s for s in scenes}

        # Get all shots
        shots_result = client.table("backlot_scene_shots").select("*").eq("project_id", project_id).order("scene_id").order("sort_order").execute()
        shots = shots_result.data or []

        # Build report
        report = []
        for shot in shots:
            scene = scenes_map.get(shot["scene_id"], {})
            report.append({
                "scene_number": scene.get("scene_number", ""),
                "scene_setting": scene.get("slugline", ""),
                "shot_number": shot["shot_number"],
                "shot_type": shot["shot_type"],
                "lens": shot.get("lens", ""),
                "camera_movement": shot.get("camera_movement", ""),
                "description": shot.get("description", ""),
                "priority": shot.get("priority", ""),
                "coverage_status": shot["coverage_status"],
                "est_time_minutes": shot.get("est_time_minutes"),
                "notes": shot.get("notes", ""),
            })

        if format == "csv":
            import csv
            import io
            output = io.StringIO()
            if report:
                writer = csv.DictWriter(output, fieldnames=report[0].keys())
                writer.writeheader()
                writer.writerows(report)
            csv_content = output.getvalue()
            return Response(
                content=csv_content,
                media_type="text/csv",
                headers={"Content-Disposition": f"attachment; filename=coverage_report_{project_id}.csv"}
            )

        return {"success": True, "report": report}

    except Exception as e:
        print(f"Error generating coverage report: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =============================================================================
# AI CO-PILOT COVERAGE SUMMARY ENDPOINT
# =============================================================================

@router.post("/projects/{project_id}/coverage/summary-for-ai")
async def get_coverage_summary_for_ai(
    project_id: str,
    authorization: str = Header(None)
):
    """
    Get structured coverage summary for AI Co-Pilot consumption.
    Returns scenes, shot coverage status, and notes for editing strategy suggestions.
    """
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get project info
        project_result = client.table("backlot_projects").select("id, title, logline, status").eq("id", project_id).execute()
        project = project_result.data[0] if project_result.data else None

        # Get scenes with descriptions
        scenes_result = client.table("backlot_scenes").select(
            "id, scene_number, setting, int_ext, time_of_day, description, page_count"
        ).eq("project_id", project_id).order("scene_number").execute()
        scenes = scenes_result.data or []

        # Get all shots
        shots_result = client.table("backlot_scene_shots").select(
            "id, scene_id, shot_number, shot_type, description, coverage_status, priority, notes"
        ).eq("project_id", project_id).execute()
        shots = shots_result.data or []

        # Group shots by scene
        shots_by_scene = {}
        for shot in shots:
            scene_id = shot["scene_id"]
            if scene_id not in shots_by_scene:
                shots_by_scene[scene_id] = []
            shots_by_scene[scene_id].append(shot)

        # Build AI-friendly summary
        scenes_summary = []
        for scene in scenes:
            scene_shots = shots_by_scene.get(scene["id"], [])

            shot_summary = {
                "total": len(scene_shots),
                "shot": len([s for s in scene_shots if s["coverage_status"] == "shot"]),
                "not_shot": len([s for s in scene_shots if s["coverage_status"] == "not_shot"]),
                "alt_needed": len([s for s in scene_shots if s["coverage_status"] == "alt_needed"]),
                "dropped": len([s for s in scene_shots if s["coverage_status"] == "dropped"]),
            }

            # Get shots needing attention (not_shot or alt_needed)
            attention_shots = [
                {
                    "shot_number": s["shot_number"],
                    "shot_type": s["shot_type"],
                    "status": s["coverage_status"],
                    "priority": s.get("priority"),
                    "notes": s.get("notes"),
                }
                for s in scene_shots
                if s["coverage_status"] in ("not_shot", "alt_needed")
            ]

            scenes_summary.append({
                "scene_number": scene["scene_number"],
                "setting": scene.get("setting", ""),
                "int_ext": scene.get("int_ext", ""),
                "time_of_day": scene.get("time_of_day", ""),
                "description": scene.get("description", ""),
                "page_count": scene.get("page_count"),
                "coverage": shot_summary,
                "shots_needing_attention": attention_shots,
            })

        # Calculate overall stats
        total_shots = len(shots)
        shot_count = len([s for s in shots if s["coverage_status"] == "shot"])
        coverage_pct = round(100.0 * shot_count / total_shots, 1) if total_shots > 0 else 0

        ai_summary = {
            "project": {
                "id": project["id"] if project else project_id,
                "title": project["title"] if project else "",
                "logline": project.get("logline", "") if project else "",
            },
            "overall_coverage": {
                "total_scenes_with_shots": len([s for s in scenes_summary if s["coverage"]["total"] > 0]),
                "total_shots": total_shots,
                "shots_completed": shot_count,
                "shots_not_shot": len([s for s in shots if s["coverage_status"] == "not_shot"]),
                "shots_alt_needed": len([s for s in shots if s["coverage_status"] == "alt_needed"]),
                "coverage_percentage": coverage_pct,
            },
            "scenes": scenes_summary,
            "notes_summary": {
                "alt_needed_count": len([s for s in shots if s["coverage_status"] == "alt_needed"]),
                "alt_needed_notes": [
                    {"scene_id": s["scene_id"], "shot": s["shot_number"], "notes": s["notes"]}
                    for s in shots
                    if s["coverage_status"] == "alt_needed" and s.get("notes")
                ],
            },
        }

        return {"success": True, "ai_summary": ai_summary}

    except Exception as e:
        print(f"Error generating AI coverage summary: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =============================================================================
# CALL SHEET SCENE SHOTS - Get shots for scenes in a call sheet
# =============================================================================

@router.get("/call-sheets/{call_sheet_id}/shots")
async def get_call_sheet_shots(
    call_sheet_id: str,
    authorization: str = Header(None)
):
    """Get all shots for scenes linked to a call sheet"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get call sheet
        cs_result = client.table("backlot_call_sheets").select("id, project_id").eq("id", call_sheet_id).execute()
        if not cs_result.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        project_id = cs_result.data[0]["project_id"]

        # Get scene links for this call sheet
        links_result = client.table("backlot_call_sheet_scene_links").select("scene_id").eq("call_sheet_id", call_sheet_id).execute()
        scene_ids = [l["scene_id"] for l in (links_result.data or [])]

        if not scene_ids:
            return {"success": True, "scenes_with_shots": []}

        # Get scenes
        scenes_result = client.table("backlot_scenes").select("id, scene_number, slugline, description").in_("id", scene_ids).order("scene_number").execute()
        scenes = scenes_result.data or []

        # Get shots for these scenes
        shots_result = client.table("backlot_scene_shots").select("*").in_("scene_id", scene_ids).order("sort_order").order("shot_number").execute()
        shots = shots_result.data or []

        # Group shots by scene
        shots_by_scene = {}
        for shot in shots:
            scene_id = shot["scene_id"]
            if scene_id not in shots_by_scene:
                shots_by_scene[scene_id] = []
            shots_by_scene[scene_id].append(shot)

        # Build response
        scenes_with_shots = []
        for scene in scenes:
            scene_shots = shots_by_scene.get(scene["id"], [])
            scenes_with_shots.append({
                "scene": scene,
                "shots": scene_shots,
                "coverage": {
                    "total": len(scene_shots),
                    "shot": len([s for s in scene_shots if s["coverage_status"] == "shot"]),
                    "not_shot": len([s for s in scene_shots if s["coverage_status"] == "not_shot"]),
                    "alt_needed": len([s for s in scene_shots if s["coverage_status"] == "alt_needed"]),
                }
            })

        return {"success": True, "scenes_with_shots": scenes_with_shots}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching call sheet shots: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/scenes/{scene_id}/next-shot-number")
async def get_next_shot_number(
    project_id: str,
    scene_id: str,
    authorization: str = Header(None)
):
    """Get suggested next shot number for a scene"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get existing shot numbers
        shots_result = client.table("backlot_scene_shots").select("shot_number").eq("scene_id", scene_id).execute()
        shots = shots_result.data or []

        if not shots:
            return {"success": True, "next_shot_number": "1"}

        # Try to find max numeric value
        max_num = 0
        for shot in shots:
            num_str = shot["shot_number"]
            # Extract leading number
            import re
            match = re.match(r'^(\d+)', num_str)
            if match:
                num = int(match.group(1))
                if num > max_num:
                    max_num = num

        return {"success": True, "next_shot_number": str(max_num + 1)}

    except Exception as e:
        print(f"Error getting next shot number: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =============================================================================
# ASSETS, MEDIA, AND DELIVERABLES
# =============================================================================

class AssetInput(BaseModel):
    asset_type: str  # episode, feature, trailer, teaser, social, bts, other
    title: str
    description: Optional[str] = None
    duration_seconds: Optional[int] = None
    version_label: Optional[str] = None
    file_reference: Optional[str] = None
    status: Optional[str] = "not_started"
    sort_order: Optional[int] = None


class DeliverableTemplateInput(BaseModel):
    name: str
    description: Optional[str] = None
    target_platform: str
    specs: Optional[Dict[str, Any]] = None


class ProjectDeliverableInput(BaseModel):
    asset_id: str
    template_id: str
    status: Optional[str] = "not_started"
    due_date: Optional[str] = None
    delivered_date: Optional[str] = None
    reviewer_name: Optional[str] = None
    notes: Optional[str] = None
    custom_specs: Optional[Dict[str, Any]] = None


# -----------------------------------------------------------------------------
# ASSETS ENDPOINTS
# -----------------------------------------------------------------------------

@router.get("/projects/{project_id}/assets")
async def get_project_assets(
    project_id: str,
    asset_type: Optional[str] = None,
    status: Optional[str] = None,
    authorization: str = Header(None)
):
    """Get all assets for a project"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        query = client.table("backlot_assets").select("*").eq("project_id", project_id).order("sort_order", desc=False).order("created_at", desc=True)

        if asset_type:
            query = query.eq("asset_type", asset_type)
        if status:
            query = query.eq("status", status)

        result = query.execute()

        return {"success": True, "assets": result.data or []}

    except Exception as e:
        print(f"Error fetching assets: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/assets")
async def create_asset(
    project_id: str,
    asset_input: AssetInput,
    authorization: str = Header(None)
):
    """Create a new asset"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Validate asset_type
        valid_types = ["episode", "feature", "trailer", "teaser", "social", "bts", "other"]
        if asset_input.asset_type not in valid_types:
            raise HTTPException(status_code=400, detail=f"Invalid asset_type. Must be one of: {valid_types}")

        # Validate status
        valid_statuses = ["not_started", "in_progress", "in_review", "approved", "delivered"]
        if asset_input.status and asset_input.status not in valid_statuses:
            raise HTTPException(status_code=400, detail=f"Invalid status. Must be one of: {valid_statuses}")

        # Get next sort order
        sort_order = asset_input.sort_order
        if sort_order is None:
            max_result = client.table("backlot_assets").select("sort_order").eq("project_id", project_id).order("sort_order", desc=True).limit(1).execute()
            if max_result.data:
                sort_order = (max_result.data[0].get("sort_order") or 0) + 1
            else:
                sort_order = 0

        insert_data = {
            "project_id": project_id,
            "asset_type": asset_input.asset_type,
            "title": asset_input.title,
            "description": asset_input.description,
            "duration_seconds": asset_input.duration_seconds,
            "version_label": asset_input.version_label,
            "file_reference": asset_input.file_reference,
            "status": asset_input.status or "not_started",
            "sort_order": sort_order,
            "created_by_user_id": user["id"],
        }

        result = client.table("backlot_assets").insert(insert_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create asset")

        return {"success": True, "asset": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating asset: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/assets/{asset_id}")
async def get_asset(
    asset_id: str,
    authorization: str = Header(None)
):
    """Get a single asset"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        result = client.table("backlot_assets").select("*").eq("id", asset_id).single().execute()

        if not result.data:
            raise HTTPException(status_code=404, detail="Asset not found")

        return {"success": True, "asset": result.data}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching asset: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/assets/{asset_id}")
async def update_asset(
    asset_id: str,
    asset_input: AssetInput,
    authorization: str = Header(None)
):
    """Update an asset"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Validate asset_type
        valid_types = ["episode", "feature", "trailer", "teaser", "social", "bts", "other"]
        if asset_input.asset_type not in valid_types:
            raise HTTPException(status_code=400, detail=f"Invalid asset_type. Must be one of: {valid_types}")

        # Validate status
        valid_statuses = ["not_started", "in_progress", "in_review", "approved", "delivered"]
        if asset_input.status and asset_input.status not in valid_statuses:
            raise HTTPException(status_code=400, detail=f"Invalid status. Must be one of: {valid_statuses}")

        update_data = {
            "asset_type": asset_input.asset_type,
            "title": asset_input.title,
            "description": asset_input.description,
            "duration_seconds": asset_input.duration_seconds,
            "version_label": asset_input.version_label,
            "file_reference": asset_input.file_reference,
            "status": asset_input.status,
        }

        if asset_input.sort_order is not None:
            update_data["sort_order"] = asset_input.sort_order

        result = client.table("backlot_assets").update(update_data).eq("id", asset_id).execute()

        if not result.data:
            raise HTTPException(status_code=404, detail="Asset not found")

        return {"success": True, "asset": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating asset: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/assets/{asset_id}/status")
async def update_asset_status(
    asset_id: str,
    status: str = Body(..., embed=True),
    authorization: str = Header(None)
):
    """Update asset status only"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        valid_statuses = ["not_started", "in_progress", "in_review", "approved", "delivered"]
        if status not in valid_statuses:
            raise HTTPException(status_code=400, detail=f"Invalid status. Must be one of: {valid_statuses}")

        result = client.table("backlot_assets").update({"status": status}).eq("id", asset_id).execute()

        if not result.data:
            raise HTTPException(status_code=404, detail="Asset not found")

        return {"success": True, "asset": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating asset status: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/assets/{asset_id}")
async def delete_asset(
    asset_id: str,
    authorization: str = Header(None)
):
    """Delete an asset"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Delete associated deliverables first
        client.table("backlot_project_deliverables").delete().eq("asset_id", asset_id).execute()

        # Delete the asset
        result = client.table("backlot_assets").delete().eq("id", asset_id).execute()

        return {"success": True, "deleted": True}

    except Exception as e:
        print(f"Error deleting asset: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/assets/summary")
async def get_assets_summary(
    project_id: str,
    authorization: str = Header(None)
):
    """Get assets summary for a project"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        result = client.table("backlot_assets").select("asset_type, status").eq("project_id", project_id).execute()
        assets = result.data or []

        summary = {
            "total": len(assets),
            "by_type": {
                "episode": 0, "feature": 0, "trailer": 0, "teaser": 0,
                "social": 0, "bts": 0, "other": 0
            },
            "by_status": {
                "not_started": 0, "in_progress": 0, "in_review": 0,
                "approved": 0, "delivered": 0
            }
        }

        for asset in assets:
            if asset.get("asset_type") in summary["by_type"]:
                summary["by_type"][asset["asset_type"]] += 1
            if asset.get("status") in summary["by_status"]:
                summary["by_status"][asset["status"]] += 1

        return {"success": True, "summary": summary}

    except Exception as e:
        print(f"Error fetching assets summary: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# -----------------------------------------------------------------------------
# DELIVERABLE TEMPLATES ENDPOINTS
# -----------------------------------------------------------------------------

@router.get("/deliverable-templates")
async def get_deliverable_templates(
    platform: Optional[str] = None,
    authorization: str = Header(None)
):
    """Get all deliverable templates (system + user's own)"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        user_id = user["id"]

        # Get system templates
        system_query = client.table("backlot_deliverable_templates").select("*").eq(
            "is_active", True
        ).eq("is_system_template", True)
        if platform:
            system_query = system_query.eq("target_platform", platform)
        system_result = system_query.execute()

        # Get user's own templates
        user_query = client.table("backlot_deliverable_templates").select("*").eq(
            "is_active", True
        ).eq("owner_user_id", user_id)
        if platform:
            user_query = user_query.eq("target_platform", platform)
        user_result = user_query.execute()

        # Combine and deduplicate
        all_templates = (system_result.data or []) + (user_result.data or [])
        # Sort by platform then name
        all_templates.sort(key=lambda x: (x.get("target_platform", ""), x.get("name", "")))

        return {"success": True, "templates": all_templates}

    except Exception as e:
        print(f"Error fetching templates: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/deliverable-templates")
async def create_deliverable_template(
    template_input: DeliverableTemplateInput,
    authorization: str = Header(None)
):
    """Create a custom deliverable template"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        insert_data = {
            "name": template_input.name,
            "description": template_input.description,
            "target_platform": template_input.target_platform,
            "specs": template_input.specs or {},
            "is_system_template": False,
            "owner_user_id": user["id"],
        }

        result = client.table("backlot_deliverable_templates").insert(insert_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create template")

        return {"success": True, "template": result.data[0]}

    except Exception as e:
        print(f"Error creating template: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/deliverable-templates/{template_id}")
async def get_deliverable_template(
    template_id: str,
    authorization: str = Header(None)
):
    """Get a single deliverable template"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        result = client.table("backlot_deliverable_templates").select("*").eq("id", template_id).single().execute()

        if not result.data:
            raise HTTPException(status_code=404, detail="Template not found")

        return {"success": True, "template": result.data}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching template: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/deliverable-templates/{template_id}")
async def update_deliverable_template(
    template_id: str,
    template_input: DeliverableTemplateInput,
    authorization: str = Header(None)
):
    """Update a custom deliverable template"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Check ownership
        existing = client.table("backlot_deliverable_templates").select("owner_user_id, is_system_template").eq("id", template_id).single().execute()

        if not existing.data:
            raise HTTPException(status_code=404, detail="Template not found")

        if existing.data.get("is_system_template"):
            raise HTTPException(status_code=403, detail="Cannot modify system templates")

        if existing.data.get("owner_user_id") != user["id"]:
            raise HTTPException(status_code=403, detail="Not authorized to modify this template")

        update_data = {
            "name": template_input.name,
            "description": template_input.description,
            "target_platform": template_input.target_platform,
            "specs": template_input.specs or {},
        }

        result = client.table("backlot_deliverable_templates").update(update_data).eq("id", template_id).execute()

        return {"success": True, "template": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating template: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/deliverable-templates/{template_id}")
async def delete_deliverable_template(
    template_id: str,
    authorization: str = Header(None)
):
    """Delete a custom deliverable template"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Check ownership
        existing = client.table("backlot_deliverable_templates").select("owner_user_id, is_system_template").eq("id", template_id).single().execute()

        if not existing.data:
            raise HTTPException(status_code=404, detail="Template not found")

        if existing.data.get("is_system_template"):
            raise HTTPException(status_code=403, detail="Cannot delete system templates")

        if existing.data.get("owner_user_id") != user["id"]:
            raise HTTPException(status_code=403, detail="Not authorized to delete this template")

        # Soft delete - just mark as inactive
        result = client.table("backlot_deliverable_templates").update({"is_active": False}).eq("id", template_id).execute()

        return {"success": True, "deleted": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting template: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/deliverable-templates/platforms/list")
async def get_platforms_list(
    authorization: str = Header(None)
):
    """Get list of unique platforms from templates"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        result = client.table("backlot_deliverable_templates").select("target_platform").eq("is_active", True).execute()

        platforms = list(set([t["target_platform"] for t in (result.data or [])]))
        platforms.sort()

        return {"success": True, "platforms": platforms}

    except Exception as e:
        print(f"Error fetching platforms: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# -----------------------------------------------------------------------------
# PROJECT DELIVERABLES ENDPOINTS
# -----------------------------------------------------------------------------

@router.get("/projects/{project_id}/deliverables")
async def get_project_deliverables(
    project_id: str,
    asset_id: Optional[str] = None,
    status: Optional[str] = None,
    authorization: str = Header(None)
):
    """Get all deliverables for a project"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        query = client.table("backlot_project_deliverables").select("*").eq("project_id", project_id).order("due_date", desc=False).order("created_at", desc=True)

        if asset_id:
            query = query.eq("asset_id", asset_id)
        if status:
            query = query.eq("status", status)

        result = query.execute()

        return {"success": True, "deliverables": result.data or []}

    except Exception as e:
        print(f"Error fetching deliverables: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/deliverables")
async def create_project_deliverable(
    project_id: str,
    deliverable_input: ProjectDeliverableInput,
    authorization: str = Header(None)
):
    """Create a new deliverable for an asset"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Validate status
        valid_statuses = ["not_started", "in_progress", "in_review", "approved", "delivered"]
        if deliverable_input.status and deliverable_input.status not in valid_statuses:
            raise HTTPException(status_code=400, detail=f"Invalid status. Must be one of: {valid_statuses}")

        # Verify asset belongs to project
        asset_check = client.table("backlot_assets").select("id").eq("id", deliverable_input.asset_id).eq("project_id", project_id).execute()
        if not asset_check.data:
            raise HTTPException(status_code=400, detail="Asset not found in project")

        # Verify template exists
        template_check = client.table("backlot_deliverable_templates").select("id").eq("id", deliverable_input.template_id).execute()
        if not template_check.data:
            raise HTTPException(status_code=400, detail="Template not found")

        insert_data = {
            "project_id": project_id,
            "asset_id": deliverable_input.asset_id,
            "template_id": deliverable_input.template_id,
            "status": deliverable_input.status or "not_started",
            "due_date": deliverable_input.due_date,
            "delivered_date": deliverable_input.delivered_date,
            "reviewer_name": deliverable_input.reviewer_name,
            "notes": deliverable_input.notes,
            "custom_specs": deliverable_input.custom_specs,
            "created_by_user_id": user["id"],
        }

        result = client.table("backlot_project_deliverables").insert(insert_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create deliverable")

        deliverable = result.data[0]
        # Manually fetch related data
        if deliverable.get("asset_id"):
            asset_resp = client.table("backlot_assets").select("id, title, asset_type, version_label, status").eq("id", deliverable["asset_id"]).execute()
            deliverable["asset"] = asset_resp.data[0] if asset_resp.data else None
        if deliverable.get("template_id"):
            template_resp = client.table("backlot_deliverable_templates").select("id, name, target_platform, specs").eq("id", deliverable["template_id"]).execute()
            deliverable["template"] = template_resp.data[0] if template_resp.data else None

        return {"success": True, "deliverable": deliverable}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating deliverable: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/deliverables/{deliverable_id}")
async def get_deliverable(
    deliverable_id: str,
    authorization: str = Header(None)
):
    """Get a single deliverable"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        result = client.table("backlot_project_deliverables").select("*").eq("id", deliverable_id).execute()

        if not result.data:
            raise HTTPException(status_code=404, detail="Deliverable not found")

        deliverable = result.data[0]
        # Manually fetch related data
        if deliverable.get("asset_id"):
            asset_resp = client.table("backlot_assets").select("id, title, asset_type, version_label, status").eq("id", deliverable["asset_id"]).execute()
            deliverable["asset"] = asset_resp.data[0] if asset_resp.data else None
        if deliverable.get("template_id"):
            template_resp = client.table("backlot_deliverable_templates").select("id, name, target_platform, specs").eq("id", deliverable["template_id"]).execute()
            deliverable["template"] = template_resp.data[0] if template_resp.data else None

        return {"success": True, "deliverable": deliverable}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching deliverable: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/deliverables/{deliverable_id}")
async def update_deliverable(
    deliverable_id: str,
    deliverable_input: ProjectDeliverableInput,
    authorization: str = Header(None)
):
    """Update a deliverable"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Validate status
        valid_statuses = ["not_started", "in_progress", "in_review", "approved", "delivered"]
        if deliverable_input.status and deliverable_input.status not in valid_statuses:
            raise HTTPException(status_code=400, detail=f"Invalid status. Must be one of: {valid_statuses}")

        update_data = {
            "status": deliverable_input.status,
            "due_date": deliverable_input.due_date,
            "delivered_date": deliverable_input.delivered_date,
            "reviewer_name": deliverable_input.reviewer_name,
            "notes": deliverable_input.notes,
            "custom_specs": deliverable_input.custom_specs,
        }

        result = client.table("backlot_project_deliverables").update(update_data).eq("id", deliverable_id).execute()

        if not result.data:
            raise HTTPException(status_code=404, detail="Deliverable not found")

        deliverable = result.data[0]
        # Manually fetch related data
        if deliverable.get("asset_id"):
            asset_resp = client.table("backlot_assets").select("id, title, asset_type, version_label, status").eq("id", deliverable["asset_id"]).execute()
            deliverable["asset"] = asset_resp.data[0] if asset_resp.data else None
        if deliverable.get("template_id"):
            template_resp = client.table("backlot_deliverable_templates").select("id, name, target_platform, specs").eq("id", deliverable["template_id"]).execute()
            deliverable["template"] = template_resp.data[0] if template_resp.data else None

        return {"success": True, "deliverable": deliverable}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating deliverable: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/deliverables/{deliverable_id}/status")
async def update_deliverable_status(
    deliverable_id: str,
    status: str = Body(..., embed=True),
    delivered_date: Optional[str] = Body(None, embed=True),
    authorization: str = Header(None)
):
    """Update deliverable status"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        valid_statuses = ["not_started", "in_progress", "in_review", "approved", "delivered"]
        if status not in valid_statuses:
            raise HTTPException(status_code=400, detail=f"Invalid status. Must be one of: {valid_statuses}")

        update_data = {"status": status}

        # Auto-set delivered_date if marking as delivered
        if status == "delivered":
            if delivered_date:
                update_data["delivered_date"] = delivered_date
            else:
                from datetime import date
                update_data["delivered_date"] = date.today().isoformat()

        result = client.table("backlot_project_deliverables").update(update_data).eq("id", deliverable_id).execute()

        if not result.data:
            raise HTTPException(status_code=404, detail="Deliverable not found")

        return {"success": True, "deliverable": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating deliverable status: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/deliverables/{deliverable_id}")
async def delete_deliverable(
    deliverable_id: str,
    authorization: str = Header(None)
):
    """Delete a deliverable"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        result = client.table("backlot_project_deliverables").delete().eq("id", deliverable_id).execute()

        return {"success": True, "deleted": True}

    except Exception as e:
        print(f"Error deleting deliverable: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/deliverables/summary")
async def get_deliverables_summary(
    project_id: str,
    authorization: str = Header(None)
):
    """Get deliverables summary for a project"""
    await get_current_user_from_token(authorization)
    client = get_client()

    try:
        from datetime import date

        # Get all deliverables
        result = client.table("backlot_project_deliverables").select("id, status, due_date").eq("project_id", project_id).execute()
        deliverables = result.data or []

        # Get asset count
        assets_result = client.table("backlot_assets").select("id").eq("project_id", project_id).execute()

        summary = {
            "total_assets": len(assets_result.data or []),
            "total_deliverables": len(deliverables),
            "by_status": {
                "not_started": 0, "in_progress": 0, "in_review": 0,
                "approved": 0, "delivered": 0
            },
            "delivered_count": 0,
            "overdue_count": 0,
            "upcoming_deadlines": []
        }

        today = date.today().isoformat()

        for d in deliverables:
            status = d.get("status", "not_started")
            if status in summary["by_status"]:
                summary["by_status"][status] += 1

            if status == "delivered":
                summary["delivered_count"] += 1

            # Check overdue
            if d.get("due_date") and d["due_date"] < today and status not in ["delivered", "approved"]:
                summary["overdue_count"] += 1

            # Upcoming deadlines
            if d.get("due_date") and d["due_date"] >= today and status not in ["delivered", "approved"]:
                summary["upcoming_deadlines"].append({
                    "id": d["id"],
                    "asset_title": d.get("asset", {}).get("title") if d.get("asset") else None,
                    "template_name": d.get("template", {}).get("name") if d.get("template") else None,
                    "due_date": d["due_date"],
                    "status": status
                })

        # Sort upcoming deadlines by due date
        summary["upcoming_deadlines"] = sorted(summary["upcoming_deadlines"], key=lambda x: x["due_date"])[:5]

        return {"success": True, "summary": summary}

    except Exception as e:
        print(f"Error fetching deliverables summary: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/assets/{asset_id}/deliverables/bulk")
async def bulk_create_deliverables(
    asset_id: str,
    template_ids: List[str] = Body(..., embed=True),
    authorization: str = Header(None)
):
    """Bulk create deliverables for an asset from multiple templates"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get asset to verify it exists and get project_id
        asset_result = client.table("backlot_assets").select("id, project_id").eq("id", asset_id).single().execute()
        if not asset_result.data:
            raise HTTPException(status_code=404, detail="Asset not found")

        project_id = asset_result.data["project_id"]

        # Create deliverables for each template
        created = []
        for template_id in template_ids:
            try:
                insert_data = {
                    "project_id": project_id,
                    "asset_id": asset_id,
                    "template_id": template_id,
                    "status": "not_started",
                    "created_by_user_id": user["id"],
                }
                result = client.table("backlot_project_deliverables").insert(insert_data).execute()
                if result.data:
                    created.append(result.data[0])
            except Exception as e:
                # Skip duplicates silently
                print(f"Skipping template {template_id}: {e}")
                continue

        return {"success": True, "created_count": len(created), "deliverables": created}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error bulk creating deliverables: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# PRODUCER ANALYTICS (READ-ONLY)
# =====================================================

@router.get("/projects/{project_id}/analytics/cost-by-department")
async def get_cost_by_department_analytics(
    project_id: str,
    authorization: str = Header(None)
):
    """
    READ-ONLY: Get cost vs budget breakdown by department/category.
    Reads from budget categories and line items - no modifications.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify user has access to project (producer/admin only)
        member_result = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user["id"]).single().execute()
        if not member_result.data or member_result.data["role"] not in ["owner", "producer", "admin"]:
            raise HTTPException(status_code=403, detail="Analytics access requires producer or admin role")

        # Get the active budget for the project
        budget_result = client.table("backlot_budgets").select("id, name, estimated_total, actual_total, variance").eq("project_id", project_id).eq("status", "approved").limit(1).execute()

        if not budget_result.data:
            # Try to get any budget if no approved one
            budget_result = client.table("backlot_budgets").select("id, name, estimated_total, actual_total, variance").eq("project_id", project_id).order("created_at", desc=True).limit(1).execute()

        if not budget_result.data:
            return {
                "success": True,
                "has_budget": False,
                "departments": [],
                "totals": {"budgeted": 0, "actual": 0, "variance": 0}
            }

        budget = budget_result.data[0]
        budget_id = budget["id"]

        # Get categories with their line items aggregated
        categories_result = client.table("backlot_budget_categories").select(
            "id, name, category_type, account_code_prefix, estimated_subtotal, actual_subtotal"
        ).eq("budget_id", budget_id).order("sort_order").execute()

        departments = []
        for cat in (categories_result.data or []):
            # Get line items for this category to sum by department
            items_result = client.table("backlot_budget_line_items").select(
                "department, estimated_total, actual_total"
            ).eq("category_id", cat["id"]).execute()

            # Group by department within category
            dept_totals = {}
            for item in (items_result.data or []):
                dept = item.get("department") or cat["name"]
                if dept not in dept_totals:
                    dept_totals[dept] = {"budgeted": 0, "actual": 0}
                dept_totals[dept]["budgeted"] += float(item.get("estimated_total") or 0)
                dept_totals[dept]["actual"] += float(item.get("actual_total") or 0)

            # If no items, use category totals
            if not dept_totals:
                dept_totals[cat["name"]] = {
                    "budgeted": float(cat.get("estimated_subtotal") or 0),
                    "actual": float(cat.get("actual_subtotal") or 0)
                }

            for dept_name, totals in dept_totals.items():
                departments.append({
                    "department": dept_name,
                    "category_type": cat.get("category_type", "other"),
                    "budgeted_amount": totals["budgeted"],
                    "actual_amount": totals["actual"],
                    "variance": totals["actual"] - totals["budgeted"],
                    "variance_percent": round((totals["actual"] - totals["budgeted"]) / totals["budgeted"] * 100, 1) if totals["budgeted"] > 0 else 0
                })

        # Sort by budgeted amount descending
        departments.sort(key=lambda x: x["budgeted_amount"], reverse=True)

        return {
            "success": True,
            "has_budget": True,
            "budget_name": budget["name"],
            "departments": departments,
            "totals": {
                "budgeted": float(budget.get("estimated_total") or 0),
                "actual": float(budget.get("actual_total") or 0),
                "variance": float(budget.get("variance") or 0)
            }
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching cost analytics: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/analytics/time-and-schedule")
async def get_time_schedule_analytics(
    project_id: str,
    authorization: str = Header(None)
):
    """
    READ-ONLY: Get schedule health metrics - pages planned vs shot over time.
    Reads from scenes, call sheets, and production days - no modifications.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify user has access to project
        member_result = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user["id"]).single().execute()
        if not member_result.data or member_result.data["role"] not in ["owner", "producer", "admin"]:
            raise HTTPException(status_code=403, detail="Analytics access requires producer or admin role")

        # Get all scenes with page counts and coverage status
        scenes_result = client.table("backlot_scenes").select(
            "id, scene_number, page_count, coverage_status, is_omitted"
        ).eq("project_id", project_id).eq("is_omitted", False).execute()

        scenes = scenes_result.data or []

        # Calculate total pages
        total_pages = 0
        pages_by_status = {"not_scheduled": 0, "scheduled": 0, "shot": 0, "needs_pickup": 0}

        for scene in scenes:
            try:
                page_count = float(scene.get("page_count") or 0)
            except (ValueError, TypeError):
                page_count = 0
            total_pages += page_count
            status = scene.get("coverage_status", "not_scheduled")
            if status in pages_by_status:
                pages_by_status[status] += page_count

        # Get production days with dates
        prod_days_result = client.table("backlot_production_days").select(
            "id, day_number, date, is_completed"
        ).eq("project_id", project_id).order("day_number").execute()

        production_days = prod_days_result.data or []
        total_shoot_days = len(production_days)
        completed_days = sum(1 for d in production_days if d.get("is_completed"))

        # Get call sheet scenes to calculate pages per day
        daily_data = []
        cumulative_planned = 0
        cumulative_shot = 0

        for day in production_days:
            # Get scenes linked to this day's call sheet
            cs_result = client.table("backlot_call_sheets").select("id").eq("production_day_id", day["id"]).limit(1).execute()

            pages_planned = 0
            pages_shot = 0

            if cs_result.data:
                call_sheet_id = cs_result.data[0]["id"]

                # Get scene links for this call sheet
                links_result = client.table("backlot_call_sheet_scene_links").select(
                    "scene_id, status"
                ).eq("call_sheet_id", call_sheet_id).execute()

                for link in (links_result.data or []):
                    # Find the scene's page count
                    scene = next((s for s in scenes if s["id"] == link["scene_id"]), None)
                    if scene:
                        try:
                            pc = float(scene.get("page_count") or 0)
                        except:
                            pc = 0
                        pages_planned += pc
                        if link.get("status") == "completed":
                            pages_shot += pc

            cumulative_planned += pages_planned
            cumulative_shot += pages_shot

            daily_data.append({
                "day_number": day["day_number"],
                "date": day.get("date"),
                "is_completed": day.get("is_completed", False),
                "pages_planned": round(pages_planned, 2),
                "pages_shot": round(pages_shot, 2),
                "cumulative_planned": round(cumulative_planned, 2),
                "cumulative_shot": round(cumulative_shot, 2)
            })

        # Calculate schedule health
        pages_shot = pages_by_status["shot"]
        pages_scheduled = pages_by_status["scheduled"] + pages_by_status["shot"]

        # Determine schedule status
        if total_shoot_days == 0:
            schedule_status = "not_started"
            progress_percent = 0
        else:
            progress_percent = round((pages_shot / total_pages * 100) if total_pages > 0 else 0, 1)
            expected_progress = (completed_days / total_shoot_days * 100) if total_shoot_days > 0 else 0

            if progress_percent >= expected_progress + 5:
                schedule_status = "ahead"
            elif progress_percent >= expected_progress - 5:
                schedule_status = "on_track"
            else:
                schedule_status = "behind"

        # Average pages per day
        avg_pages_per_day = round(pages_shot / completed_days, 2) if completed_days > 0 else 0
        target_pages_per_day = round(total_pages / total_shoot_days, 2) if total_shoot_days > 0 else 0

        return {
            "success": True,
            "summary": {
                "total_pages": round(total_pages, 2),
                "pages_shot": round(pages_shot, 2),
                "pages_scheduled": round(pages_scheduled, 2),
                "pages_remaining": round(total_pages - pages_shot, 2),
                "total_shoot_days": total_shoot_days,
                "completed_days": completed_days,
                "remaining_days": total_shoot_days - completed_days,
                "progress_percent": progress_percent,
                "schedule_status": schedule_status,
                "avg_pages_per_day": avg_pages_per_day,
                "target_pages_per_day": target_pages_per_day
            },
            "pages_by_status": {
                "not_scheduled": round(pages_by_status["not_scheduled"], 2),
                "scheduled": round(pages_by_status["scheduled"], 2),
                "shot": round(pages_by_status["shot"], 2),
                "needs_pickup": round(pages_by_status["needs_pickup"], 2)
            },
            "daily_trend": daily_data
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching schedule analytics: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/analytics/utilization")
async def get_utilization_analytics(
    project_id: str,
    authorization: str = Header(None)
):
    """
    READ-ONLY: Get resource utilization metrics - locations, cast, and crew usage.
    Reads from production days, call sheets, locations, and bookings - no modifications.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify user has access to project
        member_result = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user["id"]).single().execute()
        if not member_result.data or member_result.data["role"] not in ["owner", "producer", "admin"]:
            raise HTTPException(status_code=403, detail="Analytics access requires producer or admin role")

        # Get all production days
        prod_days_result = client.table("backlot_production_days").select(
            "id, day_number, date, location_id, location_name, is_completed"
        ).eq("project_id", project_id).execute()

        production_days = prod_days_result.data or []
        total_days = len(production_days)
        completed_days = sum(1 for d in production_days if d.get("is_completed"))

        # Location utilization
        location_usage = {}
        for day in production_days:
            loc_id = day.get("location_id")
            loc_name = day.get("location_name", "Unknown Location")

            if loc_id:
                if loc_id not in location_usage:
                    # Get location name
                    loc_result = client.table("backlot_locations").select("name").eq("id", loc_id).single().execute()
                    location_usage[loc_id] = {
                        "location_id": loc_id,
                        "name": loc_result.data["name"] if loc_result.data else loc_name,
                        "days_scheduled": 0,
                        "days_completed": 0
                    }
                location_usage[loc_id]["days_scheduled"] += 1
                if day.get("is_completed"):
                    location_usage[loc_id]["days_completed"] += 1
            elif loc_name:
                key = f"name:{loc_name}"
                if key not in location_usage:
                    location_usage[key] = {
                        "location_id": None,
                        "name": loc_name,
                        "days_scheduled": 0,
                        "days_completed": 0
                    }
                location_usage[key]["days_scheduled"] += 1
                if day.get("is_completed"):
                    location_usage[key]["days_completed"] += 1

        locations = sorted(location_usage.values(), key=lambda x: x["days_scheduled"], reverse=True)

        # Cast and crew utilization from call sheet people
        person_usage = {}

        for day in production_days:
            # Get call sheet for this day
            cs_result = client.table("backlot_call_sheets").select("id").eq("production_day_id", day["id"]).limit(1).execute()

            if cs_result.data:
                call_sheet_id = cs_result.data[0]["id"]

                # Get people on this call sheet
                people_result = client.table("backlot_call_sheet_people").select(
                    "id, name, role, department, is_cast, character_name"
                ).eq("call_sheet_id", call_sheet_id).execute()

                for person in (people_result.data or []):
                    key = person.get("name", "Unknown")
                    if key not in person_usage:
                        person_usage[key] = {
                            "name": key,
                            "role": person.get("role") or person.get("character_name", ""),
                            "department": person.get("department", ""),
                            "is_cast": person.get("is_cast", False),
                            "days_scheduled": 0,
                            "days_worked": 0
                        }
                    person_usage[key]["days_scheduled"] += 1
                    if day.get("is_completed"):
                        person_usage[key]["days_worked"] += 1

        # Separate cast and crew
        cast_usage = [p for p in person_usage.values() if p["is_cast"]]
        crew_usage = [p for p in person_usage.values() if not p["is_cast"]]

        # Sort by days scheduled
        cast_usage.sort(key=lambda x: x["days_scheduled"], reverse=True)
        crew_usage.sort(key=lambda x: x["days_scheduled"], reverse=True)

        # Get booked roles for additional context
        roles_result = client.table("backlot_project_roles").select(
            "id, title, type, department, status, days_estimated, booked_user_id"
        ).eq("project_id", project_id).execute()

        roles = roles_result.data or []
        booked_roles = [r for r in roles if r.get("booked_user_id")]
        open_roles = [r for r in roles if r.get("status") == "open"]

        return {
            "success": True,
            "summary": {
                "total_shoot_days": total_days,
                "completed_days": completed_days,
                "unique_locations": len(locations),
                "total_cast_booked": len([c for c in cast_usage if c["days_scheduled"] > 0]),
                "total_crew_booked": len([c for c in crew_usage if c["days_scheduled"] > 0]),
                "open_roles": len(open_roles),
                "filled_roles": len(booked_roles)
            },
            "locations": locations[:20],
            "cast": cast_usage[:20],
            "crew": crew_usage[:30],
            "roles_summary": {
                "total": len(roles),
                "booked": len(booked_roles),
                "open": len(open_roles),
                "cast_roles": len([r for r in roles if r.get("type") == "cast"]),
                "crew_roles": len([r for r in roles if r.get("type") == "crew"])
            }
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching utilization analytics: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/analytics/overview")
async def get_analytics_overview(
    project_id: str,
    authorization: str = Header(None)
):
    """
    READ-ONLY: Get combined analytics overview for producer dashboard.
    Aggregates key metrics from cost, schedule, and utilization.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify user has access to project (producer/admin only)
        member_result = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user["id"]).single().execute()
        if not member_result.data or member_result.data["role"] not in ["owner", "producer", "admin"]:
            raise HTTPException(status_code=403, detail="Analytics access requires producer or admin role")

        # Get project info
        project_result = client.table("backlot_projects").select("title, status").eq("id", project_id).single().execute()
        project = project_result.data if project_result.data else {"title": "Unknown", "status": "unknown"}

        # Budget summary
        budget_result = client.table("backlot_budgets").select(
            "estimated_total, actual_total, variance"
        ).eq("project_id", project_id).order("created_at", desc=True).limit(1).execute()

        budget_summary = {
            "has_budget": bool(budget_result.data),
            "estimated_total": float(budget_result.data[0].get("estimated_total") or 0) if budget_result.data else 0,
            "actual_total": float(budget_result.data[0].get("actual_total") or 0) if budget_result.data else 0,
            "variance": float(budget_result.data[0].get("variance") or 0) if budget_result.data else 0,
            "budget_status": "on_track"
        }

        if budget_summary["has_budget"] and budget_summary["estimated_total"] > 0:
            variance_percent = (budget_summary["variance"] / budget_summary["estimated_total"]) * 100
            if variance_percent > 10:
                budget_summary["budget_status"] = "over_budget"
            elif variance_percent < -10:
                budget_summary["budget_status"] = "under_budget"

        # Schedule summary
        scenes_result = client.table("backlot_scenes").select("page_count, coverage_status").eq("project_id", project_id).eq("is_omitted", False).execute()

        total_pages = 0
        pages_shot = 0
        for scene in (scenes_result.data or []):
            try:
                pc = float(scene.get("page_count") or 0)
            except:
                pc = 0
            total_pages += pc
            if scene.get("coverage_status") == "shot":
                pages_shot += pc

        prod_days_result = client.table("backlot_production_days").select("id, is_completed").eq("project_id", project_id).execute()
        total_days = len(prod_days_result.data or [])
        completed_days = sum(1 for d in (prod_days_result.data or []) if d.get("is_completed"))

        schedule_summary = {
            "total_pages": round(total_pages, 2),
            "pages_shot": round(pages_shot, 2),
            "progress_percent": round((pages_shot / total_pages * 100) if total_pages > 0 else 0, 1),
            "total_shoot_days": total_days,
            "completed_days": completed_days,
            "schedule_status": "on_track"
        }

        if total_days > 0:
            expected = completed_days / total_days * 100
            actual = schedule_summary["progress_percent"]
            if actual >= expected + 5:
                schedule_summary["schedule_status"] = "ahead"
            elif actual < expected - 5:
                schedule_summary["schedule_status"] = "behind"

        # Team summary
        members_result = client.table("backlot_project_members").select("id").eq("project_id", project_id).execute()
        roles_result = client.table("backlot_project_roles").select("status").eq("project_id", project_id).execute()

        team_summary = {
            "total_members": len(members_result.data or []),
            "total_roles": len(roles_result.data or []),
            "open_roles": len([r for r in (roles_result.data or []) if r.get("status") == "open"]),
            "booked_roles": len([r for r in (roles_result.data or []) if r.get("status") == "booked"])
        }

        return {
            "success": True,
            "project": project,
            "budget": budget_summary,
            "schedule": schedule_summary,
            "team": team_summary
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching analytics overview: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/dashboard")
async def get_project_dashboard(
    project_id: str,
    authorization: str = Header(None)
):
    """
    Get optimized project dashboard data in a single request.
    Aggregates task stats, production days, locations, team, and updates.
    This endpoint replaces multiple separate API calls for better performance.
    """
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    try:
        # Look up profile ID from cognito user ID
        profile_id = get_profile_id_from_cognito_id(cognito_user_id)
        if not profile_id:
            raise HTTPException(status_code=403, detail="Profile not found")

        # Verify access - check owner or member
        project_result = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        if not project_result.data:
            raise HTTPException(status_code=404, detail="Project not found")

        is_owner = str(project_result.data[0]["owner_id"]) == str(profile_id)
        if not is_owner:
            member_result = client.table("backlot_project_members").select("id").eq("project_id", project_id).eq("user_id", profile_id).execute()
            if not member_result.data:
                raise HTTPException(status_code=403, detail="Access denied")

        # 1. Task Stats - aggregate counts by status
        tasks_result = client.table("backlot_tasks").select("status").eq("project_id", project_id).execute()
        tasks = tasks_result.data or []
        task_stats = {
            "total": len(tasks),
            "todo": sum(1 for t in tasks if t.get("status") == "todo"),
            "in_progress": sum(1 for t in tasks if t.get("status") == "in_progress"),
            "review": sum(1 for t in tasks if t.get("status") == "review"),
            "completed": sum(1 for t in tasks if t.get("status") == "done"),
        }

        # 2. Production Days - get all with basic info
        days_result = client.table("backlot_production_days").select(
            "id, day_number, date, title, general_call_time, is_completed"
        ).eq("project_id", project_id).order("date").execute()
        days = days_result.data or []

        # 3. Locations count
        locations_result = client.table("backlot_project_locations").select("id").eq("project_id", project_id).execute()
        locations_count = len(locations_result.data or [])

        # 4. Team members count (including profiles for display)
        members_result = client.table("backlot_project_members").select(
            "id, user_id, role, production_role"
        ).eq("project_id", project_id).execute()
        members = members_result.data or []

        # Batch fetch profiles for members
        if members:
            user_ids = list(set(m["user_id"] for m in members))
            profiles_result = client.table("profiles").select(
                "id, full_name, display_name, avatar_url"
            ).in_("id", user_ids).execute()
            profile_map = {p["id"]: p for p in (profiles_result.data or [])}

            for member in members:
                member["profile"] = profile_map.get(member["user_id"])

        # 5. Recent updates (last 5)
        updates_result = client.table("backlot_updates").select(
            "id, title, content, created_at, author_id"
        ).eq("project_id", project_id).order("created_at", desc=True).limit(5).execute()
        updates = updates_result.data or []

        # Batch fetch update authors
        if updates:
            author_ids = list(set(u["author_id"] for u in updates if u.get("author_id")))
            if author_ids:
                authors_result = client.table("profiles").select(
                    "id, full_name, display_name, avatar_url"
                ).in_("id", author_ids).execute()
                author_map = {a["id"]: a for a in (authors_result.data or [])}

                for update in updates:
                    update["author"] = author_map.get(update.get("author_id"))

        # 6. Gear count (optional, quick count)
        gear_result = client.table("backlot_gear_items").select("id").eq("project_id", project_id).execute()
        gear_count = len(gear_result.data or [])

        return {
            "success": True,
            "task_stats": task_stats,
            "days": days,
            "days_count": len(days),
            "locations_count": locations_count,
            "members": members,
            "members_count": len(members),
            "updates": updates,
            "gear_count": gear_count
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching project dashboard: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# SHOT LISTS API (Professional DP/Producer Shot Lists)
# =====================================================

class ShotListCreate(BaseModel):
    """Request model for creating a shot list"""
    title: str
    description: Optional[str] = None
    list_type: Optional[str] = None  # 'scene_based', 'day_based', 'sequence_based', 'location_based', 'custom'
    production_day_id: Optional[str] = None
    scene_id: Optional[str] = None


class ShotListUpdate(BaseModel):
    """Request model for updating a shot list"""
    title: Optional[str] = None
    description: Optional[str] = None
    list_type: Optional[str] = None
    production_day_id: Optional[str] = None
    scene_id: Optional[str] = None
    is_archived: Optional[bool] = None


class ShotCreate(BaseModel):
    """Request model for creating a shot"""
    shot_number: Optional[str] = None
    scene_number: Optional[str] = None
    scene_id: Optional[str] = None
    camera_label: Optional[str] = None
    frame_size: Optional[str] = None
    lens: Optional[str] = None
    focal_length_mm: Optional[float] = None
    camera_height: Optional[str] = None
    movement: Optional[str] = None
    location_hint: Optional[str] = None
    time_of_day: Optional[str] = None
    description: Optional[str] = None
    technical_notes: Optional[str] = None
    performance_notes: Optional[str] = None
    est_time_minutes: Optional[float] = None


class ShotUpdate(BaseModel):
    """Request model for updating a shot"""
    shot_number: Optional[str] = None
    scene_number: Optional[str] = None
    scene_id: Optional[str] = None
    camera_label: Optional[str] = None
    frame_size: Optional[str] = None
    lens: Optional[str] = None
    focal_length_mm: Optional[float] = None
    camera_height: Optional[str] = None
    movement: Optional[str] = None
    location_hint: Optional[str] = None
    time_of_day: Optional[str] = None
    description: Optional[str] = None
    technical_notes: Optional[str] = None
    performance_notes: Optional[str] = None
    est_time_minutes: Optional[float] = None
    is_completed: Optional[bool] = None
    sort_order: Optional[int] = None


class ShotReorderItem(BaseModel):
    """Single item in a reorder request"""
    id: str
    sort_order: int


class ShotReorderRequest(BaseModel):
    """Request model for reordering shots"""
    shots: List[ShotReorderItem]


# Helper to check if user can edit shot lists (producer-level roles)
async def verify_shot_list_edit_access(client, project_id: str, user_id: str) -> bool:
    """Check if user has producer-level access to edit shot lists"""
    # Convert cognito user ID to profile ID
    profile_id = get_profile_id_from_cognito_id(user_id)
    if not profile_id:
        return False

    # Check if owner
    project_result = client.table("backlot_projects").select("owner_id").eq("id", project_id).single().execute()
    if project_result.data and project_result.data.get("owner_id") == profile_id:
        return True

    # Check membership role
    member_result = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id).single().execute()
    if member_result.data:
        role = member_result.data.get("role")
        if role in ["owner", "admin", "editor", "producer", "director", "dp", "first_ad"]:
            return True

    return False


@router.get("/projects/{project_id}/shot-lists")
async def list_shot_lists(
    project_id: str,
    include_archived: bool = False,
    authorization: str = Header(None)
):
    """
    Get all shot lists for a project.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify project access
        await verify_project_access(client, project_id, user["id"])

        # Build query - simple select without joins to avoid schema issues
        query = client.table("backlot_shot_lists").select("*").eq("project_id", project_id)

        if not include_archived:
            query = query.eq("is_archived", False)

        query = query.order("created_at", desc=True)
        result = query.execute()

        shot_lists = result.data or []

        # Get shot counts for each list
        for shot_list in shot_lists:
            count_result = client.table("backlot_shots").select("id", count="exact").eq("shot_list_id", shot_list["id"]).execute()
            shot_list["shot_count"] = count_result.count or 0

            # Get completion stats
            completed_result = client.table("backlot_shots").select("id", count="exact").eq("shot_list_id", shot_list["id"]).eq("is_completed", True).execute()
            shot_list["completed_count"] = completed_result.count or 0

        return {"success": True, "shot_lists": shot_lists}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error listing shot lists: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/shot-lists")
async def create_shot_list(
    project_id: str,
    request: ShotListCreate,
    authorization: str = Header(None)
):
    """
    Create a new shot list.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify edit access
        has_access = await verify_shot_list_edit_access(client, project_id, user["id"])
        if not has_access:
            raise HTTPException(status_code=403, detail="You don't have permission to create shot lists")

        # Convert cognito user ID to profile ID
        profile_id = get_profile_id_from_cognito_id(user["id"])
        if not profile_id:
            raise HTTPException(status_code=403, detail="Profile not found")

        # Create shot list
        shot_list_data = {
            "project_id": project_id,
            "title": request.title,
            "description": request.description,
            "list_type": request.list_type,
            "production_day_id": request.production_day_id,
            "scene_id": request.scene_id,
            "created_by_user_id": profile_id,
        }

        result = client.table("backlot_shot_lists").insert(shot_list_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create shot list")

        return {"success": True, "shot_list": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating shot list: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/shot-lists/{shot_list_id}")
async def get_shot_list(
    shot_list_id: str,
    authorization: str = Header(None)
):
    """
    Get a single shot list with all its shots.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get shot list - simple select without joins to avoid schema issues
        shot_list_result = client.table("backlot_shot_lists").select("*").eq("id", shot_list_id).single().execute()

        if not shot_list_result.data:
            raise HTTPException(status_code=404, detail="Shot list not found")

        shot_list = shot_list_result.data

        # Verify project access
        await verify_project_access(client, shot_list["project_id"], user["id"])

        # Get shots - simple select without joins to avoid schema issues
        shots_result = client.table("backlot_shots").select("*").eq("shot_list_id", shot_list_id).order("sort_order").order("created_at").execute()

        shot_list["shots"] = shots_result.data or []

        return {"success": True, "shot_list": shot_list}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting shot list: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/shot-lists/{shot_list_id}")
async def update_shot_list(
    shot_list_id: str,
    request: ShotListUpdate,
    authorization: str = Header(None)
):
    """
    Update a shot list.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get shot list to verify access
        shot_list_result = client.table("backlot_shot_lists").select("project_id").eq("id", shot_list_id).single().execute()

        if not shot_list_result.data:
            raise HTTPException(status_code=404, detail="Shot list not found")

        project_id = shot_list_result.data["project_id"]

        # Verify edit access
        has_access = await verify_shot_list_edit_access(client, project_id, user["id"])
        if not has_access:
            raise HTTPException(status_code=403, detail="You don't have permission to edit shot lists")

        # Build update data
        update_data = {}
        if request.title is not None:
            update_data["title"] = request.title
        if request.description is not None:
            update_data["description"] = request.description
        if request.list_type is not None:
            update_data["list_type"] = request.list_type
        if request.production_day_id is not None:
            update_data["production_day_id"] = request.production_day_id if request.production_day_id else None
        if request.scene_id is not None:
            update_data["scene_id"] = request.scene_id if request.scene_id else None
        if request.is_archived is not None:
            update_data["is_archived"] = request.is_archived

        if update_data:
            result = client.table("backlot_shot_lists").update(update_data).eq("id", shot_list_id).execute()
            return {"success": True, "shot_list": result.data[0] if result.data else None}

        return {"success": True, "shot_list": shot_list_result.data}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating shot list: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/shot-lists/{shot_list_id}")
async def delete_shot_list(
    shot_list_id: str,
    hard_delete: bool = False,
    authorization: str = Header(None)
):
    """
    Delete (archive) a shot list.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get shot list to verify access
        shot_list_result = client.table("backlot_shot_lists").select("project_id").eq("id", shot_list_id).single().execute()

        if not shot_list_result.data:
            raise HTTPException(status_code=404, detail="Shot list not found")

        project_id = shot_list_result.data["project_id"]

        # Verify edit access
        has_access = await verify_shot_list_edit_access(client, project_id, user["id"])
        if not has_access:
            raise HTTPException(status_code=403, detail="You don't have permission to delete shot lists")

        if hard_delete:
            # Hard delete - will cascade to shots
            client.table("backlot_shot_lists").delete().eq("id", shot_list_id).execute()
        else:
            # Soft delete - archive
            client.table("backlot_shot_lists").update({"is_archived": True}).eq("id", shot_list_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting shot list: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# SHOTS API (Individual shots within a list)
# =====================================================

@router.post("/shot-lists/{shot_list_id}/shots")
async def create_shot(
    shot_list_id: str,
    request: ShotCreate,
    authorization: str = Header(None)
):
    """
    Create a new shot in a shot list.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get shot list to verify access and get project_id
        shot_list_result = client.table("backlot_shot_lists").select("project_id").eq("id", shot_list_id).single().execute()

        if not shot_list_result.data:
            raise HTTPException(status_code=404, detail="Shot list not found")

        project_id = shot_list_result.data["project_id"]

        # Verify edit access
        has_access = await verify_shot_list_edit_access(client, project_id, user["id"])
        if not has_access:
            raise HTTPException(status_code=403, detail="You don't have permission to add shots")

        # Get next sort order
        max_order_result = client.table("backlot_shots").select("sort_order").eq("shot_list_id", shot_list_id).order("sort_order", desc=True).limit(1).execute()
        next_sort_order = (max_order_result.data[0]["sort_order"] + 1) if max_order_result.data else 0

        # Get next shot number if not provided
        shot_number = request.shot_number
        if not shot_number:
            max_num_result = client.table("backlot_shots").select("shot_number").eq("shot_list_id", shot_list_id).execute()
            if max_num_result.data:
                # Extract max numeric part
                max_num = 0
                for s in max_num_result.data:
                    try:
                        num_part = ''.join(c for c in s["shot_number"] if c.isdigit())
                        if num_part:
                            max_num = max(max_num, int(num_part))
                    except:
                        pass
                shot_number = str(max_num + 1)
            else:
                shot_number = "1"

        # Create shot
        shot_data = {
            "project_id": project_id,
            "shot_list_id": shot_list_id,
            "sort_order": next_sort_order,
            "shot_number": shot_number,
            "scene_number": request.scene_number,
            "scene_id": request.scene_id,
            "camera_label": request.camera_label,
            "frame_size": request.frame_size,
            "lens": request.lens,
            "focal_length_mm": request.focal_length_mm,
            "camera_height": request.camera_height,
            "movement": request.movement,
            "location_hint": request.location_hint,
            "time_of_day": request.time_of_day,
            "description": request.description,
            "technical_notes": request.technical_notes,
            "performance_notes": request.performance_notes,
            "est_time_minutes": request.est_time_minutes,
            "created_by_user_id": user["id"],
        }

        result = client.table("backlot_shots").insert(shot_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create shot")

        return {"success": True, "shot": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating shot: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/shots/{shot_id}")
async def update_shot(
    shot_id: str,
    request: ShotUpdate,
    authorization: str = Header(None)
):
    """
    Update a shot.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get shot to verify access
        shot_result = client.table("backlot_shots").select("project_id").eq("id", shot_id).single().execute()

        if not shot_result.data:
            raise HTTPException(status_code=404, detail="Shot not found")

        project_id = shot_result.data["project_id"]

        # Verify edit access
        has_access = await verify_shot_list_edit_access(client, project_id, user["id"])
        if not has_access:
            raise HTTPException(status_code=403, detail="You don't have permission to edit shots")

        # Build update data
        update_data = {}
        fields = [
            "shot_number", "scene_number", "scene_id", "camera_label", "frame_size",
            "lens", "focal_length_mm", "camera_height", "movement", "location_hint",
            "time_of_day", "description", "technical_notes", "performance_notes",
            "est_time_minutes", "is_completed", "sort_order"
        ]

        for field in fields:
            value = getattr(request, field, None)
            if value is not None:
                update_data[field] = value

        if update_data:
            result = client.table("backlot_shots").update(update_data).eq("id", shot_id).execute()
            return {"success": True, "shot": result.data[0] if result.data else None}

        return {"success": True, "shot": shot_result.data}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating shot: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/shots/{shot_id}")
async def delete_shot(
    shot_id: str,
    authorization: str = Header(None)
):
    """
    Delete a shot.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get shot to verify access
        shot_result = client.table("backlot_shots").select("project_id").eq("id", shot_id).single().execute()

        if not shot_result.data:
            raise HTTPException(status_code=404, detail="Shot not found")

        project_id = shot_result.data["project_id"]

        # Verify edit access
        has_access = await verify_shot_list_edit_access(client, project_id, user["id"])
        if not has_access:
            raise HTTPException(status_code=403, detail="You don't have permission to delete shots")

        # Delete
        client.table("backlot_shots").delete().eq("id", shot_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting shot: {e}")
        raise HTTPException(status_code=500, detail=str(e))


class CloneShotListShotInput(BaseModel):
    """Input for cloning a shot in a shot list"""
    destination_shot_list_id: Optional[str] = None


@router.post("/shots/{shot_id}/clone")
async def clone_shot_list_shot(
    shot_id: str,
    input_data: CloneShotListShotInput,
    authorization: str = Header(None)
):
    """
    Clone a shot within a shot list, optionally to a different shot list.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get original shot
        shot_result = client.table("backlot_shots").select("*").eq("id", shot_id).single().execute()
        if not shot_result.data:
            raise HTTPException(status_code=404, detail="Shot not found")

        original = shot_result.data
        project_id = original["project_id"]
        source_shot_list_id = original["shot_list_id"]

        # Determine destination
        dest_shot_list_id = input_data.destination_shot_list_id or source_shot_list_id

        # Verify edit access
        has_access = await verify_shot_list_edit_access(client, project_id, user["id"])
        if not has_access:
            raise HTTPException(status_code=403, detail="You don't have permission to clone shots")

        # If different shot list, verify it belongs to same project
        if dest_shot_list_id != source_shot_list_id:
            dest_list = client.table("backlot_shot_lists").select("project_id").eq("id", dest_shot_list_id).single().execute()
            if not dest_list.data:
                raise HTTPException(status_code=404, detail="Destination shot list not found")
            if dest_list.data["project_id"] != project_id:
                raise HTTPException(status_code=400, detail="Cannot clone to shot list in different project")

        # Get existing shots in destination to generate new shot number
        existing = client.table("backlot_shots").select("shot_number, sort_order").eq("shot_list_id", dest_shot_list_id).execute()
        existing_data = existing.data or []

        # Generate new shot number
        new_shot_number = generate_next_shot_number(original["shot_number"], existing_data)

        # Get max sort order
        max_sort = max([s.get("sort_order", 0) for s in existing_data], default=0)

        # Get profile ID for created_by
        profile_id = get_profile_id_from_cognito_id(user["id"])

        # Create clone
        clone_data = {
            "project_id": project_id,
            "shot_list_id": dest_shot_list_id,
            "shot_number": new_shot_number,
            "scene_number": original.get("scene_number"),
            "scene_id": original.get("scene_id"),
            "camera_label": original.get("camera_label"),
            "frame_size": original.get("frame_size"),
            "lens": original.get("lens"),
            "focal_length_mm": original.get("focal_length_mm"),
            "camera_height": original.get("camera_height"),
            "movement": original.get("movement"),
            "location_hint": original.get("location_hint"),
            "time_of_day": original.get("time_of_day"),
            "description": original.get("description"),
            "technical_notes": original.get("technical_notes"),
            "performance_notes": original.get("performance_notes"),
            "est_time_minutes": original.get("est_time_minutes"),
            "is_completed": False,
            "sort_order": max_sort + 1,
            "created_by_user_id": profile_id,
        }

        result = client.table("backlot_shots").insert(clone_data).execute()
        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to clone shot")

        return {"success": True, "shot": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error cloning shot: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/shot-lists/{shot_list_id}/shots/reorder")
async def reorder_shots(
    shot_list_id: str,
    request: ShotReorderRequest,
    authorization: str = Header(None)
):
    """
    Reorder shots within a shot list.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get shot list to verify access
        shot_list_result = client.table("backlot_shot_lists").select("project_id").eq("id", shot_list_id).single().execute()

        if not shot_list_result.data:
            raise HTTPException(status_code=404, detail="Shot list not found")

        project_id = shot_list_result.data["project_id"]

        # Verify edit access
        has_access = await verify_shot_list_edit_access(client, project_id, user["id"])
        if not has_access:
            raise HTTPException(status_code=403, detail="You don't have permission to reorder shots")

        # Verify all shots belong to this shot list
        shot_ids = [s.id for s in request.shots]
        verify_result = client.table("backlot_shots").select("id").eq("shot_list_id", shot_list_id).in_("id", shot_ids).execute()

        if len(verify_result.data or []) != len(shot_ids):
            raise HTTPException(status_code=400, detail="Some shots don't belong to this shot list")

        # Update sort orders
        for shot_item in request.shots:
            client.table("backlot_shots").update({"sort_order": shot_item.sort_order}).eq("id", shot_item.id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error reordering shots: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/shot-lists/{shot_list_id}/shots/bulk")
async def bulk_create_shots(
    shot_list_id: str,
    shots: List[ShotCreate],
    authorization: str = Header(None)
):
    """
    Bulk create multiple shots in a shot list.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get shot list to verify access and get project_id
        shot_list_result = client.table("backlot_shot_lists").select("project_id").eq("id", shot_list_id).single().execute()

        if not shot_list_result.data:
            raise HTTPException(status_code=404, detail="Shot list not found")

        project_id = shot_list_result.data["project_id"]

        # Verify edit access
        has_access = await verify_shot_list_edit_access(client, project_id, user["id"])
        if not has_access:
            raise HTTPException(status_code=403, detail="You don't have permission to add shots")

        # Get starting sort order
        max_order_result = client.table("backlot_shots").select("sort_order").eq("shot_list_id", shot_list_id).order("sort_order", desc=True).limit(1).execute()
        next_sort_order = (max_order_result.data[0]["sort_order"] + 1) if max_order_result.data else 0

        # Get max shot number
        max_num_result = client.table("backlot_shots").select("shot_number").eq("shot_list_id", shot_list_id).execute()
        max_num = 0
        if max_num_result.data:
            for s in max_num_result.data:
                try:
                    num_part = ''.join(c for c in s["shot_number"] if c.isdigit())
                    if num_part:
                        max_num = max(max_num, int(num_part))
                except:
                    pass

        # Create shots
        created_shots = []
        for i, shot_req in enumerate(shots):
            shot_number = shot_req.shot_number or str(max_num + i + 1)

            shot_data = {
                "project_id": project_id,
                "shot_list_id": shot_list_id,
                "sort_order": next_sort_order + i,
                "shot_number": shot_number,
                "scene_number": shot_req.scene_number,
                "scene_id": shot_req.scene_id,
                "camera_label": shot_req.camera_label,
                "frame_size": shot_req.frame_size,
                "lens": shot_req.lens,
                "focal_length_mm": shot_req.focal_length_mm,
                "camera_height": shot_req.camera_height,
                "movement": shot_req.movement,
                "location_hint": shot_req.location_hint,
                "time_of_day": shot_req.time_of_day,
                "description": shot_req.description,
                "technical_notes": shot_req.technical_notes,
                "performance_notes": shot_req.performance_notes,
                "est_time_minutes": shot_req.est_time_minutes,
                "created_by_user_id": user["id"],
            }

            result = client.table("backlot_shots").insert(shot_data).execute()
            if result.data:
                created_shots.append(result.data[0])

        return {"success": True, "shots": created_shots, "count": len(created_shots)}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error bulk creating shots: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# TASK SYSTEM - Pydantic Models
# =====================================================

class TaskListCreate(BaseModel):
    name: str
    description: Optional[str] = None
    icon: Optional[str] = None
    default_view_type: Optional[str] = "board"
    sharing_mode: Optional[str] = "project_wide"


class TaskListUpdate(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    icon: Optional[str] = None
    default_view_type: Optional[str] = None
    sharing_mode: Optional[str] = None
    is_archived: Optional[bool] = None


class TaskListMemberCreate(BaseModel):
    user_id: str
    can_edit: Optional[bool] = True


class TaskCreate(BaseModel):
    title: str
    description: Optional[str] = None
    status: Optional[str] = "todo"
    priority: Optional[str] = None
    section: Optional[str] = None
    due_date: Optional[str] = None
    start_date: Optional[str] = None
    department: Optional[str] = None
    source_type: Optional[str] = None
    source_id: Optional[str] = None
    estimate_hours: Optional[float] = None
    assignee_ids: Optional[List[str]] = None
    label_ids: Optional[List[str]] = None
    # Extended source tracking
    source_camera_media_id: Optional[str] = None
    source_continuity_note_id: Optional[str] = None
    source_location_id: Optional[str] = None
    source_hot_set_session_id: Optional[str] = None
    source_gear_id: Optional[str] = None
    source_costume_id: Optional[str] = None
    scene_id: Optional[str] = None
    production_day_id: Optional[str] = None


class TaskUpdate(BaseModel):
    title: Optional[str] = None
    description: Optional[str] = None
    status: Optional[str] = None
    priority: Optional[str] = None
    section: Optional[str] = None
    due_date: Optional[str] = None
    start_date: Optional[str] = None
    department: Optional[str] = None
    source_type: Optional[str] = None
    source_id: Optional[str] = None
    estimate_hours: Optional[float] = None
    actual_hours: Optional[float] = None
    is_completed: Optional[bool] = None
    sort_index: Optional[float] = None
    # Extended source tracking
    source_camera_media_id: Optional[str] = None
    source_continuity_note_id: Optional[str] = None
    source_location_id: Optional[str] = None
    source_hot_set_session_id: Optional[str] = None
    source_gear_id: Optional[str] = None
    source_costume_id: Optional[str] = None
    scene_id: Optional[str] = None
    production_day_id: Optional[str] = None


class TaskLabelCreate(BaseModel):
    name: str
    color: Optional[str] = None


class TaskCommentCreate(BaseModel):
    content: str


class TaskCommentUpdate(BaseModel):
    content: str


class TaskViewCreate(BaseModel):
    name: str
    view_type: str = "board"
    config: Optional[Dict[str, Any]] = None
    is_default: Optional[bool] = False


class TaskViewUpdate(BaseModel):
    name: Optional[str] = None
    view_type: Optional[str] = None
    config: Optional[Dict[str, Any]] = None
    is_default: Optional[bool] = None


# =====================================================
# TASK SYSTEM - Helper Functions
# =====================================================

async def verify_task_list_access(client, task_list_id: str, user_id: str, require_edit: bool = False) -> Dict[str, Any]:
    """Verify user has access to a task list and return task list data"""
    # Get task list
    result = client.table("backlot_task_lists").select("*").eq("id", task_list_id).single().execute()

    if not result.data:
        raise HTTPException(status_code=404, detail="Task list not found")

    task_list = result.data
    project_id = task_list["project_id"]

    # Check if project admin
    member_result = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).single().execute()

    if member_result.data and member_result.data["role"] == "admin":
        return task_list

    # Check sharing mode
    if task_list["sharing_mode"] == "project_wide":
        # Any project member can view
        if not member_result.data:
            raise HTTPException(status_code=403, detail="You don't have access to this project")
        if require_edit and member_result.data["role"] not in ["admin", "editor"]:
            raise HTTPException(status_code=403, detail="You don't have permission to edit this task list")
        return task_list
    else:
        # Selected sharing mode - check task list members
        list_member_result = client.table("backlot_task_list_members").select("can_edit").eq("task_list_id", task_list_id).eq("user_id", user_id).single().execute()

        if not list_member_result.data:
            raise HTTPException(status_code=403, detail="You don't have access to this task list")

        if require_edit and not list_member_result.data["can_edit"]:
            raise HTTPException(status_code=403, detail="You don't have permission to edit this task list")

        return task_list


async def can_manage_task_list(client, task_list_id: str, user_id: str) -> bool:
    """Check if user can manage task list (owner, project admin)"""
    result = client.table("backlot_task_lists").select("project_id, created_by_user_id").eq("id", task_list_id).single().execute()

    if not result.data:
        return False

    # Creator can always manage
    if result.data["created_by_user_id"] == user_id:
        return True

    # Check if project admin
    member_result = client.table("backlot_project_members").select("role").eq("project_id", result.data["project_id"]).eq("user_id", user_id).single().execute()

    return member_result.data and member_result.data["role"] == "admin"


# =====================================================
# TASK LIST ENDPOINTS
# =====================================================

@router.get("/projects/{project_id}/task-lists")
async def get_project_task_lists(
    project_id: str,
    include_archived: bool = False,
    authorization: str = Header(None)
):
    """Get all task lists for a project that the user can access"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify project access
        await verify_project_access(client, project_id, user["id"])

        # Check if user is project admin
        member_result = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user["id"]).single().execute()
        is_admin = member_result.data and member_result.data["role"] == "admin"

        # Build query
        query = client.table("backlot_task_lists").select("*").eq("project_id", project_id)

        if not include_archived:
            query = query.eq("is_archived", False)

        result = query.order("created_at", desc=False).execute()
        task_lists = result.data or []

        # Filter by sharing if not admin
        if not is_admin:
            # Get list memberships for user
            memberships_result = client.table("backlot_task_list_members").select("task_list_id").eq("user_id", user["id"]).execute()
            user_list_ids = set(m["task_list_id"] for m in (memberships_result.data or []))

            task_lists = [
                tl for tl in task_lists
                if tl["sharing_mode"] == "project_wide" or tl["id"] in user_list_ids
            ]

        # Get task counts for each list
        for task_list in task_lists:
            # Get status counts
            count_result = client.table("backlot_tasks").select("status").eq("task_list_id", task_list["id"]).execute()
            tasks = count_result.data or []

            status_counts = {}
            for task in tasks:
                status = task.get("status", "todo")
                status_counts[status] = status_counts.get(status, 0) + 1

            task_list["task_count"] = len(tasks)
            task_list["status_counts"] = status_counts

        return {"success": True, "task_lists": task_lists}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting task lists: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/task-lists")
async def create_task_list(
    project_id: str,
    request: TaskListCreate,
    authorization: str = Header(None)
):
    """Create a new task list for a project"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify edit access to project
        await verify_project_access(client, project_id, user["id"], require_edit=True)

        # Create task list
        task_list_data = {
            "project_id": project_id,
            "name": request.name,
            "description": request.description,
            "icon": request.icon,
            "default_view_type": request.default_view_type or "board",
            "sharing_mode": request.sharing_mode or "project_wide",
            "created_by_user_id": user["id"],
        }

        result = client.table("backlot_task_lists").insert(task_list_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create task list")

        task_list = result.data[0]

        # Create default views
        default_views = [
            {
                "task_list_id": task_list["id"],
                "name": "Board",
                "view_type": "board",
                "is_default": True,
                "config": {"group_by": "status", "sort_by": [{"field": "sort_index", "direction": "asc"}]},
                "created_by_user_id": user["id"],
            },
            {
                "task_list_id": task_list["id"],
                "name": "List",
                "view_type": "list",
                "is_default": False,
                "config": {"sort_by": [{"field": "sort_index", "direction": "asc"}]},
                "created_by_user_id": user["id"],
            },
            {
                "task_list_id": task_list["id"],
                "name": "Calendar",
                "view_type": "calendar",
                "is_default": False,
                "config": {"calendar_field": "due_date"},
                "created_by_user_id": user["id"],
            },
        ]

        client.table("backlot_task_views").insert(default_views).execute()

        # If selective sharing mode, add creator as member
        if request.sharing_mode == "selective":
            client.table("backlot_task_list_members").insert({
                "task_list_id": task_list["id"],
                "user_id": user["id"],
                "can_edit": True,
            }).execute()

        return {"success": True, "task_list": task_list}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating task list: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/task-lists/{task_list_id}")
async def get_task_list(
    task_list_id: str,
    authorization: str = Header(None)
):
    """Get a task list with its views, sharing info, and tasks"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        task_list = await verify_task_list_access(client, task_list_id, user["id"])

        # Get views
        views_result = client.table("backlot_task_views").select("*").eq("task_list_id", task_list_id).order("created_at").execute()
        task_list["views"] = views_result.data or []

        # Get members if selective sharing mode
        if task_list["sharing_mode"] == "selective":
            members_result = client.table("backlot_task_list_members").select("*").eq("task_list_id", task_list_id).execute()
            task_list["members"] = members_result.data or []
        else:
            task_list["members"] = []

        # Get all tasks for this task list
        tasks_result = client.table("backlot_tasks").select("*").eq("task_list_id", task_list_id).order("sort_index").order("created_at").execute()
        tasks = tasks_result.data or []

        # Get assignees and labels for all tasks
        if tasks:
            task_ids = [t["id"] for t in tasks]

            # Get assignees
            assignees_result = client.table("backlot_task_assignees").select("*").in_("task_id", task_ids).execute()
            assignees_by_task = {}
            for a in (assignees_result.data or []):
                task_id = a["task_id"]
                if task_id not in assignees_by_task:
                    assignees_by_task[task_id] = []
                assignees_by_task[task_id].append(a)

            # Get labels - fetch links and labels separately
            links_result = client.table("backlot_task_label_links").select("*").in_("task_id", task_ids).execute()
            label_ids = list(set(l["label_id"] for l in (links_result.data or []) if l.get("label_id")))
            labels_map = {}
            if label_ids:
                labels_resp = client.table("backlot_task_labels").select("*").in_("id", label_ids).execute()
                labels_map = {lb["id"]: lb for lb in (labels_resp.data or [])}
            labels_by_task = {}
            for l in (links_result.data or []):
                task_id = l["task_id"]
                if task_id not in labels_by_task:
                    labels_by_task[task_id] = []
                label = labels_map.get(l.get("label_id"))
                if label:
                    labels_by_task[task_id].append(label)

            # Add assignees and labels to tasks
            for task in tasks:
                task["assignees"] = assignees_by_task.get(task["id"], [])
                task["labels"] = labels_by_task.get(task["id"], [])

        task_list["tasks"] = tasks

        # Calculate status counts
        status_counts = {}
        for task in tasks:
            status = task.get("status", "todo")
            status_counts[status] = status_counts.get(status, 0) + 1

        task_list["task_count"] = len(tasks)
        task_list["status_counts"] = status_counts

        return {"success": True, "task_list": task_list}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting task list: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/task-lists/{task_list_id}")
async def update_task_list(
    task_list_id: str,
    request: TaskListUpdate,
    authorization: str = Header(None)
):
    """Update a task list"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        task_list = await verify_task_list_access(client, task_list_id, user["id"], require_edit=True)

        # Build update data
        update_data = {}
        if request.name is not None:
            update_data["name"] = request.name
        if request.description is not None:
            update_data["description"] = request.description
        if request.icon is not None:
            update_data["icon"] = request.icon
        if request.default_view_type is not None:
            update_data["default_view_type"] = request.default_view_type
        if request.sharing_mode is not None:
            update_data["sharing_mode"] = request.sharing_mode
        if request.is_archived is not None:
            update_data["is_archived"] = request.is_archived

        if update_data:
            result = client.table("backlot_task_lists").update(update_data).eq("id", task_list_id).execute()

            # If switching to selective mode, ensure creator is a member
            if request.sharing_mode == "selective":
                existing_member = client.table("backlot_task_list_members").select("id").eq("task_list_id", task_list_id).eq("user_id", task_list["created_by_user_id"]).single().execute()

                if not existing_member.data:
                    client.table("backlot_task_list_members").insert({
                        "task_list_id": task_list_id,
                        "user_id": task_list["created_by_user_id"],
                        "can_edit": True,
                    }).execute()

            return {"success": True, "task_list": result.data[0] if result.data else None}

        return {"success": True, "task_list": task_list}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating task list: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/task-lists/{task_list_id}")
async def delete_task_list(
    task_list_id: str,
    hard_delete: bool = False,
    authorization: str = Header(None)
):
    """Delete (archive) a task list"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        can_manage = await can_manage_task_list(client, task_list_id, user["id"])
        if not can_manage:
            raise HTTPException(status_code=403, detail="You don't have permission to delete this task list")

        if hard_delete:
            client.table("backlot_task_lists").delete().eq("id", task_list_id).execute()
        else:
            client.table("backlot_task_lists").update({"is_archived": True}).eq("id", task_list_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting task list: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# TASK LIST MEMBERS ENDPOINTS
# =====================================================

@router.get("/task-lists/{task_list_id}/members")
async def get_task_list_members(
    task_list_id: str,
    authorization: str = Header(None)
):
    """Get members of a task list"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        task_list = await verify_task_list_access(client, task_list_id, user["id"])

        result = client.table("backlot_task_list_members").select("*").eq("task_list_id", task_list_id).execute()

        return {"success": True, "members": result.data or []}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting task list members: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/task-lists/{task_list_id}/members")
async def add_task_list_member(
    task_list_id: str,
    request: TaskListMemberCreate,
    authorization: str = Header(None)
):
    """Add a member to a task list"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        can_manage = await can_manage_task_list(client, task_list_id, user["id"])
        if not can_manage:
            raise HTTPException(status_code=403, detail="You don't have permission to manage this task list")

        # Check if already a member
        existing = client.table("backlot_task_list_members").select("id").eq("task_list_id", task_list_id).eq("user_id", request.user_id).single().execute()

        if existing.data:
            # Update existing
            result = client.table("backlot_task_list_members").update({"can_edit": request.can_edit}).eq("id", existing.data["id"]).execute()
        else:
            # Create new
            result = client.table("backlot_task_list_members").insert({
                "task_list_id": task_list_id,
                "user_id": request.user_id,
                "can_edit": request.can_edit if request.can_edit is not None else True,
            }).execute()

        return {"success": True, "member": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error adding task list member: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/task-list-members/{member_id}")
async def remove_task_list_member(
    member_id: str,
    authorization: str = Header(None)
):
    """Remove a member from a task list"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get member to find task list
        member_result = client.table("backlot_task_list_members").select("task_list_id").eq("id", member_id).single().execute()

        if not member_result.data:
            raise HTTPException(status_code=404, detail="Member not found")

        task_list_id = member_result.data["task_list_id"]

        can_manage = await can_manage_task_list(client, task_list_id, user["id"])
        if not can_manage:
            raise HTTPException(status_code=403, detail="You don't have permission to manage this task list")

        client.table("backlot_task_list_members").delete().eq("id", member_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error removing task list member: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# TASK ENDPOINTS
# =====================================================

@router.get("/task-lists/{task_list_id}/tasks")
async def get_task_list_tasks(
    task_list_id: str,
    view_id: Optional[str] = None,
    status: Optional[str] = None,
    section: Optional[str] = None,
    department: Optional[str] = None,
    assignee_id: Optional[str] = None,
    authorization: str = Header(None)
):
    """Get tasks in a task list, optionally filtered by view"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        task_list = await verify_task_list_access(client, task_list_id, user["id"])

        # Build query
        query = client.table("backlot_tasks").select("*").eq("task_list_id", task_list_id)

        # Apply view filters if provided
        if view_id:
            view_result = client.table("backlot_task_views").select("config").eq("id", view_id).single().execute()
            if view_result.data and view_result.data.get("config"):
                config = view_result.data["config"]

                # Apply filters from view config
                filters = config.get("filters", [])
                for f in filters:
                    field = f.get("field")
                    op = f.get("op")
                    value = f.get("value")

                    if field and op and value is not None:
                        if op == "eq":
                            query = query.eq(field, value)
                        elif op == "in" and isinstance(value, list):
                            query = query.in_(field, value)
                        elif op == "neq":
                            query = query.neq(field, value)

        # Apply direct filters
        if status:
            query = query.eq("status", status)
        if section:
            query = query.eq("section", section)
        if department:
            query = query.eq("department", department)

        query = query.order("sort_index").order("created_at")
        result = query.execute()
        tasks = result.data or []

        # Get assignees for all tasks
        if tasks:
            task_ids = [t["id"] for t in tasks]
            assignees_result = client.table("backlot_task_assignees").select("*").in_("task_id", task_ids).execute()

            # Group assignees by task
            assignees_by_task = {}
            for a in (assignees_result.data or []):
                task_id = a["task_id"]
                if task_id not in assignees_by_task:
                    assignees_by_task[task_id] = []
                assignees_by_task[task_id].append(a)

            # Get labels - fetch links and labels separately
            links_result = client.table("backlot_task_label_links").select("*").in_("task_id", task_ids).execute()
            label_ids = list(set(l["label_id"] for l in (links_result.data or []) if l.get("label_id")))
            labels_map = {}
            if label_ids:
                labels_resp = client.table("backlot_task_labels").select("*").in_("id", label_ids).execute()
                labels_map = {lb["id"]: lb for lb in (labels_resp.data or [])}

            # Group labels by task
            labels_by_task = {}
            for l in (links_result.data or []):
                task_id = l["task_id"]
                if task_id not in labels_by_task:
                    labels_by_task[task_id] = []
                label = labels_map.get(l.get("label_id"))
                if label:
                    labels_by_task[task_id].append(label)

            # Add to tasks
            for task in tasks:
                task["assignees"] = assignees_by_task.get(task["id"], [])
                task["labels"] = labels_by_task.get(task["id"], [])

        # Filter by assignee if provided
        if assignee_id:
            tasks = [t for t in tasks if any(a["user_id"] == assignee_id for a in t.get("assignees", []))]

        return {"success": True, "tasks": tasks}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting tasks: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/task-lists/{task_list_id}/tasks")
async def create_task(
    task_list_id: str,
    request: TaskCreate,
    authorization: str = Header(None)
):
    """Create a new task in a task list"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        task_list = await verify_task_list_access(client, task_list_id, user["id"], require_edit=True)

        # Get next sort index
        max_sort_result = client.table("backlot_tasks").select("sort_index").eq("task_list_id", task_list_id).order("sort_index", desc=True).limit(1).execute()
        next_sort_index = (max_sort_result.data[0]["sort_index"] + 1) if max_sort_result.data else 0

        # Create task
        task_data = {
            "project_id": task_list["project_id"],
            "task_list_id": task_list_id,
            "title": request.title,
            "description": request.description,
            "status": request.status or "todo",
            "priority": request.priority,
            "section": request.section,
            "due_date": request.due_date,
            "start_date": request.start_date,
            "department": request.department,
            "source_type": request.source_type,
            "source_id": request.source_id,
            "estimate_hours": request.estimate_hours,
            "sort_index": next_sort_index,
            "created_by_user_id": user["id"],
            "is_completed": request.status == "done",
            # Extended source tracking
            "source_camera_media_id": request.source_camera_media_id,
            "source_continuity_note_id": request.source_continuity_note_id,
            "source_location_id": request.source_location_id,
            "source_hot_set_session_id": request.source_hot_set_session_id,
            "source_gear_id": request.source_gear_id,
            "source_costume_id": request.source_costume_id,
            "scene_id": request.scene_id,
            "production_day_id": request.production_day_id,
        }

        result = client.table("backlot_tasks").insert(task_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create task")

        task = result.data[0]

        # Add assignees if provided
        if request.assignee_ids:
            assignee_data = [{"task_id": task["id"], "user_id": uid} for uid in request.assignee_ids]
            client.table("backlot_task_assignees").insert(assignee_data).execute()

        # Add labels if provided
        if request.label_ids:
            label_data = [{"task_id": task["id"], "label_id": lid} for lid in request.label_ids]
            client.table("backlot_task_label_links").insert(label_data).execute()

        # Fetch complete task with relations
        task["assignees"] = []
        task["labels"] = []

        if request.assignee_ids:
            assignees_result = client.table("backlot_task_assignees").select("*").eq("task_id", task["id"]).execute()
            task["assignees"] = assignees_result.data or []

        if request.label_ids:
            links_result = client.table("backlot_task_label_links").select("*").eq("task_id", task["id"]).execute()
            label_ids = [l["label_id"] for l in (links_result.data or []) if l.get("label_id")]
            if label_ids:
                labels_resp = client.table("backlot_task_labels").select("*").in_("id", label_ids).execute()
                task["labels"] = labels_resp.data or []
            else:
                task["labels"] = []

        return {"success": True, "task": task}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating task: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/tasks/{task_id}")
async def get_task(
    task_id: str,
    authorization: str = Header(None)
):
    """Get a single task with all details"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get task
        task_result = client.table("backlot_tasks").select("*").eq("id", task_id).single().execute()

        if not task_result.data:
            raise HTTPException(status_code=404, detail="Task not found")

        task = task_result.data

        # Verify access to task list
        await verify_task_list_access(client, task["task_list_id"], user["id"])

        # Get assignees with profile data
        assignees_result = client.table("backlot_task_assignees").select("*").eq("task_id", task_id).execute()
        assignees = assignees_result.data or []

        # Fetch profiles for assignees
        if assignees:
            assignee_user_ids = [a["user_id"] for a in assignees if a.get("user_id")]
            if assignee_user_ids:
                profiles_resp = client.table("profiles").select(
                    "id, full_name, display_name, avatar_url, username"
                ).in_("id", assignee_user_ids).execute()
                profiles_by_id = {p["id"]: p for p in (profiles_resp.data or [])}

                for assignee in assignees:
                    profile = profiles_by_id.get(assignee.get("user_id"))
                    if profile:
                        assignee["profile"] = {
                            "id": profile["id"],
                            "display_name": profile.get("display_name") or profile.get("full_name"),
                            "full_name": profile.get("full_name"),
                            "avatar_url": profile.get("avatar_url"),
                            "username": profile.get("username"),
                        }

        task["assignees"] = assignees

        # Get watchers
        watchers_result = client.table("backlot_task_watchers").select("*").eq("task_id", task_id).execute()
        task["watchers"] = watchers_result.data or []

        # Get labels
        links_result = client.table("backlot_task_label_links").select("*").eq("task_id", task_id).execute()
        label_ids = [l["label_id"] for l in (links_result.data or []) if l.get("label_id")]
        if label_ids:
            labels_resp = client.table("backlot_task_labels").select("*").in_("id", label_ids).execute()
            task["labels"] = labels_resp.data or []
        else:
            task["labels"] = []

        # Get comment count
        comments_result = client.table("backlot_task_comments").select("id", count="exact").eq("task_id", task_id).execute()
        task["comment_count"] = comments_result.count or 0

        return {"success": True, "task": task}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting task: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/tasks/{task_id}")
async def update_task(
    task_id: str,
    request: TaskUpdate,
    authorization: str = Header(None)
):
    """Update a task"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get task
        task_result = client.table("backlot_tasks").select("task_list_id").eq("id", task_id).single().execute()

        if not task_result.data:
            raise HTTPException(status_code=404, detail="Task not found")

        # Verify edit access
        await verify_task_list_access(client, task_result.data["task_list_id"], user["id"], require_edit=True)

        # Build update data
        update_data = {}

        if request.title is not None:
            update_data["title"] = request.title
        if request.description is not None:
            update_data["description"] = request.description
        if request.status is not None:
            update_data["status"] = request.status
            update_data["is_completed"] = request.status == "done"
        if request.priority is not None:
            update_data["priority"] = request.priority
        if request.section is not None:
            update_data["section"] = request.section
        if request.due_date is not None:
            update_data["due_date"] = request.due_date if request.due_date else None
        if request.start_date is not None:
            update_data["start_date"] = request.start_date if request.start_date else None
        if request.department is not None:
            update_data["department"] = request.department
        if request.source_type is not None:
            update_data["source_type"] = request.source_type
        if request.source_id is not None:
            update_data["source_id"] = request.source_id
        if request.estimate_hours is not None:
            update_data["estimate_hours"] = request.estimate_hours
        if request.actual_hours is not None:
            update_data["actual_hours"] = request.actual_hours
        if request.is_completed is not None:
            update_data["is_completed"] = request.is_completed
            if request.is_completed:
                update_data["status"] = "done"
        if request.sort_index is not None:
            update_data["sort_index"] = request.sort_index
        # Extended source tracking
        if request.source_camera_media_id is not None:
            update_data["source_camera_media_id"] = request.source_camera_media_id if request.source_camera_media_id else None
        if request.source_continuity_note_id is not None:
            update_data["source_continuity_note_id"] = request.source_continuity_note_id if request.source_continuity_note_id else None
        if request.source_location_id is not None:
            update_data["source_location_id"] = request.source_location_id if request.source_location_id else None
        if request.source_hot_set_session_id is not None:
            update_data["source_hot_set_session_id"] = request.source_hot_set_session_id if request.source_hot_set_session_id else None
        if request.source_gear_id is not None:
            update_data["source_gear_id"] = request.source_gear_id if request.source_gear_id else None
        if request.source_costume_id is not None:
            update_data["source_costume_id"] = request.source_costume_id if request.source_costume_id else None
        if request.scene_id is not None:
            update_data["scene_id"] = request.scene_id if request.scene_id else None
        if request.production_day_id is not None:
            update_data["production_day_id"] = request.production_day_id if request.production_day_id else None

        result = client.table("backlot_tasks").update(update_data).eq("id", task_id).execute()

        return {"success": True, "task": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating task: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/tasks/{task_id}")
async def delete_task(
    task_id: str,
    authorization: str = Header(None)
):
    """Delete a task"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get task
        task_result = client.table("backlot_tasks").select("task_list_id, created_by_user_id").eq("id", task_id).single().execute()

        if not task_result.data:
            raise HTTPException(status_code=404, detail="Task not found")

        task = task_result.data

        # Check if creator or can manage list
        if task["created_by_user_id"] != user["id"]:
            can_manage = await can_manage_task_list(client, task["task_list_id"], user["id"])
            if not can_manage:
                # Also check if user has edit access
                await verify_task_list_access(client, task["task_list_id"], user["id"], require_edit=True)

        client.table("backlot_tasks").delete().eq("id", task_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting task: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# TASK ASSIGNEES & WATCHERS ENDPOINTS
# =====================================================

@router.post("/tasks/{task_id}/assignees")
async def add_task_assignee(
    task_id: str,
    user_id: str = Body(..., embed=True),
    authorization: str = Header(None)
):
    """Add an assignee to a task"""
    current_user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get task
        task_result = client.table("backlot_tasks").select("task_list_id").eq("id", task_id).single().execute()

        if not task_result.data:
            raise HTTPException(status_code=404, detail="Task not found")

        # Verify edit access
        await verify_task_list_access(client, task_result.data["task_list_id"], current_user["id"], require_edit=True)

        # Check if already assigned
        existing = client.table("backlot_task_assignees").select("*").eq("task_id", task_id).eq("user_id", user_id).single().execute()

        if existing.data:
            # Fetch profile for the existing assignee
            profile_resp = client.table("profiles").select(
                "id, full_name, display_name, avatar_url, username"
            ).eq("id", user_id).single().execute()
            assignee = existing.data
            if profile_resp.data:
                profile = profile_resp.data
                assignee["profile"] = {
                    "id": profile["id"],
                    "display_name": profile.get("display_name") or profile.get("full_name"),
                    "full_name": profile.get("full_name"),
                    "avatar_url": profile.get("avatar_url"),
                    "username": profile.get("username"),
                }
            return {"success": True, "assignee": assignee}

        result = client.table("backlot_task_assignees").insert({
            "task_id": task_id,
            "user_id": user_id,
        }).execute()

        assignee = result.data[0] if result.data else None
        if assignee:
            # Fetch profile for the new assignee
            profile_resp = client.table("profiles").select(
                "id, full_name, display_name, avatar_url, username"
            ).eq("id", user_id).single().execute()
            if profile_resp.data:
                profile = profile_resp.data
                assignee["profile"] = {
                    "id": profile["id"],
                    "display_name": profile.get("display_name") or profile.get("full_name"),
                    "full_name": profile.get("full_name"),
                    "avatar_url": profile.get("avatar_url"),
                    "username": profile.get("username"),
                }

        return {"success": True, "assignee": assignee}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error adding assignee: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/tasks/{task_id}/assignees/{assignee_id}")
async def remove_task_assignee(
    task_id: str,
    assignee_id: str,
    authorization: str = Header(None)
):
    """Remove an assignee from a task"""
    current_user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get task
        task_result = client.table("backlot_tasks").select("task_list_id").eq("id", task_id).single().execute()

        if not task_result.data:
            raise HTTPException(status_code=404, detail="Task not found")

        # Verify edit access
        await verify_task_list_access(client, task_result.data["task_list_id"], current_user["id"], require_edit=True)

        client.table("backlot_task_assignees").delete().eq("id", assignee_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error removing assignee: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/tasks/{task_id}/watchers")
async def add_task_watcher(
    task_id: str,
    user_id: str = Body(..., embed=True),
    authorization: str = Header(None)
):
    """Add a watcher to a task"""
    current_user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get task
        task_result = client.table("backlot_tasks").select("task_list_id").eq("id", task_id).single().execute()

        if not task_result.data:
            raise HTTPException(status_code=404, detail="Task not found")

        # Verify view access (anyone who can view can watch)
        await verify_task_list_access(client, task_result.data["task_list_id"], current_user["id"])

        # Check if already watching
        existing = client.table("backlot_task_watchers").select("id").eq("task_id", task_id).eq("user_id", user_id).single().execute()

        if existing.data:
            return {"success": True, "watcher": existing.data}

        result = client.table("backlot_task_watchers").insert({
            "task_id": task_id,
            "user_id": user_id,
        }).execute()

        return {"success": True, "watcher": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error adding watcher: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/tasks/{task_id}/watchers/{watcher_id}")
async def remove_task_watcher(
    task_id: str,
    watcher_id: str,
    authorization: str = Header(None)
):
    """Remove a watcher from a task"""
    current_user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get watcher to check ownership
        watcher_result = client.table("backlot_task_watchers").select("user_id, task_id").eq("id", watcher_id).single().execute()

        if not watcher_result.data:
            raise HTTPException(status_code=404, detail="Watcher not found")

        # Get task
        task_result = client.table("backlot_tasks").select("task_list_id").eq("id", watcher_result.data["task_id"]).single().execute()

        if not task_result.data:
            raise HTTPException(status_code=404, detail="Task not found")

        # User can remove themselves or admins can remove anyone
        if watcher_result.data["user_id"] != current_user["id"]:
            can_manage = await can_manage_task_list(client, task_result.data["task_list_id"], current_user["id"])
            if not can_manage:
                raise HTTPException(status_code=403, detail="You can only remove yourself as a watcher")

        client.table("backlot_task_watchers").delete().eq("id", watcher_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error removing watcher: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# TASK LABELS ENDPOINTS
# =====================================================

@router.get("/projects/{project_id}/task-labels")
async def get_project_task_labels(
    project_id: str,
    authorization: str = Header(None)
):
    """Get all task labels for a project"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        result = client.table("backlot_task_labels").select("*").eq("project_id", project_id).order("name").execute()

        return {"success": True, "labels": result.data or []}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting task labels: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/task-labels")
async def create_task_label(
    project_id: str,
    request: TaskLabelCreate,
    authorization: str = Header(None)
):
    """Create a new task label for a project"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"], require_edit=True)

        result = client.table("backlot_task_labels").insert({
            "project_id": project_id,
            "name": request.name,
            "color": request.color,
        }).execute()

        return {"success": True, "label": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating task label: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/task-labels/{label_id}")
async def delete_task_label(
    label_id: str,
    authorization: str = Header(None)
):
    """Delete a task label"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get label to find project
        label_result = client.table("backlot_task_labels").select("project_id").eq("id", label_id).single().execute()

        if not label_result.data:
            raise HTTPException(status_code=404, detail="Label not found")

        # Verify edit access
        await verify_project_access(client, label_result.data["project_id"], user["id"], require_edit=True)

        client.table("backlot_task_labels").delete().eq("id", label_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting task label: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/tasks/{task_id}/labels")
async def add_task_label(
    task_id: str,
    label_id: str = Body(..., embed=True),
    authorization: str = Header(None)
):
    """Add a label to a task"""
    current_user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get task
        task_result = client.table("backlot_tasks").select("task_list_id").eq("id", task_id).single().execute()

        if not task_result.data:
            raise HTTPException(status_code=404, detail="Task not found")

        # Verify edit access
        await verify_task_list_access(client, task_result.data["task_list_id"], current_user["id"], require_edit=True)

        # Check if already linked
        existing = client.table("backlot_task_label_links").select("id").eq("task_id", task_id).eq("label_id", label_id).single().execute()

        if existing.data:
            return {"success": True, "label_link": existing.data}

        result = client.table("backlot_task_label_links").insert({
            "task_id": task_id,
            "label_id": label_id,
        }).execute()

        return {"success": True, "label_link": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error adding task label: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/tasks/{task_id}/labels/{label_link_id}")
async def remove_task_label(
    task_id: str,
    label_link_id: str,
    authorization: str = Header(None)
):
    """Remove a label from a task"""
    current_user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get task
        task_result = client.table("backlot_tasks").select("task_list_id").eq("id", task_id).single().execute()

        if not task_result.data:
            raise HTTPException(status_code=404, detail="Task not found")

        # Verify edit access
        await verify_task_list_access(client, task_result.data["task_list_id"], current_user["id"], require_edit=True)

        client.table("backlot_task_label_links").delete().eq("id", label_link_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error removing task label: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# TASK COMMENTS ENDPOINTS
# =====================================================

@router.get("/tasks/{task_id}/comments")
async def get_task_comments(
    task_id: str,
    authorization: str = Header(None)
):
    """Get comments for a task"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get task
        task_result = client.table("backlot_tasks").select("task_list_id").eq("id", task_id).single().execute()

        if not task_result.data:
            raise HTTPException(status_code=404, detail="Task not found")

        # Verify view access
        await verify_task_list_access(client, task_result.data["task_list_id"], user["id"])

        result = client.table("backlot_task_comments").select("*").eq("task_id", task_id).order("created_at").execute()
        comments = result.data or []

        # Fetch user profiles for all comment authors
        if comments:
            user_ids = list(set(c["user_id"] for c in comments if c.get("user_id")))
            profiles_by_id = {}
            if user_ids:
                profiles_result = client.table("profiles").select(
                    "id, display_name, full_name, avatar_url, username"
                ).in_("id", user_ids).execute()
                for p in (profiles_result.data or []):
                    profiles_by_id[str(p["id"])] = p

            # Attach user_profile to each comment
            for comment in comments:
                user_id = str(comment.get("user_id", ""))
                profile = profiles_by_id.get(user_id, {})
                comment["user_profile"] = {
                    "id": user_id,
                    "display_name": profile.get("display_name") or profile.get("full_name"),
                    "full_name": profile.get("full_name"),
                    "avatar_url": profile.get("avatar_url"),
                    "username": profile.get("username"),
                }

        return {"success": True, "comments": comments}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting task comments: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/tasks/{task_id}/comments")
async def create_task_comment(
    task_id: str,
    request: TaskCommentCreate,
    authorization: str = Header(None)
):
    """Add a comment to a task"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get task
        task_result = client.table("backlot_tasks").select("task_list_id").eq("id", task_id).single().execute()

        if not task_result.data:
            raise HTTPException(status_code=404, detail="Task not found")

        # Verify view access (anyone who can view can comment)
        await verify_task_list_access(client, task_result.data["task_list_id"], user["id"])

        result = client.table("backlot_task_comments").insert({
            "task_id": task_id,
            "user_id": user["id"],
            "content": request.content,
        }).execute()

        comment = result.data[0] if result.data else None

        # Fetch the user's profile to include with the response
        if comment:
            profile_result = client.table("profiles").select(
                "id, display_name, full_name, avatar_url, username"
            ).eq("id", user["id"]).single().execute()
            profile = profile_result.data or {}
            comment["user_profile"] = {
                "id": user["id"],
                "display_name": profile.get("display_name") or profile.get("full_name"),
                "full_name": profile.get("full_name"),
                "avatar_url": profile.get("avatar_url"),
                "username": profile.get("username"),
            }

        return {"success": True, "comment": comment}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating comment: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/task-comments/{comment_id}")
async def update_task_comment(
    comment_id: str,
    request: TaskCommentUpdate,
    authorization: str = Header(None)
):
    """Update a comment"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get comment
        comment_result = client.table("backlot_task_comments").select("user_id").eq("id", comment_id).single().execute()

        if not comment_result.data:
            raise HTTPException(status_code=404, detail="Comment not found")

        # Only author can edit
        if comment_result.data["user_id"] != user["id"]:
            raise HTTPException(status_code=403, detail="You can only edit your own comments")

        result = client.table("backlot_task_comments").update({
            "content": request.content,
        }).eq("id", comment_id).execute()

        return {"success": True, "comment": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating comment: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/task-comments/{comment_id}")
async def delete_task_comment(
    comment_id: str,
    authorization: str = Header(None)
):
    """Delete a comment"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get comment
        comment_result = client.table("backlot_task_comments").select("user_id, task_id").eq("id", comment_id).single().execute()

        if not comment_result.data:
            raise HTTPException(status_code=404, detail="Comment not found")

        comment = comment_result.data

        # Author can delete, or admins
        if comment["user_id"] != user["id"]:
            # Get task to check permissions
            task_result = client.table("backlot_tasks").select("task_list_id").eq("id", comment["task_id"]).single().execute()

            if task_result.data:
                can_manage = await can_manage_task_list(client, task_result.data["task_list_id"], user["id"])
                if not can_manage:
                    raise HTTPException(status_code=403, detail="You can only delete your own comments")

        client.table("backlot_task_comments").delete().eq("id", comment_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting comment: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# TASK VIEWS ENDPOINTS
# =====================================================

@router.get("/task-lists/{task_list_id}/views")
async def get_task_list_views(
    task_list_id: str,
    authorization: str = Header(None)
):
    """Get views for a task list"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_task_list_access(client, task_list_id, user["id"])

        result = client.table("backlot_task_views").select("*").eq("task_list_id", task_list_id).order("created_at").execute()

        return {"success": True, "views": result.data or []}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting task views: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/task-lists/{task_list_id}/views")
async def create_task_view(
    task_list_id: str,
    request: TaskViewCreate,
    authorization: str = Header(None)
):
    """Create a new view for a task list"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_task_list_access(client, task_list_id, user["id"], require_edit=True)

        # If setting as default, unset other defaults
        if request.is_default:
            client.table("backlot_task_views").update({"is_default": False}).eq("task_list_id", task_list_id).execute()

        result = client.table("backlot_task_views").insert({
            "task_list_id": task_list_id,
            "name": request.name,
            "view_type": request.view_type,
            "config": request.config or {},
            "is_default": request.is_default or False,
            "created_by_user_id": user["id"],
        }).execute()

        return {"success": True, "view": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating task view: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/task-views/{view_id}")
async def update_task_view(
    view_id: str,
    request: TaskViewUpdate,
    authorization: str = Header(None)
):
    """Update a task view"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get view
        view_result = client.table("backlot_task_views").select("task_list_id, created_by_user_id").eq("id", view_id).single().execute()

        if not view_result.data:
            raise HTTPException(status_code=404, detail="View not found")

        view = view_result.data

        # Check if creator or can manage list
        if view["created_by_user_id"] != user["id"]:
            can_manage = await can_manage_task_list(client, view["task_list_id"], user["id"])
            if not can_manage:
                raise HTTPException(status_code=403, detail="You don't have permission to edit this view")

        # Build update data
        update_data = {}
        if request.name is not None:
            update_data["name"] = request.name
        if request.view_type is not None:
            update_data["view_type"] = request.view_type
        if request.config is not None:
            update_data["config"] = request.config
        if request.is_default is not None:
            # If setting as default, unset other defaults
            if request.is_default:
                client.table("backlot_task_views").update({"is_default": False}).eq("task_list_id", view["task_list_id"]).execute()
            update_data["is_default"] = request.is_default

        if update_data:
            result = client.table("backlot_task_views").update(update_data).eq("id", view_id).execute()
            return {"success": True, "view": result.data[0] if result.data else None}

        return {"success": True, "view": view}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating task view: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/task-views/{view_id}")
async def delete_task_view(
    view_id: str,
    authorization: str = Header(None)
):
    """Delete a task view"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get view
        view_result = client.table("backlot_task_views").select("task_list_id, created_by_user_id").eq("id", view_id).single().execute()

        if not view_result.data:
            raise HTTPException(status_code=404, detail="View not found")

        view = view_result.data

        # Check if creator or can manage list
        if view["created_by_user_id"] != user["id"]:
            can_manage = await can_manage_task_list(client, view["task_list_id"], user["id"])
            if not can_manage:
                raise HTTPException(status_code=403, detail="You don't have permission to delete this view")

        client.table("backlot_task_views").delete().eq("id", view_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting task view: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# TASK AGGREGATION ENDPOINTS
# =====================================================

@router.get("/projects/{project_id}/tasks/by-scene/{scene_id}")
async def get_tasks_by_scene(
    project_id: str,
    scene_id: str,
    authorization: str = Header(None)
):
    """Get all tasks linked to a specific scene"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        # Get tasks where scene_id matches
        result = client.table("backlot_tasks").select("*").eq("project_id", project_id).eq("scene_id", scene_id).order("created_at", desc=True).execute()
        tasks = result.data or []

        # Get assignees for each task
        for task in tasks:
            assignees_result = client.table("backlot_task_assignees").select("*").eq("task_id", task["id"]).execute()
            task["assignees"] = assignees_result.data or []

        return {"success": True, "tasks": tasks}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting tasks by scene: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/tasks/by-day/{production_day_id}")
async def get_tasks_by_day(
    project_id: str,
    production_day_id: str,
    authorization: str = Header(None)
):
    """Get all tasks linked to a specific production day"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        # Get tasks where production_day_id matches or due_date falls on that day
        result = client.table("backlot_tasks").select("*").eq("project_id", project_id).eq("production_day_id", production_day_id).order("created_at", desc=True).execute()
        tasks = result.data or []

        # Get assignees for each task
        for task in tasks:
            assignees_result = client.table("backlot_task_assignees").select("*").eq("task_id", task["id"]).execute()
            task["assignees"] = assignees_result.data or []

        return {"success": True, "tasks": tasks}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting tasks by day: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/tasks/by-source/{source_type}/{source_id}")
async def get_tasks_by_source(
    project_id: str,
    source_type: str,
    source_id: str,
    authorization: str = Header(None)
):
    """Get all tasks linked to a specific source entity"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        # Build query based on source type
        query = client.table("backlot_tasks").select("*").eq("project_id", project_id)

        if source_type == "camera_media":
            query = query.eq("source_camera_media_id", source_id)
        elif source_type == "continuity":
            query = query.eq("source_continuity_note_id", source_id)
        elif source_type == "location":
            query = query.eq("source_location_id", source_id)
        elif source_type == "hot_set":
            query = query.eq("source_hot_set_session_id", source_id)
        elif source_type == "gear":
            query = query.eq("source_gear_id", source_id)
        elif source_type == "costume":
            query = query.eq("source_costume_id", source_id)
        else:
            # Fall back to generic source_type/source_id
            query = query.eq("source_type", source_type).eq("source_id", source_id)

        result = query.order("created_at", desc=True).execute()
        tasks = result.data or []

        # Get assignees for each task
        for task in tasks:
            assignees_result = client.table("backlot_task_assignees").select("*").eq("task_id", task["id"]).execute()
            task["assignees"] = assignees_result.data or []

        return {"success": True, "tasks": tasks}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting tasks by source: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# TASK REORDERING ENDPOINT
# =====================================================

class TaskReorderItem(BaseModel):
    id: str
    sort_index: float
    status: Optional[str] = None
    section: Optional[str] = None


class TaskReorderRequest(BaseModel):
    tasks: List[TaskReorderItem]


@router.post("/task-lists/{task_list_id}/tasks/reorder")
async def reorder_tasks(
    task_list_id: str,
    request: TaskReorderRequest,
    authorization: str = Header(None)
):
    """Reorder tasks (for drag-and-drop) and optionally update status/section"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_task_list_access(client, task_list_id, user["id"], require_edit=True)

        # Verify all tasks belong to this list
        task_ids = [t.id for t in request.tasks]
        verify_result = client.table("backlot_tasks").select("id").eq("task_list_id", task_list_id).in_("id", task_ids).execute()

        if len(verify_result.data or []) != len(task_ids):
            raise HTTPException(status_code=400, detail="Some tasks don't belong to this task list")

        # Update each task
        for task_item in request.tasks:
            update_data = {
                "sort_index": task_item.sort_index,
            }

            if task_item.status is not None:
                update_data["status"] = task_item.status
                update_data["is_completed"] = task_item.status == "done"

            if task_item.section is not None:
                update_data["section"] = task_item.section

            client.table("backlot_tasks").update(update_data).eq("id", task_item.id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error reordering tasks: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Review System Models (Frame.io-style)
# =====================================================

class ReviewAssetCreate(BaseModel):
    """Create a new review asset"""
    name: str
    description: Optional[str] = None
    video_url: Optional[str] = None  # Optional for browser uploads (version created via upload-url endpoint)
    video_provider: str = "placeholder"  # 'placeholder' | 'vimeo' | 'youtube'
    external_video_id: Optional[str] = None
    thumbnail_url: Optional[str] = None
    duration_seconds: Optional[int] = None
    linked_scene_id: Optional[str] = None
    linked_shot_list_id: Optional[str] = None


class ReviewAssetUpdate(BaseModel):
    """Update a review asset"""
    name: Optional[str] = None
    description: Optional[str] = None
    thumbnail_url: Optional[str] = None
    linked_scene_id: Optional[str] = None
    linked_shot_list_id: Optional[str] = None


class ReviewAssetResponse(BaseModel):
    """Review asset response"""
    id: str
    project_id: str
    name: str
    description: Optional[str] = None
    thumbnail_url: Optional[str] = None
    active_version_id: Optional[str] = None
    linked_scene_id: Optional[str] = None
    linked_shot_list_id: Optional[str] = None
    created_by_user_id: str
    created_at: datetime
    updated_at: datetime
    # Joined data
    active_version: Optional[Dict[str, Any]] = None
    version_count: Optional[int] = None
    note_count: Optional[int] = None


class ReviewVersionCreate(BaseModel):
    """Create a new version for a review asset"""
    name: Optional[str] = None  # e.g., "V2", "Final Cut"
    video_url: str
    video_provider: str = "placeholder"
    external_video_id: Optional[str] = None
    thumbnail_url: Optional[str] = None
    duration_seconds: Optional[int] = None


class ReviewVersionResponse(BaseModel):
    """Review version response"""
    id: str
    asset_id: str
    version_number: int
    name: Optional[str] = None
    video_url: str
    video_provider: str
    external_video_id: Optional[str] = None
    thumbnail_url: Optional[str] = None
    duration_seconds: Optional[int] = None
    created_by_user_id: str
    created_at: datetime


class ReviewNoteCreate(BaseModel):
    """Create a new review note"""
    timecode_seconds: Optional[float] = None  # None for general notes
    timecode_end_seconds: Optional[float] = None  # For range notes
    content: str
    drawing_data: Optional[Dict[str, Any]] = None  # For future annotation support


class ReviewNoteUpdate(BaseModel):
    """Update a review note"""
    content: Optional[str] = None
    drawing_data: Optional[Dict[str, Any]] = None
    is_resolved: Optional[bool] = None


class ReviewNoteResponse(BaseModel):
    """Review note response"""
    id: str
    version_id: str
    timecode_seconds: Optional[float] = None
    timecode_end_seconds: Optional[float] = None
    content: str
    drawing_data: Optional[Dict[str, Any]] = None
    is_resolved: bool
    created_by_user_id: str
    created_at: datetime
    updated_at: datetime
    # Joined data
    created_by_user: Optional[Dict[str, Any]] = None
    replies: Optional[List[Dict[str, Any]]] = None
    linked_task_id: Optional[str] = None


class ReviewNoteReplyCreate(BaseModel):
    """Create a reply to a note"""
    content: str


class ReviewNoteReplyResponse(BaseModel):
    """Review note reply response"""
    id: str
    note_id: str
    content: str
    created_by_user_id: str
    created_at: datetime
    # Joined data
    created_by_user: Optional[Dict[str, Any]] = None


class CreateTaskFromNoteRequest(BaseModel):
    """Create a task from a review note"""
    task_list_id: str
    title: Optional[str] = None  # Will use note content if not provided
    priority: Optional[str] = "medium"
    assignee_user_id: Optional[str] = None


# =====================================================
# Review Folder Models
# =====================================================

class ReviewFolderCreate(BaseModel):
    """Create a new review folder"""
    name: str
    description: Optional[str] = None
    color: Optional[str] = None  # Hex color code
    parent_folder_id: Optional[str] = None


class ReviewFolderUpdate(BaseModel):
    """Update a review folder"""
    name: Optional[str] = None
    description: Optional[str] = None
    color: Optional[str] = None
    parent_folder_id: Optional[str] = None
    sort_order: Optional[int] = None


class ReviewAssetMoveRequest(BaseModel):
    """Move a review asset to a folder"""
    folder_id: Optional[str] = None  # None = move to root


class ReviewAssetStatusUpdate(BaseModel):
    """Update review asset status"""
    status: str  # draft, in_review, changes_requested, approved, final


class ReviewAssetBulkMoveRequest(BaseModel):
    """Move multiple assets to a folder"""
    asset_ids: List[str]
    folder_id: Optional[str] = None


# =====================================================
# Review Helper Functions
# =====================================================

async def verify_review_asset_access(
    client,
    asset_id: str,
    user_id: str,
    require_edit: bool = False
) -> Dict[str, Any]:
    """Verify user has access to review asset and return asset data"""
    asset_response = client.table("backlot_review_assets").select("*").eq("id", asset_id).execute()

    if not asset_response.data:
        raise HTTPException(status_code=404, detail="Review asset not found")

    asset = asset_response.data[0]
    project_id = asset["project_id"]

    # Verify project access
    await verify_project_access(client, project_id, user_id, require_edit)

    return asset


async def verify_review_version_access(
    client,
    version_id: str,
    user_id: str,
    require_edit: bool = False
) -> Dict[str, Any]:
    """Verify user has access to review version and return version data"""
    version_response = client.table("backlot_review_versions").select("*").eq("id", version_id).execute()

    if not version_response.data:
        raise HTTPException(status_code=404, detail="Review version not found")

    version = version_response.data[0]

    # Get asset to find project_id
    asset_response = client.table("backlot_review_assets").select("project_id").eq("id", version["asset_id"]).execute()
    if not asset_response.data:
        raise HTTPException(status_code=404, detail="Review asset not found")

    project_id = asset_response.data[0]["project_id"]

    # Verify project access
    await verify_project_access(client, project_id, user_id, require_edit)

    return version


async def verify_review_note_access(
    client,
    note_id: str,
    user_id: str,
    require_edit: bool = False
) -> Dict[str, Any]:
    """Verify user has access to review note and return note data"""
    note_response = client.table("backlot_review_notes").select("*").eq("id", note_id).execute()

    if not note_response.data:
        raise HTTPException(status_code=404, detail="Review note not found")

    note = note_response.data[0]

    # Get version to find asset_id
    version_response = client.table("backlot_review_versions").select("asset_id").eq("id", note["version_id"]).execute()
    if not version_response.data:
        raise HTTPException(status_code=404, detail="Review version not found")

    asset_id = version_response.data[0]["asset_id"]

    # Get asset to find project_id
    asset_response = client.table("backlot_review_assets").select("project_id").eq("id", asset_id).execute()
    if not asset_response.data:
        raise HTTPException(status_code=404, detail="Review asset not found")

    project_id = asset_response.data[0]["project_id"]

    # Verify project access
    await verify_project_access(client, project_id, user_id, require_edit)

    # If editing, user must own the note or have edit permission
    note_author = note.get("created_by_user_id") or note.get("user_id")
    if require_edit and note_author != user_id:
        # Check if user has edit permission on project
        await verify_project_access(client, project_id, user_id, require_edit=True)

    return note


def enrich_user_data(client, user_id: str) -> Optional[Dict[str, Any]]:
    """Get basic user info for display"""
    try:
        profile = client.table("profiles").select("id, display_name, avatar_url").eq("id", user_id).execute()
        if profile.data:
            return profile.data[0]
    except:
        pass
    return {"id": user_id, "display_name": "Unknown User", "avatar_url": None}


# =====================================================
# Review Folder Endpoints
# =====================================================

@router.get("/projects/{project_id}/review/folders")
async def list_review_folders(
    project_id: str,
    authorization: str = Header(None)
):
    """List all review folders for a project (tree structure)"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        # Get all folders
        folders_response = client.table("backlot_review_folders").select(
            "*, created_by:profiles!created_by_user_id(id, display_name, avatar_url)"
        ).eq("project_id", project_id).order("sort_order").execute()

        folders = folders_response.data or []

        # Get asset counts for each folder
        for folder in folders:
            count_resp = client.table("backlot_review_assets").select(
                "id", count="exact"
            ).eq("folder_id", folder["id"]).execute()
            folder["asset_count"] = count_resp.count or 0

            # Get subfolder count
            subfolder_resp = client.table("backlot_review_folders").select(
                "id", count="exact"
            ).eq("parent_folder_id", folder["id"]).execute()
            folder["subfolder_count"] = subfolder_resp.count or 0

        # Build tree structure
        def build_tree(parent_id=None):
            children = []
            for folder in folders:
                if folder.get("parent_folder_id") == parent_id:
                    folder["children"] = build_tree(folder["id"])
                    children.append(folder)
            return children

        tree = build_tree(None)

        return {"folders": tree, "all_folders": folders}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error listing review folders: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/review/folders")
async def create_review_folder(
    project_id: str,
    request: ReviewFolderCreate,
    authorization: str = Header(None)
):
    """Create a new review folder"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"], require_edit=True)

        folder_id = str(uuid.uuid4())

        # Validate parent folder if specified
        if request.parent_folder_id:
            parent_resp = client.table("backlot_review_folders").select("id").eq(
                "id", request.parent_folder_id
            ).eq("project_id", project_id).execute()
            if not parent_resp.data:
                raise HTTPException(status_code=404, detail="Parent folder not found")

        # Get max sort_order for this level
        sort_query = client.table("backlot_review_folders").select("sort_order").eq(
            "project_id", project_id
        )
        if request.parent_folder_id:
            sort_query = sort_query.eq("parent_folder_id", request.parent_folder_id)
        else:
            sort_query = sort_query.is_("parent_folder_id", "null")
        sort_resp = sort_query.order("sort_order", desc=True).limit(1).execute()
        max_sort = (sort_resp.data[0]["sort_order"] if sort_resp.data else 0) + 1

        folder_data = {
            "id": folder_id,
            "project_id": project_id,
            "name": request.name,
            "description": request.description,
            "color": request.color,
            "parent_folder_id": request.parent_folder_id,
            "sort_order": max_sort,
            "created_by_user_id": user["id"]
        }

        result = client.table("backlot_review_folders").insert(folder_data).execute()

        return {"folder": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating review folder: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/review/folders/{folder_id}")
async def get_review_folder(
    folder_id: str,
    authorization: str = Header(None)
):
    """Get a folder with its contents"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get folder
        folder_resp = client.table("backlot_review_folders").select("*").eq(
            "id", folder_id
        ).execute()

        if not folder_resp.data:
            raise HTTPException(status_code=404, detail="Folder not found")

        folder = folder_resp.data[0]
        await verify_project_access(client, folder["project_id"], user["id"])

        # Get subfolders
        subfolders_resp = client.table("backlot_review_folders").select("*").eq(
            "parent_folder_id", folder_id
        ).order("sort_order").execute()
        folder["subfolders"] = subfolders_resp.data or []

        # Get assets in this folder
        assets_resp = client.table("backlot_review_assets").select("*").eq(
            "folder_id", folder_id
        ).order("sort_order").execute()
        folder["assets"] = assets_resp.data or []

        # Get breadcrumb path
        path_resp = client.rpc("get_review_folder_path", {"folder_id": folder_id}).execute()
        folder["path"] = path_resp.data or []

        return {"folder": folder}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting review folder: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/review/folders/{folder_id}")
async def update_review_folder(
    folder_id: str,
    request: ReviewFolderUpdate,
    authorization: str = Header(None)
):
    """Update a review folder"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get folder
        folder_resp = client.table("backlot_review_folders").select("*").eq(
            "id", folder_id
        ).execute()

        if not folder_resp.data:
            raise HTTPException(status_code=404, detail="Folder not found")

        folder = folder_resp.data[0]
        await verify_project_access(client, folder["project_id"], user["id"], require_edit=True)

        # Build update data
        update_data = {}
        if request.name is not None:
            update_data["name"] = request.name
        if request.description is not None:
            update_data["description"] = request.description
        if request.color is not None:
            update_data["color"] = request.color
        if request.sort_order is not None:
            update_data["sort_order"] = request.sort_order
        if request.parent_folder_id is not None:
            # Validate new parent isn't self or descendant
            if request.parent_folder_id == folder_id:
                raise HTTPException(status_code=400, detail="Cannot move folder into itself")
            update_data["parent_folder_id"] = request.parent_folder_id

        if update_data:
            result = client.table("backlot_review_folders").update(update_data).eq(
                "id", folder_id
            ).execute()
            return {"folder": result.data[0]}

        return {"folder": folder}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating review folder: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/review/folders/{folder_id}")
async def delete_review_folder(
    folder_id: str,
    authorization: str = Header(None)
):
    """Delete a review folder (moves contents to parent)"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get folder
        folder_resp = client.table("backlot_review_folders").select("*").eq(
            "id", folder_id
        ).execute()

        if not folder_resp.data:
            raise HTTPException(status_code=404, detail="Folder not found")

        folder = folder_resp.data[0]
        await verify_project_access(client, folder["project_id"], user["id"], require_edit=True)

        parent_id = folder.get("parent_folder_id")

        # Move subfolders to parent
        client.table("backlot_review_folders").update(
            {"parent_folder_id": parent_id}
        ).eq("parent_folder_id", folder_id).execute()

        # Move assets to parent
        client.table("backlot_review_assets").update(
            {"folder_id": parent_id}
        ).eq("folder_id", folder_id).execute()

        # Delete folder
        client.table("backlot_review_folders").delete().eq("id", folder_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting review folder: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/review/folders/{folder_id}/move")
async def move_review_folder(
    folder_id: str,
    request: ReviewAssetMoveRequest,
    authorization: str = Header(None)
):
    """Move a folder to a new parent"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get folder
        folder_resp = client.table("backlot_review_folders").select("*").eq(
            "id", folder_id
        ).execute()

        if not folder_resp.data:
            raise HTTPException(status_code=404, detail="Folder not found")

        folder = folder_resp.data[0]
        await verify_project_access(client, folder["project_id"], user["id"], require_edit=True)

        # Can't move into itself
        if request.folder_id == folder_id:
            raise HTTPException(status_code=400, detail="Cannot move folder into itself")

        # Update parent
        result = client.table("backlot_review_folders").update(
            {"parent_folder_id": request.folder_id}
        ).eq("id", folder_id).execute()

        return {"folder": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error moving review folder: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/review/assets/{asset_id}/move")
async def move_review_asset(
    asset_id: str,
    request: ReviewAssetMoveRequest,
    authorization: str = Header(None)
):
    """Move an asset to a folder"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        asset = await verify_review_asset_access(client, asset_id, user["id"], require_edit=True)

        # Validate target folder if specified
        if request.folder_id:
            folder_resp = client.table("backlot_review_folders").select("id").eq(
                "id", request.folder_id
            ).eq("project_id", asset["project_id"]).execute()
            if not folder_resp.data:
                raise HTTPException(status_code=404, detail="Target folder not found")

        # Update asset folder
        result = client.table("backlot_review_assets").update(
            {"folder_id": request.folder_id}
        ).eq("id", asset_id).execute()

        return {"asset": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error moving review asset: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/review/assets/{asset_id}/status")
async def update_review_asset_status(
    asset_id: str,
    request: ReviewAssetStatusUpdate,
    authorization: str = Header(None)
):
    """Update asset status (draft, in_review, approved, etc.)"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_review_asset_access(client, asset_id, user["id"], require_edit=True)

        valid_statuses = ['draft', 'in_review', 'changes_requested', 'approved', 'final']
        if request.status not in valid_statuses:
            raise HTTPException(status_code=400, detail=f"Invalid status. Must be one of: {valid_statuses}")

        result = client.table("backlot_review_assets").update(
            {"status": request.status}
        ).eq("id", asset_id).execute()

        return {"asset": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating review asset status: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/review/assets/bulk-move")
async def bulk_move_review_assets(
    project_id: str,
    request: ReviewAssetBulkMoveRequest,
    authorization: str = Header(None)
):
    """Move multiple assets to a folder"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"], require_edit=True)

        # Validate target folder if specified
        if request.folder_id:
            folder_resp = client.table("backlot_review_folders").select("id").eq(
                "id", request.folder_id
            ).eq("project_id", project_id).execute()
            if not folder_resp.data:
                raise HTTPException(status_code=404, detail="Target folder not found")

        # Update all assets
        for asset_id in request.asset_ids:
            client.table("backlot_review_assets").update(
                {"folder_id": request.folder_id}
            ).eq("id", asset_id).eq("project_id", project_id).execute()

        return {"success": True, "moved_count": len(request.asset_ids)}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error bulk moving review assets: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Review Asset Endpoints
# =====================================================

@router.get("/projects/{project_id}/review/assets")
async def list_review_assets(
    project_id: str,
    authorization: str = Header(None)
):
    """List all review assets for a project"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        # Get assets without FK join (join syntax may not work)
        assets_response = client.table("backlot_review_assets").select("*").eq(
            "project_id", project_id
        ).order("created_at", desc=True).execute()

        assets = assets_response.data or []

        # Fetch active versions separately
        active_version_ids = [a["active_version_id"] for a in assets if a.get("active_version_id")]
        active_versions_map = {}
        if active_version_ids:
            versions_resp = client.table("backlot_review_versions").select("*").in_("id", active_version_ids).execute()
            for v in (versions_resp.data or []):
                active_versions_map[str(v["id"])] = v

        # Get counts for each asset
        for asset in assets:
            # Attach active version
            if asset.get("active_version_id"):
                asset["active_version"] = active_versions_map.get(str(asset["active_version_id"]))
            else:
                asset["active_version"] = None

            # Get version count
            versions_count = client.table("backlot_review_versions").select("id", count="exact").eq("asset_id", asset["id"]).execute()
            asset["version_count"] = versions_count.count or 0

            # Get note count across all versions
            if asset["version_count"] > 0:
                versions = client.table("backlot_review_versions").select("id").eq("asset_id", asset["id"]).execute()
                version_ids = [v["id"] for v in (versions.data or [])]
                if version_ids:
                    notes_count = client.table("backlot_review_notes").select("id", count="exact").in_("version_id", version_ids).execute()
                    asset["note_count"] = notes_count.count or 0
                else:
                    asset["note_count"] = 0
            else:
                asset["note_count"] = 0

        return {"assets": assets}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error listing review assets: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/review/assets")
async def create_review_asset(
    project_id: str,
    request: ReviewAssetCreate,
    authorization: str = Header(None)
):
    """Create a new review asset with initial version"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"], require_edit=True)

        asset_id = str(uuid.uuid4())

        # Create the asset
        asset_data = {
            "id": asset_id,
            "project_id": project_id,
            "name": request.name,
            "description": request.description,
            "thumbnail_url": request.thumbnail_url,
            "uploaded_by": user["id"],
            "status": "draft",
        }

        # Conditionally include linked IDs when provided
        if request.linked_scene_id:
            asset_data["linked_scene_id"] = request.linked_scene_id
        if request.linked_shot_list_id:
            asset_data["linked_shot_list_id"] = request.linked_shot_list_id

        # Always insert the asset first (without active_version_id to avoid FK violation)
        client.table("backlot_review_assets").insert(asset_data).execute()

        # Only create an initial version if video_url is provided (link flow)
        # For browser uploads, the version is created by the upload-url endpoint
        if request.video_url:
            version_id = str(uuid.uuid4())

            version_data = {
                "id": version_id,
                "asset_id": asset_id,
                "version_number": 1,
                "file_url": request.video_url,
                "thumbnail_url": request.thumbnail_url,
                "duration_seconds": request.duration_seconds,
                "uploaded_by": user["id"],
            }

            client.table("backlot_review_versions").insert(version_data).execute()
            client.table("backlot_review_assets").update({"active_version_id": version_id}).eq("id", asset_id).execute()

        # Return the created asset with version (if any)
        result = client.table("backlot_review_assets").select("*").eq("id", asset_id).execute()
        asset = result.data[0] if result.data else None
        if asset and asset.get("active_version_id"):
            version_resp = client.table("backlot_review_versions").select("*").eq("id", asset["active_version_id"]).execute()
            asset["active_version"] = version_resp.data[0] if version_resp.data else None
        elif asset:
            asset["active_version"] = None

        return {"asset": asset}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating review asset: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/review/assets/{asset_id}")
async def get_review_asset(
    asset_id: str,
    authorization: str = Header(None)
):
    """Get a single review asset with all versions"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        asset = await verify_review_asset_access(client, asset_id, user["id"])

        # Get all versions
        versions_response = client.table("backlot_review_versions").select("*").eq("asset_id", asset_id).order("version_number", desc=True).execute()
        asset["versions"] = versions_response.data or []

        # Get note counts per version
        for version in asset["versions"]:
            notes_count = client.table("backlot_review_notes").select("id", count="exact").eq("version_id", version["id"]).execute()
            version["note_count"] = notes_count.count or 0

        # Populate active_version from active_version_id
        if asset.get("active_version_id"):
            active_version_resp = client.table("backlot_review_versions").select("*").eq(
                "id", asset["active_version_id"]
            ).single().execute()
            asset["active_version"] = active_version_resp.data if active_version_resp.data else None
        else:
            # Fall back to latest version if no active version is set
            asset["active_version"] = asset["versions"][0] if asset["versions"] else None

        return {"asset": asset}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting review asset: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/review/assets/{asset_id}")
async def update_review_asset(
    asset_id: str,
    request: ReviewAssetUpdate,
    authorization: str = Header(None)
):
    """Update a review asset"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_review_asset_access(client, asset_id, user["id"], require_edit=True)

        update_data = {}
        if request.name is not None:
            update_data["name"] = request.name
        if request.description is not None:
            update_data["description"] = request.description
        if request.thumbnail_url is not None:
            update_data["thumbnail_url"] = request.thumbnail_url
        if update_data:
            client.table("backlot_review_assets").update(update_data).eq("id", asset_id).execute()

        result = client.table("backlot_review_assets").select("*").eq("id", asset_id).execute()
        asset = result.data[0] if result.data else None
        if asset and asset.get("active_version_id"):
            version_resp = client.table("backlot_review_versions").select("*").eq("id", asset["active_version_id"]).execute()
            asset["active_version"] = version_resp.data[0] if version_resp.data else None
        elif asset:
            asset["active_version"] = None

        return {"asset": asset}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating review asset: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/review/assets/{asset_id}")
async def delete_review_asset(
    asset_id: str,
    authorization: str = Header(None)
):
    """Delete a review asset and all its versions/notes"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_review_asset_access(client, asset_id, user["id"], require_edit=True)

        # Delete is cascaded via foreign keys
        client.table("backlot_review_assets").delete().eq("id", asset_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting review asset: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Review Version Endpoints
# =====================================================

@router.post("/review/assets/{asset_id}/versions")
async def create_review_version(
    asset_id: str,
    request: ReviewVersionCreate,
    authorization: str = Header(None)
):
    """Create a new version for a review asset"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        asset = await verify_review_asset_access(client, asset_id, user["id"], require_edit=True)

        # Get current highest version number
        versions = client.table("backlot_review_versions").select("version_number").eq("asset_id", asset_id).order("version_number", desc=True).limit(1).execute()
        next_version_number = (versions.data[0]["version_number"] + 1) if versions.data else 1

        version_id = str(uuid.uuid4())
        version_data = {
            "id": version_id,
            "asset_id": asset_id,
            "version_number": next_version_number,
            "file_url": request.video_url,
            "thumbnail_url": request.thumbnail_url,
            "duration_seconds": request.duration_seconds,
            "uploaded_by": user["id"],
        }

        client.table("backlot_review_versions").insert(version_data).execute()

        # Automatically set as active version
        client.table("backlot_review_assets").update({"active_version_id": version_id}).eq("id", asset_id).execute()

        result = client.table("backlot_review_versions").select("*").eq("id", version_id).execute()

        return {"version": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating review version: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/review/versions/{version_id}/make-active")
async def make_version_active(
    version_id: str,
    authorization: str = Header(None)
):
    """Set a version as the active version for its asset"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        version = await verify_review_version_access(client, version_id, user["id"], require_edit=True)

        client.table("backlot_review_assets").update({"active_version_id": version_id}).eq("id", version["asset_id"]).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error making version active: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/review/versions/{version_id}")
async def delete_review_version(
    version_id: str,
    authorization: str = Header(None)
):
    """Delete a review version"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        version = await verify_review_version_access(client, version_id, user["id"], require_edit=True)

        # Check if this is the only version
        versions_count = client.table("backlot_review_versions").select("id", count="exact").eq("asset_id", version["asset_id"]).execute()
        if versions_count.count <= 1:
            raise HTTPException(status_code=400, detail="Cannot delete the only version. Delete the asset instead.")

        # Check if this is the active version
        asset = client.table("backlot_review_assets").select("active_version_id").eq("id", version["asset_id"]).execute()
        if asset.data and asset.data[0]["active_version_id"] == version_id:
            # Set another version as active
            other_version = client.table("backlot_review_versions").select("id").eq("asset_id", version["asset_id"]).neq("id", version_id).order("version_number", desc=True).limit(1).execute()
            if other_version.data:
                client.table("backlot_review_assets").update({"active_version_id": other_version.data[0]["id"]}).eq("id", version["asset_id"]).execute()

        client.table("backlot_review_versions").delete().eq("id", version_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting review version: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Review Version Streaming (S3)
# =====================================================

@router.get("/review/versions/{version_id}/stream-url")
async def get_review_version_stream_url(
    version_id: str,
    quality: Optional[str] = None,
    authorization: str = Header(None)
):
    """Get presigned streaming URL for a review version"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        version = await verify_review_version_access(client, version_id, user["id"])

        # Check storage mode
        storage_mode = version.get("storage_mode", "external")
        if storage_mode == "external":
            # For external videos, just return the video URL
            return {
                "url": version.get("file_url") or version.get("cloud_url", ""),
                "quality": "external",
                "expires_at": None
            }

        # S3 storage - generate presigned URL
        s3_key = version.get("s3_key")
        if not s3_key:
            raise HTTPException(status_code=404, detail="Video file not found")

        # Determine which quality to serve
        renditions = version.get("renditions") or {}
        requested_quality = quality or "auto"

        if requested_quality == "auto":
            # Auto-select best available
            for q in ["1080p", "720p", "480p", "original"]:
                if q in renditions or q == "original":
                    requested_quality = q
                    break

        # Get the S3 key for the requested quality
        if requested_quality in renditions:
            stream_key = renditions[requested_quality]
        else:
            stream_key = s3_key  # Fall back to original

        # Generate presigned URL
        import boto3
        from datetime import datetime, timedelta
        from botocore.config import Config

        s3_client = boto3.client(
            's3',
            region_name='us-east-1',
            config=Config(signature_version='s3v4')
        )

        # All new uploads go to the files bucket.
        # Legacy keys starting with "assets/" (not "projects/") used the main bucket.
        # Legacy "review/" and "dailies/" keys are in the files bucket.
        main_bucket = os.environ.get("S3_BACKLOT_BUCKET", "swn-backlot-517220555400")
        files_bucket = os.environ.get("AWS_S3_BACKLOT_FILES_BUCKET", "swn-backlot-files-517220555400")

        if stream_key.startswith("assets/"):
            bucket_name = main_bucket
        else:
            bucket_name = files_bucket

        expires_in = 3600  # 1 hour

        presigned_url = s3_client.generate_presigned_url(
            'get_object',
            Params={'Bucket': bucket_name, 'Key': stream_key},
            ExpiresIn=expires_in
        )

        expires_at = (datetime.utcnow() + timedelta(seconds=expires_in)).isoformat()

        # Record bandwidth usage for streaming
        try:
            asset_response = client.table("backlot_review_assets").select("project_id").eq("id", version["asset_id"]).execute()
            if asset_response.data:
                stream_project_id = asset_response.data[0]["project_id"]
                # Get file size from linked standalone asset
                file_size = 0
                if version.get("linked_standalone_asset_id"):
                    sa = execute_single(
                        "SELECT file_size_bytes FROM backlot_standalone_assets WHERE id = :said",
                        {"said": version["linked_standalone_asset_id"]}
                    )
                    file_size = (sa.get("file_size_bytes") or 0) if sa else 0
                if file_size > 0:
                    _enforce_org_bandwidth_and_record(
                        stream_project_id, file_size, user["id"],
                        event_type="stream_view", resource_type="review_version",
                        resource_id=version_id,
                    )
        except Exception as bw_err:
            print(f"Warning: bandwidth recording failed for review stream: {bw_err}")

        return {
            "url": presigned_url,
            "quality": requested_quality,
            "expires_at": expires_at
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting stream URL: {e}")
        raise HTTPException(status_code=500, detail=str(e))


class ReviewVersionUploadRequest(BaseModel):
    filename: str
    content_type: str


@router.post("/review/assets/{asset_id}/upload-url")
async def get_review_version_upload_url(
    asset_id: str,
    request: ReviewVersionUploadRequest,
    authorization: str = Header(None)
):
    """Get presigned upload URL for a new review version.

    Uploads go to the standalone assets system so there is only one copy
    of the file. The review version links to it via linked_standalone_asset_id.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        review_asset = await verify_review_asset_access(client, asset_id, user["id"], require_edit=True)
        project_id = review_asset["project_id"]

        # Org-level storage enforcement
        _enforce_org_storage(project_id)

        import boto3
        import uuid
        from datetime import datetime, timedelta
        from botocore.config import Config

        version_id = str(uuid.uuid4())
        standalone_asset_id = str(uuid.uuid4())

        # Store under standalone assets path  single source of truth
        s3_key = f"projects/{project_id}/assets/{standalone_asset_id}/{request.filename}"
        bucket_name = os.environ.get("AWS_S3_BACKLOT_FILES_BUCKET", "swn-backlot-files-517220555400")
        expires_in = 3600  # 1 hour

        # Generate presigned upload URL
        s3_client = boto3.client(
            's3',
            region_name='us-east-1',
            config=Config(signature_version='s3v4')
        )

        presigned_url = s3_client.generate_presigned_url(
            'put_object',
            Params={
                'Bucket': bucket_name,
                'Key': s3_key,
                'ContentType': request.content_type
            },
            ExpiresIn=expires_in
        )

        # Create standalone asset record (the single copy of the file)
        file_ext = request.filename.split('.')[-1].lower() if '.' in request.filename else ''
        is_video = request.content_type.startswith('video/') or file_ext in ('mp4', 'mov', 'avi', 'webm', 'mkv')
        asset_type = "video" if is_video else "other"
        asset_name = request.filename.rsplit('.', 1)[0] if '.' in request.filename else request.filename

        standalone_data = {
            "id": standalone_asset_id,
            "project_id": project_id,
            "name": asset_name,
            "asset_type": asset_type,
            "file_name": request.filename,
            "s3_key": s3_key,
            "mime_type": request.content_type,
            "tags": [],
            "metadata": {},
            "created_by_user_id": user["id"],
        }
        client.table("backlot_standalone_assets").insert(standalone_data).execute()

        # Get current version count
        versions = client.table("backlot_review_versions").select("version_number").eq("asset_id", asset_id).order("version_number", desc=True).limit(1).execute()
        next_version_number = (versions.data[0]["version_number"] + 1) if versions.data else 1

        # Create review version linked to the standalone asset
        new_version = {
            "id": version_id,
            "asset_id": asset_id,
            "version_number": next_version_number,
            "file_url": "",
            "storage_mode": "s3",
            "s3_key": s3_key,
            "original_filename": request.filename,
            "transcode_status": "pending",
            "uploaded_by": user["id"],
            "linked_standalone_asset_id": standalone_asset_id,
        }

        client.table("backlot_review_versions").insert(new_version).execute()

        # Also link the review asset itself
        client.table("backlot_review_assets").update({
            "linked_standalone_asset_id": standalone_asset_id,
        }).eq("id", asset_id).execute()

        return {
            "upload_url": presigned_url,
            "s3_key": s3_key,
            "version_id": version_id
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting upload URL: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/review/versions/{version_id}/complete-upload")
async def complete_review_version_upload(
    version_id: str,
    authorization: str = Header(None)
):
    """Mark upload as complete and trigger transcoding"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        version = await verify_review_version_access(client, version_id, user["id"], require_edit=True)

        if version.get("storage_mode") != "s3":
            raise HTTPException(status_code=400, detail="Version is not S3 storage")

        # Update transcode status to processing
        updated = client.table("backlot_review_versions").update({
            "transcode_status": "processing"
        }).eq("id", version_id).execute()

        # Trigger background FFmpeg transcoding
        import asyncio
        from app.services.review_transcoder import transcode_review_version
        asyncio.create_task(
            transcode_review_version(version_id, version["s3_key"], version["asset_id"])
        )

        # Set as active version
        client.table("backlot_review_assets").update({
            "active_version_id": version_id
        }).eq("id", version["asset_id"]).execute()

        # If linked to a standalone asset, try to get file size from S3
        standalone_id = version.get("linked_standalone_asset_id")
        if standalone_id and version.get("s3_key"):
            try:
                import boto3
                s3_client = boto3.client("s3", region_name="us-east-1")
                bucket = os.environ.get("AWS_S3_BACKLOT_FILES_BUCKET", "swn-backlot-files-517220555400")
                head = s3_client.head_object(Bucket=bucket, Key=version["s3_key"])
                file_size = head.get("ContentLength")
                if file_size:
                    client.table("backlot_standalone_assets").update({
                        "file_size_bytes": file_size,
                    }).eq("id", standalone_id).execute()
                    client.table("backlot_review_versions").update({
                        "file_size_bytes": file_size,
                    }).eq("id", version_id).execute()
            except Exception as size_err:
                print(f"Could not get file size for standalone asset: {size_err}")

        return {
            "version": updated.data[0] if updated.data else None,
            "transcode_started": True
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error completing upload: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/review/versions/{version_id}/transcode-status")
async def get_review_version_transcode_status(
    version_id: str,
    authorization: str = Header(None)
):
    """Get transcoding status for a review version"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        version = await verify_review_version_access(client, version_id, user["id"])

        return {
            "status": version.get("transcode_status", "pending"),
            "progress": 100 if version.get("transcode_status") == "completed" else 0,
            "renditions": version.get("renditions") or {},
            "error": version.get("transcode_error")
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting transcode status: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# External Review Links
# =====================================================

class ExternalLinkCreate(BaseModel):
    name: str
    asset_id: Optional[str] = None
    folder_id: Optional[str] = None
    password: Optional[str] = None
    can_comment: bool = True
    can_download: bool = False
    can_approve: bool = False
    expires_at: Optional[str] = None
    max_views: Optional[int] = None


class ExternalLinkUpdate(BaseModel):
    name: Optional[str] = None
    password: Optional[str] = None
    can_comment: Optional[bool] = None
    can_download: Optional[bool] = None
    can_approve: Optional[bool] = None
    expires_at: Optional[str] = None
    max_views: Optional[int] = None
    is_active: Optional[bool] = None


@router.get("/projects/{project_id}/review/external-links")
async def list_external_links(
    project_id: str,
    authorization: str = Header(None)
):
    """List all external links for a project"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        links = client.table("backlot_review_external_links").select(
            "*, created_by:profiles!created_by_user_id(id, display_name, avatar_url)"
        ).eq("project_id", project_id).order("created_at", desc=True).execute()

        return {"links": links.data or []}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error listing external links: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/review/external-links")
async def create_external_link(
    project_id: str,
    request: ExternalLinkCreate,
    authorization: str = Header(None)
):
    """Create an external review link"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"], require_edit=True)

        import secrets
        import hashlib

        # Generate unique token
        token = secrets.token_urlsafe(32)

        # Hash password if provided
        password_hash = None
        if request.password:
            password_hash = hashlib.sha256(request.password.encode()).hexdigest()

        new_link = {
            "project_id": project_id,
            "asset_id": request.asset_id,
            "folder_id": request.folder_id,
            "token": token,
            "name": request.name,
            "password_hash": password_hash,
            "can_comment": request.can_comment,
            "can_download": request.can_download,
            "can_approve": request.can_approve,
            "expires_at": request.expires_at,
            "max_views": request.max_views,
            "created_by_user_id": user["id"],
            "is_active": True,
        }

        result = client.table("backlot_review_external_links").insert(new_link).execute()

        return {"link": result.data[0] if result.data else None, "token": token}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating external link: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/review/external-links/{link_id}")
async def update_external_link(
    link_id: str,
    request: ExternalLinkUpdate,
    authorization: str = Header(None)
):
    """Update an external review link"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get link and verify access
        link = client.table("backlot_review_external_links").select("*").eq("id", link_id).execute()
        if not link.data:
            raise HTTPException(status_code=404, detail="Link not found")

        await verify_project_access(client, link.data[0]["project_id"], user["id"], require_edit=True)

        import hashlib

        update_data = {}
        if request.name is not None:
            update_data["name"] = request.name
        if request.password is not None:
            update_data["password_hash"] = hashlib.sha256(request.password.encode()).hexdigest() if request.password else None
        if request.can_comment is not None:
            update_data["can_comment"] = request.can_comment
        if request.can_download is not None:
            update_data["can_download"] = request.can_download
        if request.can_approve is not None:
            update_data["can_approve"] = request.can_approve
        if request.expires_at is not None:
            update_data["expires_at"] = request.expires_at
        if request.max_views is not None:
            update_data["max_views"] = request.max_views
        if request.is_active is not None:
            update_data["is_active"] = request.is_active

        result = client.table("backlot_review_external_links").update(update_data).eq("id", link_id).execute()

        return {"link": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating external link: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/review/external-links/{link_id}")
async def delete_external_link(
    link_id: str,
    authorization: str = Header(None)
):
    """Delete an external review link"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get link and verify access
        link = client.table("backlot_review_external_links").select("project_id").eq("id", link_id).execute()
        if not link.data:
            raise HTTPException(status_code=404, detail="Link not found")

        await verify_project_access(client, link.data[0]["project_id"], user["id"], require_edit=True)

        client.table("backlot_review_external_links").delete().eq("id", link_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting external link: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Public External Review Access (No Auth Required)
# =====================================================

class ExternalSessionStart(BaseModel):
    display_name: str
    email: Optional[str] = None
    password: Optional[str] = None


@router.get("/public/review/{token}")
async def get_public_review_link(token: str):
    """Validate an external review link (public endpoint)"""
    client = get_client()

    try:
        from datetime import datetime

        link = client.table("backlot_review_external_links").select("*").eq("token", token).eq("is_active", True).execute()

        if not link.data:
            raise HTTPException(status_code=404, detail="Link not found or expired")

        link_data = link.data[0]

        # Check expiration
        if link_data.get("expires_at"):
            expires_at = datetime.fromisoformat(link_data["expires_at"].replace("Z", "+00:00"))
            if datetime.now(expires_at.tzinfo) > expires_at:
                raise HTTPException(status_code=410, detail="Link has expired")

        # Check max views
        if link_data.get("max_views") and link_data["view_count"] >= link_data["max_views"]:
            raise HTTPException(status_code=410, detail="Link has reached maximum views")

        return {
            "link": {
                "id": link_data["id"],
                "name": link_data["name"],
                "requires_password": link_data.get("password_hash") is not None,
                "can_comment": link_data["can_comment"],
                "can_download": link_data["can_download"],
                "can_approve": link_data["can_approve"],
                "asset_id": link_data.get("asset_id"),
                "folder_id": link_data.get("folder_id"),
            }
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting public review link: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/public/review/{token}/start-session")
async def start_external_session(token: str, request: ExternalSessionStart):
    """Start an external review session (public endpoint)"""
    client = get_client()

    try:
        import secrets
        import hashlib
        from datetime import datetime, timedelta

        link = client.table("backlot_review_external_links").select("*").eq("token", token).eq("is_active", True).execute()

        if not link.data:
            raise HTTPException(status_code=404, detail="Link not found")

        link_data = link.data[0]

        # Verify password if required
        if link_data.get("password_hash"):
            if not request.password:
                raise HTTPException(status_code=401, detail="Password required")
            provided_hash = hashlib.sha256(request.password.encode()).hexdigest()
            if provided_hash != link_data["password_hash"]:
                raise HTTPException(status_code=401, detail="Invalid password")

        # Create session
        session_token = secrets.token_urlsafe(32)
        expires_at = datetime.utcnow() + timedelta(hours=24)

        new_session = {
            "link_id": link_data["id"],
            "session_token": session_token,
            "display_name": request.display_name,
            "email": request.email,
            "expires_at": expires_at.isoformat(),
        }

        client.table("backlot_review_external_sessions").insert(new_session).execute()

        # Increment view count and update last accessed
        client.table("backlot_review_external_links").update({
            "view_count": link_data["view_count"] + 1,
            "last_accessed_at": datetime.utcnow().isoformat()
        }).eq("id", link_data["id"]).execute()

        return {
            "session_token": session_token,
            "expires_at": expires_at.isoformat(),
            "permissions": {
                "can_comment": link_data["can_comment"],
                "can_download": link_data["can_download"],
                "can_approve": link_data["can_approve"],
            }
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error starting external session: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/public/review/{token}/content")
async def get_public_review_content(
    token: str,
    session_token: str = Header(None, alias="X-Session-Token")
):
    """Get viewable content for an external review link"""
    client = get_client()

    try:
        from datetime import datetime

        # Verify session
        if not session_token:
            raise HTTPException(status_code=401, detail="Session token required")

        session = client.table("backlot_review_external_sessions").select(
            "*, link:backlot_review_external_links(*)"
        ).eq("session_token", session_token).execute()

        if not session.data:
            raise HTTPException(status_code=401, detail="Invalid session")

        session_data = session.data[0]

        # Check session expiry
        expires_at = datetime.fromisoformat(session_data["expires_at"].replace("Z", "+00:00"))
        if datetime.now(expires_at.tzinfo) > expires_at:
            raise HTTPException(status_code=401, detail="Session expired")

        link_data = session_data["link"]

        # Verify token matches
        if link_data["token"] != token:
            raise HTTPException(status_code=401, detail="Invalid token")

        # Get content based on link target
        if link_data.get("asset_id"):
            # Single asset
            asset = client.table("backlot_review_assets").select(
                "*, active_version:backlot_review_versions!active_version_id(*)"
            ).eq("id", link_data["asset_id"]).execute()

            if not asset.data:
                raise HTTPException(status_code=404, detail="Asset not found")

            return {"type": "asset", "asset": asset.data[0], "assets": None, "folder": None}

        elif link_data.get("folder_id"):
            # Folder contents
            folder = client.table("backlot_review_folders").select("*").eq("id", link_data["folder_id"]).execute()
            assets = client.table("backlot_review_assets").select(
                "*, active_version:backlot_review_versions!active_version_id(*)"
            ).eq("folder_id", link_data["folder_id"]).execute()

            return {
                "type": "folder",
                "folder": folder.data[0] if folder.data else None,
                "assets": assets.data or [],
                "asset": None
            }

        else:
            # Whole project - get root assets
            assets = client.table("backlot_review_assets").select(
                "*, active_version:backlot_review_versions!active_version_id(*)"
            ).eq("project_id", link_data["project_id"]).is_("folder_id", "null").execute()

            folders = client.table("backlot_review_folders").select("*").eq("project_id", link_data["project_id"]).is_("parent_folder_id", "null").execute()

            return {
                "type": "project",
                "assets": assets.data or [],
                "folders": folders.data or [],
                "asset": None,
                "folder": None
            }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting public review content: {e}")
        raise HTTPException(status_code=500, detail=str(e))


class ExternalNoteCreate(BaseModel):
    version_id: str
    timecode_seconds: Optional[float] = None
    content: str


@router.post("/public/review/{token}/notes")
async def create_external_note(
    token: str,
    request: ExternalNoteCreate,
    session_token: str = Header(None, alias="X-Session-Token")
):
    """Create a note as an external reviewer"""
    client = get_client()

    try:
        from datetime import datetime

        # Verify session
        if not session_token:
            raise HTTPException(status_code=401, detail="Session token required")

        session = client.table("backlot_review_external_sessions").select(
            "*, link:backlot_review_external_links(*)"
        ).eq("session_token", session_token).execute()

        if not session.data:
            raise HTTPException(status_code=401, detail="Invalid session")

        session_data = session.data[0]
        link_data = session_data["link"]

        # Verify token and permissions
        if link_data["token"] != token:
            raise HTTPException(status_code=401, detail="Invalid token")
        if not link_data["can_comment"]:
            raise HTTPException(status_code=403, detail="Commenting not allowed")

        # Create note with external session reference
        new_note = {
            "version_id": request.version_id,
            "timecode": request.timecode_seconds,
            "content": request.content,
            "external_session_id": session_data["id"],
            "external_author_name": session_data["display_name"],
        }

        result = client.table("backlot_review_notes").insert(new_note).execute()

        # Update session last activity
        client.table("backlot_review_external_sessions").update({
            "last_activity_at": datetime.utcnow().isoformat()
        }).eq("id", session_data["id"]).execute()

        note = result.data[0] if result.data else None
        if note:
            note["timecode_seconds"] = note.get("timecode")
        return {"note": note}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating external note: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Review Note Endpoints
# =====================================================

@router.get("/review/versions/{version_id}/notes")
async def list_version_notes(
    version_id: str,
    authorization: str = Header(None)
):
    """List all notes for a version"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_review_version_access(client, version_id, user["id"])

        notes_response = client.table("backlot_review_notes").select("*").eq("version_id", version_id).order("timecode", desc=False).execute()

        notes = notes_response.data or []

        # Enrich with user data and replies
        for note in notes:
            note["timecode_seconds"] = note.get("timecode")
            author_id = note.get("created_by_user_id") or note.get("user_id")
            note["created_by_user"] = enrich_user_data(client, author_id) if author_id else None

            # Get replies
            replies_response = client.table("backlot_review_note_replies").select("*").eq("note_id", note["id"]).order("created_at", desc=False).execute()
            note["replies"] = replies_response.data or []

            for reply in note["replies"]:
                reply_author_id = reply.get("created_by_user_id") or reply.get("user_id")
                reply["created_by_user"] = enrich_user_data(client, reply_author_id) if reply_author_id else None

        return {"notes": notes}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error listing notes: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/review/versions/{version_id}/notes")
async def create_review_note(
    version_id: str,
    request: ReviewNoteCreate,
    authorization: str = Header(None)
):
    """Create a new note on a version"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_review_version_access(client, version_id, user["id"])

        note_id = str(uuid.uuid4())
        note_data = {
            "id": note_id,
            "version_id": version_id,
            "timecode": request.timecode_seconds,
            "content": request.content,
            "user_id": user["id"],
        }

        client.table("backlot_review_notes").insert(note_data).execute()

        result = client.table("backlot_review_notes").select("*").eq("id", note_id).execute()
        note = result.data[0] if result.data else None

        if note:
            note["timecode_seconds"] = note.get("timecode")
            author_id = note.get("created_by_user_id") or note.get("user_id")
            note["created_by_user"] = enrich_user_data(client, author_id) if author_id else None
            note["replies"] = []

        return {"note": note}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating note: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/review/notes/{note_id}")
async def update_review_note(
    note_id: str,
    request: ReviewNoteUpdate,
    authorization: str = Header(None)
):
    """Update a review note"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        note = await verify_review_note_access(client, note_id, user["id"], require_edit=True)

        update_data = {}
        if request.content is not None:
            update_data["content"] = request.content
        if request.drawing_data is not None:
            update_data["drawing_data"] = request.drawing_data
        if request.is_resolved is not None:
            update_data["is_resolved"] = request.is_resolved

        if update_data:
            client.table("backlot_review_notes").update(update_data).eq("id", note_id).execute()

        result = client.table("backlot_review_notes").select("*").eq("id", note_id).execute()
        updated_note = result.data[0] if result.data else None

        if updated_note:
            author_id = updated_note.get("created_by_user_id") or updated_note.get("user_id")
            updated_note["created_by_user"] = enrich_user_data(client, author_id) if author_id else None
            # Get replies
            replies_response = client.table("backlot_review_note_replies").select("*").eq("note_id", note_id).order("created_at", desc=False).execute()
            updated_note["replies"] = replies_response.data or []
            for reply in updated_note["replies"]:
                reply_author_id = reply.get("created_by_user_id") or reply.get("user_id")
                reply["created_by_user"] = enrich_user_data(client, reply_author_id) if reply_author_id else None

        return {"note": updated_note}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating note: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/review/notes/{note_id}")
async def delete_review_note(
    note_id: str,
    authorization: str = Header(None)
):
    """Delete a review note"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_review_note_access(client, note_id, user["id"], require_edit=True)

        client.table("backlot_review_notes").delete().eq("id", note_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting note: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Review Note Reply Endpoints
# =====================================================

@router.post("/review/notes/{note_id}/replies")
async def create_note_reply(
    note_id: str,
    request: ReviewNoteReplyCreate,
    authorization: str = Header(None)
):
    """Create a reply to a note"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_review_note_access(client, note_id, user["id"])

        reply_id = str(uuid.uuid4())
        reply_data = {
            "id": reply_id,
            "note_id": note_id,
            "content": request.content,
            "created_by_user_id": user["id"],
        }

        client.table("backlot_review_note_replies").insert(reply_data).execute()

        result = client.table("backlot_review_note_replies").select("*").eq("id", reply_id).execute()
        reply = result.data[0] if result.data else None

        if reply:
            reply_author_id = reply.get("created_by_user_id") or reply.get("user_id")
            reply["created_by_user"] = enrich_user_data(client, reply_author_id) if reply_author_id else None

        return {"reply": reply}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating reply: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/review/replies/{reply_id}")
async def delete_note_reply(
    reply_id: str,
    authorization: str = Header(None)
):
    """Delete a reply (only owner can delete)"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get reply and verify ownership
        reply_response = client.table("backlot_review_note_replies").select("*").eq("id", reply_id).execute()
        if not reply_response.data:
            raise HTTPException(status_code=404, detail="Reply not found")

        reply = reply_response.data[0]
        reply_author = reply.get("created_by_user_id") or reply.get("user_id")
        if reply_author != user["id"]:
            raise HTTPException(status_code=403, detail="You can only delete your own replies")

        client.table("backlot_review_note_replies").delete().eq("id", reply_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting reply: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Note to Task Integration
# =====================================================

@router.post("/review/notes/{note_id}/create-task")
async def create_task_from_note(
    note_id: str,
    request: CreateTaskFromNoteRequest,
    authorization: str = Header(None)
):
    """Create a task from a review note"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        note = await verify_review_note_access(client, note_id, user["id"])

        # Verify task list access
        await verify_task_list_access(client, request.task_list_id, user["id"], require_edit=True)

        # Get note details for task description
        version_response = client.table("backlot_review_versions").select(
            "*, backlot_review_assets(id, name, project_id)"
        ).eq("id", note["version_id"]).execute()

        version = version_response.data[0] if version_response.data else None
        asset_name = version["backlot_review_assets"]["name"] if version else "Unknown"

        # Build task title
        task_title = request.title or note["content"][:100]  # Truncate if too long
        if note.get("timecode") is not None:
            # Format timecode as MM:SS
            minutes = int(note["timecode"] // 60)
            seconds = int(note["timecode"] % 60)
            task_title = f"[{minutes:02d}:{seconds:02d}] {task_title}"

        # Build task description with link back to review
        task_description = f"From review note on \"{asset_name}\":\n\n{note['content']}"

        # Create the task
        task_id = str(uuid.uuid4())
        task_data = {
            "id": task_id,
            "task_list_id": request.task_list_id,
            "title": task_title,
            "description": task_description,
            "priority": request.priority or "medium",
            "status": "todo",
            "created_by_user_id": user["id"],
            "assignee_user_id": request.assignee_user_id,
        }

        client.table("backlot_tasks").insert(task_data).execute()

        # Update note with linked task ID
        client.table("backlot_review_notes").update({"linked_task_id": task_id}).eq("id", note_id).execute()

        # Get the created task
        task_result = client.table("backlot_tasks").select("*").eq("id", task_id).execute()

        return {"task": task_result.data[0] if task_result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating task from note: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# PROJECT-LEVEL SCRIPT BREAKDOWN ENDPOINTS
# =====================================================

@router.get("/projects/{project_id}/script/breakdown")
async def get_project_breakdown(
    project_id: str,
    scene_id: Optional[str] = None,
    type_filter: Optional[str] = None,
    department_filter: Optional[str] = None,
    stripboard_day: Optional[int] = None,
    authorization: str = Header(None)
):
    """Get all breakdown items for a project with optional filters

    Query params:
    - scene_id: Filter by specific scene
    - type_filter: Filter by breakdown type (cast, prop, etc.)
    - department_filter: Filter by department
    - stripboard_day: Filter by stripboard day number
    """
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user["id"]
    # Convert Cognito ID to profile ID for ownership/membership checks
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    if not profile_id:
        raise HTTPException(status_code=403, detail="Profile not found for user")
    profile_id_str = str(profile_id)
    client = get_client()

    # Verify project access
    project_response = client.table("backlot_projects").select("owner_id, title").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    is_owner = str(project_response.data[0]["owner_id"]) == profile_id_str
    if not is_owner:
        member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id_str).execute()
        if not member_response.data:
            raise HTTPException(status_code=403, detail="Access denied - not a project member")

    try:
        # Get all scenes for project
        scenes_response = client.table("backlot_scenes").select(
            "id, scene_number, slugline, page_length, int_ext, time_of_day, sequence"
        ).eq("project_id", project_id).order("sequence").execute()

        # Deduplicate scenes by scene_number (keep first by sequence order)
        scenes_raw = scenes_response.data or []
        seen_scene_numbers = set()
        scenes = {}
        for s in scenes_raw:
            scene_num = s.get("scene_number")
            if scene_num not in seen_scene_numbers:
                seen_scene_numbers.add(scene_num)
                scenes[s["id"]] = s
        scene_ids = list(scenes.keys())

        if not scene_ids:
            return {
                "breakdown_items": [],
                "scenes": [],
                "grouped_by_type": {},
                "grouped_by_department": {},
                "grouped_by_scene": {}
            }

        # Build breakdown query
        query = client.table("backlot_scene_breakdown_items").select("*").in_("scene_id", scene_ids)

        if scene_id:
            query = query.eq("scene_id", scene_id)
        if type_filter:
            query = query.eq("type", type_filter)
        if department_filter:
            query = query.eq("department", department_filter)
        if stripboard_day is not None:
            query = query.eq("stripboard_day", stripboard_day)

        breakdown_response = query.order("type").execute()
        breakdown_items = breakdown_response.data or []

        # Add scene info to each item
        for item in breakdown_items:
            if item["scene_id"] in scenes:
                item["scene"] = scenes[item["scene_id"]]

        # Get related highlights for each breakdown item
        item_ids = [item["id"] for item in breakdown_items]
        if item_ids:
            highlights_response = client.table("backlot_script_highlight_breakdowns").select(
                "id, breakdown_item_id"
            ).in_("breakdown_item_id", item_ids).execute()

            highlight_map = {}
            for h in (highlights_response.data or []):
                if h["breakdown_item_id"] not in highlight_map:
                    highlight_map[h["breakdown_item_id"]] = []
                highlight_map[h["breakdown_item_id"]].append(h["id"])

            for item in breakdown_items:
                item["highlight_ids"] = highlight_map.get(item["id"], [])

        # Group by type
        grouped_by_type = {}
        for item in breakdown_items:
            item_type = item["type"]
            if item_type not in grouped_by_type:
                grouped_by_type[item_type] = []
            grouped_by_type[item_type].append(item)

        # Group by department
        grouped_by_department = {}
        for item in breakdown_items:
            dept = item.get("department") or "unassigned"
            if dept not in grouped_by_department:
                grouped_by_department[dept] = []
            grouped_by_department[dept].append(item)

        # Group by scene
        grouped_by_scene = {}
        for item in breakdown_items:
            sid = item["scene_id"]
            if sid not in grouped_by_scene:
                scene = scenes.get(sid, {})
                grouped_by_scene[sid] = {
                    "scene": scene,
                    "items": []
                }
            grouped_by_scene[sid]["items"].append(item)

        return {
            "breakdown_items": breakdown_items,
            "scenes": list(scenes.values()),
            "grouped_by_type": grouped_by_type,
            "grouped_by_department": grouped_by_department,
            "grouped_by_scene": grouped_by_scene,
            "project_title": project_response.data[0]["title"]
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching project breakdown: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/script/breakdown/summary")
async def get_project_breakdown_summary(
    project_id: str,
    authorization: str = Header(None)
):
    """Get breakdown summary stats for a project"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user["id"]
    # Convert Cognito ID to profile ID for ownership/membership checks
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    if not profile_id:
        raise HTTPException(status_code=403, detail="Profile not found for user")
    profile_id_str = str(profile_id)
    client = get_client()

    # Verify project access
    project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    is_owner = str(project_response.data[0]["owner_id"]) == profile_id_str
    if not is_owner:
        member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id_str).execute()
        if not member_response.data:
            raise HTTPException(status_code=403, detail="Access denied - not a project member")

    try:
        # Get scenes and deduplicate by scene_number
        scenes_response = client.table("backlot_scenes").select("id, scene_number").eq("project_id", project_id).order("sequence").execute()
        seen_scene_numbers = set()
        scene_ids = []
        for s in (scenes_response.data or []):
            scene_num = s.get("scene_number")
            if scene_num not in seen_scene_numbers:
                seen_scene_numbers.add(scene_num)
                scene_ids.append(s["id"])

        if not scene_ids:
            return {
                "total_items": 0,
                "by_type": {},
                "by_department": {},
                "scenes_with_breakdown": 0
            }

        # Get all breakdown items
        breakdown_response = client.table("backlot_scene_breakdown_items").select("*").in_("scene_id", scene_ids).execute()
        items = breakdown_response.data or []

        # Count by type
        by_type = {}
        for item in items:
            t = item["type"]
            if t not in by_type:
                by_type[t] = 0
            by_type[t] += 1

        # Count by department
        by_department = {}
        for item in items:
            d = item.get("department") or "unassigned"
            if d not in by_department:
                by_department[d] = 0
            by_department[d] += 1

        # Scenes with at least one breakdown item
        scenes_with_breakdown = len(set(item["scene_id"] for item in items))

        return {
            "total_items": len(items),
            "by_type": by_type,
            "by_department": by_department,
            "scenes_with_breakdown": scenes_with_breakdown,
            "total_scenes": len(scene_ids)
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching breakdown summary: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/script/breakdown/pdf")
async def export_project_breakdown_pdf(
    project_id: str,
    scene_id: Optional[str] = None,
    type_filter: Optional[str] = None,
    department_filter: Optional[str] = None,
    include_notes: bool = Query(True, description="Whether to include notes in the PDF"),
    authorization: str = Header(None)
):
    """Export project breakdown as PDF

    If scene_id is provided, exports just that scene's breakdown.
    Otherwise, exports all scenes with breakdown items.
    """
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user["id"]
    # Convert Cognito ID to profile ID for ownership/membership checks
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    if not profile_id:
        raise HTTPException(status_code=403, detail="Profile not found for user")
    profile_id_str = str(profile_id)
    client = get_client()

    # Verify project access
    project_response = client.table("backlot_projects").select("owner_id, title").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    project_title = project_response.data[0]["title"]

    is_owner = str(project_response.data[0]["owner_id"]) == profile_id_str
    if not is_owner:
        member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id_str).execute()
        if not member_response.data:
            raise HTTPException(status_code=403, detail="Access denied - not a project member")

    try:
        # Get scenes
        scenes_response = client.table("backlot_scenes").select(
            "id, scene_number, slugline, page_length, int_ext, time_of_day, description, sequence"
        ).eq("project_id", project_id).order("sequence").execute()

        scenes = {s["id"]: s for s in (scenes_response.data or [])}
        scene_ids = list(scenes.keys())

        if not scene_ids:
            raise HTTPException(status_code=404, detail="No scenes found for this project")

        # Build breakdown query
        query = client.table("backlot_scene_breakdown_items").select("*").in_("scene_id", scene_ids)

        if scene_id:
            query = query.eq("scene_id", scene_id)
        if type_filter:
            query = query.eq("type", type_filter)
        if department_filter:
            query = query.eq("department", department_filter)

        breakdown_response = query.order("type").execute()
        breakdown_items = breakdown_response.data or []

        if not breakdown_items:
            raise HTTPException(status_code=404, detail="No breakdown items found")

        # Single scene export
        if scene_id:
            scene = scenes.get(scene_id)
            if not scene:
                raise HTTPException(status_code=404, detail="Scene not found")

            pdf_bytes = generate_breakdown_pdf(
                project_title=project_title,
                scene=scene,
                breakdown_items=breakdown_items,
                include_notes=include_notes,
            )

            filename = f"breakdown_scene_{scene.get('scene_number', scene_id)}.pdf"
            return Response(
                content=pdf_bytes,
                media_type="application/pdf",
                headers={"Content-Disposition": f"attachment; filename={filename}"}
            )

        # Multi-scene export
        # Group items by scene
        scenes_with_breakdown = []
        items_by_scene = {}
        for item in breakdown_items:
            sid = item["scene_id"]
            if sid not in items_by_scene:
                items_by_scene[sid] = []
            items_by_scene[sid].append(item)

        for sid in scene_ids:
            if sid in items_by_scene:
                scenes_with_breakdown.append({
                    "scene": scenes[sid],
                    "items": items_by_scene[sid]
                })

        # Generate summary stats
        by_type = {}
        by_department = {}
        for item in breakdown_items:
            t = item["type"]
            d = item.get("department") or "unassigned"
            by_type[t] = by_type.get(t, 0) + 1
            by_department[d] = by_department.get(d, 0) + 1

        summary_stats = {
            "total_items": len(breakdown_items),
            "by_type": by_type,
            "by_department": by_department,
            "total_scenes": len(scene_ids),
            "scenes_with_breakdown": len(scenes_with_breakdown)
        }

        # Build filter info string
        filter_parts = []
        if type_filter:
            filter_parts.append(f"Type: {type_filter}")
        if department_filter:
            filter_parts.append(f"Department: {department_filter}")
        filter_info = " | ".join(filter_parts) if filter_parts else None

        pdf_bytes = generate_project_breakdown_pdf(
            project_title=project_title,
            scenes_with_breakdown=scenes_with_breakdown,
            summary_stats=summary_stats,
            filter_info=filter_info,
            include_notes=include_notes,
        )

        filename = f"breakdown_{project_title.replace(' ', '_')}.pdf"
        return Response(
            content=pdf_bytes,
            media_type="application/pdf",
            headers={"Content-Disposition": f"attachment; filename={filename}"}
        )

    except HTTPException:
        raise
    except Exception as e:
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Failed to generate breakdown PDF: {str(e)}")


@router.get("/scenes/{scene_id}/breakdown/pdf")
async def export_scene_breakdown_pdf(
    scene_id: str,
    authorization: str = Header(None)
):
    """Export a single scene's breakdown as PDF"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get scene and verify access
        scene_response = client.table("backlot_scenes").select(
            "id, scene_number, slugline, page_length, int_ext, time_of_day, description, project_id"
        ).eq("id", scene_id).single().execute()

        if not scene_response.data:
            raise HTTPException(status_code=404, detail="Scene not found")

        scene = scene_response.data
        project_id = scene["project_id"]

        # Check access
        project_response = client.table("backlot_projects").select("owner_id, title").eq("id", project_id).execute()
        if not project_response.data:
            raise HTTPException(status_code=404, detail="Project not found")

        project_title = project_response.data[0]["title"]

        is_owner = str(project_response.data[0]["owner_id"]) == str(user_id)
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", user_id).execute()
            if not member_response.data:
                raise HTTPException(status_code=403, detail="Access denied - not a project member")

        # Get breakdown items for this scene
        breakdown_response = client.table("backlot_scene_breakdown_items").select("*").eq("scene_id", scene_id).order("type").execute()
        breakdown_items = breakdown_response.data or []

        if not breakdown_items:
            raise HTTPException(status_code=404, detail="No breakdown items found for this scene")

        pdf_bytes = generate_breakdown_pdf(
            project_title=project_title,
            scene=scene,
            breakdown_items=breakdown_items,
        )

        filename = f"breakdown_scene_{scene.get('scene_number', scene_id)}.pdf"
        return Response(
            content=pdf_bytes,
            media_type="application/pdf",
            headers={"Content-Disposition": f"attachment; filename={filename}"}
        )

    except HTTPException:
        raise
    except Exception as e:
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Failed to generate scene breakdown PDF: {str(e)}")


# =====================================================
# PROJECT-LEVEL SCRIPT NOTES ENDPOINTS
# =====================================================

@router.get("/projects/{project_id}/script/notes")
async def get_project_script_notes(
    project_id: str,
    script_id: Optional[str] = None,
    page_number: Optional[int] = None,
    note_type: Optional[str] = None,
    resolved: Optional[bool] = None,
    scene_id: Optional[str] = None,
    author_user_id: Optional[str] = None,
    group_by: Optional[str] = None,  # page, scene, type, author
    authorization: str = Header(None)
):
    """Get all script page notes for a project with optional filters

    Query params:
    - script_id: Filter by specific script
    - page_number: Filter by page number
    - note_type: Filter by note type (general, direction, production, etc.)
    - resolved: Filter by resolved status
    - scene_id: Filter by linked scene
    - author_user_id: Filter by note author
    - group_by: How to group results (page, scene, type, author)
    """
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    # Convert Cognito ID to profile ID
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)

    # Verify project access
    project_response = client.table("backlot_projects").select("owner_id, title").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    is_owner = project_response.data[0]["owner_id"] == profile_id
    if not is_owner:
        member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id).execute()
        if not member_response.data:
            raise HTTPException(status_code=403, detail="Access denied - not a project member")

    try:
        # Build query
        query = client.table("backlot_script_page_notes").select("*").eq("project_id", project_id)

        if script_id:
            query = query.eq("script_id", script_id)
        if page_number is not None:
            query = query.eq("page_number", page_number)
        if note_type and note_type != "all":
            query = query.eq("note_type", note_type)
        if resolved is not None:
            query = query.eq("resolved", resolved)
        if scene_id:
            query = query.eq("scene_id", scene_id)
        if author_user_id:
            query = query.eq("author_user_id", author_user_id)

        query = query.order("page_number").order("created_at")
        notes_result = query.execute()
        notes = notes_result.data or []

        # Get scripts for this project
        scripts_response = client.table("backlot_scripts").select("id, title, version").eq("project_id", project_id).execute()
        scripts = {s["id"]: s for s in (scripts_response.data or [])}

        # Get scenes for linking
        scenes_response = client.table("backlot_scenes").select("id, scene_number, slugline").eq("project_id", project_id).execute()
        scenes = {s["id"]: s for s in (scenes_response.data or [])}

        # Get author profiles
        author_ids = list(set(n.get("author_user_id") for n in notes if n.get("author_user_id")))
        authors = {}
        if author_ids:
            authors_response = client.table("profiles").select("id, full_name, avatar_url").in_("id", author_ids).execute()
            authors = {a["id"]: a for a in (authors_response.data or [])}

        # Enrich notes with joined data
        for note in notes:
            note["script"] = scripts.get(note.get("script_id"))
            note["scene"] = scenes.get(note.get("scene_id"))
            note["author"] = authors.get(note.get("author_user_id"))

        # Group if requested
        grouped = None
        if group_by:
            grouped = {}
            if group_by == "page":
                for note in notes:
                    key = note.get("page_number", 0)
                    if key not in grouped:
                        grouped[key] = []
                    grouped[key].append(note)
            elif group_by == "scene":
                for note in notes:
                    scene_id = note.get("scene_id")
                    scene = scenes.get(scene_id, {})
                    key = scene.get("scene_number", "No Scene") if scene_id else "No Scene"
                    if key not in grouped:
                        grouped[key] = []
                    grouped[key].append(note)
            elif group_by == "type":
                for note in notes:
                    key = note.get("note_type", "general")
                    if key not in grouped:
                        grouped[key] = []
                    grouped[key].append(note)
            elif group_by == "author":
                for note in notes:
                    author = authors.get(note.get("author_user_id"), {})
                    key = author.get("full_name", "Unknown")
                    if key not in grouped:
                        grouped[key] = []
                    grouped[key].append(note)

        return {
            "notes": notes,
            "grouped": grouped,
            "scripts": list(scripts.values()),
            "scenes": list(scenes.values()),
            "authors": list(authors.values()),
            "project_title": project_response.data[0]["title"],
            "total_count": len(notes),
            "unresolved_count": sum(1 for n in notes if not n.get("resolved", False))
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching project notes: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/script/notes/summary")
async def get_project_notes_summary(
    project_id: str,
    authorization: str = Header(None)
):
    """Get notes summary stats for a project"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    # Convert Cognito ID to profile ID
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)

    # Verify project access
    project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    is_owner = project_response.data[0]["owner_id"] == profile_id
    if not is_owner:
        member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id).execute()
        if not member_response.data:
            raise HTTPException(status_code=403, detail="Access denied - not a project member")

    try:
        # Get all notes for project
        notes_response = client.table("backlot_script_page_notes").select(
            "page_number, note_type, resolved, scene_id, author_user_id"
        ).eq("project_id", project_id).execute()
        notes = notes_response.data or []

        if not notes:
            return {
                "total_notes": 0,
                "unresolved_count": 0,
                "resolved_count": 0,
                "by_type": {},
                "by_page": [],
                "pages_with_notes": 0,
                "unique_authors": 0
            }

        # Count by type
        by_type = {}
        for note in notes:
            t = note.get("note_type", "general")
            if t not in by_type:
                by_type[t] = {"total": 0, "unresolved": 0}
            by_type[t]["total"] += 1
            if not note.get("resolved", False):
                by_type[t]["unresolved"] += 1

        # Summary by page
        page_summary = {}
        for note in notes:
            pg = note.get("page_number", 0)
            if pg not in page_summary:
                page_summary[pg] = {
                    "page_number": pg,
                    "total_count": 0,
                    "unresolved_count": 0,
                    "note_types": []
                }
            page_summary[pg]["total_count"] += 1
            if not note.get("resolved", False):
                page_summary[pg]["unresolved_count"] += 1
            note_type = note.get("note_type", "general")
            if note_type not in page_summary[pg]["note_types"]:
                page_summary[pg]["note_types"].append(note_type)

        unresolved_count = sum(1 for n in notes if not n.get("resolved", False))
        unique_authors = len(set(n.get("author_user_id") for n in notes if n.get("author_user_id")))

        return {
            "total_notes": len(notes),
            "unresolved_count": unresolved_count,
            "resolved_count": len(notes) - unresolved_count,
            "by_type": by_type,
            "by_page": list(page_summary.values()),
            "pages_with_notes": len(page_summary),
            "unique_authors": unique_authors
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching notes summary: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/script/notes/pdf")
async def export_project_notes_pdf(
    project_id: str,
    script_id: Optional[str] = None,
    note_type: Optional[str] = None,
    resolved: Optional[bool] = None,
    scene_id: Optional[str] = None,
    author_user_id: Optional[str] = None,
    group_by: str = "page",  # page, scene, type, author
    authorization: str = Header(None)
):
    """Export project script notes as PDF

    Query params:
    - script_id: Filter by specific script
    - note_type: Filter by note type
    - resolved: Filter by resolved status
    - scene_id: Filter by linked scene
    - author_user_id: Filter by author
    - group_by: How to group notes in PDF (page, scene, type, author)
    """
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    client = get_client()

    # Convert Cognito ID to profile ID
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)

    # Verify project access
    project_response = client.table("backlot_projects").select("owner_id, title").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    project_title = project_response.data[0]["title"]

    is_owner = project_response.data[0]["owner_id"] == profile_id
    if not is_owner:
        member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", profile_id).execute()
        if not member_response.data:
            raise HTTPException(status_code=403, detail="Access denied - not a project member")

    try:
        # Build query
        query = client.table("backlot_script_page_notes").select("*").eq("project_id", project_id)

        if script_id:
            query = query.eq("script_id", script_id)
        if note_type and note_type != "all":
            query = query.eq("note_type", note_type)
        if resolved is not None:
            query = query.eq("resolved", resolved)
        if scene_id:
            query = query.eq("scene_id", scene_id)
        if author_user_id:
            query = query.eq("author_user_id", author_user_id)

        query = query.order("page_number").order("created_at")
        notes_result = query.execute()
        notes = notes_result.data or []

        if not notes:
            raise HTTPException(status_code=404, detail="No notes found matching filters")

        # Get script info for title
        script_title = "All Scripts"
        if script_id:
            script_response = client.table("backlot_scripts").select("title, version").eq("id", script_id).single().execute()
            if script_response.data:
                script_title = script_response.data.get("title", "Script")
                if script_response.data.get("version"):
                    script_title += f" ({script_response.data['version']})"

        # Get scenes
        scenes_response = client.table("backlot_scenes").select("id, scene_number, slugline").eq("project_id", project_id).execute()
        scenes_by_id = {s["id"]: s for s in (scenes_response.data or [])}

        # Get author profiles
        author_ids = list(set(n.get("author_user_id") for n in notes if n.get("author_user_id")))
        authors_by_id = {}
        if author_ids:
            authors_response = client.table("profiles").select("id, full_name, avatar_url").in_("id", author_ids).execute()
            authors_by_id = {a["id"]: a for a in (authors_response.data or [])}

        # Build filter info string
        filter_parts = []
        if script_id:
            filter_parts.append(f"Script: {script_title}")
        if note_type and note_type != "all":
            filter_parts.append(f"Type: {note_type}")
        if resolved is not None:
            filter_parts.append(f"Status: {'Resolved' if resolved else 'Unresolved'}")
        if author_user_id and author_user_id in authors_by_id:
            filter_parts.append(f"Author: {authors_by_id[author_user_id].get('full_name', 'Unknown')}")
        filter_info = " | ".join(filter_parts) if filter_parts else None

        # Import and generate PDF
        from app.services.notes_pdf_service import generate_notes_pdf

        pdf_bytes = generate_notes_pdf(
            project_title=project_title,
            script_title=script_title,
            notes=notes,
            scenes_by_id=scenes_by_id,
            authors_by_id=authors_by_id,
            group_by=group_by,
            filter_info=filter_info,
        )

        filename = f"script_notes_{project_title.replace(' ', '_')}.pdf"
        return Response(
            content=pdf_bytes,
            media_type="application/pdf",
            headers={"Content-Disposition": f"attachment; filename={filename}"}
        )

    except HTTPException:
        raise
    except ImportError as e:
        raise HTTPException(status_code=500, detail="PDF generation not available - WeasyPrint not installed")
    except Exception as e:
        print(f"Error generating notes PDF: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Dailies System Models and Endpoints
# =====================================================

class DailiesDayInput(BaseModel):
    """Input for creating/updating a dailies day"""
    shoot_date: str  # YYYY-MM-DD format
    label: str
    unit: Optional[str] = None
    notes: Optional[str] = None


class DailiesCardInput(BaseModel):
    """Input for creating/updating a dailies card"""
    camera_label: str
    roll_name: str
    storage_mode: Optional[str] = "cloud"
    media_root_path: Optional[str] = None
    storage_location: Optional[str] = None
    notes: Optional[str] = None


class DailiesClipInput(BaseModel):
    """Input for creating a dailies clip"""
    file_name: str
    relative_path: Optional[str] = None
    storage_mode: Optional[str] = "cloud"
    cloud_url: Optional[str] = None
    duration_seconds: Optional[float] = None
    timecode_start: Optional[str] = None
    frame_rate: Optional[float] = None
    resolution: Optional[str] = None
    codec: Optional[str] = None
    camera_label: Optional[str] = None
    scene_number: Optional[str] = None
    take_number: Optional[int] = None
    is_circle_take: Optional[bool] = False
    rating: Optional[int] = None
    script_scene_id: Optional[str] = None
    shot_id: Optional[str] = None
    notes: Optional[str] = None


class DailiesClipUpdateInput(BaseModel):
    """Input for updating a dailies clip"""
    file_name: Optional[str] = None
    scene_number: Optional[str] = None
    take_number: Optional[int] = None
    camera_label: Optional[str] = None
    timecode_start: Optional[str] = None
    is_circle_take: Optional[bool] = None
    is_locked: Optional[bool] = None
    rating: Optional[int] = None
    script_scene_id: Optional[str] = None
    shot_id: Optional[str] = None
    notes: Optional[str] = None
    duration_seconds: Optional[float] = None
    thumbnail_url: Optional[str] = None


class DailiesClipNoteInput(BaseModel):
    """Input for creating/updating a clip note"""
    time_seconds: Optional[float] = None
    note_text: str
    category: Optional[str] = None


# =====================================================
# Dailies Days CRUD Endpoints
# =====================================================

@router.get("/projects/{project_id}/dailies/days")
async def get_dailies_days(
    project_id: str,
    limit: int = Query(100, ge=1, le=500),
    authorization: str = Header(None)
):
    """Get all dailies days for a project with aggregate stats"""
    from app.services.feature_gates import enforce_project_feature
    enforce_project_feature(project_id, "DAILIES")

    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        # Get days
        days_result = client.table("backlot_dailies_days").select("*").eq(
            "project_id", project_id
        ).order("shoot_date", desc=True).limit(limit).execute()

        days = days_result.data or []
        if not days:
            return {"days": []}

        day_ids = [d["id"] for d in days]

        # Get cards for all days
        cards_result = client.table("backlot_dailies_cards").select(
            "id, dailies_day_id"
        ).in_("dailies_day_id", day_ids).execute()

        cards = cards_result.data or []
        card_count_map = {}
        card_to_day_map = {}
        for card in cards:
            day_id = card["dailies_day_id"]
            card_count_map[day_id] = card_count_map.get(day_id, 0) + 1
            card_to_day_map[card["id"]] = day_id

        # Get clips for aggregate stats (clips are linked to project, not cards)
        clip_stats = {}  # day_id -> {count, circles, duration}

        # Since clips don't have dailies_card_id, get project-level clip stats
        clips_result = client.table("backlot_dailies_clips").select(
            "id, is_circle_take, duration_seconds"
        ).eq("project_id", project_id).execute()

        # For now, aggregate all clips at project level (clips aren't linked to days/cards)
        total_clips = clips_result.data or []
        project_clip_stats = {
            "count": len(total_clips),
            "circles": sum(1 for c in total_clips if c.get("is_circle_take")),
            "duration": sum(c.get("duration_seconds") or 0 for c in total_clips)
        }

        # Distribute clips evenly across days for display (temporary until schema is updated)
        if days and project_clip_stats["count"] > 0:
            # Put all clips under the first day for now
            clip_stats[days[0]["id"]] = project_clip_stats

        # Build response
        result = []
        for day in days:
            day_data = dict(day)
            day_id = day["id"]
            day_data["card_count"] = card_count_map.get(day_id, 0)
            day_data["clip_count"] = clip_stats.get(day_id, {}).get("count", 0)
            day_data["circle_take_count"] = clip_stats.get(day_id, {}).get("circles", 0)
            day_data["total_duration_seconds"] = clip_stats.get(day_id, {}).get("duration", 0)
            result.append(day_data)

        return {"days": result}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting dailies days: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/dailies/days/{day_id}")
async def get_dailies_day(
    day_id: str,
    authorization: str = Header(None)
):
    """Get a single dailies day"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        day_result = client.table("backlot_dailies_days").select("*").eq(
            "id", day_id
        ).single().execute()

        if not day_result.data:
            raise HTTPException(status_code=404, detail="Day not found")

        # Verify project access
        await verify_project_access(client, day_result.data["project_id"], user["id"])

        return {"day": day_result.data}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting dailies day: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/dailies/days")
async def create_dailies_day(
    project_id: str,
    input: DailiesDayInput,
    authorization: str = Header(None)
):
    """Create a new dailies day"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"], require_edit=True)

        day_result = client.table("backlot_dailies_days").insert({
            "project_id": project_id,
            "shoot_date": input.shoot_date,
            "label": input.label,
            "unit": input.unit,
            "notes": input.notes,
            "created_by_user_id": user["id"]
        }).execute()

        if not day_result.data:
            raise HTTPException(status_code=500, detail="Failed to create day")

        return {"day": day_result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating dailies day: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/dailies/days/{day_id}")
async def update_dailies_day(
    day_id: str,
    input: DailiesDayInput,
    authorization: str = Header(None)
):
    """Update a dailies day"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get day to check project access
        day_result = client.table("backlot_dailies_days").select("project_id").eq(
            "id", day_id
        ).single().execute()

        if not day_result.data:
            raise HTTPException(status_code=404, detail="Day not found")

        await verify_project_access(client, day_result.data["project_id"], user["id"], require_edit=True)

        update_data = {}
        if input.shoot_date is not None:
            update_data["shoot_date"] = input.shoot_date
        if input.label is not None:
            update_data["label"] = input.label
        if input.unit is not None:
            update_data["unit"] = input.unit
        if input.notes is not None:
            update_data["notes"] = input.notes

        result = client.table("backlot_dailies_days").update(update_data).eq(
            "id", day_id
        ).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to update day")

        return {"day": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating dailies day: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/dailies/days/{day_id}")
async def delete_dailies_day(
    day_id: str,
    authorization: str = Header(None)
):
    """Delete a dailies day and all associated cards/clips"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get day to check project access
        day_result = client.table("backlot_dailies_days").select("project_id").eq(
            "id", day_id
        ).single().execute()

        if not day_result.data:
            raise HTTPException(status_code=404, detail="Day not found")

        await verify_project_access(client, day_result.data["project_id"], user["id"], require_edit=True)

        # Delete cascades via database constraints
        client.table("backlot_dailies_days").delete().eq("id", day_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting dailies day: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Dailies Cards CRUD Endpoints
# =====================================================

@router.get("/dailies/days/{day_id}/cards")
async def get_dailies_cards_by_day(
    day_id: str,
    limit: int = Query(50, ge=1, le=500),
    authorization: str = Header(None)
):
    """Get all cards for a dailies day"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get day to verify access
        day_result = client.table("backlot_dailies_days").select("project_id").eq(
            "id", day_id
        ).single().execute()

        if not day_result.data:
            raise HTTPException(status_code=404, detail="Day not found")

        await verify_project_access(client, day_result.data["project_id"], user["id"])

        cards_result = client.table("backlot_dailies_cards").select("*").eq(
            "dailies_day_id", day_id
        ).order("created_at").limit(limit).execute()

        cards = cards_result.data or []

        # Get clip counts
        if cards:
            card_ids = [c["id"] for c in cards]
            clips_result = client.table("backlot_dailies_clips").select(
                "dailies_card_id"
            ).in_("dailies_card_id", card_ids).execute()

            clip_count_map = {}
            for clip in (clips_result.data or []):
                card_id = clip["dailies_card_id"]
                clip_count_map[card_id] = clip_count_map.get(card_id, 0) + 1

            for card in cards:
                card["clip_count"] = clip_count_map.get(card["id"], 0)

        return {"cards": cards}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting dailies cards: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/dailies/cards")
async def get_dailies_cards_by_project(
    project_id: str,
    limit: int = Query(50, ge=1, le=500),
    authorization: str = Header(None)
):
    """Get all cards for a project"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        cards_result = client.table("backlot_dailies_cards").select("*").eq(
            "project_id", project_id
        ).order("created_at").limit(limit).execute()

        cards = cards_result.data or []

        # Get clip counts
        if cards:
            card_ids = [c["id"] for c in cards]
            clips_result = client.table("backlot_dailies_clips").select(
                "dailies_card_id"
            ).in_("dailies_card_id", card_ids).execute()

            clip_count_map = {}
            for clip in (clips_result.data or []):
                card_id = clip["dailies_card_id"]
                clip_count_map[card_id] = clip_count_map.get(card_id, 0) + 1

            for card in cards:
                card["clip_count"] = clip_count_map.get(card["id"], 0)

        return {"cards": cards}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting dailies cards: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/dailies/days/{day_id}/cards")
async def create_dailies_card(
    day_id: str,
    input: DailiesCardInput,
    authorization: str = Header(None)
):
    """Create a new dailies card"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get day to verify access and get project_id
        day_result = client.table("backlot_dailies_days").select("project_id").eq(
            "id", day_id
        ).single().execute()

        if not day_result.data:
            raise HTTPException(status_code=404, detail="Day not found")

        project_id = day_result.data["project_id"]
        await verify_project_access(client, project_id, user["id"], require_edit=True)

        card_result = client.table("backlot_dailies_cards").insert({
            "dailies_day_id": day_id,
            "camera": input.camera_label,
            "card_number": input.roll_name,
            "status": "pending",
            "notes": input.notes,
        }).execute()

        if not card_result.data:
            raise HTTPException(status_code=500, detail="Failed to create card")

        return {"card": card_result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating dailies card: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/dailies/cards/{card_id}")
async def update_dailies_card(
    card_id: str,
    input: DailiesCardInput,
    authorization: str = Header(None)
):
    """Update a dailies card"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get card to check project access
        card_result = client.table("backlot_dailies_cards").select("project_id").eq(
            "id", card_id
        ).single().execute()

        if not card_result.data:
            raise HTTPException(status_code=404, detail="Card not found")

        await verify_project_access(client, card_result.data["project_id"], user["id"], require_edit=True)

        update_data = {}
        if input.camera_label is not None:
            update_data["camera"] = input.camera_label
        if input.roll_name is not None:
            update_data["card_number"] = input.roll_name
        if input.media_root_path is not None:
            update_data["media_root_path"] = input.media_root_path
        if input.storage_location is not None:
            update_data["storage_location"] = input.storage_location
        if input.notes is not None:
            update_data["notes"] = input.notes

        result = client.table("backlot_dailies_cards").update(update_data).eq(
            "id", card_id
        ).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to update card")

        return {"card": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating dailies card: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/dailies/cards/{card_id}/checksum")
async def verify_card_checksum(
    card_id: str,
    verified: bool = Query(...),
    authorization: str = Header(None)
):
    """Mark card checksum as verified/unverified"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get card to check project access
        card_result = client.table("backlot_dailies_cards").select("project_id").eq(
            "id", card_id
        ).single().execute()

        if not card_result.data:
            raise HTTPException(status_code=404, detail="Card not found")

        await verify_project_access(client, card_result.data["project_id"], user["id"], require_edit=True)

        result = client.table("backlot_dailies_cards").update({
            "checksum_verified": verified
        }).eq("id", card_id).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to update card")

        return {"card": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error verifying card checksum: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/dailies/cards/{card_id}")
async def delete_dailies_card(
    card_id: str,
    authorization: str = Header(None)
):
    """Delete a dailies card and all associated clips"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get card to check project access
        card_result = client.table("backlot_dailies_cards").select("project_id").eq(
            "id", card_id
        ).single().execute()

        if not card_result.data:
            raise HTTPException(status_code=404, detail="Card not found")

        await verify_project_access(client, card_result.data["project_id"], user["id"], require_edit=True)

        # Delete cascades via database constraints
        client.table("backlot_dailies_cards").delete().eq("id", card_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting dailies card: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Dailies Clips CRUD Endpoints
# =====================================================

@router.get("/dailies/cards/{card_id}/clips")
async def get_dailies_clips_by_card(
    card_id: str,
    limit: int = Query(200, ge=1, le=1000),
    authorization: str = Header(None)
):
    """Get all clips for a dailies card"""
    print(f"[Clips] get_dailies_clips_by_card called for card_id={card_id}")
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get card to verify access
        card_result = client.table("backlot_dailies_cards").select("project_id").eq(
            "id", card_id
        ).single().execute()

        if not card_result.data:
            raise HTTPException(status_code=404, detail="Card not found")

        await verify_project_access(client, card_result.data["project_id"], user["id"])

        clips_result = client.table("backlot_dailies_clips").select("*").eq(
            "dailies_card_id", card_id
        ).order("created_at").limit(limit).execute()

        clips = clips_result.data or []

        # Get note counts
        if clips:
            clip_ids = [c["id"] for c in clips]
            notes_result = client.table("backlot_dailies_clip_notes").select(
                "clip_id"
            ).in_("clip_id", clip_ids).execute()

            note_count_map = {}
            for note in (notes_result.data or []):
                clip_id = note["clip_id"]
                note_count_map[clip_id] = note_count_map.get(clip_id, 0) + 1

            for clip in clips:
                clip["note_count"] = note_count_map.get(clip["id"], 0)

            # Generate presigned URLs for thumbnails (since bucket has Block Public Access)
            import boto3
            s3_client = boto3.client('s3', region_name='us-east-1')
            bucket_name = os.environ.get("AWS_S3_BACKLOT_FILES_BUCKET", "swn-backlot-files-517220555400")

            clips_with_thumbs = [c for c in clips if c.get("thumbnail_url")]
            print(f"[Thumbnail] Processing {len(clips_with_thumbs)} clips with thumbnails out of {len(clips)} total")

            for clip in clips:
                if clip.get("thumbnail_url"):
                    thumbnail_url = clip["thumbnail_url"]
                    print(f"[Thumbnail] Processing: {thumbnail_url[:80]}...")
                    if bucket_name in thumbnail_url:
                        s3_key = thumbnail_url.split(f"{bucket_name}.s3.us-east-1.amazonaws.com/")[-1]
                        print(f"[Thumbnail] Extracted S3 key: {s3_key}")
                        if s3_key:
                            try:
                                presigned_url = s3_client.generate_presigned_url(
                                    'get_object',
                                    Params={'Bucket': bucket_name, 'Key': s3_key},
                                    ExpiresIn=3600,
                                )
                                clip["thumbnail_url"] = presigned_url
                                print(f"[Thumbnail] Generated presigned URL successfully")
                            except Exception as e:
                                print(f"[Thumbnail] Error generating presigned URL: {e}")
                    else:
                        print(f"[Thumbnail] Bucket name not in URL, skipping presign")

        return {"clips": clips}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting dailies clips: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/dailies/clips")
async def get_dailies_clips_by_project(
    project_id: str,
    day_id: Optional[str] = None,
    camera: Optional[str] = None,
    scene_number: Optional[str] = None,
    take_number: Optional[int] = None,
    is_circle_take: Optional[bool] = None,
    rating_min: Optional[int] = None,
    storage_mode: Optional[str] = None,
    has_notes: Optional[bool] = None,
    text_search: Optional[str] = None,
    sort_by: str = Query("created_at", regex="^(created_at|shoot_date|scene_number|take_number|rating|duration_seconds|file_name)$"),
    sort_order: str = Query("desc", regex="^(asc|desc)$"),
    offset: int = Query(0, ge=0),
    limit: int = Query(50, ge=1, le=200),
    authorization: str = Header(None)
):
    """Get clips for a project with optional filters, pagination, and sorting for Media Library view"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        # Clips are linked directly to project_id (not to cards)
        query = client.table("backlot_dailies_clips").select("*", count="exact").eq(
            "project_id", project_id
        )

        # Apply filters
        if camera:
            query = query.eq("camera_label", camera)
        if scene_number:
            query = query.eq("scene_number", scene_number)
        if take_number is not None:
            query = query.eq("take_number", take_number)
        if is_circle_take is not None:
            query = query.eq("is_circle_take", is_circle_take)
        if rating_min is not None:
            query = query.gte("rating", rating_min)
        if storage_mode:
            query = query.eq("storage_mode", storage_mode)
        if text_search:
            query = query.or_(f"file_name.ilike.%{text_search}%,notes.ilike.%{text_search}%")

        # Apply sorting
        if sort_order == "desc":
            query = query.order(sort_by, desc=True)
        else:
            query = query.order(sort_by, desc=False)

        # Apply pagination
        query = query.range(offset, offset + limit - 1)

        clips_result = query.execute()
        clips = clips_result.data or []
        total = clips_result.count if clips_result.count is not None else len(clips)

        # Get note counts for clips
        if clips:
            clip_ids = [c["id"] for c in clips]
            notes_result = client.table("backlot_dailies_clip_notes").select(
                "clip_id"
            ).in_("clip_id", clip_ids).execute()

            note_count_map = {}
            for note in (notes_result.data or []):
                cid = note["clip_id"]
                note_count_map[cid] = note_count_map.get(cid, 0) + 1

            for clip in clips:
                clip["note_count"] = note_count_map.get(clip["id"], 0)

        # Filter by has_notes (post-query since we need note counts)
        if has_notes is not None:
            if has_notes:
                clips = [c for c in clips if c.get("note_count", 0) > 0]
            else:
                clips = [c for c in clips if c.get("note_count", 0) == 0]

        # Generate presigned URLs for thumbnails (since bucket has Block Public Access)
        if clips:
            import boto3
            s3_client = boto3.client('s3', region_name='us-east-1')
            bucket_name = os.environ.get("AWS_S3_BACKLOT_FILES_BUCKET", "swn-backlot-files-517220555400")

            clips_with_thumbs = [c for c in clips if c.get("thumbnail_url")]
            print(f"[Thumbnail-Project] Processing {len(clips_with_thumbs)} clips with thumbnails out of {len(clips)} total")

            for clip in clips:
                if clip.get("thumbnail_url"):
                    # Extract S3 key from the stored URL
                    thumbnail_url = clip["thumbnail_url"]
                    print(f"[Thumbnail-Project] Processing: {thumbnail_url[:80]}...")
                    if bucket_name in thumbnail_url:
                        # Parse the key from URL like https://bucket.s3.region.amazonaws.com/key
                        s3_key = thumbnail_url.split(f"{bucket_name}.s3.us-east-1.amazonaws.com/")[-1]
                        print(f"[Thumbnail-Project] Extracted S3 key: {s3_key}")
                        if s3_key:
                            try:
                                presigned_url = s3_client.generate_presigned_url(
                                    'get_object',
                                    Params={'Bucket': bucket_name, 'Key': s3_key},
                                    ExpiresIn=3600,  # 1 hour
                                )
                                clip["thumbnail_url"] = presigned_url
                                print(f"[Thumbnail-Project] Generated presigned URL successfully")
                            except Exception as e:
                                print(f"[Thumbnail-Project] Error generating presigned URL: {e}")
                    else:
                        print(f"[Thumbnail-Project] Bucket name not in URL, skipping presign")

        return {"clips": clips, "total": total, "offset": offset, "limit": limit}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting dailies clips: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/dailies/clips/{clip_id}/stream-url")
async def get_dailies_clip_stream_url(
    clip_id: str,
    quality: str = "auto",
    authorization: str = Header(None)
):
    """Get a presigned URL for streaming a dailies clip

    Quality options: auto, 1080p, 720p, 480p, original
    If a transcoded version doesn't exist, falls back to original.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        clip_result = client.table("backlot_dailies_clips").select(
            "id, project_id, file_path, cloud_url, renditions"
        ).eq("id", clip_id).single().execute()

        if not clip_result.data:
            raise HTTPException(status_code=404, detail="Clip not found")

        clip = clip_result.data
        await verify_project_access(client, clip["project_id"], user["id"])

        # Generate presigned URL for the clip
        import boto3
        s3_client = boto3.client('s3', region_name='us-east-1')

        # Detect which bucket the file is in
        # Default to files bucket  all new uploads go here
        bucket_name = os.environ.get("AWS_S3_BACKLOT_FILES_BUCKET", "swn-backlot-files-517220555400")
        main_bucket = os.environ.get("AWS_S3_BACKLOT_BUCKET", "swn-backlot-517220555400")
        source_url = clip.get("cloud_url") or clip.get("file_path") or ""

        # Detect bucket from URL or key:
        # - Explicit bucket references in URLs override key-based detection
        # - Legacy "assets/" prefix keys (not "projects/") used the main bucket
        if "swn-backlot-517220555400.s3" in source_url and "swn-backlot-files" not in source_url:
            bucket_name = main_bucket
        elif source_url.startswith("assets/"):
            bucket_name = main_bucket

        # Use file_path as the S3 key (original quality)
        original_s3_key = clip.get("file_path") or ""

        # Handle case where file_path is a full URL instead of just the S3 key
        if original_s3_key.startswith("https://"):
            # Extract just the key from the URL
            for bucket in ["swn-backlot-files-517220555400", "swn-backlot-517220555400"]:
                if f"{bucket}.s3" in original_s3_key:
                    # Handle both URL formats: bucket.s3.region.amazonaws.com/key or bucket.s3.amazonaws.com/key
                    if f"{bucket}.s3.us-east-1.amazonaws.com/" in original_s3_key:
                        original_s3_key = original_s3_key.split(f"{bucket}.s3.us-east-1.amazonaws.com/")[-1]
                    elif f"{bucket}.s3.amazonaws.com/" in original_s3_key:
                        original_s3_key = original_s3_key.split(f"{bucket}.s3.amazonaws.com/")[-1]
                    bucket_name = bucket  # Use the detected bucket
                    break

        if not original_s3_key and clip.get("cloud_url"):
            # Extract key from cloud_url if file_path is empty
            cloud_url = clip["cloud_url"]
            for bucket in ["swn-backlot-files-517220555400", "swn-backlot-517220555400"]:
                if f"{bucket}.s3" in cloud_url:
                    if f"{bucket}.s3.us-east-1.amazonaws.com/" in cloud_url:
                        original_s3_key = cloud_url.split(f"{bucket}.s3.us-east-1.amazonaws.com/")[-1]
                    elif f"{bucket}.s3.amazonaws.com/" in cloud_url:
                        original_s3_key = cloud_url.split(f"{bucket}.s3.amazonaws.com/")[-1]
                    bucket_name = bucket  # Use the detected bucket
                    break

        # Strip any query parameters from the key
        if "?" in original_s3_key:
            original_s3_key = original_s3_key.split("?")[0]

        if not original_s3_key:
            raise HTTPException(status_code=404, detail="Clip file path not found")

        # Determine which S3 key to use based on quality
        s3_key = original_s3_key
        actual_quality = "original"
        transcoding_queued = False

        # Check if renditions exist in the database
        renditions = clip.get("renditions") or {}

        if quality != "original" and quality != "auto":
            # Try to get the requested quality rendition
            quality_key = renditions.get(quality)
            if quality_key:
                # Verify the rendition exists in S3
                try:
                    s3_client.head_object(Bucket=bucket_name, Key=quality_key)
                    s3_key = quality_key
                    actual_quality = quality
                except:
                    # Rendition doesn't exist in S3, fall back to original
                    pass

            # If requested quality not available, handle based on quality level
            # Server-side transcoding ONLY handles 1080p as a fallback
            # 720p and 480p should be transcoded by the desktop helper
            if actual_quality == "original":
                if quality == "1080p":
                    # Server can transcode 1080p as a fallback
                    existing_job = execute_single(
                        """
                        SELECT id, status FROM backlot_transcoding_jobs
                        WHERE clip_id = :clip_id AND status IN ('pending', 'processing')
                        """,
                        {"clip_id": clip_id}
                    )

                    if not existing_job and "1080p" not in renditions:
                        job_id = str(uuid.uuid4())
                        execute_single(
                            """
                            INSERT INTO backlot_transcoding_jobs (id, clip_id, project_id, source_key, target_qualities)
                            VALUES (:id, :clip_id, :project_id, :source_key, :qualities)
                            RETURNING id
                            """,
                            {
                                "id": job_id,
                                "clip_id": clip_id,
                                "project_id": clip["project_id"],
                                "source_key": original_s3_key,
                                "qualities": ["1080p"]  # Server only does 1080p
                            }
                        )
                        transcoding_queued = True
                        print(f"Auto-queued 1080p transcoding job {job_id} for clip {clip_id}")

                        # Trigger ECS Fargate task for transcoding
                        try:
                            ecs_client = boto3.client('ecs', region_name='us-east-1')
                            ecs_client.run_task(
                                cluster='swn-transcode-cluster',
                                taskDefinition='swn-transcode-task',
                                launchType='FARGATE',
                                networkConfiguration={
                                    'awsvpcConfiguration': {
                                        'subnets': ['subnet-097d1d86c1bc18b3b', 'subnet-013241dd6ffc1e819'],
                                        'securityGroups': ['sg-01b01424383262ebd'],
                                        'assignPublicIp': 'ENABLED'
                                    }
                                },
                                count=1
                            )
                            print(f"Started ECS transcoding task for job {job_id}")
                        except Exception as ecs_error:
                            print(f"Failed to start ECS task: {ecs_error}")
        elif quality == "auto":
            # For auto, try to use 720p if available, otherwise original
            for q in ["720p", "1080p", "480p"]:
                quality_key = renditions.get(q)
                if quality_key:
                    try:
                        s3_client.head_object(Bucket=bucket_name, Key=quality_key)
                        s3_key = quality_key
                        actual_quality = q
                        break
                    except:
                        continue

        presigned_url = s3_client.generate_presigned_url(
            'get_object',
            Params={'Bucket': bucket_name, 'Key': s3_key},
            ExpiresIn=3600,  # 1 hour
        )

        # Record bandwidth usage for streaming
        try:
            sa = execute_single(
                """SELECT sa.file_size_bytes FROM backlot_standalone_assets sa
                   JOIN backlot_dailies_clips c ON c.linked_standalone_asset_id = sa.id
                   WHERE c.id = :cid""",
                {"cid": clip_id}
            )
            stream_file_size = (sa.get("file_size_bytes") or 0) if sa else 0
            if stream_file_size > 0:
                _enforce_org_bandwidth_and_record(
                    clip["project_id"], stream_file_size, user["id"],
                    event_type="stream_view", resource_type="dailies",
                    resource_id=clip_id,
                )
        except Exception as bw_err:
            print(f"Warning: bandwidth recording failed for dailies stream: {bw_err}")

        # Filter out 'original' from available renditions - only return proxy quality levels
        available = [k for k in renditions.keys() if k != 'original'] if renditions else []

        return {
            "url": presigned_url,
            "expires_in": 3600,
            "clip_id": clip_id,
            "quality": actual_quality,
            "available_renditions": available,
            "transcoding_queued": transcoding_queued
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error generating stream URL: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/dailies/clips/{clip_id}/stream-urls")
async def get_dailies_clip_stream_urls(
    clip_id: str,
    authorization: str = Header(None)
):
    """Get presigned URLs for all available qualities of a dailies clip.

    Returns URLs for adaptive playback quality selection.
    Original quality is only included if project settings allow it.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        clip_result = client.table("backlot_dailies_clips").select(
            "id, project_id, file_path, cloud_url, renditions"
        ).eq("id", clip_id).single().execute()

        if not clip_result.data:
            raise HTTPException(status_code=404, detail="Clip not found")

        clip = clip_result.data
        await verify_project_access(client, clip["project_id"], user["id"])

        # Get project settings to check if original is allowed
        project_result = client.table("backlot_projects").select(
            "settings"
        ).eq("id", clip["project_id"]).single().execute()

        project_settings = project_result.data.get("settings") or {} if project_result.data else {}
        allow_original = project_settings.get("allow_original_playback", False)

        import boto3
        s3_client = boto3.client('s3', region_name='us-east-1')

        # Detect which bucket the file is in  default to files bucket
        bucket_name = os.environ.get("AWS_S3_BACKLOT_FILES_BUCKET", "swn-backlot-files-517220555400")
        main_bucket = os.environ.get("AWS_S3_BACKLOT_BUCKET", "swn-backlot-517220555400")
        source_url = clip.get("cloud_url") or clip.get("file_path") or ""

        # Legacy "assets/" prefix keys (not "projects/") used the main bucket
        if "swn-backlot-517220555400.s3" in source_url and "swn-backlot-files" not in source_url:
            bucket_name = main_bucket
        elif source_url.startswith("assets/"):
            bucket_name = main_bucket

        # Get original S3 key
        original_s3_key = clip.get("file_path") or ""
        if not original_s3_key and clip.get("cloud_url"):
            cloud_url = clip["cloud_url"]
            for bucket in ["swn-backlot-files-517220555400", "swn-backlot-517220555400"]:
                if f"{bucket}.s3" in cloud_url:
                    if f"{bucket}.s3.us-east-1.amazonaws.com/" in cloud_url:
                        original_s3_key = cloud_url.split(f"{bucket}.s3.us-east-1.amazonaws.com/")[-1]
                    elif f"{bucket}.s3.amazonaws.com/" in cloud_url:
                        original_s3_key = cloud_url.split(f"{bucket}.s3.amazonaws.com/")[-1]
                    break

        # Strip query params
        if "?" in original_s3_key:
            original_s3_key = original_s3_key.split("?")[0]

        renditions = clip.get("renditions") or {}
        qualities = {}

        # Generate URLs for each available quality
        for quality in ["720p", "1080p", "4k"]:
            quality_key = renditions.get(quality)
            if quality_key:
                try:
                    s3_client.head_object(Bucket=bucket_name, Key=quality_key)
                    qualities[quality] = s3_client.generate_presigned_url(
                        'get_object',
                        Params={'Bucket': bucket_name, 'Key': quality_key},
                        ExpiresIn=3600,
                    )
                except:
                    pass

        # Include original only if project allows
        if allow_original and original_s3_key:
            try:
                s3_client.head_object(Bucket=bucket_name, Key=original_s3_key)
                qualities["original"] = s3_client.generate_presigned_url(
                    'get_object',
                    Params={'Bucket': bucket_name, 'Key': original_s3_key},
                    ExpiresIn=3600,
                )
            except:
                pass

        # Record bandwidth for stream URL generation (best-effort)
        try:
            sa = execute_single(
                """SELECT sa.file_size_bytes FROM backlot_standalone_assets sa
                   JOIN backlot_dailies_clips c ON c.linked_standalone_asset_id = sa.id
                   WHERE c.id = :cid""",
                {"cid": clip_id}
            )
            stream_file_size = (sa.get("file_size_bytes") or 0) if sa else 0
            if stream_file_size > 0 and qualities:
                _enforce_org_bandwidth_and_record(
                    clip["project_id"], stream_file_size, user["id"],
                    event_type="stream_view", resource_type="dailies",
                    resource_id=clip_id,
                )
        except Exception as bw_err:
            print(f"Warning: bandwidth recording failed for multi-stream: {bw_err}")

        return {
            "clip_id": clip_id,
            "qualities": qualities,
            "available": list(qualities.keys()),
            "allow_original": allow_original,
            "expires_in": 3600,
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error generating stream URLs: {e}")
        raise HTTPException(status_code=500, detail=str(e))


class TranscodeRequest(BaseModel):
    """Request to start transcoding a clip"""
    qualities: List[str] = ["720p", "480p"]


@router.post("/dailies/clips/{clip_id}/transcode")
async def start_clip_transcoding(
    clip_id: str,
    request: TranscodeRequest,
    authorization: str = Header(None)
):
    """
    Queue a transcoding job for a dailies clip.
    Creates renditions at the requested quality levels.

    Quality options: 1080p, 720p, 480p
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get clip info
        clip_result = client.table("backlot_dailies_clips").select(
            "id, project_id, file_path, cloud_url"
        ).eq("id", clip_id).single().execute()

        if not clip_result.data:
            raise HTTPException(status_code=404, detail="Clip not found")

        clip = clip_result.data
        await verify_project_access(client, clip["project_id"], user["id"], require_edit=True)

        # Get source S3 key
        source_key = clip.get("file_path") or ""
        if not source_key and clip.get("cloud_url"):
            bucket_name = os.environ.get("AWS_S3_BACKLOT_FILES_BUCKET", "swn-backlot-files-517220555400")
            cloud_url = clip["cloud_url"]
            if f"{bucket_name}.s3" in cloud_url:
                source_key = cloud_url.split(f"{bucket_name}.s3.us-east-1.amazonaws.com/")[-1]

        if not source_key:
            raise HTTPException(status_code=400, detail="Clip has no source file")

        # Check for existing pending/processing job
        existing_job = execute_single(
            """
            SELECT id, status FROM backlot_transcoding_jobs
            WHERE clip_id = :clip_id AND status IN ('pending', 'processing')
            """,
            {"clip_id": clip_id}
        )

        if existing_job:
            return {
                "job_id": existing_job["id"],
                "status": existing_job["status"],
                "message": "Transcoding job already exists"
            }

        # Create new transcoding job
        job_id = str(uuid.uuid4())
        execute_single(
            """
            INSERT INTO backlot_transcoding_jobs (id, clip_id, project_id, source_key, target_qualities)
            VALUES (:id, :clip_id, :project_id, :source_key, :qualities)
            RETURNING id
            """,
            {
                "id": job_id,
                "clip_id": clip_id,
                "project_id": clip["project_id"],
                "source_key": source_key,
                "qualities": request.qualities
            }
        )

        # Trigger ECS Fargate task for transcoding
        ecs_task_arn = None
        try:
            import boto3
            ecs_client = boto3.client('ecs', region_name='us-east-1')
            response = ecs_client.run_task(
                cluster='swn-transcode-cluster',
                taskDefinition='swn-transcode-task',
                launchType='FARGATE',
                networkConfiguration={
                    'awsvpcConfiguration': {
                        'subnets': ['subnet-097d1d86c1bc18b3b', 'subnet-013241dd6ffc1e819'],
                        'securityGroups': ['sg-01b01424383262ebd'],
                        'assignPublicIp': 'ENABLED'
                    }
                },
                count=1
            )
            if response.get('tasks'):
                ecs_task_arn = response['tasks'][0]['taskArn']
                print(f"Started ECS task: {ecs_task_arn}")
        except Exception as ecs_error:
            print(f"Failed to start ECS task (job still queued): {ecs_error}")

        return {
            "job_id": job_id,
            "status": "pending",
            "message": "Transcoding job queued",
            "target_qualities": request.qualities,
            "ecs_task_arn": ecs_task_arn
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error starting transcoding: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/dailies/clips/{clip_id}/transcode-status")
async def get_clip_transcoding_status(
    clip_id: str,
    authorization: str = Header(None)
):
    """Get the transcoding status for a clip"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify access
        clip_result = client.table("backlot_dailies_clips").select(
            "id, project_id, renditions"
        ).eq("id", clip_id).single().execute()

        if not clip_result.data:
            raise HTTPException(status_code=404, detail="Clip not found")

        clip = clip_result.data
        await verify_project_access(client, clip["project_id"], user["id"])

        # Get latest transcoding job
        job = execute_single(
            """
            SELECT id, status, progress, target_qualities, error_message, created_at, completed_at
            FROM backlot_transcoding_jobs
            WHERE clip_id = :clip_id
            ORDER BY created_at DESC
            LIMIT 1
            """,
            {"clip_id": clip_id}
        )

        return {
            "clip_id": clip_id,
            "renditions": clip.get("renditions") or {},
            "job": job if job else None
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting transcoding status: {e}")
        raise HTTPException(status_code=500, detail=str(e))


class AddRenditionRequest(BaseModel):
    """Request to add a rendition to a clip"""
    quality: str  # "480p", "720p", "1080p"
    s3_key: str
    size: int  # file size in bytes


@router.post("/dailies/clips/{clip_id}/renditions")
async def add_clip_rendition(
    clip_id: str,
    request: AddRenditionRequest,
    authorization: str = Header(None),
    x_api_key: str = Header(None, alias="X-API-Key")
):
    """
    Add a rendition to a clip (used by desktop helper after local transcoding).

    This endpoint allows the desktop helper to register renditions that were
    transcoded locally and uploaded to S3.
    """
    # Support both JWT auth and API key auth
    user = None
    if authorization:
        user = await get_current_user_from_token(authorization)
    elif x_api_key:
        # Verify desktop API key
        if not x_api_key.startswith("swn_dk_"):
            raise HTTPException(status_code=401, detail="Invalid API key format")

        key_hash = hashlib.sha256(x_api_key.encode()).hexdigest()
        key_record = execute_single(
            """
            SELECT dk.id, dk.user_id
            FROM backlot_desktop_keys dk
            WHERE dk.key_hash = :key_hash AND dk.is_active = true
            """,
            {"key_hash": key_hash}
        )

        if not key_record:
            raise HTTPException(status_code=401, detail="Invalid or inactive API key")

        user = {"id": key_record["user_id"]}
    else:
        raise HTTPException(status_code=401, detail="Authentication required")

    client = get_client()

    try:
        # Get clip info
        clip_result = client.table("backlot_dailies_clips").select(
            "id, project_id, renditions"
        ).eq("id", clip_id).single().execute()

        if not clip_result.data:
            raise HTTPException(status_code=404, detail="Clip not found")

        clip = clip_result.data

        # Verify access - for API key auth, the key was already validated for the project
        if authorization:
            await verify_project_access(client, clip["project_id"], user["id"])

        # Validate quality
        valid_qualities = ["480p", "720p", "1080p", "original"]
        if request.quality not in valid_qualities:
            raise HTTPException(status_code=400, detail=f"Invalid quality. Must be one of: {valid_qualities}")

        # Update renditions JSONB column
        current_renditions = clip.get("renditions") or {}
        current_renditions[request.quality] = request.s3_key

        # Add size info if we want to track it
        if not isinstance(current_renditions.get(request.quality), dict):
            # Simple format: just the S3 key
            pass

        # Update the clip
        client.table("backlot_dailies_clips").update({
            "renditions": current_renditions,
            "updated_at": datetime.now(timezone.utc).isoformat()
        }).eq("id", clip_id).execute()

        print(f"Added {request.quality} rendition for clip {clip_id}: {request.s3_key}")

        return {
            "success": True,
            "clip_id": clip_id,
            "quality": request.quality,
            "s3_key": request.s3_key,
            "renditions": current_renditions
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error adding rendition: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/dailies/clips/{clip_id}/thumbnail-upload-url")
async def get_dailies_clip_thumbnail_upload_url(
    clip_id: str,
    authorization: str = Header(None)
):
    """Get a presigned URL for uploading a thumbnail for a dailies clip"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        clip_result = client.table("backlot_dailies_clips").select(
            "id, project_id"
        ).eq("id", clip_id).single().execute()

        if not clip_result.data:
            raise HTTPException(status_code=404, detail="Clip not found")

        clip = clip_result.data
        await verify_project_access(client, clip["project_id"], user["id"], require_edit=True)

        # Generate presigned URL for thumbnail upload
        import boto3
        import uuid
        s3_client = boto3.client('s3', region_name='us-east-1')
        bucket_name = os.environ.get("AWS_S3_BACKLOT_FILES_BUCKET", "swn-backlot-files-517220555400")

        # Create S3 key for thumbnail under projects path
        thumbnail_key = f"projects/{clip['project_id']}/thumbnails/{clip_id}.jpg"

        presigned_url = s3_client.generate_presigned_url(
            'put_object',
            Params={
                'Bucket': bucket_name,
                'Key': thumbnail_key,
                'ContentType': 'image/jpeg',
            },
            ExpiresIn=300,  # 5 minutes
        )

        # Generate the final thumbnail URL
        thumbnail_url = f"https://{bucket_name}.s3.us-east-1.amazonaws.com/{thumbnail_key}"

        return {
            "upload_url": presigned_url,
            "thumbnail_url": thumbnail_url,
            "expires_in": 300,
            "clip_id": clip_id
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error generating thumbnail upload URL: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/dailies/clips/{clip_id}")
async def get_dailies_clip(
    clip_id: str,
    authorization: str = Header(None)
):
    """Get a single dailies clip with full details"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        clip_result = client.table("backlot_dailies_clips").select("*").eq(
            "id", clip_id
        ).single().execute()

        if not clip_result.data:
            raise HTTPException(status_code=404, detail="Clip not found")

        clip = clip_result.data
        await verify_project_access(client, clip["project_id"], user["id"])

        # Fetch card
        if clip.get("dailies_card_id"):
            card_result = client.table("backlot_dailies_cards").select("*").eq(
                "id", clip["dailies_card_id"]
            ).single().execute()
            clip["card"] = card_result.data

        # Fetch scene
        if clip.get("script_scene_id"):
            scene_result = client.table("backlot_scenes").select(
                "id, scene_number, scene_heading, int_ext, time_of_day"
            ).eq("id", clip["script_scene_id"]).single().execute()
            clip["scene"] = scene_result.data

        # Get note count
        notes_result = client.table("backlot_dailies_clip_notes").select(
            "id", count="exact"
        ).eq("clip_id", clip_id).execute()
        clip["note_count"] = notes_result.count or 0

        return {"clip": clip}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting dailies clip: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/dailies/cards/{card_id}/clips")
async def create_dailies_clip(
    card_id: str,
    input: DailiesClipInput,
    authorization: str = Header(None)
):
    """Create a new dailies clip"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get card to verify access and get project_id
        card_result = client.table("backlot_dailies_cards").select("project_id").eq(
            "id", card_id
        ).single().execute()

        if not card_result.data:
            raise HTTPException(status_code=404, detail="Card not found")

        project_id = card_result.data["project_id"]
        await verify_project_access(client, project_id, user["id"], require_edit=True)

        clip_result = client.table("backlot_dailies_clips").insert({
            "dailies_card_id": card_id,
            "project_id": project_id,
            "file_name": input.file_name,
            "relative_path": input.relative_path,
            "storage_mode": input.storage_mode or "cloud",
            "cloud_url": input.cloud_url,
            "duration_seconds": input.duration_seconds,
            "timecode_start": input.timecode_start,
            "frame_rate": input.frame_rate,
            "resolution": input.resolution,
            "codec": input.codec,
            "camera_label": input.camera_label,
            "scene_number": input.scene_number,
            "take_number": input.take_number,
            "is_circle_take": input.is_circle_take or False,
            "rating": input.rating,
            "script_scene_id": input.script_scene_id,
            "shot_id": input.shot_id,
            "notes": input.notes,
            "created_by_user_id": user["id"]
        }).execute()

        if not clip_result.data:
            raise HTTPException(status_code=500, detail="Failed to create clip")

        return {"clip": clip_result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating dailies clip: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/dailies/clips/{clip_id}")
async def update_dailies_clip(
    clip_id: str,
    input: DailiesClipUpdateInput,
    authorization: str = Header(None)
):
    """Update a dailies clip"""
    print(f"[ClipUpdate] Updating clip {clip_id} with input: {input}")
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get clip to check project access
        clip_result = client.table("backlot_dailies_clips").select("project_id").eq(
            "id", clip_id
        ).single().execute()

        if not clip_result.data:
            raise HTTPException(status_code=404, detail="Clip not found")

        await verify_project_access(client, clip_result.data["project_id"], user["id"], require_edit=True)

        update_data = {}
        if input.file_name is not None:
            update_data["file_name"] = input.file_name
        if input.scene_number is not None:
            update_data["scene_number"] = input.scene_number
        if input.take_number is not None:
            update_data["take_number"] = input.take_number
        if input.is_circle_take is not None:
            update_data["is_circle_take"] = input.is_circle_take
        if input.is_locked is not None:
            update_data["is_locked"] = input.is_locked
        if input.rating is not None:
            update_data["rating"] = input.rating
        if input.script_scene_id is not None:
            update_data["script_scene_id"] = input.script_scene_id
        if input.shot_id is not None:
            update_data["shot_id"] = input.shot_id
        if input.notes is not None:
            update_data["notes"] = input.notes
        if input.duration_seconds is not None:
            update_data["duration_seconds"] = input.duration_seconds
        if input.thumbnail_url is not None:
            update_data["thumbnail_url"] = input.thumbnail_url
        if input.camera_label is not None:
            update_data["camera_label"] = input.camera_label
        if input.timecode_start is not None:
            update_data["timecode_start"] = input.timecode_start

        print(f"[ClipUpdate] Built update_data: {update_data}")

        # If no fields to update, just return the current clip
        if not update_data:
            print(f"[ClipUpdate] No fields to update, returning current clip")
            current_clip = client.table("backlot_dailies_clips").select("*").eq(
                "id", clip_id
            ).single().execute()
            return {"clip": current_clip.data}

        print(f"[ClipUpdate] Executing update...")
        result = client.table("backlot_dailies_clips").update(update_data).eq(
            "id", clip_id
        ).execute()
        print(f"[ClipUpdate] Update result: {result.data}")

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to update clip")

        return {"clip": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating dailies clip: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/dailies/clips/{clip_id}/circle")
async def toggle_clip_circle_take(
    clip_id: str,
    is_circle: bool = Query(...),
    authorization: str = Header(None)
):
    """Toggle clip circle take status"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        clip_result = client.table("backlot_dailies_clips").select("project_id").eq(
            "id", clip_id
        ).single().execute()

        if not clip_result.data:
            raise HTTPException(status_code=404, detail="Clip not found")

        await verify_project_access(client, clip_result.data["project_id"], user["id"], require_edit=True)

        result = client.table("backlot_dailies_clips").update({
            "is_circle_take": is_circle
        }).eq("id", clip_id).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to update clip")

        return {"clip": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error toggling circle take: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/dailies/clips/{clip_id}/rating")
async def set_clip_rating(
    clip_id: str,
    rating: Optional[int] = Query(None),
    authorization: str = Header(None)
):
    """Set clip rating (1-5 or null)"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        clip_result = client.table("backlot_dailies_clips").select("project_id").eq(
            "id", clip_id
        ).single().execute()

        if not clip_result.data:
            raise HTTPException(status_code=404, detail="Clip not found")

        await verify_project_access(client, clip_result.data["project_id"], user["id"], require_edit=True)

        result = client.table("backlot_dailies_clips").update({
            "rating": rating
        }).eq("id", clip_id).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to update clip")

        return {"clip": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error setting clip rating: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/dailies/clips/{clip_id}")
async def delete_dailies_clip(
    clip_id: str,
    authorization: str = Header(None)
):
    """Delete a dailies clip"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        clip_result = client.table("backlot_dailies_clips").select("project_id").eq(
            "id", clip_id
        ).single().execute()

        if not clip_result.data:
            raise HTTPException(status_code=404, detail="Clip not found")

        await verify_project_access(client, clip_result.data["project_id"], user["id"], require_edit=True)

        client.table("backlot_dailies_clips").delete().eq("id", clip_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting dailies clip: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/dailies/clips/by-scene/{scene_id}")
async def get_clips_by_scene(
    project_id: str,
    scene_id: str,
    authorization: str = Header(None)
):
    """Get clips linked to a specific scene"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        clips_result = client.table("backlot_dailies_clips").select("*").eq(
            "project_id", project_id
        ).eq("script_scene_id", scene_id).order("take_number").execute()

        return {"clips": clips_result.data or []}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting clips by scene: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/dailies/clips/circle-takes")
async def get_circle_takes(
    project_id: str,
    day_id: Optional[str] = None,
    authorization: str = Header(None)
):
    """Get all circle takes for a project, optionally filtered by day"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        query = client.table("backlot_dailies_clips").select("*").eq(
            "project_id", project_id
        ).eq("is_circle_take", True)

        clips_result = query.order("scene_number").order("take_number").execute()
        clips = clips_result.data or []

        # Filter by day if specified
        if day_id and clips:
            cards_result = client.table("backlot_dailies_cards").select("id").eq(
                "dailies_day_id", day_id
            ).execute()
            day_card_ids = set(c["id"] for c in (cards_result.data or []))
            clips = [c for c in clips if c.get("dailies_card_id") in day_card_ids]

        return {"clips": clips}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting circle takes: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Dailies to Review Promotion
# =====================================================

class PromoteToReviewRequest(BaseModel):
    """Request to promote a dailies clip to the Review system"""
    folder_id: Optional[str] = None
    name: Optional[str] = None
    description: Optional[str] = None
    copy_notes: bool = True


@router.post("/dailies/clips/{clip_id}/promote-to-review")
async def promote_dailies_clip_to_review(
    clip_id: str,
    request: PromoteToReviewRequest,
    authorization: str = Header(None)
):
    """
    Promote a dailies clip to the Review system.

    This creates a new review asset with a version pointing to the same S3 file.
    Optionally copies notes from the dailies clip.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get the dailies clip
        clip_result = client.table("backlot_dailies_clips").select("*").eq(
            "id", clip_id
        ).single().execute()

        if not clip_result.data:
            raise HTTPException(status_code=404, detail="Clip not found")

        clip = clip_result.data
        project_id = clip["project_id"]

        # Verify project access
        await verify_project_access(client, project_id, user["id"], require_edit=True)

        # Check if clip has S3 content
        s3_key = clip.get("s3_key") or clip.get("proxy_s3_key") or clip.get("file_path")
        if not s3_key:
            raise HTTPException(
                status_code=400,
                detail="Clip has no uploaded content to promote"
            )

        # Determine asset name
        asset_name = request.name
        if not asset_name:
            # Build name from clip metadata
            parts = []
            if clip.get("scene_number"):
                parts.append(f"Scene {clip['scene_number']}")
            if clip.get("take_number"):
                parts.append(f"Take {clip['take_number']}")
            if clip.get("file_name"):
                parts.append(clip["file_name"])
            asset_name = " - ".join(parts) if parts else f"Promoted Clip {clip_id[:8]}"

        # Create review asset
        asset_data = {
            "project_id": project_id,
            "name": asset_name,
            "description": request.description or clip.get("notes", ""),
            "status": "in_review",
            "uploaded_by": user["id"],
        }
        if request.folder_id:
            asset_data["folder_id"] = request.folder_id

        asset_result = client.table("backlot_review_assets").insert(asset_data).execute()
        if not asset_result.data:
            raise HTTPException(status_code=500, detail="Failed to create review asset")

        asset = asset_result.data[0]
        asset_id = asset["id"]

        # Create review version pointing to the S3 file
        version_data = {
            "asset_id": asset_id,
            "version_number": 1,
            "file_url": "",
            "storage_mode": "s3",
            "s3_key": s3_key,
            "original_filename": clip.get("file_name"),
            "file_size_bytes": clip.get("file_size_bytes"),
            "duration_seconds": clip.get("duration_seconds"),
            "resolution": clip.get("resolution"),
            "frame_rate": clip.get("frame_rate"),
            "codec": clip.get("codec"),
            "thumbnail_url": clip.get("thumbnail_url"),
            "uploaded_by": user["id"],
            # Copy renditions if available
            "renditions": clip.get("renditions", {}),
            "transcode_status": clip.get("transcode_status", "pending"),
        }

        version_result = client.table("backlot_review_versions").insert(version_data).execute()
        if not version_result.data:
            raise HTTPException(status_code=500, detail="Failed to create review version")

        version = version_result.data[0]
        version_id = version["id"]

        # Update asset with active version
        client.table("backlot_review_assets").update({
            "active_version_id": version_id
        }).eq("id", asset_id).execute()

        # Copy notes if requested
        copied_notes_count = 0
        if request.copy_notes:
            notes_result = client.table("backlot_dailies_clip_notes").select("*").eq(
                "clip_id", clip_id
            ).execute()

            if notes_result.data:
                for note in notes_result.data:
                    note_data = {
                        "version_id": version_id,
                        "user_id": note.get("user_id"),
                        "content": note.get("content"),
                        "timecode_in": note.get("timecode_in"),
                        "timecode_out": note.get("timecode_out"),
                        "frame_number": note.get("frame_number"),
                        "note_type": note.get("note_type", "general"),
                        "is_resolved": note.get("is_resolved", False),
                    }
                    client.table("backlot_review_notes").insert(note_data).execute()
                    copied_notes_count += 1

        # Optionally link the clip to the asset as source
        link_data = {
            "clip_id": clip_id,
            "asset_id": asset_id,
            "link_type": "promoted_to",
            "created_by": user["id"],
        }
        client.table("backlot_dailies_clip_asset_links").insert(link_data).execute()

        return {
            "success": True,
            "asset_id": asset_id,
            "version_id": version_id,
            "asset_name": asset_name,
            "copied_notes_count": copied_notes_count,
            "message": f"Clip promoted to Review as '{asset_name}'"
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error promoting clip to review: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Dailies Clip Notes CRUD Endpoints
# =====================================================

@router.get("/dailies/clips/{clip_id}/notes")
async def get_clip_notes(
    clip_id: str,
    include_resolved: bool = Query(True),
    authorization: str = Header(None)
):
    """Get notes for a clip"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get clip to verify access
        clip_result = client.table("backlot_dailies_clips").select("project_id").eq(
            "id", clip_id
        ).single().execute()

        if not clip_result.data:
            raise HTTPException(status_code=404, detail="Clip not found")

        await verify_project_access(client, clip_result.data["project_id"], user["id"])

        query = client.table("backlot_dailies_clip_notes").select("*").eq(
            "clip_id", clip_id
        )

        notes_result = query.order("timecode", desc=False).order("created_at").execute()
        notes = notes_result.data or []

        project_id = clip_result.data["project_id"]

        # Map column names to frontend expected format and fetch author profiles with marker colors
        if notes:
            author_ids = list(set(n["user_id"] for n in notes if n.get("user_id")))
            if author_ids:
                # Fetch user profiles
                profiles_result = client.table("profiles").select(
                    "id, username, full_name, display_name, avatar_url"
                ).in_("id", author_ids).execute()
                author_map = {p["id"]: p for p in (profiles_result.data or [])}

                # Fetch marker colors from project members
                members_result = client.table("backlot_project_members").select(
                    "user_id, marker_color"
                ).eq("project_id", project_id).in_("user_id", author_ids).execute()
                color_map = {m["user_id"]: m["marker_color"] for m in (members_result.data or [])}

                for note in notes:
                    # Map DB column names to frontend expected names
                    note["author_user_id"] = note.get("user_id")
                    note["time_seconds"] = float(note.get("timecode", 0)) if note.get("timecode") else None
                    note["note_text"] = note.get("content")
                    note["category"] = note.get("note_type")
                    author = author_map.get(note.get("user_id"))
                    if author:
                        author["marker_color"] = color_map.get(note.get("user_id"))
                    note["author"] = author

        return {"notes": notes}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting clip notes: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/dailies/clips/{clip_id}/notes")
async def add_clip_note(
    clip_id: str,
    input: DailiesClipNoteInput,
    authorization: str = Header(None)
):
    """Add a note to a clip"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get clip to verify access
        clip_result = client.table("backlot_dailies_clips").select("project_id").eq(
            "id", clip_id
        ).single().execute()

        if not clip_result.data:
            raise HTTPException(status_code=404, detail="Clip not found")

        await verify_project_access(client, clip_result.data["project_id"], user["id"], require_edit=True)

        note_result = client.table("backlot_dailies_clip_notes").insert({
            "clip_id": clip_id,
            "user_id": user["id"],
            "timecode": str(input.time_seconds) if input.time_seconds is not None else None,
            "content": input.note_text,
            "note_type": input.category
        }).execute()

        if not note_result.data:
            raise HTTPException(status_code=500, detail="Failed to add note")

        return {"note": note_result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error adding clip note: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/dailies/notes/{note_id}")
async def update_clip_note(
    note_id: str,
    input: DailiesClipNoteInput,
    authorization: str = Header(None)
):
    """Update a clip note"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get note to verify access
        note_result = client.table("backlot_dailies_clip_notes").select(
            "clip_id"
        ).eq("id", note_id).single().execute()

        if not note_result.data:
            raise HTTPException(status_code=404, detail="Note not found")

        clip_result = client.table("backlot_dailies_clips").select("project_id").eq(
            "id", note_result.data["clip_id"]
        ).single().execute()

        await verify_project_access(client, clip_result.data["project_id"], user["id"], require_edit=True)

        update_data = {}
        if input.time_seconds is not None:
            update_data["timecode"] = str(input.time_seconds)
        if input.note_text is not None:
            update_data["content"] = input.note_text
        if input.category is not None:
            update_data["note_type"] = input.category

        if not update_data:
            note_data = client.table("backlot_dailies_clip_notes").select("*").eq(
                "id", note_id
            ).single().execute()
            return {"note": note_data.data}

        result = client.table("backlot_dailies_clip_notes").update(update_data).eq(
            "id", note_id
        ).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to update note")

        return {"note": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating clip note: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/dailies/notes/{note_id}/resolve")
async def resolve_clip_note(
    note_id: str,
    resolved: bool = Query(...),
    authorization: str = Header(None)
):
    """Mark a note as resolved/unresolved"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get note to verify access
        note_result = client.table("backlot_dailies_clip_notes").select(
            "clip_id"
        ).eq("id", note_id).single().execute()

        if not note_result.data:
            raise HTTPException(status_code=404, detail="Note not found")

        clip_result = client.table("backlot_dailies_clips").select("project_id").eq(
            "id", note_result.data["clip_id"]
        ).single().execute()

        await verify_project_access(client, clip_result.data["project_id"], user["id"], require_edit=True)

        result = client.table("backlot_dailies_clip_notes").update({
            "is_resolved": resolved
        }).eq("id", note_id).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to update note")

        return {"note": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error resolving clip note: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/dailies/notes/{note_id}")
async def delete_clip_note(
    note_id: str,
    authorization: str = Header(None)
):
    """Delete a clip note"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get note to verify access
        note_result = client.table("backlot_dailies_clip_notes").select(
            "clip_id"
        ).eq("id", note_id).single().execute()

        if not note_result.data:
            raise HTTPException(status_code=404, detail="Note not found")

        clip_result = client.table("backlot_dailies_clips").select("project_id").eq(
            "id", note_result.data["clip_id"]
        ).single().execute()

        await verify_project_access(client, clip_result.data["project_id"], user["id"], require_edit=True)

        client.table("backlot_dailies_clip_notes").delete().eq("id", note_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting clip note: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Member Marker Color (for timeline notes)
# =====================================================

class MemberMarkerColorInput(BaseModel):
    marker_color: str  # Hex color code like #3B82F6


@router.patch("/projects/{project_id}/members/marker-color")
async def update_member_marker_color(
    project_id: str,
    input: MemberMarkerColorInput,
    authorization: str = Header(None)
):
    """Update the current user's marker color for a project"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify user is a project member
        member_result = client.table("backlot_project_members").select(
            "id"
        ).eq("project_id", project_id).eq("user_id", user["id"]).single().execute()

        if not member_result.data:
            raise HTTPException(status_code=403, detail="Not a project member")

        # Validate hex color format
        color = input.marker_color
        if not color.startswith('#') or len(color) != 7:
            raise HTTPException(status_code=400, detail="Invalid color format. Use hex like #3B82F6")

        # Update marker color
        result = client.table("backlot_project_members").update({
            "marker_color": color
        }).eq("project_id", project_id).eq("user_id", user["id"]).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to update marker color")

        return {"success": True, "marker_color": color}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating marker color: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Local Ingest and Summary (existing endpoints)
# =====================================================

class DailiesLocalIngestClip(BaseModel):
    """Single clip from local ingest"""
    file_name: str
    relative_path: Optional[str] = None
    duration_seconds: Optional[float] = None
    timecode_start: Optional[str] = None
    frame_rate: Optional[float] = None
    resolution: Optional[str] = None
    codec: Optional[str] = None
    scene_number: Optional[str] = None
    take_number: Optional[int] = None


class DailiesLocalIngestCard(BaseModel):
    """Single card/roll from local ingest"""
    camera_label: str
    roll_name: str
    media_root_path: Optional[str] = None
    storage_location: Optional[str] = None
    clips: List[DailiesLocalIngestClip] = []


class DailiesLocalIngestRequest(BaseModel):
    """Request to ingest dailies from local drive via desktop companion"""
    project_id: str
    shoot_date: str  # YYYY-MM-DD format
    day_label: str
    unit: Optional[str] = None
    cards: List[DailiesLocalIngestCard]


class DailiesLocalIngestResponse(BaseModel):
    """Response from local ingest"""
    success: bool
    day_id: str
    cards_created: int
    clips_created: int
    message: str = ""


class DailiesProjectSummary(BaseModel):
    """Summary statistics for project dailies"""
    total_days: int
    total_cards: int
    total_clips: int
    circle_takes: int
    cloud_clips: int
    local_clips: int
    total_notes: int
    unresolved_notes: int


@router.post("/dailies/local-ingest", response_model=DailiesLocalIngestResponse)
async def ingest_local_dailies(
    request: DailiesLocalIngestRequest,
    authorization: str = Header(None)
):
    """
    Ingest dailies metadata from local drive (via desktop companion app)
    Creates day, cards, and clips with storage_mode='local_drive'

    Args:
        request: Ingest request with project, date, and cards/clips

    Returns:
        Ingest result with created counts
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify project access
        await verify_project_access(client, request.project_id, user["id"], require_edit=True)

        # Check if day exists for this date
        existing_day = client.table("backlot_dailies_days").select("id").eq(
            "project_id", request.project_id
        ).eq("shoot_date", request.shoot_date).execute()

        day_id = None
        if existing_day.data:
            day_id = existing_day.data[0]["id"]
        else:
            # Create new day
            new_day = client.table("backlot_dailies_days").insert({
                "project_id": request.project_id,
                "shoot_date": request.shoot_date,
                "label": request.day_label,
                "unit": request.unit,
                "created_by_user_id": user["id"]
            }).execute()

            if not new_day.data:
                raise HTTPException(status_code=500, detail="Failed to create dailies day")
            day_id = new_day.data[0]["id"]

        cards_created = 0
        clips_created = 0

        # Process each card
        for card_input in request.cards:
            # Create card
            new_card = client.table("backlot_dailies_cards").insert({
                "dailies_day_id": day_id,
                "camera": card_input.camera_label,
                "card_number": card_input.roll_name,
                "status": "pending",
            }).execute()

            if not new_card.data:
                continue

            cards_created += 1

            # Create clips for this card (clips link to project, not card)
            if card_input.clips:
                clip_inserts = []
                for clip in card_input.clips:
                    clip_inserts.append({
                        "project_id": request.project_id,
                        "file_name": clip.file_name,
                        "file_path": clip.relative_path,
                        "storage_mode": "local_drive",
                        "duration_seconds": clip.duration_seconds,
                        "timecode_start": clip.timecode_start,
                        "frame_rate": clip.frame_rate,
                        "resolution": clip.resolution,
                        "codec": clip.codec,
                        "camera_label": card_input.camera_label,
                        "scene_number": clip.scene_number,
                        "take_number": clip.take_number,
                        "is_circle_take": False,
                    })

                if clip_inserts:
                    result = client.table("backlot_dailies_clips").insert(clip_inserts).execute()
                    clips_created += len(result.data) if result.data else 0

        return DailiesLocalIngestResponse(
            success=True,
            day_id=day_id,
            cards_created=cards_created,
            clips_created=clips_created,
            message=f"Successfully ingested {cards_created} cards with {clips_created} clips"
        )

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error in local dailies ingest: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/dailies/summary", response_model=DailiesProjectSummary)
async def get_dailies_summary(
    project_id: str,
    authorization: str = Header(None)
):
    """
    Get summary statistics for project dailies

    Args:
        project_id: Project ID

    Returns:
        Summary with counts for days, cards, clips, notes
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify project access
        await verify_project_access(client, project_id, user["id"])

        # Get days with their IDs
        days_result = client.table("backlot_dailies_days").select(
            "id"
        ).eq("project_id", project_id).execute()
        day_ids = [d["id"] for d in (days_result.data or [])]
        total_days = len(day_ids)

        # Count cards through days (cards don't have project_id directly)
        total_cards = 0
        if day_ids:
            cards_result = client.table("backlot_dailies_cards").select(
                "id", count="exact"
            ).in_("dailies_day_id", day_ids).execute()
            total_cards = cards_result.count or 0

        # Get clips with details
        clips_result = client.table("backlot_dailies_clips").select(
            "id, is_circle_take, storage_mode"
        ).eq("project_id", project_id).execute()

        total_clips = len(clips_result.data) if clips_result.data else 0
        circle_takes = sum(1 for c in (clips_result.data or []) if c.get("is_circle_take"))
        cloud_clips = sum(1 for c in (clips_result.data or []) if c.get("storage_mode") == "cloud")
        local_clips = sum(1 for c in (clips_result.data or []) if c.get("storage_mode") == "local_drive")

        # Get notes
        clip_ids = [c["id"] for c in (clips_result.data or [])]
        total_notes = 0
        unresolved_notes = 0

        if clip_ids:
            notes_result = client.table("backlot_dailies_clip_notes").select(
                "id"
            ).in_("clip_id", clip_ids).execute()

            total_notes = len(notes_result.data) if notes_result.data else 0
            unresolved_notes = 0  # is_resolved column doesn't exist in this table

        return DailiesProjectSummary(
            total_days=total_days,
            total_cards=total_cards,
            total_clips=total_clips,
            circle_takes=circle_takes,
            cloud_clips=cloud_clips,
            local_clips=local_clips,
            total_notes=total_notes,
            unresolved_notes=unresolved_notes
        )

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting dailies summary: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Production Day to Dailies Sync Endpoints
# =====================================================

class ImportProductionDaysInput(BaseModel):
    """Input for importing production days into dailies"""
    production_day_ids: List[str]
    create_footage_assets: bool = False


@router.get("/projects/{project_id}/production-days/unlinked-to-dailies")
async def get_unlinked_production_days(
    project_id: str,
    authorization: str = Header(None)
):
    """
    Get production days that don't have a linked dailies day.

    These are days from the Schedule that haven't been imported into the Dailies system yet.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        # Get all production days for the project
        prod_days_result = client.table("backlot_production_days").select(
            "id, day_number, date, title, location_name, is_completed"
        ).eq("project_id", project_id).order("day_number").execute()

        prod_days = prod_days_result.data or []
        if not prod_days:
            return {"production_days": []}

        prod_day_ids = [d["id"] for d in prod_days]

        # Get dailies days that are already linked
        dailies_result = client.table("backlot_dailies_days").select(
            "production_day_id"
        ).eq("project_id", project_id).in_(
            "production_day_id", prod_day_ids
        ).execute()

        linked_ids = set(
            d["production_day_id"] for d in (dailies_result.data or [])
            if d.get("production_day_id")
        )

        # Filter to unlinked production days
        unlinked = [d for d in prod_days if d["id"] not in linked_ids]

        # Get scene counts for each production day
        for day in unlinked:
            scenes_result = client.table("backlot_scenes").select(
                "id", count="exact"
            ).eq("scheduled_day_id", day["id"]).execute()
            day["scene_count"] = scenes_result.count or 0

        return {"production_days": unlinked}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting unlinked production days: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/dailies/import-from-schedule")
async def import_production_days_to_dailies(
    project_id: str,
    input: ImportProductionDaysInput,
    authorization: str = Header(None)
):
    """
    Import production days from the Schedule as Dailies days.

    Creates a dailies day for each selected production day, linking them together.
    Optionally creates a 'footage' asset for each day.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"], require_edit=True)

        if not input.production_day_ids:
            raise HTTPException(status_code=400, detail="No production days specified")

        # Get the production days to import
        prod_days_result = client.table("backlot_production_days").select(
            "id, day_number, date, title"
        ).eq("project_id", project_id).in_(
            "id", input.production_day_ids
        ).execute()

        prod_days = prod_days_result.data or []
        if not prod_days:
            raise HTTPException(status_code=404, detail="Production days not found")

        # Check which are already linked
        existing_result = client.table("backlot_dailies_days").select(
            "production_day_id"
        ).eq("project_id", project_id).in_(
            "production_day_id", input.production_day_ids
        ).execute()

        already_linked = set(
            d["production_day_id"] for d in (existing_result.data or [])
            if d.get("production_day_id")
        )

        # Filter to days not yet linked
        days_to_import = [d for d in prod_days if d["id"] not in already_linked]

        if not days_to_import:
            return {
                "imported": [],
                "skipped": len(prod_days),
                "message": "All selected days are already imported"
            }

        created_days = []
        created_assets = []

        for prod_day in days_to_import:
            # Create the dailies day
            dailies_day_data = {
                "project_id": project_id,
                "production_day_id": prod_day["id"],
                "shoot_date": prod_day["date"],
                "status": "pending",
                "notes": None
            }

            day_result = client.table("backlot_dailies_days").insert(
                dailies_day_data
            ).execute()

            if day_result.data:
                created_day = day_result.data[0]
                created_days.append(created_day)

                # Optionally create a footage asset
                if input.create_footage_assets:
                    day_label = prod_day.get("title") or f"Day {prod_day.get('day_number', '')}"
                    asset_data = {
                        "project_id": project_id,
                        "asset_type": "footage",
                        "title": f"{day_label} - Raw Footage",
                        "description": f"Raw footage from {prod_day['date']}",
                        "status": "not_started",
                        "created_by_user_id": user["id"]
                    }

                    asset_result = client.table("backlot_assets").insert(
                        asset_data
                    ).execute()

                    if asset_result.data:
                        created_assets.append(asset_result.data[0])

        return {
            "imported": created_days,
            "assets_created": created_assets,
            "skipped": len(already_linked),
            "message": f"Imported {len(created_days)} production days"
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error importing production days: {e}")
        raise HTTPException(status_code=500, detail=str(e))


class EnsureDailiesDayInput(BaseModel):
    """Input for ensuring a dailies day exists for a production day"""
    production_day_id: str


@router.get("/projects/{project_id}/dailies/production-day-view")
async def get_production_day_view(
    project_id: str,
    authorization: str = Header(None)
):
    """
    Get unified view of all production days with their dailies status.

    Returns all production days from the schedule, enriched with dailies info
    (has_footage, clip_count, card_count, circle_take_count, total_duration).
    This allows showing all scheduled shoot days in the Dailies tab without
    requiring manual dailies day creation.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        # Get all production days for the project
        prod_days_result = client.table("backlot_production_days").select(
            "id, day_number, date, title, location_name, is_completed, general_call_time, wrap_time"
        ).eq("project_id", project_id).order("day_number").execute()

        prod_days = prod_days_result.data or []
        if not prod_days:
            return {"production_days": []}

        prod_day_ids = [d["id"] for d in prod_days]

        # Get all dailies days linked to these production days
        dailies_result = client.table("backlot_dailies_days").select(
            "id, production_day_id, shoot_date, notes, status"
        ).eq("project_id", project_id).in_(
            "production_day_id", prod_day_ids
        ).execute()

        dailies_map = {}
        dailies_day_ids = []
        for d in (dailies_result.data or []):
            if d.get("production_day_id"):
                dailies_map[d["production_day_id"]] = d
                dailies_day_ids.append(d["id"])

        # Get cards for all dailies days
        card_counts = {}
        if dailies_day_ids:
            cards_result = client.table("backlot_dailies_cards").select(
                "id, dailies_day_id"
            ).in_("dailies_day_id", dailies_day_ids).execute()

            for card in (cards_result.data or []):
                day_id = card["dailies_day_id"]
                card_counts[day_id] = card_counts.get(day_id, 0) + 1

        # Get clip stats grouped by production_day_id
        clips_result = client.table("backlot_dailies_clips").select(
            "id, is_circle_take, duration_seconds, production_day_id"
        ).eq("project_id", project_id).execute()

        # Aggregate clip stats per production day
        per_day_clip_stats = {}
        for clip in (clips_result.data or []):
            pd_id = clip.get("production_day_id")
            if pd_id:
                if pd_id not in per_day_clip_stats:
                    per_day_clip_stats[pd_id] = {"count": 0, "circles": 0, "duration": 0}
                per_day_clip_stats[pd_id]["count"] += 1
                if clip.get("is_circle_take"):
                    per_day_clip_stats[pd_id]["circles"] += 1
                per_day_clip_stats[pd_id]["duration"] += clip.get("duration_seconds") or 0

        # Get scene counts for each production day
        scene_counts = {}
        for prod_day in prod_days:
            scenes_result = client.table("backlot_scenes").select(
                "id", count="exact"
            ).eq("scheduled_day_id", prod_day["id"]).execute()
            scene_counts[prod_day["id"]] = scenes_result.count or 0

        # Build response
        result = []
        for prod_day in prod_days:
            dailies_day = dailies_map.get(prod_day["id"])
            dailies_day_id = dailies_day["id"] if dailies_day else None

            day_data = {
                # Production day info
                "production_day_id": prod_day["id"],
                "day_number": prod_day["day_number"],
                "date": prod_day["date"],
                "title": prod_day.get("title"),
                "location_name": prod_day.get("location_name"),
                "is_completed": prod_day.get("is_completed", False),
                "call_time": prod_day.get("general_call_time"),
                "first_shot_time": None,
                "wrap_time": prod_day.get("wrap_time"),
                "scene_count": scene_counts.get(prod_day["id"], 0),
                # Dailies day info (null if not created yet)
                "dailies_day_id": dailies_day_id,
                "dailies_day_label": dailies_day.get("notes") if dailies_day else None,
                "dailies_day_unit": None,
                "dailies_day_status": dailies_day.get("status") if dailies_day else None,
                # Footage stats (per production day via production_day_id on clips)
                "has_footage": per_day_clip_stats.get(prod_day["id"], {}).get("count", 0) > 0,
                "card_count": card_counts.get(dailies_day_id, 0) if dailies_day_id else 0,
                "clip_count": per_day_clip_stats.get(prod_day["id"], {}).get("count", 0),
                "circle_take_count": per_day_clip_stats.get(prod_day["id"], {}).get("circles", 0),
                "total_duration_seconds": per_day_clip_stats.get(prod_day["id"], {}).get("duration", 0),
            }
            result.append(day_data)

        return {"production_days": result}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting production day view: {e}")
        raise HTTPException(status_code=500, detail=str(e))


class AssignClipsInput(BaseModel):
    """Input for assigning/unassigning clips to a production day"""
    clip_ids: list[str]


@router.post("/projects/{project_id}/dailies/production-days/{production_day_id}/assign-clips")
async def assign_clips_to_production_day(
    project_id: str,
    production_day_id: str,
    input: AssignClipsInput,
    authorization: str = Header(None)
):
    """
    Assign clips to a production day by setting their production_day_id.
    Only updates clips that belong to the same project.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"], require_edit=True)

        # Verify production day belongs to this project
        pd_result = client.table("backlot_production_days").select("id").eq(
            "id", production_day_id
        ).eq("project_id", project_id).execute()
        if not pd_result.data:
            raise HTTPException(status_code=404, detail="Production day not found")

        updated_count = 0
        for clip_id in input.clip_ids:
            try:
                client.table("backlot_dailies_clips").update(
                    {"production_day_id": production_day_id}
                ).eq("id", clip_id).eq("project_id", project_id).execute()
                updated_count += 1
            except Exception:
                pass  # Skip clips that don't exist or don't belong to this project

        return {"updated_count": updated_count}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error assigning clips to production day: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/dailies/production-days/{production_day_id}/unassign-clips")
async def unassign_clips_from_production_day(
    project_id: str,
    production_day_id: str,
    input: AssignClipsInput,
    authorization: str = Header(None)
):
    """
    Unassign clips from a production day by setting production_day_id to NULL.
    Only updates clips that belong to the same project and production day.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"], require_edit=True)

        updated_count = 0
        for clip_id in input.clip_ids:
            try:
                client.table("backlot_dailies_clips").update(
                    {"production_day_id": None}
                ).eq("id", clip_id).eq("project_id", project_id).eq(
                    "production_day_id", production_day_id
                ).execute()
                updated_count += 1
            except Exception:
                pass

        return {"updated_count": updated_count}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error unassigning clips from production day: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/dailies/production-days/{production_day_id}/clips")
async def get_production_day_clips(
    project_id: str,
    production_day_id: str,
    authorization: str = Header(None)
):
    """
    Get all clips assigned to a specific production day.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        clips_result = client.table("backlot_dailies_clips").select(
            "id, project_id, file_name, file_path, storage_mode, "
            "cloud_url, duration_seconds, file_size_bytes, timecode_start, frame_rate, "
            "resolution, codec, camera_label, scene_number, take_number, is_circle_take, "
            "is_locked, rating, notes, thumbnail_url, proxy_url, "
            "created_at, updated_at, production_day_id, scene_id"
        ).eq("project_id", project_id).eq(
            "production_day_id", production_day_id
        ).order("created_at").execute()

        return {"clips": clips_result.data or []}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting production day clips: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/dailies/ensure-day-for-production-day")
async def ensure_dailies_day_for_production_day(
    project_id: str,
    input: EnsureDailiesDayInput,
    authorization: str = Header(None)
):
    """
    Ensure a dailies day exists for a production day.

    If a dailies day already exists for the given production day, returns the existing one.
    Otherwise, creates a new dailies day linked to the production day.
    Auto-populates label from production day info.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"], require_edit=True)

        # Check if dailies day already exists for this production day
        existing_result = client.table("backlot_dailies_days").select("*").eq(
            "project_id", project_id
        ).eq("production_day_id", input.production_day_id).limit(1).execute()

        if existing_result.data:
            # Return existing dailies day
            return {"day": existing_result.data[0], "created": False}

        # Get the production day to populate label
        prod_day_result = client.table("backlot_production_days").select(
            "id, day_number, date, title"
        ).eq("id", input.production_day_id).eq(
            "project_id", project_id
        ).single().execute()

        if not prod_day_result.data:
            raise HTTPException(status_code=404, detail="Production day not found")

        prod_day = prod_day_result.data

        # Generate label from production day info
        if prod_day.get("title"):
            label = f"Day {prod_day['day_number']} - {prod_day['title']}"
        else:
            label = f"Day {prod_day['day_number']}"

        # Create new dailies day
        dailies_day_data = {
            "project_id": project_id,
            "production_day_id": input.production_day_id,
            "shoot_date": prod_day["date"],
            "label": label,
            "status": "pending",
            "created_by_user_id": user["id"]
        }

        day_result = client.table("backlot_dailies_days").insert(
            dailies_day_data
        ).execute()

        if not day_result.data:
            raise HTTPException(status_code=500, detail="Failed to create dailies day")

        return {"day": day_result.data[0], "created": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error ensuring dailies day: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/dailies/days/{day_id}/production-day")
async def get_linked_production_day(
    day_id: str,
    authorization: str = Header(None)
):
    """
    Get the production day linked to a dailies day.

    Returns the production day info including scenes scheduled for that day.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get the dailies day
        day_result = client.table("backlot_dailies_days").select(
            "id, project_id, production_day_id"
        ).eq("id", day_id).single().execute()

        if not day_result.data:
            raise HTTPException(status_code=404, detail="Dailies day not found")

        await verify_project_access(client, day_result.data["project_id"], user["id"])

        prod_day_id = day_result.data.get("production_day_id")
        if not prod_day_id:
            return {"production_day": None, "scenes": []}

        # Get the production day
        prod_day_result = client.table("backlot_production_days").select(
            "*"
        ).eq("id", prod_day_id).single().execute()

        if not prod_day_result.data:
            return {"production_day": None, "scenes": []}

        # Get scenes scheduled for this day
        scenes_result = client.table("backlot_scenes").select(
            "id, scene_number, slugline, page_length"
        ).eq("scheduled_day_id", prod_day_id).order("sequence").execute()

        return {
            "production_day": prod_day_result.data,
            "scenes": scenes_result.data or []
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting linked production day: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Offload Manifest API Endpoints (Desktop Helper)
# =====================================================

class OffloadManifestFileInput(BaseModel):
    file_name: str
    relative_path: Optional[str] = None
    file_size_bytes: int = 0
    content_type: Optional[str] = None
    source_checksum: Optional[str] = None
    dest_checksum: Optional[str] = None
    checksum_verified: bool = False


class CreateOffloadManifestInput(BaseModel):
    production_day_id: Optional[str] = None
    manifest_name: str
    source_device: Optional[str] = None
    camera_label: Optional[str] = None
    roll_name: Optional[str] = None
    total_files: int = 0
    total_bytes: int = 0
    create_footage_asset: bool = False
    files: List[OffloadManifestFileInput] = []


@router.post("/projects/{project_id}/dailies/offload-manifest")
async def create_offload_manifest(
    project_id: str,
    input: CreateOffloadManifestInput,
    authorization: str = Header(None)
):
    """
    Create an offload manifest to track footage copied from a camera card.
    Called by the Desktop Helper during offload.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        # Find or create the dailies day for this production day
        dailies_day_id = None
        if input.production_day_id:
            day_result = client.table("backlot_dailies_days").select("id").eq(
                "production_day_id", input.production_day_id
            ).limit(1).execute()

            if day_result.data:
                dailies_day_id = day_result.data[0]["id"]

        # Create the manifest
        manifest_data = {
            "project_id": project_id,
            "production_day_id": input.production_day_id,
            "dailies_day_id": dailies_day_id,
            "manifest_name": input.manifest_name,
            "source_device": input.source_device,
            "camera_label": input.camera_label,
            "roll_name": input.roll_name,
            "total_files": input.total_files,
            "total_bytes": input.total_bytes,
            "offload_status": "pending",
            "upload_status": "pending",
            "create_footage_asset": input.create_footage_asset,
            "created_by_user_id": user["id"]
        }

        manifest_result = client.table("backlot_offload_manifests").insert(
            manifest_data
        ).execute()

        if not manifest_result.data:
            raise HTTPException(status_code=500, detail="Failed to create manifest")

        manifest = manifest_result.data[0]

        # Create manifest file records
        if input.files:
            file_records = [
                {
                    "manifest_id": manifest["id"],
                    "file_name": f.file_name,
                    "relative_path": f.relative_path,
                    "file_size_bytes": f.file_size_bytes,
                    "content_type": f.content_type,
                    "source_checksum": f.source_checksum,
                    "dest_checksum": f.dest_checksum,
                    "checksum_verified": f.checksum_verified,
                    "offload_status": "pending",
                    "upload_status": "pending"
                }
                for f in input.files
            ]

            client.table("backlot_offload_manifest_files").insert(file_records).execute()

        return {"manifest": manifest}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating offload manifest: {e}")
        raise HTTPException(status_code=500, detail=str(e))


class UpdateOffloadManifestInput(BaseModel):
    offload_status: Optional[str] = None
    upload_status: Optional[str] = None
    started_at: Optional[str] = None
    completed_at: Optional[str] = None
    dailies_day_id: Optional[str] = None


@router.patch("/dailies/offload-manifest/{manifest_id}")
async def update_offload_manifest(
    manifest_id: str,
    input: UpdateOffloadManifestInput,
    authorization: str = Header(None)
):
    """Update an offload manifest status."""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get manifest and verify access
        manifest_result = client.table("backlot_offload_manifests").select(
            "id, project_id"
        ).eq("id", manifest_id).single().execute()

        if not manifest_result.data:
            raise HTTPException(status_code=404, detail="Manifest not found")

        await verify_project_access(client, manifest_result.data["project_id"], user["id"])

        # Build update data
        update_data = {}
        if input.offload_status:
            update_data["offload_status"] = input.offload_status
        if input.upload_status:
            update_data["upload_status"] = input.upload_status
        if input.started_at:
            update_data["started_at"] = input.started_at
        if input.completed_at:
            update_data["completed_at"] = input.completed_at
        if input.dailies_day_id:
            update_data["dailies_day_id"] = input.dailies_day_id

        if update_data:
            client.table("backlot_offload_manifests").update(
                update_data
            ).eq("id", manifest_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating offload manifest: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/dailies/offload-manifests")
async def list_offload_manifests(
    project_id: str,
    production_day_id: Optional[str] = None,
    status: Optional[str] = None,
    limit: int = Query(50, ge=1, le=200),
    authorization: str = Header(None)
):
    """List offload manifests for a project."""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        query = client.table("backlot_offload_manifests").select("*").eq(
            "project_id", project_id
        )

        if production_day_id:
            query = query.eq("production_day_id", production_day_id)
        if status:
            query = query.eq("offload_status", status)

        result = query.order("created_at", desc=True).limit(limit).execute()

        return {"manifests": result.data or []}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error listing offload manifests: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Project Credits API Endpoints
# =====================================================

@router.get("/projects/{project_id}/credits")
async def get_project_credits(
    project_id: str,
    authorization: str = Header(None)
):
    """Get all credits for a project"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify project access
        await verify_project_access(client, project_id, user["id"])

        # Get credits ordered by department and order_index
        credits_result = client.table("backlot_project_credits").select("*").eq(
            "project_id", project_id
        ).order("department").order("order_index").execute()

        credits = credits_result.data or []

        # Get linked user profiles
        user_ids = [c["user_id"] for c in credits if c.get("user_id")]
        profiles_map = {}

        if user_ids:
            profiles_result = client.table("profiles").select(
                "id, username, full_name, display_name, avatar_url, role"
            ).in_("id", user_ids).execute()

            for p in (profiles_result.data or []):
                profiles_map[p["id"]] = {
                    "id": str(p["id"]),
                    "username": p.get("username"),
                    "full_name": p.get("full_name"),
                    "display_name": p.get("display_name"),
                    "avatar_url": p.get("avatar_url"),
                    "role": p.get("role")
                }

        # Add linked_user to each credit
        result = []
        for credit in credits:
            credit_data = dict(credit)
            credit_data["id"] = str(credit_data["id"])
            credit_data["project_id"] = str(credit_data["project_id"])
            if credit_data.get("user_id"):
                credit_data["user_id"] = str(credit_data["user_id"])
                credit_data["linked_user"] = profiles_map.get(credit_data["user_id"])
            if credit_data.get("created_by"):
                credit_data["created_by"] = str(credit_data["created_by"])
            if credit_data.get("created_at"):
                credit_data["created_at"] = credit_data["created_at"].isoformat() if hasattr(credit_data["created_at"], 'isoformat') else str(credit_data["created_at"])
            result.append(credit_data)

        return result

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting project credits: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/credits")
async def create_project_credit(
    project_id: str,
    input: ProjectCreditInput,
    authorization: str = Header(None)
):
    """Create a new project credit"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify project access
        await verify_project_access(client, project_id, user["id"])

        credit_data = {
            "project_id": project_id,
            "department": input.department,
            "credit_role": input.credit_role,
            "name": input.name,
            "user_id": input.user_id if input.user_id else None,
            "is_primary": input.is_primary,
            "is_public": input.is_public,
            "order_index": input.order_index,
            "endorsement_note": input.endorsement_note,
            "imdb_id": input.imdb_id,
            "created_by": user["id"]
        }

        result = client.table("backlot_project_credits").insert(credit_data).execute()

        if result.data:
            credit = result.data[0]
            credit["id"] = str(credit["id"])
            credit["project_id"] = str(credit["project_id"])
            if credit.get("user_id"):
                credit["user_id"] = str(credit["user_id"])
            if credit.get("created_by"):
                credit["created_by"] = str(credit["created_by"])
            return credit

        raise HTTPException(status_code=500, detail="Failed to create credit")

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating project credit: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/credits/{credit_id}")
async def update_project_credit(
    credit_id: str,
    input: ProjectCreditInput,
    authorization: str = Header(None)
):
    """Update a project credit"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get credit to verify access
        credit_result = client.table("backlot_project_credits").select("project_id").eq("id", credit_id).execute()
        if not credit_result.data:
            raise HTTPException(status_code=404, detail="Credit not found")

        project_id = credit_result.data[0]["project_id"]
        await verify_project_access(client, str(project_id), user["id"])

        update_data = {
            "department": input.department,
            "credit_role": input.credit_role,
            "name": input.name,
            "user_id": input.user_id if input.user_id else None,
            "is_primary": input.is_primary,
            "is_public": input.is_public,
            "order_index": input.order_index,
            "endorsement_note": input.endorsement_note,
            "imdb_id": input.imdb_id
        }

        result = client.table("backlot_project_credits").update(update_data).eq("id", credit_id).execute()

        if result.data:
            credit = result.data[0]
            credit["id"] = str(credit["id"])
            credit["project_id"] = str(credit["project_id"])
            if credit.get("user_id"):
                credit["user_id"] = str(credit["user_id"])
            if credit.get("created_by"):
                credit["created_by"] = str(credit["created_by"])
            return credit

        raise HTTPException(status_code=500, detail="Failed to update credit")

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating project credit: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/credits/{credit_id}")
async def delete_project_credit(
    credit_id: str,
    authorization: str = Header(None)
):
    """Delete a project credit"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get credit to verify access
        credit_result = client.table("backlot_project_credits").select("project_id").eq("id", credit_id).execute()
        if not credit_result.data:
            raise HTTPException(status_code=404, detail="Credit not found")

        project_id = credit_result.data[0]["project_id"]
        await verify_project_access(client, str(project_id), user["id"])

        client.table("backlot_project_credits").delete().eq("id", credit_id).execute()

        return {"success": True, "message": "Credit deleted"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting project credit: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/credits/{credit_id}/primary")
async def toggle_credit_primary(
    credit_id: str,
    is_primary: bool = Body(..., embed=True),
    authorization: str = Header(None)
):
    """Toggle primary status of a credit"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get credit to verify access
        credit_result = client.table("backlot_project_credits").select("project_id").eq("id", credit_id).execute()
        if not credit_result.data:
            raise HTTPException(status_code=404, detail="Credit not found")

        project_id = credit_result.data[0]["project_id"]
        await verify_project_access(client, str(project_id), user["id"])

        result = client.table("backlot_project_credits").update(
            {"is_primary": is_primary}
        ).eq("id", credit_id).execute()

        if result.data:
            return result.data[0]

        raise HTTPException(status_code=500, detail="Failed to update credit")

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error toggling credit primary: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/credits/{credit_id}/public")
async def toggle_credit_public(
    credit_id: str,
    is_public: bool = Body(..., embed=True),
    authorization: str = Header(None)
):
    """Toggle public visibility of a credit"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get credit to verify access
        credit_result = client.table("backlot_project_credits").select("project_id").eq("id", credit_id).execute()
        if not credit_result.data:
            raise HTTPException(status_code=404, detail="Credit not found")

        project_id = credit_result.data[0]["project_id"]
        await verify_project_access(client, str(project_id), user["id"])

        result = client.table("backlot_project_credits").update(
            {"is_public": is_public}
        ).eq("id", credit_id).execute()

        if result.data:
            return result.data[0]

        raise HTTPException(status_code=500, detail="Failed to update credit")

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error toggling credit public: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/projects/{project_id}/credits/reorder")
async def reorder_project_credits(
    project_id: str,
    credits: List[Dict[str, Any]] = Body(...),
    authorization: str = Header(None)
):
    """Reorder credits within a department"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        # Update each credit's order_index
        for credit in credits:
            client.table("backlot_project_credits").update(
                {"order_index": credit["order_index"]}
            ).eq("id", credit["id"]).execute()

        return {"success": True, "message": "Credits reordered"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error reordering credits: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/credits/public")
async def get_public_project_credits(project_id: str):
    """Get public credits for a project (no auth required)"""
    client = get_client()

    try:
        # Get public credits
        credits_result = client.table("backlot_project_credits").select("*").eq(
            "project_id", project_id
        ).eq("is_public", True).order(
            "is_primary", desc=True
        ).order("department").order("order_index").execute()

        credits = credits_result.data or []

        # Get linked user profiles
        user_ids = [c["user_id"] for c in credits if c.get("user_id")]
        profiles_map = {}

        if user_ids:
            profiles_result = client.table("profiles").select(
                "id, username, full_name, display_name, avatar_url, role"
            ).in_("id", user_ids).execute()

            for p in (profiles_result.data or []):
                profiles_map[p["id"]] = {
                    "id": str(p["id"]),
                    "username": p.get("username"),
                    "full_name": p.get("full_name"),
                    "display_name": p.get("display_name"),
                    "avatar_url": p.get("avatar_url"),
                    "role": p.get("role")
                }

        # Add linked_user to each credit
        result = []
        for credit in credits:
            credit_data = dict(credit)
            credit_data["id"] = str(credit_data["id"])
            credit_data["project_id"] = str(credit_data["project_id"])
            if credit_data.get("user_id"):
                credit_data["user_id"] = str(credit_data["user_id"])
                credit_data["linked_user"] = profiles_map.get(credit_data["user_id"])
            if credit_data.get("created_by"):
                credit_data["created_by"] = str(credit_data["created_by"])
            result.append(credit_data)

        return result

    except Exception as e:
        print(f"Error getting public project credits: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# Department mapping from project roles to credit departments
CREDIT_DEPARTMENT_MAP = {
    'camera': 'Camera',
    'lighting': 'Lighting',
    'grip': 'Lighting',
    'electric': 'Lighting',
    'sound': 'Sound',
    'audio': 'Sound',
    'art': 'Art',
    'production_design': 'Art',
    'wardrobe': 'Costume',
    'costume': 'Costume',
    'makeup': 'Makeup',
    'hair': 'Makeup',
    'production': 'Production',
    'direction': 'Direction',
    'writing': 'Writing',
    'editing': 'Editing',
    'post': 'Editing',
    'vfx': 'Visual Effects',
    'visual_effects': 'Visual Effects',
    'music': 'Music',
    'stunts': 'Stunts',
    'locations': 'Locations',
    'transportation': 'Transportation',
    'catering': 'Catering',
    'craft_services': 'Catering',
    'cast': 'Cast',
    'acting': 'Cast',
}

def map_department_to_credit(dept: str) -> str:
    """Map a project role department to a credit department."""
    if not dept:
        return 'Other'
    normalized = dept.lower().replace(' ', '_').replace('-', '_')
    return CREDIT_DEPARTMENT_MAP.get(normalized, 'Other')


@router.post("/projects/{project_id}/credits/sync")
async def sync_credits_from_roles(
    project_id: str,
    authorization: str = Header(None)
):
    """Sync credits from booked project roles - creates or updates credits."""
    user = await get_current_user_from_token(authorization)
    current_user_id = user["id"]
    client = get_client()

    try:
        # Verify project access
        project_result = client.table("backlot_projects").select("id, owner_id, credit_settings").eq("id", project_id).single().execute()
        if not project_result.data:
            raise HTTPException(status_code=404, detail="Project not found")

        project = project_result.data
        credit_settings = project.get("credit_settings") or {"show_character_name": True}

        # Check permissions
        is_owner = project["owner_id"] == current_user_id
        if not is_owner:
            member_result = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", current_user_id).execute()
            if not member_result.data or member_result.data[0]["role"] not in ["owner", "admin", "manager"]:
                raise HTTPException(status_code=403, detail="Permission denied")

        # Get all booked roles
        roles_result = client.table("backlot_project_roles").select(
            "id, type, title, department, character_name, booked_user_id"
        ).eq("project_id", project_id).not_.is_("booked_user_id", "null").execute()

        booked_roles = roles_result.data or []
        if not booked_roles:
            return {"created": 0, "updated": 0, "unchanged": 0, "message": "No booked roles found"}

        # Get all booked user IDs
        booked_user_ids = list(set([r["booked_user_id"] for r in booked_roles]))

        # Fetch user profiles
        profiles_result = client.table("profiles").select(
            "id, full_name, display_name, username"
        ).in_("id", booked_user_ids).execute()
        profiles_map = {p["id"]: p for p in (profiles_result.data or [])}

        # Fetch credit preferences for these users
        prefs_result = client.table("backlot_credit_preferences").select("*").in_(
            "user_id", booked_user_ids
        ).execute()
        # Map by user_id -> role_id -> pref, plus defaults
        prefs_by_user = {}
        defaults_by_user = {}
        for pref in (prefs_result.data or []):
            uid = pref["user_id"]
            rid = pref.get("role_id")
            if pref.get("use_as_default"):
                defaults_by_user[uid] = pref
            if rid:
                if uid not in prefs_by_user:
                    prefs_by_user[uid] = {}
                prefs_by_user[uid][rid] = pref

        # Get existing auto-created credits
        existing_result = client.table("backlot_project_credits").select(
            "id, source_role_id, user_id, name, credit_role, department"
        ).eq("project_id", project_id).eq("auto_created", True).execute()
        existing_by_role_id = {c["source_role_id"]: c for c in (existing_result.data or []) if c.get("source_role_id")}

        created = 0
        updated = 0
        unchanged = 0

        for role in booked_roles:
            role_id = role["id"]
            user_id = role["booked_user_id"]
            profile = profiles_map.get(user_id, {})

            # Get credit preference (role-specific > default > none)
            user_prefs = prefs_by_user.get(user_id, {})
            pref = user_prefs.get(role_id) or defaults_by_user.get(user_id)

            # Determine credit values
            display_name = (
                (pref.get("display_name") if pref else None) or
                profile.get("display_name") or
                profile.get("full_name") or
                profile.get("username") or
                "Unknown"
            )

            # Credit role: for cast, optionally use character name
            if role["type"] == "cast" and credit_settings.get("show_character_name") and role.get("character_name"):
                credit_role = role["character_name"]
            else:
                credit_role = (pref.get("role_title_preference") if pref else None) or role["title"]

            # Department mapping
            raw_dept = (pref.get("department_preference") if pref else None) or role.get("department")
            department = map_department_to_credit(raw_dept)

            # For cast, force Cast department
            if role["type"] == "cast":
                department = "Cast"

            # Determine if primary (directors, producers, writers, lead cast)
            is_primary = department in ["Direction", "Production", "Writing"] or (
                role["type"] == "cast" and "lead" in role["title"].lower()
            )

            credit_data = {
                "project_id": project_id,
                "user_id": user_id,
                "name": display_name,
                "credit_role": credit_role,
                "department": department,
                "is_primary": is_primary,
                "is_public": pref.get("is_public", True) if pref else True,
                "endorsement_note": pref.get("endorsement_note") if pref else None,
                "imdb_id": pref.get("imdb_id") if pref else None,
                "credit_preference_id": pref["id"] if pref else None,
                "auto_created": True,
                "source_role_id": role_id,
                "updated_at": datetime.utcnow().isoformat(),
            }

            existing = existing_by_role_id.get(role_id)
            if existing:
                # Check if update needed
                needs_update = (
                    existing.get("name") != display_name or
                    existing.get("credit_role") != credit_role or
                    existing.get("department") != department
                )
                if needs_update:
                    client.table("backlot_project_credits").update(credit_data).eq("id", existing["id"]).execute()
                    updated += 1
                else:
                    unchanged += 1
            else:
                # Create new credit
                credit_data["created_by"] = current_user_id
                client.table("backlot_project_credits").insert(credit_data).execute()
                created += 1

        return {
            "created": created,
            "updated": updated,
            "unchanged": unchanged,
            "message": f"Synced {created + updated} credits from {len(booked_roles)} booked roles"
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error syncing credits: {e}")
        raise HTTPException(status_code=500, detail=str(e))


class CreditSettingsInput(BaseModel):
    show_character_name: Optional[bool] = None


@router.get("/projects/{project_id}/credit-settings")
async def get_credit_settings(
    project_id: str,
    authorization: str = Header(None)
):
    """Get credit settings for a project."""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        result = client.table("backlot_projects").select("credit_settings").eq("id", project_id).single().execute()
        if not result.data:
            raise HTTPException(status_code=404, detail="Project not found")

        return result.data.get("credit_settings") or {"show_character_name": True}

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/projects/{project_id}/credit-settings")
async def update_credit_settings(
    project_id: str,
    settings: CreditSettingsInput,
    authorization: str = Header(None)
):
    """Update credit settings for a project."""
    user = await get_current_user_from_token(authorization)
    current_user_id = user["id"]
    client = get_client()

    try:
        # Verify project access
        project_result = client.table("backlot_projects").select("owner_id, credit_settings").eq("id", project_id).single().execute()
        if not project_result.data:
            raise HTTPException(status_code=404, detail="Project not found")

        # Check permissions
        is_owner = project_result.data["owner_id"] == current_user_id
        if not is_owner:
            member_result = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", current_user_id).execute()
            if not member_result.data or member_result.data[0]["role"] not in ["owner", "admin"]:
                raise HTTPException(status_code=403, detail="Permission denied")

        # Merge settings
        current_settings = project_result.data.get("credit_settings") or {}
        if settings.show_character_name is not None:
            current_settings["show_character_name"] = settings.show_character_name

        # Update
        client.table("backlot_projects").update({
            "credit_settings": current_settings,
            "updated_at": datetime.utcnow().isoformat()
        }).eq("id", project_id).execute()

        return current_settings

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Project Updates (Announcements) API Endpoints
# =====================================================

@router.get("/projects/{project_id}/updates")
async def get_project_updates(
    project_id: str,
    type: Optional[str] = None,
    public_only: bool = False,
    limit: int = 50,
    authorization: str = Header(None)
):
    """Get updates/announcements for a project"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        # Build query
        query = client.table("backlot_project_updates").select("*").eq(
            "project_id", project_id
        ).order("created_at", desc=True).limit(limit)

        if type and type != "all":
            query = query.eq("type", type)

        if public_only:
            query = query.eq("is_public", True)

        updates_result = query.execute()
        updates = updates_result.data or []

        if not updates:
            return []

        # Get author profiles
        author_ids = list(set([u["created_by"] for u in updates if u.get("created_by")]))
        profiles_map = {}

        if author_ids:
            profiles_result = client.table("profiles").select(
                "id, username, full_name, display_name, avatar_url, role, is_order_member"
            ).in_("id", author_ids).execute()

            for p in (profiles_result.data or []):
                profiles_map[str(p["id"])] = {
                    "id": str(p["id"]),
                    "username": p.get("username"),
                    "full_name": p.get("full_name"),
                    "display_name": p.get("display_name"),
                    "avatar_url": p.get("avatar_url"),
                    "role": p.get("role"),
                    "is_order_member": p.get("is_order_member")
                }

        # Get read status for current user
        update_ids = [u["id"] for u in updates]
        read_map = {}

        if update_ids:
            reads_result = client.table("backlot_project_update_reads").select(
                "update_id"
            ).eq("user_id", user["id"]).in_("update_id", update_ids).execute()

            for r in (reads_result.data or []):
                read_map[str(r["update_id"])] = True

        # Build response
        result = []
        for update in updates:
            update_data = dict(update)
            update_data["id"] = str(update_data["id"])
            update_data["project_id"] = str(update_data["project_id"])
            update_data["created_by"] = str(update_data["created_by"]) if update_data.get("created_by") else None
            update_data["author"] = profiles_map.get(update_data["created_by"]) if update_data.get("created_by") else None
            update_data["has_read"] = read_map.get(update_data["id"], False)
            if update_data.get("created_at"):
                update_data["created_at"] = update_data["created_at"].isoformat() if hasattr(update_data["created_at"], 'isoformat') else str(update_data["created_at"])
            if update_data.get("updated_at"):
                update_data["updated_at"] = update_data["updated_at"].isoformat() if hasattr(update_data["updated_at"], 'isoformat') else str(update_data["updated_at"])
            result.append(update_data)

        return result

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting project updates: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/updates")
async def create_project_update(
    project_id: str,
    input: ProjectAnnouncementInput,
    authorization: str = Header(None)
):
    """Create a new project update/announcement"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        import json
        update_data = {
            "project_id": project_id,
            "title": input.title,
            "content": input.content,
            "type": input.type,
            "is_public": input.is_public,
            "attachments": json.dumps(input.attachments or []),
            "visible_to_roles": json.dumps(input.visible_to_roles or []),
            "created_by": user["id"]
        }

        result = client.table("backlot_project_updates").insert(update_data).execute()

        if result.data:
            update = result.data[0]
            update["id"] = str(update["id"])
            update["project_id"] = str(update["project_id"])
            update["created_by"] = str(update["created_by"]) if update.get("created_by") else None
            return update

        raise HTTPException(status_code=500, detail="Failed to create update")

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating project update: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/updates/{update_id}")
async def get_project_update(
    update_id: str,
    authorization: str = Header(None)
):
    """Get a single project update"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        update_result = client.table("backlot_project_updates").select("*").eq("id", update_id).execute()
        if not update_result.data:
            raise HTTPException(status_code=404, detail="Update not found")

        update = update_result.data[0]
        await verify_project_access(client, str(update["project_id"]), user["id"])

        # Get author profile
        if update.get("created_by"):
            author_result = client.table("profiles").select(
                "id, username, full_name, display_name, avatar_url, role, is_order_member"
            ).eq("id", update["created_by"]).execute()

            if author_result.data:
                author = author_result.data[0]
                update["author"] = {
                    "id": str(author["id"]),
                    "username": author.get("username"),
                    "full_name": author.get("full_name"),
                    "display_name": author.get("display_name"),
                    "avatar_url": author.get("avatar_url"),
                    "role": author.get("role"),
                    "is_order_member": author.get("is_order_member")
                }

        update["id"] = str(update["id"])
        update["project_id"] = str(update["project_id"])
        update["created_by"] = str(update["created_by"]) if update.get("created_by") else None

        return update

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting project update: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/updates/{update_id}")
async def update_project_update(
    update_id: str,
    input: ProjectAnnouncementInput,
    authorization: str = Header(None)
):
    """Update a project update/announcement"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get update to verify access
        update_result = client.table("backlot_project_updates").select("project_id").eq("id", update_id).execute()
        if not update_result.data:
            raise HTTPException(status_code=404, detail="Update not found")

        project_id = update_result.data[0]["project_id"]
        await verify_project_access(client, str(project_id), user["id"])

        import json
        update_data = {
            "title": input.title,
            "content": input.content,
            "type": input.type,
            "is_public": input.is_public,
            "attachments": json.dumps(input.attachments or [])
        }

        result = client.table("backlot_project_updates").update(update_data).eq("id", update_id).execute()

        if result.data:
            update = result.data[0]
            update["id"] = str(update["id"])
            update["project_id"] = str(update["project_id"])
            update["created_by"] = str(update["created_by"]) if update.get("created_by") else None
            return update

        raise HTTPException(status_code=500, detail="Failed to update")

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating project update: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/updates/{update_id}")
async def delete_project_update(
    update_id: str,
    authorization: str = Header(None)
):
    """Delete a project update/announcement"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get update to verify access
        update_result = client.table("backlot_project_updates").select("project_id").eq("id", update_id).execute()
        if not update_result.data:
            raise HTTPException(status_code=404, detail="Update not found")

        project_id = update_result.data[0]["project_id"]
        await verify_project_access(client, str(project_id), user["id"])

        client.table("backlot_project_updates").delete().eq("id", update_id).execute()

        return {"success": True, "message": "Update deleted"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting project update: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/updates/{update_id}/public")
async def toggle_update_public(
    update_id: str,
    is_public: bool = Body(..., embed=True),
    authorization: str = Header(None)
):
    """Toggle public visibility of an update"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get update to verify access
        update_result = client.table("backlot_project_updates").select("project_id").eq("id", update_id).execute()
        if not update_result.data:
            raise HTTPException(status_code=404, detail="Update not found")

        project_id = update_result.data[0]["project_id"]
        await verify_project_access(client, str(project_id), user["id"])

        result = client.table("backlot_project_updates").update(
            {"is_public": is_public}
        ).eq("id", update_id).execute()

        if result.data:
            return result.data[0]

        raise HTTPException(status_code=500, detail="Failed to update")

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error toggling update public: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/updates/{update_id}/read")
async def mark_update_as_read(
    update_id: str,
    authorization: str = Header(None)
):
    """Mark an update as read for the current user"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # First check if the update exists
        update_check = client.table("backlot_project_updates").select("id").eq("id", update_id).execute()
        if not update_check.data:
            # Update doesn't exist - just return success to prevent frontend retries
            return {"success": True, "message": "Update not found, skipped"}

        # Upsert read record
        client.table("backlot_project_update_reads").upsert({
            "update_id": update_id,
            "user_id": user["id"]
        }, on_conflict="update_id,user_id").execute()

        return {"success": True, "message": "Marked as read"}

    except Exception as e:
        print(f"Error marking update as read: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/updates/public")
async def get_public_project_updates(
    project_id: str,
    limit: int = 10
):
    """Get public updates for a project (no auth required)"""
    client = get_client()

    try:
        updates_result = client.table("backlot_project_updates").select("*").eq(
            "project_id", project_id
        ).eq("is_public", True).order("created_at", desc=True).limit(limit).execute()

        updates = updates_result.data or []

        if not updates:
            return []

        # Get author profiles
        author_ids = list(set([u["created_by"] for u in updates if u.get("created_by")]))
        profiles_map = {}

        if author_ids:
            profiles_result = client.table("profiles").select(
                "id, username, full_name, display_name, avatar_url, role, is_order_member"
            ).in_("id", author_ids).execute()

            for p in (profiles_result.data or []):
                profiles_map[str(p["id"])] = {
                    "id": str(p["id"]),
                    "username": p.get("username"),
                    "full_name": p.get("full_name"),
                    "display_name": p.get("display_name"),
                    "avatar_url": p.get("avatar_url"),
                    "role": p.get("role"),
                    "is_order_member": p.get("is_order_member")
                }

        # Build response
        result = []
        for update in updates:
            update_data = dict(update)
            update_data["id"] = str(update_data["id"])
            update_data["project_id"] = str(update_data["project_id"])
            update_data["created_by"] = str(update_data["created_by"]) if update_data.get("created_by") else None
            update_data["author"] = profiles_map.get(update_data["created_by"]) if update_data.get("created_by") else None
            result.append(update_data)

        return result

    except Exception as e:
        print(f"Error getting public project updates: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Backlot Team Member Roles API Endpoints
# =====================================================

class BacklotMemberRoleInput(BaseModel):
    """Input for assigning a team member role"""
    user_id: str
    backlot_role: str  # showrunner, producer, director, etc.
    is_primary: bool = False


@router.get("/projects/{project_id}/member-roles")
async def get_project_member_roles(
    project_id: str,
    authorization: str = Header(None)
):
    """Get all team member roles for a project"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        roles_result = client.table("backlot_project_roles").select("*").eq(
            "project_id", project_id
        ).order("created_at").execute()

        roles = roles_result.data or []

        if not roles:
            return []

        # Get user profiles
        user_ids = list(set([r["user_id"] for r in roles if r.get("user_id")]))
        profiles_map = {}

        if user_ids:
            profiles_result = client.table("profiles").select(
                "id, username, full_name, display_name, avatar_url, role, is_order_member"
            ).in_("id", user_ids).execute()

            for p in (profiles_result.data or []):
                profiles_map[str(p["id"])] = {
                    "id": str(p["id"]),
                    "username": p.get("username"),
                    "full_name": p.get("full_name"),
                    "display_name": p.get("display_name"),
                    "avatar_url": p.get("avatar_url"),
                    "role": p.get("role"),
                    "is_order_member": p.get("is_order_member")
                }

        # Build response
        result = []
        for role in roles:
            role_data = dict(role)
            role_data["id"] = str(role_data["id"])
            role_data["project_id"] = str(role_data["project_id"])
            role_data["user_id"] = str(role_data["user_id"]) if role_data.get("user_id") else None
            role_data["profile"] = profiles_map.get(role_data["user_id"]) if role_data.get("user_id") else None
            result.append(role_data)

        return result

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting project member roles: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/member-roles")
async def assign_member_role(
    project_id: str,
    input: BacklotMemberRoleInput,
    authorization: str = Header(None)
):
    """Assign a team member role"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        # If setting as primary, clear other primary roles for this user
        if input.is_primary:
            client.table("backlot_project_roles").update(
                {"is_primary": False}
            ).eq("project_id", project_id).eq("user_id", input.user_id).execute()

        # Upsert the role
        role_data = {
            "project_id": project_id,
            "user_id": input.user_id,
            "backlot_role": input.backlot_role,
            "is_primary": input.is_primary
        }

        result = client.table("backlot_project_roles").upsert(
            role_data, on_conflict="project_id,user_id,backlot_role"
        ).execute()

        if result.data:
            role = result.data[0]
            role["id"] = str(role["id"])
            role["project_id"] = str(role["project_id"])
            role["user_id"] = str(role["user_id"]) if role.get("user_id") else None
            return role

        raise HTTPException(status_code=500, detail="Failed to assign role")

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error assigning member role: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/member-roles/{role_id}")
async def remove_member_role(
    role_id: str,
    authorization: str = Header(None)
):
    """Remove a team member role"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get role to verify access
        role_result = client.table("backlot_project_roles").select("project_id").eq("id", role_id).execute()
        if not role_result.data:
            raise HTTPException(status_code=404, detail="Role not found")

        project_id = role_result.data[0]["project_id"]
        await verify_project_access(client, str(project_id), user["id"])

        client.table("backlot_project_roles").delete().eq("id", role_id).execute()

        return {"success": True, "message": "Role removed"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error removing member role: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/member-roles/{role_id}/primary")
async def set_primary_member_role(
    role_id: str,
    authorization: str = Header(None)
):
    """Set a role as the primary role for the user"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get role info
        role_result = client.table("backlot_project_roles").select(
            "project_id, user_id"
        ).eq("id", role_id).execute()

        if not role_result.data:
            raise HTTPException(status_code=404, detail="Role not found")

        role_info = role_result.data[0]
        project_id = role_info["project_id"]
        role_user_id = role_info["user_id"]

        await verify_project_access(client, str(project_id), user["id"])

        # Clear other primary roles for this user
        client.table("backlot_project_roles").update(
            {"is_primary": False}
        ).eq("project_id", project_id).eq("user_id", role_user_id).execute()

        # Set this role as primary
        result = client.table("backlot_project_roles").update(
            {"is_primary": True}
        ).eq("id", role_id).execute()

        if result.data:
            return result.data[0]

        raise HTTPException(status_code=500, detail="Failed to update role")

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error setting primary role: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/my-roles")
async def get_my_project_roles(
    project_id: str,
    authorization: str = Header(None)
):
    """Get current user's roles in a project"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        roles_result = client.table("backlot_project_roles").select("*").eq(
            "project_id", project_id
        ).eq("user_id", user["id"]).execute()

        roles = roles_result.data or []

        result = []
        for role in roles:
            role_data = dict(role)
            role_data["id"] = str(role_data["id"])
            role_data["project_id"] = str(role_data["project_id"])
            role_data["user_id"] = str(role_data["user_id"]) if role_data.get("user_id") else None
            result.append(role_data)

        return result

    except Exception as e:
        print(f"Error getting my project roles: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/view-config")
async def get_view_config(
    project_id: str,
    view_as_role: Optional[str] = None,
    authorization: str = Header(None)
):
    """Get effective view config for the current user"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Default view configs
        default_configs = {
            "showrunner": {
                "tabs": {
                    "overview": True, "script": True, "shot-lists": True, "coverage": True,
                    "schedule": True, "call-sheets": True, "casting": True, "locations": True,
                    "gear": True, "dailies": True, "review": True, "assets": True,
                    "budget": True, "daily-budget": True, "receipts": True, "analytics": True,
                    "tasks": True, "updates": True, "contacts": True,
                    "clearances": True, "credits": True, "roles": True, "settings": True,
                },
                "sections": {"budget_numbers": True, "admin_tools": True},
            },
            "crew": {
                "tabs": {
                    "overview": True, "script": True, "shot-lists": False, "coverage": False,
                    "schedule": True, "call-sheets": True, "casting": False, "locations": False,
                    "gear": False, "dailies": False, "review": False, "assets": False,
                    "budget": False, "daily-budget": False, "receipts": False, "analytics": False,
                    "tasks": True, "updates": True, "contacts": False,
                    "clearances": False, "credits": False, "roles": False, "settings": False,
                },
                "sections": {"budget_numbers": False, "admin_tools": False},
            },
        }

        # If viewing as a specific role (admin feature)
        if view_as_role:
            config = default_configs.get(view_as_role, default_configs["crew"])
            return {"role": view_as_role, **config}

        user_id = user["id"]

        # Check if user is project owner
        project_result = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        if project_result.data and str(project_result.data[0]["owner_id"]) == str(user_id):
            return {"role": "owner", **default_configs["showrunner"]}

        # Check user's profile for admin status
        profile_result = client.table("profiles").select("role").eq("id", user_id).execute()
        if profile_result.data:
            profile_role = profile_result.data[0].get("role")
            if profile_role in ["admin", "superadmin"]:
                return {"role": "admin", **default_configs["showrunner"]}

        # Get user's primary backlot role
        roles_result = client.table("backlot_project_roles").select(
            "backlot_role, is_primary"
        ).eq("project_id", project_id).eq("user_id", user_id).order(
            "is_primary", desc=True
        ).execute()

        roles = roles_result.data or []
        primary_role = next((r["backlot_role"] for r in roles if r.get("is_primary")), None)
        if not primary_role and roles:
            primary_role = roles[0]["backlot_role"]
        if not primary_role:
            primary_role = "crew"

        # Check for custom view profile
        view_result = client.table("backlot_project_view_profiles").select("config").eq(
            "project_id", project_id
        ).eq("backlot_role", primary_role).eq("is_default", True).execute()

        if view_result.data and view_result.data[0].get("config"):
            return {"role": primary_role, "config": view_result.data[0]["config"]}

        # Return default config
        config = default_configs.get(primary_role, default_configs["crew"])
        return {"role": primary_role, **config}

    except Exception as e:
        print(f"Error getting view config: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# GEAR MANAGEMENT
# =====================================================

@router.get("/projects/{project_id}/gear")
async def get_project_gear(
    project_id: str,
    category: Optional[str] = None,
    status: Optional[str] = None,
    limit: int = Query(100, le=500),
    authorization: str = Header(None)
):
    """Get all gear items for a project"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        query = client.table("backlot_gear_items").select("*").eq("project_id", project_id)

        if category:
            query = query.eq("category", category)
        if status:
            query = query.eq("status", status)

        query = query.order("category").order("name").limit(limit)
        result = query.execute()

        gear_items = result.data or []

        # Fetch assignee profiles
        user_ids = set()
        for g in gear_items:
            if g.get("assigned_to"):
                user_ids.add(g["assigned_to"])

        profile_map = {}
        if user_ids:
            profiles_result = client.table("profiles").select(
                "id, username, full_name, display_name, avatar_url"
            ).in_("id", list(user_ids)).execute()
            profile_map = {p["id"]: p for p in (profiles_result.data or [])}

        for g in gear_items:
            g["assignee"] = profile_map.get(g.get("assigned_to"))

        return {"gear": gear_items}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting gear: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/gear/{gear_id}/enriched")
async def get_enriched_gear_item(
    gear_id: str,
    authorization: str = Header(None)
):
    """Get gear item with full rental order, work order, and org details."""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # 1. Get base gear item
        gear = execute_single(
            "SELECT * FROM backlot_gear_items WHERE id = :id",
            {"id": gear_id}
        )

        if not gear:
            raise HTTPException(status_code=404, detail="Gear item not found")

        # Verify project access
        await verify_project_access(client, gear["project_id"], user["id"])

        # 2. Get rental order if linked (parse from notes field)
        rental_order = None
        import re

        if gear.get("notes") and "Rental Request:" in gear["notes"]:
            # Parse rental request ID from notes
            match = re.search(r'Rental Request: ([a-f0-9-]+)', gear["notes"])
            if match:
                request_id = match.group(1)

                # Get rental order from request via backlot_project_id
                rental_order = execute_single(
                    """
                    SELECT ro.*,
                           org.name as rental_house_name,
                           org.logo_url as rental_house_logo
                    FROM gear_rental_orders ro
                    LEFT JOIN organizations org ON org.id = ro.rental_house_org_id
                    WHERE ro.backlot_project_id = :project_id
                    ORDER BY ro.created_at DESC
                    LIMIT 1
                    """,
                    {"project_id": gear["project_id"]}
                )

                if rental_order:
                    # Get all order items
                    rental_order["items"] = execute_query(
                        """
                        SELECT roi.*, ga.name as asset_name
                        FROM gear_rental_order_items roi
                        LEFT JOIN gear_assets ga ON ga.id = roi.asset_id
                        WHERE roi.order_id = :order_id
                        ORDER BY roi.sort_order
                        """,
                        {"order_id": rental_order["id"]}
                    )

        # 3. Get work order if linked (parse from notes field)
        work_order = None
        if gear.get("notes") and "Work Order:" in gear["notes"]:
            match = re.search(r'Work Order: (WO-\d+)', gear["notes"])
            if match:
                wo_number = match.group(1)
                work_order = execute_single(
                    """
                    SELECT wo.*,
                           assigned.display_name as assigned_to_name,
                           custodian.display_name as custodian_user_name
                    FROM gear_work_orders wo
                    LEFT JOIN profiles assigned ON assigned.id = wo.assigned_to
                    LEFT JOIN profiles custodian ON custodian.id = wo.custodian_user_id
                    WHERE wo.reference_number = :ref_num
                    """,
                    {"ref_num": wo_number}
                )

                if work_order:
                    # Get work order items
                    work_order["items"] = execute_query(
                        """
                        SELECT woi.*,
                               ga.name as asset_name,
                               staged_by_prof.display_name as staged_by_name
                        FROM gear_work_order_items woi
                        LEFT JOIN gear_assets ga ON ga.id = woi.asset_id
                        LEFT JOIN profiles staged_by_prof ON staged_by_prof.id = woi.staged_by
                        WHERE woi.work_order_id = :wo_id
                        ORDER BY woi.sort_order
                        """,
                        {"wo_id": work_order["id"]}
                    )

        # 4. Get organization details if rental house
        organization = None
        marketplace_settings = None
        if gear.get("rental_house"):
            # Find org by name
            organization = execute_single(
                "SELECT * FROM organizations WHERE name ILIKE :name LIMIT 1",
                {"name": gear["rental_house"]}
            )

            if organization:
                # Get marketplace settings for contact info
                marketplace_settings = execute_single(
                    "SELECT * FROM gear_marketplace_settings WHERE organization_id = :org_id",
                    {"org_id": organization["id"]}
                )

        # 5. Get assignee profile if assigned
        assignee = None
        if gear.get("assigned_to"):
            assignee = execute_single(
                """
                SELECT id, username, full_name, display_name, avatar_url
                FROM profiles WHERE id = :id
                """,
                {"id": gear["assigned_to"]}
            )

        # 6. Get assigned production day if linked
        assigned_day = None
        if gear.get("assigned_production_day_id"):
            assigned_day = execute_single(
                "SELECT * FROM backlot_production_days WHERE id = :id",
                {"id": gear["assigned_production_day_id"]}
            )

        return {
            "gear": gear,
            "rental_order": rental_order,
            "work_order": work_order,
            "organization": organization,
            "marketplace_settings": marketplace_settings,
            "assignee": assignee,
            "assigned_day": assigned_day,
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting enriched gear item: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/gear/{gear_id}")
async def get_gear_item(
    gear_id: str,
    authorization: str = Header(None)
):
    """Get a single gear item"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        result = client.table("backlot_gear_items").select("*").eq("id", gear_id).execute()
        if not result.data:
            raise HTTPException(status_code=404, detail="Gear item not found")

        gear = result.data[0]
        await verify_project_access(client, gear["project_id"], user["id"])

        # Fetch assignee if exists
        if gear.get("assigned_to"):
            profile_result = client.table("profiles").select(
                "id, username, full_name, display_name, avatar_url"
            ).eq("id", gear["assigned_to"]).execute()
            gear["assignee"] = profile_result.data[0] if profile_result.data else None

        return {"gear": gear}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting gear item: {e}")
        raise HTTPException(status_code=500, detail=str(e))



@router.post("/projects/{project_id}/gear")
async def create_gear_item(
    project_id: str,
    gear: dict = Body(...),
    authorization: str = Header(None)
):
    """Create a gear item"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Convert Cognito user ID to profile ID
        profile_id = get_profile_id_from_cognito_id(user["id"]) or user["id"]
        await verify_project_access(client, project_id, profile_id)

        # Helper to convert empty strings to None for date fields
        def to_nullable(val):
            return val if val else None

        gear_data = {
            "project_id": project_id,
            "name": gear.get("name"),
            "category": to_nullable(gear.get("category")),
            "description": to_nullable(gear.get("description")),
            "serial_number": to_nullable(gear.get("serial_number")),
            "asset_tag": to_nullable(gear.get("asset_tag")),
            "status": gear.get("status", "available"),
            "is_owned": gear.get("is_owned", False),
            "rental_house": to_nullable(gear.get("rental_house")),
            "rental_cost_per_day": gear.get("rental_cost_per_day"),
            "assigned_to": to_nullable(gear.get("assigned_to")),
            "assigned_production_day_id": to_nullable(gear.get("assigned_production_day_id")),
            "pickup_date": to_nullable(gear.get("pickup_date")),
            "return_date": to_nullable(gear.get("return_date")),
            "notes": to_nullable(gear.get("notes")),
            "condition_notes": to_nullable(gear.get("condition_notes")),
        }

        result = client.table("backlot_gear_items").insert(gear_data).execute()

        created_item = result.data[0] if result.data else None

        # Auto-record budget actual if rental gear (is_owned=false)
        if created_item and not created_item.get("is_owned"):
            from app.services.budget_actuals import record_gear_item_actual
            import logging
            logger = logging.getLogger(__name__)

            try:
                budget_actual = record_gear_item_actual(
                    gear_item=created_item,
                    created_by=profile_id
                )

                if budget_actual:
                    logger.info(f"Recorded budget actual for gear item {created_item['id']}")
            except Exception as e:
                logger.error(f"Error recording budget actual for gear item: {e}")
                # Don't fail the gear creation if budget recording fails

        return {"gear": created_item}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating gear: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/gear/{gear_id}")
async def update_gear_item(
    gear_id: str,
    gear: dict = Body(...),
    authorization: str = Header(None)
):
    """Update a gear item"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        existing = client.table("backlot_gear_items").select("project_id").eq("id", gear_id).execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Gear item not found")

        # Convert Cognito user ID to profile ID
        profile_id = get_profile_id_from_cognito_id(user["id"]) or user["id"]
        await verify_project_access(client, existing.data[0]["project_id"], profile_id)

        # Helper to convert empty strings to None for date/nullable fields
        def to_nullable(val):
            return val if val else None

        nullable_fields = ["category", "description", "serial_number", "asset_tag",
                          "rental_house", "assigned_to", "assigned_production_day_id",
                          "pickup_date", "return_date", "notes", "condition_notes"]

        update_data = {}
        for field in ["name", "category", "description", "serial_number", "asset_tag",
                      "status", "is_owned", "rental_house", "rental_cost_per_day",
                      "assigned_to", "assigned_production_day_id", "pickup_date",
                      "return_date", "notes", "condition_notes"]:
            if field in gear:
                if field in nullable_fields:
                    update_data[field] = to_nullable(gear[field])
                else:
                    update_data[field] = gear[field]

        result = client.table("backlot_gear_items").update(update_data).eq("id", gear_id).execute()

        return {"gear": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating gear: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/gear/{gear_id}/status")
async def update_gear_status(
    gear_id: str,
    status: str = Query(...),
    authorization: str = Header(None)
):
    """Update gear item status"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        existing = client.table("backlot_gear_items").select("project_id").eq("id", gear_id).execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Gear item not found")

        # Convert Cognito user ID to profile ID
        profile_id = get_profile_id_from_cognito_id(user["id"]) or user["id"]
        await verify_project_access(client, existing.data[0]["project_id"], profile_id)

        result = client.table("backlot_gear_items").update({"status": status}).eq("id", gear_id).execute()

        return {"gear": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating gear status: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/gear/{gear_id}")
async def delete_gear_item(
    gear_id: str,
    authorization: str = Header(None)
):
    """Delete a gear item"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        existing = client.table("backlot_gear_items").select("project_id").eq("id", gear_id).execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Gear item not found")

        # Convert Cognito user ID to profile ID
        profile_id = get_profile_id_from_cognito_id(user["id"]) or user["id"]
        await verify_project_access(client, existing.data[0]["project_id"], profile_id)

        client.table("backlot_gear_items").delete().eq("id", gear_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting gear: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/gear/categories")
async def get_gear_categories(
    project_id: str,
    authorization: str = Header(None)
):
    """Get unique gear categories for a project"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        result = client.table("backlot_gear_items").select("category").eq(
            "project_id", project_id
        ).execute()

        # Filter out null categories
        categories = list(set(item["category"] for item in (result.data or []) if item.get("category")))
        categories.sort()

        return {"categories": categories}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting gear categories: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/gear/costs")
async def get_gear_costs(
    project_id: str,
    authorization: str = Header(None)
):
    """
    Get gear cost summary for a project.
    Returns:
    - total_rental_cost: Sum of all gear rental costs
    - total_purchase_cost: Sum of owned gear purchase costs
    - by_category: Breakdown by gear category
    - by_day: Daily breakdown based on pickup/return dates
    - items: List of gear with calculated costs
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        # Get all gear items for project
        result = client.table("backlot_gear_items").select(
            "id, name, category, is_owned, rental_house, rental_cost_per_day, "
            "pickup_date, return_date, purchase_cost, budget_line_item_id, status"
        ).eq("project_id", project_id).execute()

        items = result.data or []

        # Calculate costs for each item
        total_rental = 0.0
        total_purchase = 0.0
        by_category = {}
        items_with_costs = []

        for item in items:
            rental_cost = 0.0
            rental_days = 0

            # Calculate rental cost if applicable
            if not item.get("is_owned") and item.get("rental_cost_per_day"):
                daily_rate = float(item["rental_cost_per_day"])
                if item.get("pickup_date") and item.get("return_date"):
                    from datetime import datetime
                    pickup = datetime.fromisoformat(item["pickup_date"])
                    return_date = datetime.fromisoformat(item["return_date"])
                    rental_days = (return_date - pickup).days + 1
                    rental_cost = daily_rate * rental_days
                    total_rental += rental_cost

            # Get purchase cost for owned gear
            purchase = float(item.get("purchase_cost") or 0)
            if item.get("is_owned") and purchase:
                total_purchase += purchase

            # Group by category
            cat = item.get("category") or "Uncategorized"
            if cat not in by_category:
                by_category[cat] = {"rental_cost": 0, "purchase_cost": 0, "count": 0}
            by_category[cat]["rental_cost"] += rental_cost
            by_category[cat]["purchase_cost"] += purchase if item.get("is_owned") else 0
            by_category[cat]["count"] += 1

            items_with_costs.append({
                **item,
                "calculated_rental_cost": rental_cost,
                "rental_days": rental_days,
                "daily_rate": float(item.get("rental_cost_per_day") or 0)
            })

        # Calculate daily breakdown
        by_day = {}
        for item in items_with_costs:
            if item.get("pickup_date") and item.get("return_date") and item.get("daily_rate"):
                from datetime import datetime, timedelta
                pickup = datetime.fromisoformat(item["pickup_date"])
                return_date = datetime.fromisoformat(item["return_date"])
                current = pickup
                while current <= return_date:
                    day_key = current.strftime("%Y-%m-%d")
                    if day_key not in by_day:
                        by_day[day_key] = {"total": 0, "items": []}
                    by_day[day_key]["total"] += item["daily_rate"]
                    by_day[day_key]["items"].append({
                        "id": item["id"],
                        "name": item["name"],
                        "daily_rate": item["daily_rate"]
                    })
                    current += timedelta(days=1)

        return {
            "total_rental_cost": total_rental,
            "total_purchase_cost": total_purchase,
            "total_cost": total_rental + total_purchase,
            "by_category": by_category,
            "by_day": by_day,
            "items": items_with_costs
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting gear costs: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/rental-orders")
async def get_project_rental_orders(
    project_id: str,
    authorization: str = Header(None)
):
    """
    Get all rental orders associated with a backlot project.
    Returns rental orders with their items and current status.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        # Get rental orders linked to this project
        orders = execute_query(
            """
            SELECT ro.*,
                   o.name as rental_house_name,
                   o.avatar_url as rental_house_avatar
            FROM gear_rental_orders ro
            JOIN organizations o ON o.id = ro.rental_house_org_id
            WHERE ro.backlot_project_id = :project_id
            ORDER BY ro.created_at DESC
            """,
            {"project_id": project_id}
        )

        # Get items for each order
        for order in orders:
            items = execute_query(
                """
                SELECT roi.*,
                       ga.name as asset_name,
                       ga.serial_number,
                       bg.id as backlot_gear_id
                FROM gear_rental_order_items roi
                LEFT JOIN gear_assets ga ON ga.id = roi.asset_id
                LEFT JOIN backlot_gear_items bg ON bg.gear_rental_order_item_id = roi.id
                WHERE roi.order_id = :order_id
                ORDER BY roi.sort_order
                """,
                {"order_id": order["id"]}
            )
            order["items"] = items

        return orders

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting rental orders: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/rental-summary")
async def get_rental_summary(
    project_id: str,
    authorization: str = Header(None)
):
    """
    Get rental order summary for a backlot project.
    Returns:
    - active_rentals_count: Number of active rental orders
    - total_daily_cost: Total cost per day across all active rentals
    - total_weekly_cost: Total cost per week
    - total_monthly_cost: Total cost per month
    - upcoming_pickups: Rentals with upcoming pickup dates
    - pending_returns: Rentals with upcoming/overdue return dates
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        from datetime import datetime, timedelta

        now = datetime.now()
        upcoming_window = now + timedelta(days=7)

        # Get all rental gear items for this project
        gear_items = execute_query(
            """
            SELECT bg.*,
                   ro.order_number,
                   ro.status as order_status,
                   ro.rental_start_date,
                   ro.rental_end_date
            FROM backlot_gear_items bg
            JOIN gear_rental_order_items roi ON roi.id = bg.gear_rental_order_item_id
            JOIN gear_rental_orders ro ON ro.id = roi.order_id
            WHERE bg.project_id = :project_id
              AND bg.gear_rental_order_item_id IS NOT NULL
            ORDER BY bg.pickup_date
            """,
            {"project_id": project_id}
        )

        # Calculate summary metrics
        active_rentals_count = 0
        total_daily_cost = 0.0
        total_weekly_cost = 0.0
        total_monthly_cost = 0.0
        upcoming_pickups = []
        pending_returns = []

        for item in gear_items:
            order_status = item.get("order_status", "")

            # Count active rentals (not cancelled or returned)
            if order_status in ["confirmed", "building", "ready_for_pickup", "picked_up", "in_use"]:
                active_rentals_count += 1

                # Sum costs
                if item.get("rental_cost_per_day"):
                    total_daily_cost += float(item["rental_cost_per_day"])

                if item.get("rental_weekly_rate"):
                    total_weekly_cost += float(item["rental_weekly_rate"])

                if item.get("rental_monthly_rate"):
                    total_monthly_cost += float(item["rental_monthly_rate"])

            # Check for upcoming pickups
            if item.get("pickup_date"):
                pickup_date = datetime.fromisoformat(str(item["pickup_date"]))
                if now <= pickup_date <= upcoming_window:
                    days_until = (pickup_date - now).days
                    upcoming_pickups.append({
                        "order_id": item.get("order_number"),
                        "item_name": item.get("name"),
                        "pickup_date": str(item["pickup_date"]),
                        "days_until": days_until
                    })

            # Check for pending returns
            if item.get("return_date") and order_status in ["picked_up", "in_use"]:
                return_date = datetime.fromisoformat(str(item["return_date"]))
                days_until = (return_date - now).days
                is_overdue = days_until < 0

                pending_returns.append({
                    "order_id": item.get("order_number"),
                    "item_name": item.get("name"),
                    "return_date": str(item["return_date"]),
                    "days_until": days_until,
                    "is_overdue": is_overdue
                })

        # Sort lists
        upcoming_pickups.sort(key=lambda x: x["days_until"])
        pending_returns.sort(key=lambda x: x["days_until"])

        return {
            "active_rentals_count": active_rentals_count,
            "total_daily_cost": round(total_daily_cost, 2),
            "total_weekly_cost": round(total_weekly_cost, 2),
            "total_monthly_cost": round(total_monthly_cost, 2),
            "upcoming_pickups": upcoming_pickups[:5],  # Top 5 upcoming
            "pending_returns": pending_returns
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting rental summary: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/budget/sync-gear")
async def sync_gear_to_budget(
    project_id: str,
    create_line_items: bool = True,
    update_actuals: bool = True,
    category_name: str = "Equipment Rental",
    authorization: str = Header(None)
):
    """
    Sync gear costs to budget.
    - create_line_items: Create new line items for unlinked gear
    - update_actuals: Update actual totals on linked line items
    - category_name: Budget category to use for new items
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        # Get project budget
        budget_result = client.table("backlot_budgets").select("id").eq(
            "project_id", project_id
        ).limit(1).execute()

        if not budget_result.data:
            raise HTTPException(status_code=404, detail="No budget found for project")

        budget_id = budget_result.data[0]["id"]

        # Get or create the Equipment category
        # First try exact match
        cat_result = client.table("backlot_budget_categories").select("id, name").eq(
            "budget_id", budget_id
        ).eq("name", category_name).limit(1).execute()

        if cat_result.data:
            category_id = cat_result.data[0]["id"]
        else:
            # Try to find similar category (e.g., "Equipment Rental" vs "Equipment Rentals")
            all_cats = client.table("backlot_budget_categories").select("id, name").eq(
                "budget_id", budget_id
            ).execute()

            category_id = None
            search_term = category_name.lower().rstrip('s')  # Remove trailing 's' for matching
            for cat in (all_cats.data or []):
                cat_name_normalized = cat["name"].lower().rstrip('s')
                if cat_name_normalized == search_term or search_term in cat_name_normalized:
                    category_id = cat["id"]
                    break

            if not category_id:
                # Create category only if no match found
                new_cat = client.table("backlot_budget_categories").insert({
                    "budget_id": budget_id,
                    "name": category_name,
                    "sort_order": 100
                }).execute()
                category_id = new_cat.data[0]["id"]

        # Get all gear items
        gear_result = client.table("backlot_gear_items").select(
            "id, name, category, is_owned, rental_cost_per_day, "
            "pickup_date, return_date, purchase_cost, budget_line_item_id"
        ).eq("project_id", project_id).execute()

        items = gear_result.data or []
        created = 0
        updated = 0
        linked = 0

        for item in items:
            # Calculate total cost
            total_cost = 0.0
            if not item.get("is_owned") and item.get("rental_cost_per_day"):
                if item.get("pickup_date") and item.get("return_date"):
                    from datetime import datetime
                    pickup = datetime.fromisoformat(item["pickup_date"])
                    return_date = datetime.fromisoformat(item["return_date"])
                    days = (return_date - pickup).days + 1
                    total_cost = float(item["rental_cost_per_day"]) * days
            elif item.get("is_owned") and item.get("purchase_cost"):
                total_cost = float(item["purchase_cost"])

            if total_cost == 0:
                continue

            # Check if linked line item still exists AND has a valid category
            line_item_valid = False
            if item.get("budget_line_item_id"):
                check_result = client.table("backlot_budget_line_items").select("id, category_id").eq(
                    "id", item["budget_line_item_id"]
                ).limit(1).execute()
                # Line item is only valid if it exists AND has a category (not orphaned)
                if check_result.data and check_result.data[0].get("category_id"):
                    line_item_valid = True

                if not line_item_valid:
                    # Clear the stale/orphaned reference and delete orphaned line item if exists
                    if check_result.data:
                        # Delete orphaned line item (has no category)
                        client.table("backlot_budget_line_items").delete().eq(
                            "id", item["budget_line_item_id"]
                        ).execute()
                    client.table("backlot_gear_items").update({
                        "budget_line_item_id": None
                    }).eq("id", item["id"]).execute()

            if line_item_valid and update_actuals:
                # Update existing line item actual
                try:
                    client.table("backlot_budget_line_items").update({
                        "actual_total": total_cost,
                        "updated_at": "now()"
                    }).eq("id", item["budget_line_item_id"]).execute()
                    updated += 1
                except:
                    pass
            elif not line_item_valid and create_line_items:
                # Create new line item and link
                # Note: estimated_total is a GENERATED column, don't set it directly
                line_item = client.table("backlot_budget_line_items").insert({
                    "budget_id": budget_id,
                    "category_id": category_id,
                    "description": f"{item['name']} ({item.get('category', 'Gear')})",
                    "actual_total": total_cost,
                    "notes": f"Auto-synced from gear: {item['name']}"
                }).execute()

                if line_item.data:
                    # Link gear item to budget line item
                    client.table("backlot_gear_items").update({
                        "budget_line_item_id": line_item.data[0]["id"]
                    }).eq("id", item["id"]).execute()
                    created += 1
                    linked += 1

        return {
            "success": True,
            "created": created,
            "updated": updated,
            "linked": linked,
            "category_id": category_id
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error syncing gear to budget: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/daily-budgets/{daily_budget_id}/gear-costs")
async def get_daily_gear_costs(
    daily_budget_id: str,
    authorization: str = Header(None)
):
    """
    Get gear costs for a specific daily budget.
    Returns gear that is active on this day (by date range or manual assignment).
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get daily budget with its date and project
        db_result = client.table("backlot_daily_budgets").select(
            "id, shoot_date, production_day_id, "
            "budget:backlot_budgets(id, project_id)"
        ).eq("id", daily_budget_id).limit(1).execute()

        if not db_result.data:
            raise HTTPException(status_code=404, detail="Daily budget not found")

        daily_budget = db_result.data[0]
        shoot_date = daily_budget.get("shoot_date")
        production_day_id = daily_budget.get("production_day_id")
        project_id = daily_budget["budget"]["project_id"]

        await verify_project_access(client, project_id, user["id"])

        # Get gear items active on this day
        # Method 1: Date range - shoot_date falls between pickup and return
        # Method 2: Manual assignment via assigned_production_day_id

        gear_items = []

        if shoot_date:
            # Get items by date range
            range_result = client.table("backlot_gear_items").select(
                "id, name, category, rental_cost_per_day, rental_house, "
                "pickup_date, return_date, is_owned, purchase_cost, status"
            ).eq("project_id", project_id).lte(
                "pickup_date", shoot_date
            ).gte("return_date", shoot_date).execute()

            for item in (range_result.data or []):
                item["source"] = "date_range"
                gear_items.append(item)

        if production_day_id:
            # Get items manually assigned to this production day
            assigned_result = client.table("backlot_gear_items").select(
                "id, name, category, rental_cost_per_day, rental_house, "
                "pickup_date, return_date, is_owned, purchase_cost, status"
            ).eq("project_id", project_id).eq(
                "assigned_production_day_id", production_day_id
            ).execute()

            existing_ids = {i["id"] for i in gear_items}
            for item in (assigned_result.data or []):
                if item["id"] not in existing_ids:
                    item["source"] = "manual_assignment"
                    gear_items.append(item)

        # Calculate daily total
        daily_total = 0.0
        items_with_costs = []

        for item in gear_items:
            daily_cost = 0.0
            if not item.get("is_owned") and item.get("rental_cost_per_day"):
                daily_cost = float(item["rental_cost_per_day"])
                daily_total += daily_cost

            items_with_costs.append({
                **item,
                "daily_cost": daily_cost
            })

        return {
            "daily_budget_id": daily_budget_id,
            "shoot_date": shoot_date,
            "gear_total": daily_total,
            "items": items_with_costs
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting daily gear costs: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# SIMPLE TASKS (project-based, not task-list based)
# =====================================================

@router.get("/projects/{project_id}/simple-tasks")
async def get_project_simple_tasks(
    project_id: str,
    status: Optional[str] = None,
    priority: Optional[str] = None,
    assigned_to: Optional[str] = None,
    department: Optional[str] = None,
    production_day_id: Optional[str] = None,
    parent_only: bool = True,
    limit: int = Query(100, le=500),
    authorization: str = Header(None)
):
    """Get simple tasks for a project (direct backlot_tasks query)"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        query = client.table("backlot_tasks").select("*").eq("project_id", project_id)

        if parent_only:
            query = query.is_("parent_task_id", "null")
        if status:
            query = query.eq("status", status)
        if priority:
            query = query.eq("priority", priority)
        if assigned_to:
            query = query.eq("assigned_to", assigned_to)
        if department:
            query = query.eq("department", department)
        if production_day_id:
            query = query.eq("production_day_id", production_day_id)

        query = query.order("position").limit(limit)
        result = query.execute()

        tasks = result.data or []

        # Fetch profiles for assigned users and creators
        user_ids = set()
        for t in tasks:
            if t.get("assigned_to"):
                user_ids.add(t["assigned_to"])
            if t.get("created_by"):
                user_ids.add(t["created_by"])

        profile_map = {}
        if user_ids:
            profiles_result = client.table("profiles").select(
                "id, username, full_name, display_name, avatar_url"
            ).in_("id", list(user_ids)).execute()
            profile_map = {p["id"]: p for p in (profiles_result.data or [])}

        # Fetch subtasks
        task_ids = [t["id"] for t in tasks]
        subtask_map = {}
        if task_ids:
            subtasks_result = client.table("backlot_tasks").select("*").in_(
                "parent_task_id", task_ids
            ).order("position").execute()

            for st in (subtasks_result.data or []):
                parent_id = st["parent_task_id"]
                if parent_id not in subtask_map:
                    subtask_map[parent_id] = []
                st["assignee"] = profile_map.get(st.get("assigned_to"))
                st["creator"] = profile_map.get(st.get("created_by"))
                subtask_map[parent_id].append(st)

        for t in tasks:
            t["assignee"] = profile_map.get(t.get("assigned_to"))
            t["creator"] = profile_map.get(t.get("created_by"))
            t["subtasks"] = subtask_map.get(t["id"], [])

        return {"tasks": tasks}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting simple tasks: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/simple-tasks/{task_id}")
async def get_simple_task(
    task_id: str,
    authorization: str = Header(None)
):
    """Get a single simple task"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        result = client.table("backlot_tasks").select("*").eq("id", task_id).execute()
        if not result.data:
            raise HTTPException(status_code=404, detail="Task not found")

        task = result.data[0]
        await verify_project_access(client, task["project_id"], user["id"])

        # Fetch profiles
        user_ids = set()
        if task.get("assigned_to"):
            user_ids.add(task["assigned_to"])
        if task.get("created_by"):
            user_ids.add(task["created_by"])

        profile_map = {}
        if user_ids:
            profiles_result = client.table("profiles").select(
                "id, username, full_name, display_name, avatar_url"
            ).in_("id", list(user_ids)).execute()
            profile_map = {p["id"]: p for p in (profiles_result.data or [])}

        task["assignee"] = profile_map.get(task.get("assigned_to"))
        task["creator"] = profile_map.get(task.get("created_by"))

        # Fetch subtasks
        subtasks_result = client.table("backlot_tasks").select("*").eq(
            "parent_task_id", task_id
        ).order("position").execute()
        task["subtasks"] = subtasks_result.data or []

        return {"task": task}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting simple task: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/simple-tasks")
async def create_simple_task(
    project_id: str,
    task: dict = Body(...),
    authorization: str = Header(None)
):
    """Create a simple task"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        # Get max position
        parent_task_id = task.get("parent_task_id")
        pos_query = client.table("backlot_tasks").select("position").eq(
            "project_id", project_id
        )
        if parent_task_id:
            pos_query = pos_query.eq("parent_task_id", parent_task_id)
        else:
            pos_query = pos_query.is_("parent_task_id", "null")
        pos_result = pos_query.order("position", desc=True).limit(1).execute()

        max_pos = pos_result.data[0]["position"] if pos_result.data else -1
        new_position = task.get("position", max_pos + 1)

        task_data = {
            "project_id": project_id,
            "title": task.get("title"),
            "description": task.get("description"),
            "status": task.get("status", "todo"),
            "priority": task.get("priority", "medium"),
            "assigned_to": task.get("assigned_to"),
            "department": task.get("department"),
            "due_date": task.get("due_date"),
            "parent_task_id": parent_task_id,
            "production_day_id": task.get("production_day_id"),
            "position": new_position,
            "created_by": user["id"],
        }

        result = client.table("backlot_tasks").insert(task_data).execute()

        return {"task": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating simple task: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/simple-tasks/{task_id}")
async def update_simple_task(
    task_id: str,
    task: dict = Body(...),
    authorization: str = Header(None)
):
    """Update a simple task"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        existing = client.table("backlot_tasks").select("project_id").eq("id", task_id).execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Task not found")

        await verify_project_access(client, existing.data[0]["project_id"], user["id"])

        update_data = {}
        for field in ["title", "description", "status", "priority", "assigned_to",
                      "department", "due_date", "parent_task_id", "production_day_id", "position"]:
            if field in task:
                update_data[field] = task[field]

        # Handle completed_at
        if "status" in task:
            if task["status"] == "completed":
                update_data["completed_at"] = datetime.utcnow().isoformat()
            else:
                update_data["completed_at"] = None

        result = client.table("backlot_tasks").update(update_data).eq("id", task_id).execute()

        return {"task": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating simple task: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/simple-tasks/{task_id}/status")
async def update_simple_task_status(
    task_id: str,
    status: str = Query(...),
    authorization: str = Header(None)
):
    """Update simple task status"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        existing = client.table("backlot_tasks").select("project_id").eq("id", task_id).execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Task not found")

        await verify_project_access(client, existing.data[0]["project_id"], user["id"])

        update_data = {"status": status}
        if status == "completed":
            update_data["completed_at"] = datetime.utcnow().isoformat()
        else:
            update_data["completed_at"] = None

        result = client.table("backlot_tasks").update(update_data).eq("id", task_id).execute()

        return {"task": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating simple task status: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/simple-tasks/{task_id}")
async def delete_simple_task(
    task_id: str,
    authorization: str = Header(None)
):
    """Delete a simple task"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        existing = client.table("backlot_tasks").select("project_id").eq("id", task_id).execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Task not found")

        await verify_project_access(client, existing.data[0]["project_id"], user["id"])

        client.table("backlot_tasks").delete().eq("id", task_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting simple task: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/simple-tasks/reorder")
async def reorder_simple_tasks(
    project_id: str,
    task_ids: List[str] = Body(...),
    authorization: str = Header(None)
):
    """Reorder simple tasks"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        for index, task_id in enumerate(task_ids):
            client.table("backlot_tasks").update({"position": index}).eq("id", task_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error reordering tasks: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/simple-tasks/stats")
async def get_simple_task_stats(
    project_id: str,
    authorization: str = Header(None)
):
    """Get task statistics for a project"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        result = client.table("backlot_tasks").select("status").eq("project_id", project_id).execute()

        tasks = result.data or []
        stats = {
            "total": len(tasks),
            "todo": sum(1 for t in tasks if t.get("status") == "todo"),
            "in_progress": sum(1 for t in tasks if t.get("status") == "in_progress"),
            "review": sum(1 for t in tasks if t.get("status") == "review"),
            "completed": sum(1 for t in tasks if t.get("status") == "completed"),
            "blocked": sum(1 for t in tasks if t.get("status") == "blocked"),
        }

        return stats

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting task stats: {e}")
        return {
            "total": 0, "todo": 0, "in_progress": 0,
            "review": 0, "completed": 0, "blocked": 0
        }


# =====================================================
# PRODUCTION DAYS CRUD
# =====================================================

@router.get("/projects/{project_id}/production-days")
async def get_production_days(
    project_id: str,
    authorization: str = Header(None)
):
    """Get all production days for a project"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        result = client.table("backlot_production_days").select("*").eq(
            "project_id", project_id
        ).order("day_number").execute()

        return {"days": result.data or []}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting production days: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/production-days/{day_id}")
async def get_production_day(
    day_id: str,
    authorization: str = Header(None)
):
    """Get a single production day"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        result = client.table("backlot_production_days").select("*").eq("id", day_id).execute()
        if not result.data:
            raise HTTPException(status_code=404, detail="Production day not found")

        day = result.data[0]
        await verify_project_access(client, day["project_id"], user["id"])

        return {"day": day}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting production day: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/production-days")
async def create_production_day(
    project_id: str,
    day: dict = Body(...),
    authorization: str = Header(None)
):
    """Create a production day"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        # Convert empty strings to None for time fields (PostgreSQL requires valid time or NULL)
        general_call_time = day.get("general_call_time")
        wrap_time = day.get("wrap_time")
        if general_call_time == "":
            general_call_time = None
        if wrap_time == "":
            wrap_time = None

        day_data = {
            "project_id": project_id,
            "day_number": day.get("day_number"),
            "date": day.get("date") or None,
            "title": day.get("title") or None,
            "description": day.get("description") or None,
            "general_call_time": general_call_time,
            "wrap_time": wrap_time,
            "location_id": day.get("location_id") or None,
            "location_name": day.get("location_name") or None,
            "location_address": day.get("location_address") or None,
            "notes": day.get("notes") or None,
            "weather_notes": day.get("weather_notes") or None,
        }

        result = client.table("backlot_production_days").insert(day_data).execute()

        # Trigger DOOD auto-sync for new production day
        if result.data:
            try:
                from app.api.dood import trigger_dood_sync
                import asyncio
                asyncio.create_task(trigger_dood_sync(
                    project_id, "production_day_added", result.data[0]["id"]
                ))
            except Exception:
                pass  # DOOD sync is optional, don't fail the main operation

        return {"day": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating production day: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/production-days/{day_id}")
async def update_production_day(
    day_id: str,
    day: dict = Body(...),
    authorization: str = Header(None)
):
    """Update a production day"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        existing = client.table("backlot_production_days").select("project_id").eq("id", day_id).execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Production day not found")

        await verify_project_access(client, existing.data[0]["project_id"], user["id"])

        update_data = {}
        for field in ["day_number", "date", "title", "description", "general_call_time",
                      "wrap_time", "location_id", "location_name", "location_address",
                      "notes", "weather_notes", "is_completed"]:
            if field in day:
                value = day[field]
                # Convert empty strings to None for time fields
                if field in ["general_call_time", "wrap_time"] and value == "":
                    value = None
                # Convert empty strings to None for text/uuid fields
                elif field in ["title", "description", "location_id", "location_name",
                              "location_address", "notes", "weather_notes", "date"] and value == "":
                    value = None
                update_data[field] = value

        result = client.table("backlot_production_days").update(update_data).eq("id", day_id).execute()

        # Auto-sync to linked call sheets
        if result.data:
            updated_day = result.data[0]
            project_id = updated_day.get("project_id") or existing.data[0]["project_id"]

            # Find call sheets linked to this production day
            linked_sheets = client.table("backlot_call_sheets").select("id").eq(
                "production_day_id", day_id
            ).execute()

            if linked_sheets.data:
                # Build sync data for call sheets
                sync_data = {}

                # Map production day fields to call sheet fields
                if "date" in update_data:
                    sync_data["date"] = update_data["date"]
                if "day_number" in update_data:
                    sync_data["shoot_day_number"] = update_data["day_number"]
                if "general_call_time" in update_data:
                    sync_data["crew_call_time"] = update_data["general_call_time"]
                    sync_data["general_call_time"] = update_data["general_call_time"]
                if "wrap_time" in update_data:
                    sync_data["estimated_wrap_time"] = update_data["wrap_time"]
                if "location_name" in update_data:
                    sync_data["location_name"] = update_data["location_name"]
                if "location_address" in update_data:
                    sync_data["location_address"] = update_data["location_address"]

                # Only sync if there are fields to sync
                if sync_data:
                    for sheet in linked_sheets.data:
                        try:
                            client.table("backlot_call_sheets").update(sync_data).eq(
                                "id", sheet["id"]
                            ).execute()
                        except Exception as sync_error:
                            print(f"Warning: Failed to sync to call sheet {sheet['id']}: {sync_error}")

        return {"day": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating production day: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/production-days/{day_id}/completed")
async def mark_production_day_completed(
    day_id: str,
    completed: bool = Query(...),
    authorization: str = Header(None)
):
    """Mark a production day as completed or not"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        existing = client.table("backlot_production_days").select("project_id").eq("id", day_id).execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Production day not found")

        await verify_project_access(client, existing.data[0]["project_id"], user["id"])

        result = client.table("backlot_production_days").update(
            {"is_completed": completed}
        ).eq("id", day_id).execute()

        return {"day": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error marking day completed: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# PRODUCTION DAY AD NOTES
# =====================================================

@router.get("/production-days/{day_id}/ad-notes")
async def get_production_day_ad_notes(
    day_id: str,
    authorization: str = Header(None)
):
    """Get AD notes for a production day"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        existing = client.table("backlot_production_days").select("project_id, ad_notes").eq("id", day_id).execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Production day not found")

        await verify_project_access(client, existing.data[0]["project_id"], user["id"])

        return {"notes": existing.data[0].get("ad_notes")}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting AD notes: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/production-days/{day_id}/ad-notes")
async def update_production_day_ad_notes(
    day_id: str,
    body: dict,
    authorization: str = Header(None)
):
    """Update AD notes for a production day (optimized for auto-save)"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        existing = client.table("backlot_production_days").select("project_id").eq("id", day_id).execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Production day not found")

        await verify_project_access(client, existing.data[0]["project_id"], user["id"])

        notes = body.get("notes", "")
        result = client.table("backlot_production_days").update(
            {"ad_notes": notes}
        ).eq("id", day_id).execute()

        return {"success": True, "notes": notes}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating AD notes: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# AD NOTE ENTRIES (Version History System)
# =====================================================

class AdNoteEntryInput(BaseModel):
    content: str


class AdNoteCommentInput(BaseModel):
    content: str
    parent_comment_id: Optional[str] = None


@router.get("/production-days/{day_id}/ad-note-entries")
async def get_ad_note_entries(
    day_id: str,
    include_drafts: bool = False,
    authorization: str = Header(None)
):
    """Get all published note entries for a production day (with optional drafts)"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify production day exists and get project_id
        day_result = client.table("backlot_production_days").select("project_id").eq("id", day_id).execute()
        if not day_result.data:
            raise HTTPException(status_code=404, detail="Production day not found")

        project_id = day_result.data[0]["project_id"]
        await verify_project_access(client, project_id, user["id"])

        # Build query for entries
        query = client.table("backlot_ad_note_entries").select("*").eq("production_day_id", day_id)

        if not include_drafts:
            query = query.eq("is_draft", False)

        result = query.order("created_at", desc=True).execute()

        entries = result.data or []

        # Get creator profiles for all entries
        creator_ids = list(set(e["created_by"] for e in entries if e.get("created_by")))
        profiles = {}
        if creator_ids:
            profiles_result = client.table("profiles").select("id, display_name, avatar_url").in_("id", creator_ids).execute()
            profiles = {p["id"]: p for p in (profiles_result.data or [])}

        # Get comment counts for each entry
        entry_ids = [e["id"] for e in entries]
        comment_counts = {}
        if entry_ids:
            for entry_id in entry_ids:
                count_result = client.table("backlot_ad_note_comments").select("id").eq("entry_id", entry_id).execute()
                comment_counts[entry_id] = len(count_result.data or [])

        # Enrich entries with creator info and comment counts
        for entry in entries:
            creator_id = entry.get("created_by")
            if creator_id and creator_id in profiles:
                entry["creator"] = profiles[creator_id]
            entry["comment_count"] = comment_counts.get(entry["id"], 0)

        return {"entries": entries}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting AD note entries: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/production-days/{day_id}/ad-note-draft")
async def get_ad_note_draft(
    day_id: str,
    authorization: str = Header(None)
):
    """Get or create current user's draft for a production day"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    client = get_client()

    try:
        # Verify production day exists and get project_id
        day_result = client.table("backlot_production_days").select("project_id").eq("id", day_id).execute()
        if not day_result.data:
            raise HTTPException(status_code=404, detail="Production day not found")

        project_id = day_result.data[0]["project_id"]
        await verify_project_access(client, project_id, user["id"])

        # Look for existing draft
        draft_result = client.table("backlot_ad_note_entries").select("*").eq("production_day_id", day_id).eq("created_by", profile_id).eq("is_draft", True).execute()

        if draft_result.data:
            return {"draft": draft_result.data[0]}

        # No draft exists, return null (don't create until user starts typing)
        return {"draft": None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting AD note draft: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/production-days/{day_id}/ad-note-draft")
async def save_ad_note_draft(
    day_id: str,
    body: AdNoteEntryInput,
    authorization: str = Header(None)
):
    """Save/update current user's draft for a production day (auto-save)"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    client = get_client()

    try:
        # Verify production day exists and get project_id
        day_result = client.table("backlot_production_days").select("project_id").eq("id", day_id).execute()
        if not day_result.data:
            raise HTTPException(status_code=404, detail="Production day not found")

        project_id = day_result.data[0]["project_id"]
        await verify_project_access(client, project_id, user["id"])

        # Look for existing draft
        draft_result = client.table("backlot_ad_note_entries").select("id").eq("production_day_id", day_id).eq("created_by", profile_id).eq("is_draft", True).execute()

        if draft_result.data:
            # Update existing draft
            result = client.table("backlot_ad_note_entries").update({
                "content": body.content,
                "updated_at": datetime.now(timezone.utc).isoformat()
            }).eq("id", draft_result.data[0]["id"]).execute()
            return {"draft": result.data[0] if result.data else None}
        else:
            # Create new draft
            result = client.table("backlot_ad_note_entries").insert({
                "production_day_id": day_id,
                "project_id": project_id,
                "content": body.content,
                "is_draft": True,
                "version_number": 0,
                "created_by": profile_id
            }).execute()
            return {"draft": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error saving AD note draft: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/production-days/{day_id}/ad-note-entries")
async def publish_ad_note(
    day_id: str,
    body: AdNoteEntryInput,
    authorization: str = Header(None)
):
    """Publish a new AD note entry (creates new version)"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    client = get_client()

    try:
        # Verify production day exists and get project_id
        day_result = client.table("backlot_production_days").select("project_id").eq("id", day_id).execute()
        if not day_result.data:
            raise HTTPException(status_code=404, detail="Production day not found")

        project_id = day_result.data[0]["project_id"]
        await verify_project_access(client, project_id, user["id"])

        # Get the latest version number
        latest_result = client.table("backlot_ad_note_entries").select("id, version_number").eq("production_day_id", day_id).eq("is_draft", False).order("version_number", desc=True).limit(1).execute()

        latest_version = 0
        parent_entry_id = None
        if latest_result.data:
            latest_version = latest_result.data[0]["version_number"]
            parent_entry_id = latest_result.data[0]["id"]

        new_version = latest_version + 1

        # Create published entry
        result = client.table("backlot_ad_note_entries").insert({
            "production_day_id": day_id,
            "project_id": project_id,
            "content": body.content,
            "is_draft": False,
            "version_number": new_version,
            "parent_entry_id": parent_entry_id,
            "created_by": profile_id
        }).execute()

        new_entry = result.data[0] if result.data else None

        # Delete user's draft if it exists
        client.table("backlot_ad_note_entries").delete().eq("production_day_id", day_id).eq("created_by", profile_id).eq("is_draft", True).execute()

        # Also update the legacy ad_notes field for backwards compatibility
        client.table("backlot_production_days").update({
            "ad_notes": body.content
        }).eq("id", day_id).execute()

        # Enrich with creator info
        if new_entry:
            profile_result = client.table("profiles").select("id, display_name, avatar_url").eq("id", profile_id).execute()
            if profile_result.data:
                new_entry["creator"] = profile_result.data[0]
            new_entry["comment_count"] = 0

        return {"entry": new_entry}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error publishing AD note: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/ad-note-entries/{entry_id}")
async def update_ad_note_entry(
    entry_id: str,
    body: AdNoteEntryInput,
    authorization: str = Header(None)
):
    """Update an existing AD note entry (creator only)"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    client = get_client()

    try:
        # Get entry and verify ownership
        entry_result = client.table("backlot_ad_note_entries").select("*").eq("id", entry_id).execute()
        if not entry_result.data:
            raise HTTPException(status_code=404, detail="Entry not found")

        entry = entry_result.data[0]

        if entry["created_by"] != profile_id:
            raise HTTPException(status_code=403, detail="Only the creator can edit this entry")

        # Update entry
        result = client.table("backlot_ad_note_entries").update({
            "content": body.content,
            "updated_at": datetime.now(timezone.utc).isoformat()
        }).eq("id", entry_id).execute()

        return {"entry": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating AD note entry: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# AD NOTE COMMENTS
# =====================================================

@router.get("/ad-note-entries/{entry_id}/comments")
async def get_ad_note_comments(
    entry_id: str,
    authorization: str = Header(None)
):
    """Get comments for an AD note entry (with threading)"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get entry and verify project access
        entry_result = client.table("backlot_ad_note_entries").select("project_id").eq("id", entry_id).execute()
        if not entry_result.data:
            raise HTTPException(status_code=404, detail="Entry not found")

        await verify_project_access(client, entry_result.data[0]["project_id"], user["id"])

        # Get all comments for this entry
        comments_result = client.table("backlot_ad_note_comments").select("*").eq("entry_id", entry_id).order("created_at", desc=False).execute()

        comments = comments_result.data or []

        # Get creator profiles
        creator_ids = list(set(c["created_by"] for c in comments if c.get("created_by")))
        profiles = {}
        if creator_ids:
            profiles_result = client.table("profiles").select("id, display_name, avatar_url").in_("id", creator_ids).execute()
            profiles = {p["id"]: p for p in (profiles_result.data or [])}

        # Enrich comments with creator info
        for comment in comments:
            creator_id = comment.get("created_by")
            if creator_id and creator_id in profiles:
                comment["creator"] = profiles[creator_id]

        # Build nested tree structure
        def build_tree(comments, parent_id=None):
            tree = []
            for comment in comments:
                if comment.get("parent_comment_id") == parent_id:
                    comment["replies"] = build_tree(comments, comment["id"])
                    tree.append(comment)
            return tree

        comment_tree = build_tree(comments)

        return {"comments": comment_tree}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting AD note comments: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/ad-note-entries/{entry_id}/comments")
async def add_ad_note_comment(
    entry_id: str,
    body: AdNoteCommentInput,
    authorization: str = Header(None)
):
    """Add a comment to an AD note entry"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    client = get_client()

    try:
        # Get entry and verify project access
        entry_result = client.table("backlot_ad_note_entries").select("project_id").eq("id", entry_id).execute()
        if not entry_result.data:
            raise HTTPException(status_code=404, detail="Entry not found")

        await verify_project_access(client, entry_result.data[0]["project_id"], user["id"])

        # Validate parent comment if provided
        if body.parent_comment_id:
            parent_result = client.table("backlot_ad_note_comments").select("id").eq("id", body.parent_comment_id).eq("entry_id", entry_id).execute()
            if not parent_result.data:
                raise HTTPException(status_code=400, detail="Parent comment not found")

        # Create comment
        result = client.table("backlot_ad_note_comments").insert({
            "entry_id": entry_id,
            "parent_comment_id": body.parent_comment_id,
            "content": body.content,
            "created_by": profile_id
        }).execute()

        new_comment = result.data[0] if result.data else None

        # Enrich with creator info
        if new_comment:
            profile_result = client.table("profiles").select("id, display_name, avatar_url").eq("id", profile_id).execute()
            if profile_result.data:
                new_comment["creator"] = profile_result.data[0]
            new_comment["replies"] = []

        return {"comment": new_comment}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error adding AD note comment: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/ad-note-comments/{comment_id}")
async def update_ad_note_comment(
    comment_id: str,
    body: AdNoteCommentInput,
    authorization: str = Header(None)
):
    """Update a comment (creator only)"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    client = get_client()

    try:
        # Get comment and verify ownership
        comment_result = client.table("backlot_ad_note_comments").select("*").eq("id", comment_id).execute()
        if not comment_result.data:
            raise HTTPException(status_code=404, detail="Comment not found")

        comment = comment_result.data[0]

        if comment["created_by"] != profile_id:
            raise HTTPException(status_code=403, detail="Only the creator can edit this comment")

        # Update comment
        result = client.table("backlot_ad_note_comments").update({
            "content": body.content,
            "updated_at": datetime.now(timezone.utc).isoformat(),
            "is_edited": True
        }).eq("id", comment_id).execute()

        return {"comment": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating AD note comment: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/ad-note-comments/{comment_id}")
async def delete_ad_note_comment(
    comment_id: str,
    authorization: str = Header(None)
):
    """Delete a comment (creator only)"""
    user = await get_current_user_from_token(authorization)
    cognito_user_id = user.get("user_id") or user.get("id")
    profile_id = get_profile_id_from_cognito_id(cognito_user_id)
    client = get_client()

    try:
        # Get comment and verify ownership
        comment_result = client.table("backlot_ad_note_comments").select("created_by").eq("id", comment_id).execute()
        if not comment_result.data:
            raise HTTPException(status_code=404, detail="Comment not found")

        if comment_result.data[0]["created_by"] != profile_id:
            raise HTTPException(status_code=403, detail="Only the creator can delete this comment")

        # Delete comment (cascade will handle replies)
        client.table("backlot_ad_note_comments").delete().eq("id", comment_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting AD note comment: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/production-days/{day_id}")
async def delete_production_day(
    day_id: str,
    authorization: str = Header(None)
):
    """Delete a production day"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        existing = client.table("backlot_production_days").select("project_id").eq("id", day_id).execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Production day not found")

        project_id = existing.data[0]["project_id"]
        await verify_project_access(client, project_id, user["id"])

        # Trigger DOOD auto-sync to clean up assignments for this day
        try:
            from app.api.dood import trigger_dood_sync
            import asyncio
            asyncio.create_task(trigger_dood_sync(
                project_id, "production_day_deleted", day_id
            ))
        except Exception:
            pass  # DOOD sync is optional

        client.table("backlot_production_days").delete().eq("id", day_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting production day: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# PRODUCTION DAY / CALL SHEET SYNC
# =====================================================

@router.get("/production-days/{day_id}/sync-status")
async def get_production_day_sync_status(
    day_id: str,
    authorization: str = Header(None)
):
    """Get sync status between production day and linked call sheet"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get production day with all syncable fields
        day_result = client.table("backlot_production_days").select(
            "id, project_id, date, day_number, title, general_call_time, wrap_time, "
            "location_name, location_address, updated_at"
        ).eq("id", day_id).execute()

        if not day_result.data:
            raise HTTPException(status_code=404, detail="Production day not found")

        day = day_result.data[0]
        await verify_project_access(client, day["project_id"], user["id"])

        # Find linked call sheet
        sheet_result = client.table("backlot_call_sheets").select(
            "id, date, shoot_day_number, title, crew_call_time, general_call_time, "
            "estimated_wrap_time, location_name, location_address, updated_at"
        ).eq("production_day_id", day_id).limit(1).execute()

        if not sheet_result.data:
            return {
                "has_linked_call_sheet": False,
                "call_sheet_id": None,
                "is_in_sync": True,
                "stale_entity": None,
                "fields_differ": [],
                "day_updated_at": day.get("updated_at"),
                "sheet_updated_at": None
            }

        sheet = sheet_result.data[0]

        # Compare fields
        fields_differ = []

        # Date comparison
        if day.get("date") != sheet.get("date"):
            fields_differ.append("date")

        # Day number comparison
        if day.get("day_number") != sheet.get("shoot_day_number"):
            fields_differ.append("day_number")

        # Call time comparison (production day general_call_time vs call sheet crew_call_time/general_call_time)
        day_call_time = day.get("general_call_time")
        sheet_call_time = sheet.get("general_call_time") or sheet.get("crew_call_time")
        if day_call_time != sheet_call_time:
            fields_differ.append("call_time")

        # Wrap time comparison
        if day.get("wrap_time") != sheet.get("estimated_wrap_time"):
            fields_differ.append("wrap_time")

        # Location name comparison
        if day.get("location_name") != sheet.get("location_name"):
            fields_differ.append("location_name")

        # Location address comparison
        if day.get("location_address") != sheet.get("location_address"):
            fields_differ.append("location_address")

        # Title comparison
        if day.get("title") != sheet.get("title"):
            fields_differ.append("title")

        # Determine which entity is stale (older)
        stale_entity = None
        if fields_differ:
            day_updated = day.get("updated_at")
            sheet_updated = sheet.get("updated_at")
            if day_updated and sheet_updated:
                if day_updated > sheet_updated:
                    stale_entity = "call_sheet"
                else:
                    stale_entity = "production_day"

        return {
            "has_linked_call_sheet": True,
            "call_sheet_id": sheet["id"],
            "is_in_sync": len(fields_differ) == 0,
            "stale_entity": stale_entity,
            "fields_differ": fields_differ,
            "day_updated_at": day.get("updated_at"),
            "sheet_updated_at": sheet.get("updated_at")
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting sync status: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/production-days/{day_id}/bidirectional-sync")
async def bidirectional_sync_production_day(
    day_id: str,
    sync_request: dict = Body(...),
    authorization: str = Header(None)
):
    """
    Perform bidirectional sync between production day and linked call sheet.

    Request body:
    - force_direction: "schedule_to_callsheet" | "callsheet_to_schedule" | null (auto)
    - sync_date: boolean (default True)
    - sync_times: boolean (default True)
    - sync_location: boolean (default True)
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get production day
        day_result = client.table("backlot_production_days").select(
            "id, project_id, date, day_number, title, general_call_time, wrap_time, "
            "location_name, location_address, updated_at"
        ).eq("id", day_id).execute()

        if not day_result.data:
            raise HTTPException(status_code=404, detail="Production day not found")

        day = day_result.data[0]
        await verify_project_access(client, day["project_id"], user["id"])

        # Find linked call sheet
        sheet_result = client.table("backlot_call_sheets").select(
            "id, date, shoot_day_number, title, crew_call_time, general_call_time, "
            "estimated_wrap_time, location_name, location_address, updated_at"
        ).eq("production_day_id", day_id).limit(1).execute()

        if not sheet_result.data:
            raise HTTPException(status_code=400, detail="No linked call sheet found")

        sheet = sheet_result.data[0]

        # Parse sync options
        force_direction = sync_request.get("force_direction")
        sync_date = sync_request.get("sync_date", True)
        sync_times = sync_request.get("sync_times", True)
        sync_location = sync_request.get("sync_location", True)

        # Determine sync direction
        if force_direction:
            direction = force_direction
        else:
            # Auto-detect: most recent wins
            day_updated = day.get("updated_at")
            sheet_updated = sheet.get("updated_at")
            if day_updated and sheet_updated:
                direction = "schedule_to_callsheet" if day_updated > sheet_updated else "callsheet_to_schedule"
            else:
                direction = "schedule_to_callsheet"

        # Perform sync
        if direction == "schedule_to_callsheet":
            # Update call sheet from production day
            sync_data = {}
            if sync_date:
                if day.get("date"):
                    sync_data["date"] = day["date"]
                if day.get("day_number"):
                    sync_data["shoot_day_number"] = day["day_number"]
                if day.get("title"):
                    sync_data["title"] = day["title"]
            if sync_times:
                if day.get("general_call_time"):
                    sync_data["crew_call_time"] = day["general_call_time"]
                    sync_data["general_call_time"] = day["general_call_time"]
                if day.get("wrap_time"):
                    sync_data["estimated_wrap_time"] = day["wrap_time"]
            if sync_location:
                if day.get("location_name"):
                    sync_data["location_name"] = day["location_name"]
                if day.get("location_address"):
                    sync_data["location_address"] = day["location_address"]

            if sync_data:
                client.table("backlot_call_sheets").update(sync_data).eq("id", sheet["id"]).execute()

            return {
                "success": True,
                "direction": direction,
                "fields_synced": list(sync_data.keys()),
                "source": "production_day",
                "target": "call_sheet"
            }
        else:
            # Update production day from call sheet
            sync_data = {}
            if sync_date:
                if sheet.get("date"):
                    sync_data["date"] = sheet["date"]
                if sheet.get("shoot_day_number"):
                    sync_data["day_number"] = sheet["shoot_day_number"]
                if sheet.get("title"):
                    sync_data["title"] = sheet["title"]
            if sync_times:
                call_time = sheet.get("general_call_time") or sheet.get("crew_call_time")
                if call_time:
                    sync_data["general_call_time"] = call_time
                if sheet.get("estimated_wrap_time"):
                    sync_data["wrap_time"] = sheet["estimated_wrap_time"]
            if sync_location:
                if sheet.get("location_name"):
                    sync_data["location_name"] = sheet["location_name"]
                if sheet.get("location_address"):
                    sync_data["location_address"] = sheet["location_address"]

            if sync_data:
                client.table("backlot_production_days").update(sync_data).eq("id", day_id).execute()

            return {
                "success": True,
                "direction": direction,
                "fields_synced": list(sync_data.keys()),
                "source": "call_sheet",
                "target": "production_day"
            }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error performing bidirectional sync: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# PRODUCTION DAY SCENES (Schedule Scene Assignment)
# =====================================================

class ProductionDaySceneInput(BaseModel):
    scene_id: str
    sort_order: Optional[int] = 0
    estimated_duration: Optional[str] = None
    notes: Optional[str] = None


class ProductionDaySceneReorderInput(BaseModel):
    scene_orders: List[dict]  # [{scene_id: str, sort_order: int}]


# =====================================================
# DAY VIEW (Days List with Summary Stats)
# =====================================================

@router.get("/projects/{project_id}/days")
async def get_days_list(
    project_id: str,
    start_date: str = None,
    end_date: str = None,
    authorization: str = Header(None)
):
    """
    Get list of production days with summary stats for Day View.
    Returns day info plus has_call_sheet, has_dailies, task_count, crew_scheduled_count.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        # Get all production days for the project
        days_query = client.table("backlot_production_days").select("*").eq(
            "project_id", project_id
        ).order("day_number")

        if start_date:
            days_query = days_query.gte("date", start_date)
        if end_date:
            days_query = days_query.lte("date", end_date)

        days_result = days_query.execute()
        days = days_result.data or []

        # Get all call sheets for this project to check which days have call sheets
        call_sheets_result = client.table("backlot_call_sheets").select(
            "production_day_id"
        ).eq("project_id", project_id).execute()
        call_sheet_day_ids = set(cs["production_day_id"] for cs in (call_sheets_result.data or []) if cs.get("production_day_id"))

        # Get all dailies days for this project
        dailies_result = client.table("backlot_dailies_days").select(
            "production_day_id"
        ).eq("project_id", project_id).execute()
        dailies_day_ids = set(d["production_day_id"] for d in (dailies_result.data or []) if d.get("production_day_id"))

        # Get task counts per day
        tasks_result = client.table("backlot_tasks").select(
            "production_day_id"
        ).eq("project_id", project_id).execute()
        task_counts = {}
        for t in (tasks_result.data or []):
            day_id = t.get("production_day_id")
            if day_id:
                task_counts[day_id] = task_counts.get(day_id, 0) + 1

        # Get crew scheduled counts per day (from call sheet people)
        crew_result = client.table("backlot_call_sheet_people").select(
            "call_sheet_id"
        ).execute()
        # Map call sheet ids to day ids
        cs_to_day = {}
        for cs in (call_sheets_result.data or []):
            if cs.get("production_day_id"):
                cs_to_day[cs.get("id")] = cs.get("production_day_id")
        crew_counts = {}
        for c in (crew_result.data or []):
            cs_id = c.get("call_sheet_id")
            day_id = cs_to_day.get(cs_id)
            if day_id:
                crew_counts[day_id] = crew_counts.get(day_id, 0) + 1

        # Build response
        result = []
        for day in days:
            day_id = day["id"]
            result.append({
                "id": day_id,
                "day_number": day["day_number"],
                "date": day["date"],
                "title": day.get("title"),
                "location_name": day.get("location_name"),
                "general_call_time": day.get("general_call_time"),
                "is_completed": day.get("is_completed", False),
                "has_call_sheet": day_id in call_sheet_day_ids,
                "has_dailies": day_id in dailies_day_ids,
                "task_count": task_counts.get(day_id, 0),
                "crew_scheduled_count": crew_counts.get(day_id, 0),
            })

        return result

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting days list: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/days/{day_id}/overview")
async def get_day_overview(
    project_id: str,
    day_id: str,
    authorization: str = Header(None)
):
    """
    Get comprehensive overview of a production day for Day View.
    Returns day details plus call sheets, dailies, budget, tasks, timecards, scenes, crew.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify access
        await verify_project_access(client, project_id, user["id"])

        # Get the production day
        day_result = client.table("backlot_production_days").select("*").eq("id", day_id).eq("project_id", project_id).execute()
        if not day_result.data:
            raise HTTPException(status_code=404, detail="Production day not found")
        day = day_result.data[0]

        # Get call sheets linked to this day (by date or production_day_id)
        call_sheets = []
        try:
            # Try by production_day_id first
            cs_result = client.table("backlot_call_sheets").select(
                "id, title, date, general_call_time, is_published"
            ).eq("production_day_id", day_id).execute()

            # Also try by date match if no direct link
            if not cs_result.data:
                cs_result = client.table("backlot_call_sheets").select(
                    "id, title, date, general_call_time, is_published"
                ).eq("project_id", project_id).eq("date", day["date"]).execute()

            for cs in (cs_result.data or []):
                # Get crew/cast/scene counts
                crew_count = 0
                cast_count = 0
                scene_count = 0
                try:
                    crew_result = client.table("backlot_call_sheet_crew").select("id", count="exact").eq("call_sheet_id", cs["id"]).execute()
                    crew_count = crew_result.count or 0
                except:
                    pass
                try:
                    cast_result = client.table("backlot_call_sheet_cast").select("id", count="exact").eq("call_sheet_id", cs["id"]).execute()
                    cast_count = cast_result.count or 0
                except:
                    pass
                try:
                    scene_result = client.table("backlot_call_sheet_scenes").select("id", count="exact").eq("call_sheet_id", cs["id"]).execute()
                    scene_count = scene_result.count or 0
                except:
                    pass

                call_sheets.append({
                    "id": cs["id"],
                    "title": cs.get("title", "Call Sheet"),
                    "date": cs.get("date"),
                    "general_call_time": cs.get("general_call_time"),
                    "location_name": day.get("location_name"),
                    "is_published": cs.get("is_published", False),
                    "crew_count": crew_count,
                    "cast_count": cast_count,
                    "scene_count": scene_count,
                })
        except Exception as e:
            print(f"Error getting call sheets for day overview: {e}")

        # Get daily budget
        daily_budget = None
        try:
            budget_result = client.table("backlot_daily_budgets").select(
                "id, total_planned, total_actual"
            ).eq("production_day_id", day_id).limit(1).execute()
            if budget_result.data:
                b = budget_result.data[0]
                item_count_result = client.table("backlot_daily_budget_items").select("id", count="exact").eq("daily_budget_id", b["id"]).execute()
                daily_budget = {
                    "id": b["id"],
                    "total_planned": b.get("total_planned", 0) or 0,
                    "total_actual": b.get("total_actual", 0) or 0,
                    "variance": (b.get("total_planned", 0) or 0) - (b.get("total_actual", 0) or 0),
                    "item_count": item_count_result.count or 0,
                }
        except Exception as e:
            print(f"Error getting daily budget for day overview: {e}")

        # Get dailies (by shoot_date)
        dailies = None
        try:
            dailies_result = client.table("backlot_dailies_days").select(
                "id, shoot_date, label"
            ).eq("project_id", project_id).eq("shoot_date", day["date"]).limit(1).execute()
            if dailies_result.data:
                d = dailies_result.data[0]
                # Get card/clip counts
                card_count = 0
                clip_count = 0
                circle_takes = 0
                total_duration = 0
                try:
                    cards_result = client.table("backlot_dailies_cards").select("id", count="exact").eq("dailies_day_id", d["id"]).execute()
                    card_count = cards_result.count or 0

                    clips_result = client.table("backlot_dailies_clips").select(
                        "id, is_circle_take, duration_seconds"
                    ).eq("dailies_day_id", d["id"]).execute()
                    for clip in (clips_result.data or []):
                        clip_count += 1
                        if clip.get("is_circle_take"):
                            circle_takes += 1
                        if clip.get("duration_seconds"):
                            total_duration += clip["duration_seconds"]
                except:
                    pass

                dailies = {
                    "id": d["id"],
                    "shoot_date": d.get("shoot_date"),
                    "label": d.get("label"),
                    "card_count": card_count,
                    "clip_count": clip_count,
                    "circle_take_count": circle_takes,
                    "total_duration_minutes": round(total_duration / 60, 1) if total_duration else 0,
                }
        except Exception as e:
            print(f"Error getting dailies for day overview: {e}")

        # Get travel items (would need a travel table - returning empty for now)
        travel_items = []

        # Get tasks due on this day
        tasks = []
        try:
            tasks_result = client.table("backlot_tasks").select(
                "id, title, status, priority, assigned_to, task_list_id"
            ).eq("project_id", project_id).eq("due_date", day["date"]).limit(20).execute()

            for t in (tasks_result.data or []):
                assigned_name = None
                list_name = None
                if t.get("assigned_to"):
                    try:
                        user_result = client.table("profiles").select("display_name, username").eq("id", t["assigned_to"]).limit(1).execute()
                        if user_result.data:
                            assigned_name = user_result.data[0].get("display_name") or user_result.data[0].get("username")
                    except:
                        pass
                if t.get("task_list_id"):
                    try:
                        list_result = client.table("backlot_task_lists").select("name").eq("id", t["task_list_id"]).limit(1).execute()
                        if list_result.data:
                            list_name = list_result.data[0].get("name")
                    except:
                        pass

                tasks.append({
                    "id": t["id"],
                    "title": t.get("title", ""),
                    "status": t.get("status", "pending"),
                    "priority": t.get("priority"),
                    "assigned_to_name": assigned_name,
                    "task_list_name": list_name,
                })
        except Exception as e:
            print(f"Error getting tasks for day overview: {e}")

        # Get updates (recent project updates)
        updates = []
        try:
            updates_result = client.table("backlot_updates").select(
                "id, title, content, update_type, created_by, created_at"
            ).eq("project_id", project_id).order("created_at", desc=True).limit(5).execute()

            for u in (updates_result.data or []):
                author_name = None
                if u.get("created_by"):
                    try:
                        user_result = client.table("profiles").select("display_name, username").eq("id", u["created_by"]).limit(1).execute()
                        if user_result.data:
                            author_name = user_result.data[0].get("display_name") or user_result.data[0].get("username")
                    except:
                        pass

                updates.append({
                    "id": u["id"],
                    "title": u.get("title"),
                    "content": u.get("content", ""),
                    "update_type": u.get("update_type", "general"),
                    "author_name": author_name,
                    "created_at": u.get("created_at"),
                })
        except Exception as e:
            print(f"Error getting updates for day overview: {e}")

        # Get timecard entries for this day
        timecard_entries = []
        try:
            tc_result = client.table("backlot_timecard_entries").select(
                "id, user_id, call_time, wrap_time, hours_worked, status"
            ).eq("production_day_id", day_id).execute()

            for tc in (tc_result.data or []):
                user_name = None
                if tc.get("user_id"):
                    try:
                        user_result = client.table("profiles").select("display_name, username").eq("id", tc["user_id"]).limit(1).execute()
                        if user_result.data:
                            user_name = user_result.data[0].get("display_name") or user_result.data[0].get("username")
                    except:
                        pass

                timecard_entries.append({
                    "id": tc["id"],
                    "user_id": tc.get("user_id"),
                    "user_name": user_name,
                    "call_time": tc.get("call_time"),
                    "wrap_time": tc.get("wrap_time"),
                    "hours_worked": tc.get("hours_worked"),
                    "status": tc.get("status", "pending"),
                })
        except Exception as e:
            print(f"Error getting timecard entries for day overview: {e}")

        # Get scenes scheduled for this day
        scenes_scheduled = []
        try:
            scenes_result = client.table("backlot_production_day_scenes").select(
                "scene_id"
            ).eq("production_day_id", day_id).order("sort_order").execute()

            for ps in (scenes_result.data or []):
                if ps.get("scene_id"):
                    try:
                        scene_result = client.table("backlot_scenes").select(
                            "id, scene_number, slugline, page_length"
                        ).eq("id", ps["scene_id"]).limit(1).execute()
                        if scene_result.data:
                            s = scene_result.data[0]
                            scenes_scheduled.append({
                                "id": s["id"],
                                "scene_number": s.get("scene_number"),
                                "slugline": s.get("slugline"),
                                "page_length": s.get("page_length"),
                            })
                    except:
                        pass
        except Exception as e:
            print(f"Error getting scenes for day overview: {e}")

        # Get crew summary
        crew_summary = {
            "total_crew": 0,
            "total_cast": 0,
            "departments": {},
        }
        try:
            # Get from call sheet if available
            if call_sheets:
                cs_id = call_sheets[0]["id"]
                crew_summary["total_crew"] = call_sheets[0]["crew_count"]
                crew_summary["total_cast"] = call_sheets[0]["cast_count"]

                # Get department breakdown
                dept_result = client.table("backlot_call_sheet_crew").select(
                    "department"
                ).eq("call_sheet_id", cs_id).execute()

                for c in (dept_result.data or []):
                    dept = c.get("department") or "Other"
                    crew_summary["departments"][dept] = crew_summary["departments"].get(dept, 0) + 1
        except Exception as e:
            print(f"Error getting crew summary for day overview: {e}")

        return {
            "day": day,
            "call_sheets": call_sheets,
            "daily_budget": daily_budget,
            "dailies": dailies,
            "travel_items": travel_items,
            "tasks": tasks,
            "updates": updates,
            "timecard_entries": timecard_entries,
            "scenes_scheduled": scenes_scheduled,
            "crew_summary": crew_summary,
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting day overview: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/production-days/{day_id}/scenes")
async def get_production_day_scenes(
    day_id: str,
    authorization: str = Header(None)
):
    """Get all scenes assigned to a production day with full scene details"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # First verify the day exists and user has access
        day_result = client.table("backlot_production_days").select("project_id").eq("id", day_id).execute()
        if not day_result.data:
            raise HTTPException(status_code=404, detail="Production day not found")

        await verify_project_access(client, day_result.data[0]["project_id"], user["id"])

        # Get scene assignments (the Supabase-style client doesn't support nested joins well)
        assignments_result = client.table("backlot_production_day_scenes").select("*").eq("production_day_id", day_id).order("sort_order").execute()
        assignments = assignments_result.data or []

        if not assignments:
            return {"scenes": []}

        # Get scene IDs and fetch scene details separately
        scene_ids = [a["scene_id"] for a in assignments if a.get("scene_id")]
        if scene_ids:
            scenes_result = client.table("backlot_scenes").select(
                "id, scene_number, slugline, set_name, description, page_length, int_ext, time_of_day"
            ).in_("id", scene_ids).execute()
            scenes_by_id = {s["id"]: s for s in (scenes_result.data or [])}
        else:
            scenes_by_id = {}

        # Manually join scene data to assignments
        for assignment in assignments:
            scene_id = assignment.get("scene_id")
            if scene_id and scene_id in scenes_by_id:
                assignment["scene"] = scenes_by_id[scene_id]
            else:
                assignment["scene"] = None

        return {"scenes": assignments}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting production day scenes: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/production-days/{day_id}/scenes")
async def add_scene_to_production_day(
    day_id: str,
    scene_data: ProductionDaySceneInput,
    authorization: str = Header(None)
):
    """Add a scene to a production day"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify day exists and user has access
        day_result = client.table("backlot_production_days").select("project_id").eq("id", day_id).execute()
        if not day_result.data:
            raise HTTPException(status_code=404, detail="Production day not found")

        project_id = day_result.data[0]["project_id"]
        await verify_project_access(client, project_id, user["id"])

        # Verify scene exists and belongs to same project
        scene_result = client.table("backlot_scenes").select("id, project_id").eq("id", scene_data.scene_id).execute()
        if not scene_result.data:
            raise HTTPException(status_code=404, detail="Scene not found")
        if scene_result.data[0]["project_id"] != project_id:
            raise HTTPException(status_code=400, detail="Scene does not belong to this project")

        # Check if scene is already assigned to this day
        existing = client.table("backlot_production_day_scenes").select("id").eq(
            "production_day_id", day_id
        ).eq("scene_id", scene_data.scene_id).execute()
        if existing.data:
            raise HTTPException(status_code=400, detail="Scene is already assigned to this day")

        # Get next sort order if not specified
        if scene_data.sort_order == 0:
            max_order = client.table("backlot_production_day_scenes").select("sort_order").eq(
                "production_day_id", day_id
            ).order("sort_order", desc=True).limit(1).execute()
            sort_order = (max_order.data[0]["sort_order"] + 1) if max_order.data else 0
        else:
            sort_order = scene_data.sort_order

        # Insert the assignment
        insert_data = {
            "production_day_id": day_id,
            "scene_id": scene_data.scene_id,
            "sort_order": sort_order,
            "estimated_duration": scene_data.estimated_duration,
            "notes": scene_data.notes,
        }
        result = client.table("backlot_production_day_scenes").insert(insert_data).execute()

        # Also update the scene's scheduled_day_id for stripboard sync
        client.table("backlot_scenes").update({
            "scheduled_day_id": day_id,
            "is_scheduled": True
        }).eq("id", scene_data.scene_id).execute()

        # Return with full scene details
        if result.data:
            full_result = client.table("backlot_production_day_scenes").select(
                "*, scene:scene_id(id, scene_number, slugline, set_name, description, page_length, int_ext, time_of_day)"
            ).eq("id", result.data[0]["id"]).execute()
            return {"scene_assignment": full_result.data[0] if full_result.data else result.data[0]}

        return {"scene_assignment": None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error adding scene to production day: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/production-days/{day_id}/scenes/bulk")
async def add_scenes_bulk_to_production_day(
    day_id: str,
    scene_ids: List[str] = Body(...),
    authorization: str = Header(None)
):
    """Add multiple scenes to a production day at once"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify day exists and user has access
        day_result = client.table("backlot_production_days").select("project_id").eq("id", day_id).execute()
        if not day_result.data:
            raise HTTPException(status_code=404, detail="Production day not found")

        project_id = day_result.data[0]["project_id"]
        await verify_project_access(client, project_id, user["id"])

        # Get current max sort order
        max_order = client.table("backlot_production_day_scenes").select("sort_order").eq(
            "production_day_id", day_id
        ).order("sort_order", desc=True).limit(1).execute()
        current_order = (max_order.data[0]["sort_order"] + 1) if max_order.data else 0

        # Insert all scenes
        inserted = []
        for scene_id in scene_ids:
            # Skip if already assigned
            existing = client.table("backlot_production_day_scenes").select("id").eq(
                "production_day_id", day_id
            ).eq("scene_id", scene_id).execute()
            if existing.data:
                continue

            insert_data = {
                "production_day_id": day_id,
                "scene_id": scene_id,
                "sort_order": current_order,
            }
            result = client.table("backlot_production_day_scenes").insert(insert_data).execute()
            if result.data:
                inserted.append(result.data[0])
                # Also update the scene's scheduled_day_id for stripboard sync
                client.table("backlot_scenes").update({
                    "scheduled_day_id": day_id,
                    "is_scheduled": True
                }).eq("id", scene_id).execute()
            current_order += 1

        return {"inserted_count": len(inserted), "scenes": inserted}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error bulk adding scenes to production day: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/production-days/{day_id}/scenes/{scene_id}")
async def remove_scene_from_production_day(
    day_id: str,
    scene_id: str,
    authorization: str = Header(None)
):
    """Remove a scene from a production day"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify day exists and user has access
        day_result = client.table("backlot_production_days").select("project_id").eq("id", day_id).execute()
        if not day_result.data:
            raise HTTPException(status_code=404, detail="Production day not found")

        await verify_project_access(client, day_result.data[0]["project_id"], user["id"])

        # Delete the assignment
        client.table("backlot_production_day_scenes").delete().eq(
            "production_day_id", day_id
        ).eq("scene_id", scene_id).execute()

        # Also clear the scene's scheduled_day_id for stripboard sync
        client.table("backlot_scenes").update({
            "scheduled_day_id": None,
            "is_scheduled": False
        }).eq("id", scene_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error removing scene from production day: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/production-days/{day_id}/scenes/reorder")
async def reorder_production_day_scenes(
    day_id: str,
    reorder_data: ProductionDaySceneReorderInput,
    authorization: str = Header(None)
):
    """Reorder scenes within a production day"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify day exists and user has access
        day_result = client.table("backlot_production_days").select("project_id").eq("id", day_id).execute()
        if not day_result.data:
            raise HTTPException(status_code=404, detail="Production day not found")

        await verify_project_access(client, day_result.data[0]["project_id"], user["id"])

        # Update sort orders
        for item in reorder_data.scene_orders:
            client.table("backlot_production_day_scenes").update(
                {"sort_order": item["sort_order"]}
            ).eq("production_day_id", day_id).eq("scene_id", item["scene_id"]).execute()

        # Return updated list
        result = client.table("backlot_production_day_scenes").select(
            "*, scene:scene_id(id, scene_number, slugline, set_name, description, page_length, int_ext, time_of_day)"
        ).eq("production_day_id", day_id).order("sort_order").execute()

        return {"scenes": result.data or []}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error reordering production day scenes: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/unassigned-scenes")
async def get_unassigned_scenes(
    project_id: str,
    authorization: str = Header(None)
):
    """Get all scenes that are not assigned to any production day"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        # Get all scenes for the project
        all_scenes = client.table("backlot_scenes").select(
            "id, scene_number, slugline, set_name, description, page_length, int_ext, time_of_day"
        ).eq("project_id", project_id).order("scene_number").execute()

        if not all_scenes.data:
            return {"scenes": []}

        # Get all assigned scene IDs
        assigned = client.table("backlot_production_day_scenes").select(
            "scene_id, production_day_id"
        ).execute()

        # Get production day IDs for this project
        project_days = client.table("backlot_production_days").select("id").eq("project_id", project_id).execute()
        project_day_ids = {d["id"] for d in (project_days.data or [])}

        # Filter to only assignments for this project's days
        assigned_scene_ids = {
            a["scene_id"] for a in (assigned.data or [])
            if a["production_day_id"] in project_day_ids
        }

        # Filter unassigned
        unassigned = [s for s in all_scenes.data if s["id"] not in assigned_scene_ids]

        return {"scenes": unassigned}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting unassigned scenes: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# SCHEDULE <-> CALL SHEET INTEGRATION
# =====================================================

class CreateCallSheetFromDayInput(BaseModel):
    title: Optional[str] = None
    include_scenes: bool = True


class SyncToCallSheetInput(BaseModel):
    call_sheet_id: str
    sync_date: bool = True
    sync_times: bool = True
    sync_location: bool = True
    sync_scenes: bool = True
    overwrite_existing: bool = False


@router.post("/production-days/{day_id}/create-call-sheet")
async def create_call_sheet_from_production_day(
    day_id: str,
    input_data: Optional[CreateCallSheetFromDayInput] = None,
    authorization: str = Header(None)
):
    """Create a new call sheet pre-populated with production day data"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get the production day
        day_result = client.table("backlot_production_days").select("*").eq("id", day_id).execute()
        if not day_result.data:
            raise HTTPException(status_code=404, detail="Production day not found")

        day = day_result.data[0]
        await verify_project_access(client, day["project_id"], user["id"])

        # Check if call sheet already exists for this day
        existing = client.table("backlot_call_sheets").select("id").eq("production_day_id", day_id).execute()
        if existing.data:
            raise HTTPException(
                status_code=400,
                detail="A call sheet already exists for this production day. Use sync instead."
            )

        # Create the call sheet
        call_sheet_data = {
            "project_id": day["project_id"],
            "production_day_id": day_id,
            "date": day["date"],
            "shoot_day_number": day["day_number"],
            "title": input_data.title if input_data and input_data.title else day.get("title") or f"Day {day['day_number']}",
            "general_call_time": day.get("general_call_time"),
            "estimated_wrap_time": day.get("wrap_time"),
            "location_name": day.get("location_name"),
            "location_address": day.get("location_address"),
            "general_notes": day.get("description") or day.get("notes"),
            "created_by": user["id"],
        }

        # If production day has hour_schedule, convert to schedule_blocks for call sheet
        hour_schedule = day.get("hour_schedule") or []
        if hour_schedule:
            schedule_blocks = []
            for block in hour_schedule:
                # Skip scene blocks (scenes are shown separately on call sheets)
                if block.get("type") == "scene":
                    continue
                # Format time as "7:00 AM"
                start_time = block.get("start_time", "")
                try:
                    hour, minute = start_time.split(":")
                    hour_int = int(hour)
                    period = "AM" if hour_int < 12 else "PM"
                    display_hour = hour_int if hour_int <= 12 else hour_int - 12
                    if display_hour == 0:
                        display_hour = 12
                    formatted_time = f"{display_hour}:{minute} {period}"
                except:
                    formatted_time = start_time

                # Get activity name based on block type
                activity = block.get("activity_name") or block.get("type", "").replace("_", " ").title()
                if block.get("activity_notes"):
                    activity = f"{activity} - {block['activity_notes']}"

                schedule_blocks.append({
                    "time": formatted_time,
                    "activity": activity
                })
            call_sheet_data["schedule_blocks"] = schedule_blocks

        result = client.table("backlot_call_sheets").insert(call_sheet_data).execute()
        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create call sheet")

        call_sheet = result.data[0]

        # If including scenes, add them to the call sheet
        scenes_added = 0
        if input_data is None or input_data.include_scenes:
            # Get scenes assigned to this production day
            day_scenes = client.table("backlot_production_day_scenes").select(
                "*, scene:scene_id(id, scene_number, slugline, set_name, description, page_length, int_ext, time_of_day)"
            ).eq("production_day_id", day_id).order("sort_order").execute()

            if day_scenes.data:
                for idx, ds in enumerate(day_scenes.data):
                    scene = ds.get("scene") or {}
                    scene_data = {
                        "call_sheet_id": call_sheet["id"],
                        "scene_number": scene.get("scene_number", ""),
                        "set_name": scene.get("set_name") or scene.get("slugline", ""),
                        "description": scene.get("description", ""),
                        "page_count": scene.get("page_length"),
                        "int_ext": scene.get("int_ext"),
                        "time_of_day": scene.get("time_of_day"),
                        "sort_order": idx,
                        "linked_scene_id": scene.get("id"),
                    }
                    client.table("backlot_call_sheet_scenes").insert(scene_data).execute()
                    scenes_added += 1

        synced_fields = ["date", "call_time", "wrap_time", "location"]
        if hour_schedule:
            synced_fields.append("schedule_blocks")
        if scenes_added > 0:
            synced_fields.append("scenes")

        return {
            "call_sheet": call_sheet,
            "synced_fields": synced_fields,
            "scenes_added": scenes_added,
            "schedule_blocks_imported": len(hour_schedule) > 0
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating call sheet from production day: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/production-days/{day_id}/sync-to-call-sheet")
async def sync_production_day_to_call_sheet(
    day_id: str,
    sync_input: SyncToCallSheetInput,
    authorization: str = Header(None)
):
    """Sync production day changes to an existing call sheet"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get the production day
        day_result = client.table("backlot_production_days").select("*").eq("id", day_id).execute()
        if not day_result.data:
            raise HTTPException(status_code=404, detail="Production day not found")

        day = day_result.data[0]
        await verify_project_access(client, day["project_id"], user["id"])

        # Get the target call sheet
        cs_result = client.table("backlot_call_sheets").select("*").eq("id", sync_input.call_sheet_id).execute()
        if not cs_result.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        call_sheet = cs_result.data[0]
        if call_sheet["project_id"] != day["project_id"]:
            raise HTTPException(status_code=400, detail="Call sheet belongs to a different project")

        # Build update data
        update_data = {}
        synced_fields = []

        if sync_input.sync_date:
            update_data["date"] = day["date"]
            update_data["shoot_day_number"] = day["day_number"]
            synced_fields.append("date")

        if sync_input.sync_times:
            if day.get("general_call_time"):
                update_data["general_call_time"] = day["general_call_time"]
            if day.get("wrap_time"):
                update_data["estimated_wrap_time"] = day["wrap_time"]
            synced_fields.append("times")

        if sync_input.sync_location:
            if day.get("location_name"):
                update_data["location_name"] = day["location_name"]
            if day.get("location_address"):
                update_data["location_address"] = day["location_address"]
            synced_fields.append("location")

        # Link the call sheet to this production day if not already linked
        if not call_sheet.get("production_day_id"):
            update_data["production_day_id"] = day_id

        # Update call sheet
        if update_data:
            client.table("backlot_call_sheets").update(update_data).eq("id", sync_input.call_sheet_id).execute()

        # Sync scenes
        scenes_added = 0
        scenes_removed = 0
        if sync_input.sync_scenes:
            # Get scenes assigned to this production day
            day_scenes = client.table("backlot_production_day_scenes").select(
                "*, scene:scene_id(id, scene_number, slugline, set_name, description, page_length, int_ext, time_of_day)"
            ).eq("production_day_id", day_id).order("sort_order").execute()

            if sync_input.overwrite_existing:
                # Remove existing scenes
                existing_scenes = client.table("backlot_call_sheet_scenes").select("id").eq(
                    "call_sheet_id", sync_input.call_sheet_id
                ).execute()
                scenes_removed = len(existing_scenes.data) if existing_scenes.data else 0
                client.table("backlot_call_sheet_scenes").delete().eq(
                    "call_sheet_id", sync_input.call_sheet_id
                ).execute()

            # Add scenes from production day
            existing_scene_numbers = set()
            if not sync_input.overwrite_existing:
                existing = client.table("backlot_call_sheet_scenes").select("scene_number, linked_scene_id").eq(
                    "call_sheet_id", sync_input.call_sheet_id
                ).execute()
                existing_scene_numbers = {s["scene_number"] for s in (existing.data or [])}
                existing_scene_ids = {s["linked_scene_id"] for s in (existing.data or []) if s.get("linked_scene_id")}

            # Get current max sort order
            max_order = 0
            if not sync_input.overwrite_existing:
                order_result = client.table("backlot_call_sheet_scenes").select("sort_order").eq(
                    "call_sheet_id", sync_input.call_sheet_id
                ).order("sort_order", desc=True).limit(1).execute()
                if order_result.data:
                    max_order = order_result.data[0]["sort_order"] + 1

            if day_scenes.data:
                for idx, ds in enumerate(day_scenes.data):
                    scene = ds.get("scene") or {}
                    scene_number = scene.get("scene_number", "")
                    scene_id = scene.get("id")

                    # Skip if already exists (in merge mode)
                    if not sync_input.overwrite_existing:
                        if scene_number in existing_scene_numbers or (scene_id and scene_id in existing_scene_ids):
                            continue

                    scene_data = {
                        "call_sheet_id": sync_input.call_sheet_id,
                        "scene_number": scene_number,
                        "set_name": scene.get("set_name") or scene.get("slugline", ""),
                        "description": scene.get("description", ""),
                        "page_count": scene.get("page_length"),
                        "int_ext": scene.get("int_ext"),
                        "time_of_day": scene.get("time_of_day"),
                        "sort_order": max_order + idx if not sync_input.overwrite_existing else idx,
                        "linked_scene_id": scene_id,
                    }
                    client.table("backlot_call_sheet_scenes").insert(scene_data).execute()
                    scenes_added += 1

            synced_fields.append("scenes")

        return {
            "success": True,
            "synced_fields": synced_fields,
            "scenes_added": scenes_added,
            "scenes_removed": scenes_removed,
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error syncing production day to call sheet: {e}")
        raise HTTPException(status_code=500, detail=str(e))


class AutoSchedulerConstraints(BaseModel):
    max_pages_per_day: float = 5.0
    group_by_location: bool = True
    group_by_int_ext: bool = True
    group_by_time_of_day: bool = True
    target_days: Optional[int] = None  # If set, try to fit into this many days


class AutoSchedulerRequest(BaseModel):
    scene_ids: Optional[List[str]] = None  # If None, use all unassigned scenes
    constraints: Optional[AutoSchedulerConstraints] = None


@router.post("/projects/{project_id}/schedule/auto-generate")
async def auto_generate_schedule(
    project_id: str,
    request: AutoSchedulerRequest,
    authorization: str = Header(None)
):
    """
    Auto-generate a suggested schedule by grouping scenes intelligently.
    Groups by location, INT/EXT, time of day, and respects page limits.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        constraints = request.constraints or AutoSchedulerConstraints()

        # Get scenes to schedule
        if request.scene_ids:
            scenes_result = client.table("backlot_scenes").select(
                "id, scene_number, slugline, set_name, page_length, int_ext, time_of_day, location_id"
            ).in_("id", request.scene_ids).order("scene_number").execute()
        else:
            # Get all unassigned scenes
            all_scenes = client.table("backlot_scenes").select(
                "id, scene_number, slugline, set_name, page_length, int_ext, time_of_day, location_id"
            ).eq("project_id", project_id).order("scene_number").execute()

            # Get already assigned scene IDs
            project_days = client.table("backlot_production_days").select("id").eq("project_id", project_id).execute()
            project_day_ids = [d["id"] for d in (project_days.data or [])]

            assigned_result = client.table("backlot_production_day_scenes").select("scene_id").in_(
                "production_day_id", project_day_ids
            ).execute() if project_day_ids else {"data": []}

            assigned_ids = {a["scene_id"] for a in (assigned_result.data if hasattr(assigned_result, 'data') else assigned_result.get("data", []))}

            scenes_result = type('obj', (object,), {
                'data': [s for s in (all_scenes.data or []) if s["id"] not in assigned_ids]
            })()

        scenes = scenes_result.data or []

        if not scenes:
            return {
                "suggested_days": [],
                "message": "No scenes to schedule"
            }

        # Group scenes by location/set for efficient scheduling
        def get_grouping_key(scene):
            parts = []
            if constraints.group_by_location:
                # Use set_name or slugline as location proxy
                loc = scene.get("set_name") or scene.get("slugline") or "UNKNOWN"
                # Extract location from slugline (e.g., "INT. HOUSE - LIVING ROOM" -> "HOUSE")
                if " - " in loc:
                    loc = loc.split(" - ")[0]
                if ". " in loc:
                    loc = loc.split(". ", 1)[1] if len(loc.split(". ")) > 1 else loc
                parts.append(loc.strip())
            if constraints.group_by_int_ext:
                parts.append(scene.get("int_ext") or "")
            if constraints.group_by_time_of_day:
                parts.append(scene.get("time_of_day") or "")
            return "|".join(parts)

        # Group scenes
        from collections import defaultdict
        grouped = defaultdict(list)
        for scene in scenes:
            key = get_grouping_key(scene)
            grouped[key].append(scene)

        # Sort groups by number of scenes (larger groups first for efficiency)
        sorted_groups = sorted(grouped.items(), key=lambda x: -len(x[1]))

        # Build suggested days
        suggested_days = []
        current_day = {
            "day_number": 1,
            "scenes": [],
            "total_pages": 0,
            "locations": set(),
            "reasoning": []
        }

        for group_key, group_scenes in sorted_groups:
            for scene in group_scenes:
                page_length = scene.get("page_length") or 1.0

                # Check if adding this scene would exceed the page limit
                if current_day["total_pages"] + page_length > constraints.max_pages_per_day and current_day["scenes"]:
                    # Finalize current day
                    current_day["locations"] = list(current_day["locations"])
                    current_day["reasoning"] = " | ".join(current_day["reasoning"][:3])
                    suggested_days.append(current_day)

                    # Start new day
                    current_day = {
                        "day_number": len(suggested_days) + 1,
                        "scenes": [],
                        "total_pages": 0,
                        "locations": set(),
                        "reasoning": []
                    }

                # Add scene to current day
                current_day["scenes"].append({
                    "id": scene["id"],
                    "scene_number": scene["scene_number"],
                    "slugline": scene.get("slugline") or scene.get("set_name"),
                    "page_length": page_length,
                    "int_ext": scene.get("int_ext"),
                    "time_of_day": scene.get("time_of_day"),
                })
                current_day["total_pages"] += page_length

                # Track location for reasoning
                loc = scene.get("set_name") or scene.get("slugline") or ""
                if loc:
                    current_day["locations"].add(loc.split(" - ")[0] if " - " in loc else loc)

                # Add reasoning
                if scene.get("int_ext") or scene.get("time_of_day"):
                    reason = f"{scene.get('int_ext', '')} {scene.get('time_of_day', '')}".strip()
                    if reason and reason not in current_day["reasoning"]:
                        current_day["reasoning"].append(reason)

        # Don't forget the last day
        if current_day["scenes"]:
            current_day["locations"] = list(current_day["locations"])
            current_day["reasoning"] = " | ".join(current_day["reasoning"][:3])
            suggested_days.append(current_day)

        # If target_days is set and we have more days, try to consolidate
        if constraints.target_days and len(suggested_days) > constraints.target_days:
            # Simple consolidation: merge smallest days
            while len(suggested_days) > constraints.target_days:
                # Find smallest day
                smallest_idx = min(range(len(suggested_days)), key=lambda i: suggested_days[i]["total_pages"])
                smallest = suggested_days.pop(smallest_idx)

                # Find best day to merge into (lowest total that can fit)
                best_merge_idx = None
                for i, day in enumerate(suggested_days):
                    if day["total_pages"] + smallest["total_pages"] <= constraints.max_pages_per_day * 1.2:  # Allow 20% overflow
                        if best_merge_idx is None or day["total_pages"] < suggested_days[best_merge_idx]["total_pages"]:
                            best_merge_idx = i

                if best_merge_idx is not None:
                    suggested_days[best_merge_idx]["scenes"].extend(smallest["scenes"])
                    suggested_days[best_merge_idx]["total_pages"] += smallest["total_pages"]
                    suggested_days[best_merge_idx]["locations"] = list(
                        set(suggested_days[best_merge_idx]["locations"]) | set(smallest["locations"])
                    )
                else:
                    # Can't merge, put it back
                    suggested_days.append(smallest)
                    break

            # Renumber days
            for i, day in enumerate(suggested_days):
                day["day_number"] = i + 1

        return {
            "suggested_days": suggested_days,
            "total_scenes": len(scenes),
            "total_pages": sum(s.get("page_length") or 1 for s in scenes),
            "constraints_used": {
                "max_pages_per_day": constraints.max_pages_per_day,
                "group_by_location": constraints.group_by_location,
                "group_by_int_ext": constraints.group_by_int_ext,
                "group_by_time_of_day": constraints.group_by_time_of_day,
            }
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error auto-generating schedule: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/schedule/apply-suggestion")
async def apply_schedule_suggestion(
    project_id: str,
    suggested_days: List[dict] = Body(...),
    start_date: Optional[str] = Body(None),
    authorization: str = Header(None)
):
    """
    Apply a suggested schedule by creating production days and assigning scenes.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        from datetime import datetime, timedelta

        # Get starting date (default to tomorrow)
        if start_date:
            current_date = datetime.strptime(start_date, "%Y-%m-%d")
        else:
            current_date = datetime.now() + timedelta(days=1)

        # Get existing day numbers to avoid conflicts
        existing_days = client.table("backlot_production_days").select("day_number").eq(
            "project_id", project_id
        ).execute()
        existing_numbers = {d["day_number"] for d in (existing_days.data or [])}

        created_days = []
        for suggestion in suggested_days:
            # Find next available day number
            day_number = suggestion.get("day_number", 1)
            while day_number in existing_numbers:
                day_number += 1
            existing_numbers.add(day_number)

            # Create production day
            day_data = {
                "project_id": project_id,
                "day_number": day_number,
                "date": current_date.strftime("%Y-%m-%d"),
                "title": f"Day {day_number}",
                "description": suggestion.get("reasoning", ""),
            }

            day_result = client.table("backlot_production_days").insert(day_data).execute()
            if not day_result.data:
                continue

            new_day = day_result.data[0]
            created_days.append(new_day)

            # Assign scenes to this day
            for idx, scene in enumerate(suggestion.get("scenes", [])):
                scene_assignment = {
                    "production_day_id": new_day["id"],
                    "scene_id": scene["id"],
                    "sort_order": idx,
                }
                client.table("backlot_production_day_scenes").insert(scene_assignment).execute()

            # Move to next date (skip weekends optionally)
            current_date += timedelta(days=1)

        return {
            "created_days": len(created_days),
            "days": created_days,
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error applying schedule suggestion: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/production-days/{day_id}/linked-call-sheet")
async def get_linked_call_sheet(
    day_id: str,
    authorization: str = Header(None)
):
    """Get the call sheet linked to a production day, if any"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get the production day
        day_result = client.table("backlot_production_days").select("project_id").eq("id", day_id).execute()
        if not day_result.data:
            raise HTTPException(status_code=404, detail="Production day not found")

        await verify_project_access(client, day_result.data[0]["project_id"], user["id"])

        # Find linked call sheet
        cs_result = client.table("backlot_call_sheets").select("id, title, date, is_published").eq(
            "production_day_id", day_id
        ).execute()

        return {
            "call_sheet": cs_result.data[0] if cs_result.data else None,
            "has_call_sheet": bool(cs_result.data)
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting linked call sheet: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# HOUR SCHEDULE
# =====================================================

@router.put("/production-days/{day_id}/hour-schedule")
async def save_hour_schedule(
    day_id: str,
    data: dict = Body(...),
    authorization: str = Header(None)
):
    """Save hour-by-hour schedule for a production day"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get the production day
        day_result = client.table("backlot_production_days").select("project_id").eq("id", day_id).execute()
        if not day_result.data:
            raise HTTPException(status_code=404, detail="Production day not found")

        await verify_project_access(client, day_result.data[0]["project_id"], user["id"])

        # Update hour schedule
        update_data = {
            "hour_schedule": data.get("hour_schedule", []),
            "schedule_config": data.get("schedule_config"),
        }

        result = client.table("backlot_production_days").update(update_data).eq("id", day_id).execute()

        return {
            "success": True,
            "day": result.data[0] if result.data else None,
            "message": "Hour schedule saved successfully"
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error saving hour schedule: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/production-days/{day_id}/sync-hour-schedule")
async def sync_hour_schedule(
    day_id: str,
    data: dict = Body(...),
    authorization: str = Header(None)
):
    """
    Sync hour schedule between production day and linked call sheet.
    direction: "to_callsheet" | "from_callsheet"
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        direction = data.get("direction", "to_callsheet")

        # Get the production day
        day_result = client.table("backlot_production_days").select("*").eq("id", day_id).execute()
        if not day_result.data:
            raise HTTPException(status_code=404, detail="Production day not found")

        day = day_result.data[0]
        await verify_project_access(client, day["project_id"], user["id"])

        # Find linked call sheet
        cs_result = client.table("backlot_call_sheets").select("*").eq(
            "production_day_id", day_id
        ).execute()

        if not cs_result.data:
            raise HTTPException(status_code=404, detail="No linked call sheet found")

        call_sheet = cs_result.data[0]

        if direction == "to_callsheet":
            # Convert hour schedule to call sheet schedule_blocks
            hour_schedule = day.get("hour_schedule") or []

            # Filter out scene blocks and format for call sheet
            schedule_blocks = []
            for block in hour_schedule:
                if block.get("type") != "scene":
                    # Format time as "7:00 AM"
                    start_time = block.get("start_time", "00:00")
                    try:
                        hours, minutes = start_time.split(":")
                        hours = int(hours)
                        minutes = int(minutes)
                        ampm = "AM" if hours < 12 else "PM"
                        display_hours = hours % 12 or 12
                        formatted_time = f"{display_hours}:{minutes:02d} {ampm}"
                    except:
                        formatted_time = start_time

                    schedule_blocks.append({
                        "time": formatted_time,
                        "activity": block.get("activity_name", "Activity"),
                        "notes": block.get("activity_notes")
                    })

            # Update call sheet
            client.table("backlot_call_sheets").update({
                "schedule_blocks": schedule_blocks
            }).eq("id", call_sheet["id"]).execute()

            return {
                "success": True,
                "direction": direction,
                "blocks_synced": len(schedule_blocks),
                "message": f"Synced {len(schedule_blocks)} blocks to call sheet"
            }

        else:  # from_callsheet
            # Convert call sheet schedule_blocks to hour schedule format
            schedule_blocks = call_sheet.get("schedule_blocks") or []

            # Parse schedule blocks into hour schedule format
            hour_schedule = []
            for i, block in enumerate(schedule_blocks):
                time_str = block.get("time", "")
                activity = block.get("activity", "Activity")

                # Parse time string like "7:00 AM"
                try:
                    import re
                    match = re.match(r"(\d{1,2}):(\d{2})\s*(AM|PM)?", time_str, re.I)
                    if match:
                        hours = int(match.group(1))
                        minutes = match.group(2)
                        period = match.group(3)
                        if period and period.upper() == "PM" and hours != 12:
                            hours += 12
                        elif period and period.upper() == "AM" and hours == 12:
                            hours = 0
                        start_time = f"{hours:02d}:{minutes}"
                    else:
                        start_time = "00:00"
                except:
                    start_time = "00:00"

                # Infer block type from activity name
                activity_lower = activity.lower()
                if "crew call" in activity_lower or "call time" in activity_lower:
                    block_type = "crew_call"
                elif "first shot" in activity_lower:
                    block_type = "first_shot"
                elif "lunch" in activity_lower or "meal" in activity_lower or "breakfast" in activity_lower:
                    block_type = "meal"
                elif "wrap" in activity_lower:
                    block_type = "wrap"
                elif "move" in activity_lower or "travel" in activity_lower:
                    block_type = "company_move"
                else:
                    block_type = "activity"

                # Estimate duration based on type
                duration = 0
                if block_type == "meal":
                    duration = 30
                elif block_type == "activity":
                    duration = 30
                elif block_type == "company_move":
                    duration = 30

                hour_schedule.append({
                    "id": f"block_{i}_{start_time.replace(':', '')}",
                    "type": block_type,
                    "start_time": start_time,
                    "end_time": start_time,  # Will need recalculation
                    "duration_minutes": duration,
                    "activity_name": activity,
                    "activity_notes": block.get("notes"),
                    "sort_order": i
                })

            # Update production day
            client.table("backlot_production_days").update({
                "hour_schedule": hour_schedule
            }).eq("id", day_id).execute()

            return {
                "success": True,
                "direction": direction,
                "blocks_synced": len(hour_schedule),
                "message": f"Synced {len(hour_schedule)} blocks from call sheet"
            }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error syncing hour schedule: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# CALL SHEETS CRUD
# =====================================================

@router.get("/projects/{project_id}/call-sheets")
async def get_call_sheets(
    project_id: str,
    authorization: str = Header(None)
):
    """Get all call sheets for a project"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        result = client.table("backlot_call_sheets").select("*").eq(
            "project_id", project_id
        ).order("date").execute()

        return {"call_sheets": result.data or []}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting call sheets: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/call-sheets/{call_sheet_id}")
async def get_call_sheet(
    call_sheet_id: str,
    authorization: str = Header(None)
):
    """Get a single call sheet with people, scenes, and locations"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        result = client.table("backlot_call_sheets").select("*").eq("id", call_sheet_id).execute()
        if not result.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        sheet = result.data[0]
        await verify_project_access(client, sheet["project_id"], user["id"])

        # Fetch people
        people_result = client.table("backlot_call_sheet_people").select("*").eq(
            "call_sheet_id", call_sheet_id
        ).order("sort_order").execute()
        sheet["people"] = people_result.data or []

        # Fetch scenes
        scenes_result = client.table("backlot_call_sheet_scenes").select("*").eq(
            "call_sheet_id", call_sheet_id
        ).order("sort_order").execute()
        sheet["scenes"] = scenes_result.data or []

        # Fetch locations
        locations_result = client.table("backlot_call_sheet_locations").select("*").eq(
            "call_sheet_id", call_sheet_id
        ).order("location_number").execute()
        sheet["locations"] = locations_result.data or []

        return {"call_sheet": sheet}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting call sheet: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/call-sheets")
async def create_call_sheet(
    project_id: str,
    sheet: dict = Body(...),
    authorization: str = Header(None)
):
    """Create a call sheet"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Resolve Cognito ID to profile ID
        token_user_id = user["id"]
        profile_result = client.table("profiles").select("id").eq(
            "cognito_user_id", token_user_id
        ).limit(1).execute()
        if not profile_result.data:
            profile_result = client.table("profiles").select("id").eq(
                "id", token_user_id
            ).limit(1).execute()
        if not profile_result.data:
            raise HTTPException(status_code=404, detail="User profile not found")
        user_id = str(profile_result.data[0]["id"])

        await verify_project_access(client, project_id, user_id)

        # All supported call sheet fields
        allowed_fields = [
            # Core fields
            "production_day_id", "title", "date", "template_type",
            "production_title", "production_company", "header_logo_url",
            "shoot_day_number", "total_shoot_days",
            # Timing
            "crew_call_time", "general_call_time", "first_shot_time",
            "breakfast_time", "lunch_time", "dinner_time",
            "estimated_wrap_time", "sunrise_time", "sunset_time",
            # Location
            "location_name", "location_address", "parking_notes",
            "parking_instructions", "basecamp_location",
            # Contacts
            "production_office_phone", "production_email",
            "upm_name", "upm_phone", "first_ad_name", "first_ad_phone",
            "director_name", "director_phone", "producer_name", "producer_phone",
            "production_contact", "production_phone",
            # Department notes
            "camera_notes", "sound_notes", "grip_electric_notes", "art_notes",
            "wardrobe_notes", "makeup_hair_notes", "stunts_notes", "vfx_notes",
            "transport_notes", "catering_notes",
            # Schedule
            "schedule_blocks",
            # Weather and Timezone
            "weather_forecast", "weather_info",
            "timezone", "timezone_offset", "weather_fetched_at", "weather_data",
            # Safety
            "nearest_hospital", "hospital_address", "hospital_name", "hospital_phone",
            "set_medic", "fire_safety_officer", "safety_notes",
            # Additional
            "general_notes", "advance_schedule", "special_instructions",
            # Medical/Corporate template
            "hipaa_officer", "privacy_notes", "release_status", "restricted_areas",
            "dress_code", "client_name", "client_phone", "facility_contact", "facility_phone",
            # News/ENG template
            "deadline_time", "story_angle", "reporter_name", "reporter_phone", "subject_notes",
            "location_2_name", "location_2_address", "location_3_name", "location_3_address",
            # Live Event template
            "load_in_time", "rehearsal_time", "doors_time", "intermission_time", "strike_time",
            "truck_location", "video_village", "comm_channel",
            "td_name", "td_phone", "stage_manager_name", "stage_manager_phone",
            "camera_plot", "show_rundown", "rain_plan",
            "client_notes", "broadcast_notes", "playback_notes",
            # Custom contacts
            "custom_contacts",
        ]

        # Fields that need JSON serialization for JSONB columns
        jsonb_fields = ["schedule_blocks", "custom_contacts", "weather_data"]

        # Auto-create or auto-link production day if date provided but no production_day_id
        production_day_id = sheet.get("production_day_id")
        call_sheet_date = sheet.get("date")

        if call_sheet_date and not production_day_id:
            # Check if a production day exists for this date
            existing_day = client.table("backlot_production_days").select("id").eq(
                "project_id", project_id
            ).eq("date", call_sheet_date).limit(1).execute()

            if existing_day.data:
                # Link to existing day
                production_day_id = existing_day.data[0]["id"]
            else:
                # Auto-create new production day
                max_day = client.table("backlot_production_days").select("day_number").eq(
                    "project_id", project_id
                ).order("day_number", desc=True).limit(1).execute()
                next_day_num = (max_day.data[0]["day_number"] + 1) if max_day.data else 1

                day_data = {
                    "project_id": project_id,
                    "date": call_sheet_date,
                    "day_number": sheet.get("shoot_day_number") or next_day_num,
                    "title": sheet.get("title"),
                    "general_call_time": sheet.get("general_call_time") or sheet.get("crew_call_time"),
                    "wrap_time": sheet.get("estimated_wrap_time"),
                    "location_name": sheet.get("location_name"),
                    "location_address": sheet.get("location_address"),
                }
                # Remove None values
                day_data = {k: v for k, v in day_data.items() if v is not None}

                day_result = client.table("backlot_production_days").insert(day_data).execute()
                if day_result.data:
                    production_day_id = day_result.data[0]["id"]

        sheet_data = {
            "project_id": project_id,
            "created_by_user_id": user_id,
        }

        # Add auto-linked production_day_id
        if production_day_id:
            sheet_data["production_day_id"] = production_day_id

        # Copy all allowed fields from input (except production_day_id which we handle above)
        for field in allowed_fields:
            if field == "production_day_id":
                continue  # Already handled
            if field in sheet and sheet[field] is not None:
                value = sheet[field]
                # Serialize JSONB fields to JSON strings
                if field in jsonb_fields and isinstance(value, (list, dict)):
                    sheet_data[field] = json.dumps(value)
                else:
                    sheet_data[field] = value

        result = client.table("backlot_call_sheets").insert(sheet_data).execute()

        return {"call_sheet": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating call sheet: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/call-sheets/{call_sheet_id}")
async def update_call_sheet(
    call_sheet_id: str,
    sheet: dict = Body(...),
    authorization: str = Header(None)
):
    """Update a call sheet"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        existing = client.table("backlot_call_sheets").select("project_id").eq("id", call_sheet_id).execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        await verify_project_access(client, existing.data[0]["project_id"], user["id"])

        # All supported call sheet fields
        allowed_fields = [
            # Core fields
            "production_day_id", "title", "date", "template_type",
            "production_title", "production_company", "header_logo_url",
            "shoot_day_number", "total_shoot_days",
            # Timing
            "crew_call_time", "general_call_time", "first_shot_time",
            "breakfast_time", "lunch_time", "dinner_time",
            "estimated_wrap_time", "sunrise_time", "sunset_time",
            # Location
            "location_name", "location_address", "parking_notes",
            "parking_instructions", "basecamp_location",
            # Contacts
            "production_office_phone", "production_email",
            "upm_name", "upm_phone", "first_ad_name", "first_ad_phone",
            "director_name", "director_phone", "producer_name", "producer_phone",
            "production_contact", "production_phone",
            # Department notes
            "camera_notes", "sound_notes", "grip_electric_notes", "art_notes",
            "wardrobe_notes", "makeup_hair_notes", "stunts_notes", "vfx_notes",
            "transport_notes", "catering_notes",
            # Schedule
            "schedule_blocks",
            # Weather and Timezone
            "weather_forecast", "weather_info",
            "timezone", "timezone_offset", "weather_fetched_at", "weather_data",
            # Safety
            "nearest_hospital", "hospital_address", "hospital_name", "hospital_phone",
            "set_medic", "fire_safety_officer", "safety_notes",
            # Additional
            "general_notes", "advance_schedule", "special_instructions",
            # Medical/Corporate template
            "hipaa_officer", "privacy_notes", "release_status", "restricted_areas",
            "dress_code", "client_name", "client_phone", "facility_contact", "facility_phone",
            # News/ENG template
            "deadline_time", "story_angle", "reporter_name", "reporter_phone", "subject_notes",
            "location_2_name", "location_2_address", "location_3_name", "location_3_address",
            # Live Event template
            "load_in_time", "rehearsal_time", "doors_time", "intermission_time", "strike_time",
            "truck_location", "video_village", "comm_channel",
            "td_name", "td_phone", "stage_manager_name", "stage_manager_phone",
            "camera_plot", "show_rundown", "rain_plan",
            "client_notes", "broadcast_notes", "playback_notes",
            # Custom contacts
            "custom_contacts",
        ]

        # Fields that need JSON serialization for JSONB columns
        jsonb_fields = ["schedule_blocks", "custom_contacts", "weather_data"]

        update_data = {}
        for field in allowed_fields:
            if field in sheet:
                value = sheet[field]
                # Serialize JSONB fields to JSON strings
                if field in jsonb_fields and isinstance(value, (list, dict)):
                    update_data[field] = json.dumps(value)
                else:
                    update_data[field] = value

        result = client.table("backlot_call_sheets").update(update_data).eq("id", call_sheet_id).execute()

        # Bidirectional sync: Update linked production day
        if result.data:
            call_sheet = result.data[0]
            production_day_id = call_sheet.get("production_day_id")
            if production_day_id:
                sync_data = {}
                # Sync date
                if "date" in update_data:
                    sync_data["date"] = update_data["date"]
                if "shoot_day_number" in update_data:
                    sync_data["day_number"] = update_data["shoot_day_number"]
                # Sync times
                if "general_call_time" in update_data:
                    sync_data["general_call_time"] = update_data["general_call_time"]
                if "estimated_wrap_time" in update_data:
                    sync_data["wrap_time"] = update_data["estimated_wrap_time"]
                # Sync location
                if "location_name" in update_data:
                    sync_data["location_name"] = update_data["location_name"]
                if "location_address" in update_data:
                    sync_data["location_address"] = update_data["location_address"]
                # Sync title
                if "title" in update_data:
                    sync_data["title"] = update_data["title"]

                if sync_data:
                    try:
                        client.table("backlot_production_days").update(sync_data).eq(
                            "id", production_day_id
                        ).execute()
                    except Exception as sync_err:
                        # Log but don't fail the main operation
                        print(f"Warning: Failed to sync to production day: {sync_err}")

        return {"call_sheet": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating call sheet: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/call-sheets/{call_sheet_id}/publish")
async def publish_call_sheet(
    call_sheet_id: str,
    publish: bool = Query(...),
    authorization: str = Header(None)
):
    """Publish or unpublish a call sheet"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        existing = client.table("backlot_call_sheets").select("project_id").eq("id", call_sheet_id).execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        await verify_project_access(client, existing.data[0]["project_id"], user["id"], require_edit=True)

        update_data = {
            "is_published": publish,
            "published_at": datetime.utcnow().isoformat() if publish else None,
        }

        result = client.table("backlot_call_sheets").update(update_data).eq("id", call_sheet_id).execute()

        return {"call_sheet": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error publishing call sheet: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/call-sheets/{call_sheet_id}")
async def delete_call_sheet(
    call_sheet_id: str,
    authorization: str = Header(None)
):
    """Delete a call sheet and all related data"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        existing = client.table("backlot_call_sheets").select("project_id").eq("id", call_sheet_id).execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        await verify_project_access(client, existing.data[0]["project_id"], user["id"], require_edit=True)

        # Delete related data first (cascading deletes)
        client.table("backlot_call_sheet_people").delete().eq("call_sheet_id", call_sheet_id).execute()
        client.table("backlot_call_sheet_scenes").delete().eq("call_sheet_id", call_sheet_id).execute()
        client.table("backlot_call_sheet_locations").delete().eq("call_sheet_id", call_sheet_id).execute()
        client.table("backlot_call_sheet_scene_links").delete().eq("call_sheet_id", call_sheet_id).execute()
        client.table("backlot_call_sheet_send_history").delete().eq("call_sheet_id", call_sheet_id).execute()

        # Now delete the call sheet itself
        client.table("backlot_call_sheets").delete().eq("id", call_sheet_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting call sheet: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/call-sheets/{call_sheet_id}/clone")
async def clone_call_sheet(
    call_sheet_id: str,
    clone_input: CallSheetCloneInput,
    authorization: str = Header(None)
):
    """Clone a call sheet with selected data"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get the source call sheet
        source_result = client.table("backlot_call_sheets").select("*").eq("id", call_sheet_id).execute()
        if not source_result.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        source = source_result.data[0]
        await verify_project_access(client, source["project_id"], user["id"], require_edit=True)

        # Prepare the new call sheet data (using correct column names from schema)
        new_call_sheet = {
            "project_id": source["project_id"],
            "production_day_id": source.get("production_day_id"),
            "template_type": source.get("template_type", "feature"),
            "date": clone_input.new_date,
            "shoot_day_number": clone_input.new_day_number or source.get("shoot_day_number"),
            "title": clone_input.new_title or f"Copy of {source.get('title', 'Call Sheet')}",
            "is_published": False,  # Always start as unpublished
            # Core info
            "crew_call_time": source.get("crew_call_time"),
            "general_call_time": source.get("general_call_time"),
            "first_shot_time": source.get("first_shot_time"),
            "breakfast_time": source.get("breakfast_time"),
            "lunch_time": source.get("lunch_time"),
            "dinner_time": source.get("dinner_time"),
            "estimated_wrap_time": source.get("estimated_wrap_time"),
            "sunrise_time": source.get("sunrise_time"),
            "sunset_time": source.get("sunset_time"),
            # Weather and notes
            "weather_forecast": source.get("weather_forecast"),
            "weather_info": source.get("weather_info"),
            "special_instructions": source.get("special_instructions"),
            # Contacts
            "production_office_phone": source.get("production_office_phone"),
            "production_phone": source.get("production_phone"),
            "production_contact": source.get("production_contact"),
            "production_email": source.get("production_email"),
            # Safety info
            "nearest_hospital": source.get("nearest_hospital"),
            "hospital_name": source.get("hospital_name"),
            "hospital_address": source.get("hospital_address"),
            "hospital_phone": source.get("hospital_phone"),
            "set_medic": source.get("set_medic"),
            "fire_safety_officer": source.get("fire_safety_officer"),
            "safety_notes": source.get("safety_notes"),
            # Location info
            "location_name": source.get("location_name"),
            "location_address": source.get("location_address"),
            "parking_notes": source.get("parking_notes"),
            "parking_instructions": source.get("parking_instructions"),
            "basecamp_location": source.get("basecamp_location"),
            # Production info
            "production_title": source.get("production_title"),
            "production_company": source.get("production_company"),
            "total_shoot_days": source.get("total_shoot_days"),
            "header_logo_url": source.get("header_logo_url"),
            # Key contacts
            "upm_name": source.get("upm_name"),
            "upm_phone": source.get("upm_phone"),
            "first_ad_name": source.get("first_ad_name"),
            "first_ad_phone": source.get("first_ad_phone"),
            "director_name": source.get("director_name"),
            "director_phone": source.get("director_phone"),
            "producer_name": source.get("producer_name"),
            "producer_phone": source.get("producer_phone"),
            # Additional
            "general_notes": source.get("general_notes"),
            "advance_schedule": source.get("advance_schedule"),
        }

        # Copy department notes if requested
        if clone_input.keep_department_notes:
            new_call_sheet.update({
                "camera_notes": source.get("camera_notes"),
                "sound_notes": source.get("sound_notes"),
                "grip_electric_notes": source.get("grip_electric_notes"),
                "art_notes": source.get("art_notes"),
                "wardrobe_notes": source.get("wardrobe_notes"),
                "makeup_hair_notes": source.get("makeup_hair_notes"),
                "stunts_notes": source.get("stunts_notes"),
                "vfx_notes": source.get("vfx_notes"),
                "transport_notes": source.get("transport_notes"),
                "catering_notes": source.get("catering_notes"),
            })

        # Copy schedule blocks if requested
        if clone_input.keep_schedule_blocks:
            new_call_sheet["schedule_blocks"] = source.get("schedule_blocks")
            new_call_sheet["custom_contacts"] = source.get("custom_contacts")

        # Note: Template-specific fields (medical_corporate, news_eng, live_event)
        # are not yet in the database schema - skipping for now

        # Create the new call sheet
        result = client.table("backlot_call_sheets").insert(new_call_sheet).execute()
        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create cloned call sheet")

        new_call_sheet_id = result.data[0]["id"]

        # Clone people if requested
        if clone_input.keep_people:
            people_result = client.table("backlot_call_sheet_people").select("*").eq(
                "call_sheet_id", call_sheet_id
            ).execute()

            for person in people_result.data or []:
                new_person = {
                    "call_sheet_id": new_call_sheet_id,
                    "member_id": person.get("member_id"),
                    "name": person.get("name"),
                    "role": person.get("role"),
                    "department": person.get("department"),
                    "call_time": person.get("call_time"),
                    "phone": person.get("phone"),
                    "email": person.get("email"),
                    "notes": person.get("notes"),
                    "makeup_time": person.get("makeup_time"),
                    "pickup_time": person.get("pickup_time"),
                    "on_set_time": person.get("on_set_time"),
                    "wardrobe_notes": person.get("wardrobe_notes"),
                    "sort_order": person.get("sort_order"),
                    "is_cast": person.get("is_cast"),
                    "cast_number": person.get("cast_number"),
                    "character_name": person.get("character_name"),
                }
                client.table("backlot_call_sheet_people").insert(new_person).execute()

        # Clone locations if requested
        if clone_input.keep_locations:
            locations_result = client.table("backlot_call_sheet_locations").select("*").eq(
                "call_sheet_id", call_sheet_id
            ).execute()

            for location in locations_result.data or []:
                new_location = {
                    "call_sheet_id": new_call_sheet_id,
                    "location_id": location.get("location_id"),
                    "library_location_id": location.get("library_location_id"),
                    "location_number": location.get("location_number"),
                    "name": location.get("name"),
                    "address": location.get("address"),
                    "parking_instructions": location.get("parking_instructions"),
                    "basecamp_location": location.get("basecamp_location"),
                    "call_time": location.get("call_time"),
                    "notes": location.get("notes"),
                    "sort_order": location.get("sort_order"),
                }
                client.table("backlot_call_sheet_locations").insert(new_location).execute()

        # Clone scenes if requested
        if clone_input.keep_scenes:
            scenes_result = client.table("backlot_call_sheet_scenes").select("*").eq(
                "call_sheet_id", call_sheet_id
            ).execute()

            for scene in scenes_result.data or []:
                new_scene = {
                    "call_sheet_id": new_call_sheet_id,
                    "scene_number": scene.get("scene_number"),
                    "setting": scene.get("setting"),
                    "int_ext": scene.get("int_ext"),
                    "time_of_day": scene.get("time_of_day"),
                    "description": scene.get("description"),
                    "pages": scene.get("pages"),
                    "cast_ids": scene.get("cast_ids"),
                    "notes": scene.get("notes"),
                    "sort_order": scene.get("sort_order"),
                }
                client.table("backlot_call_sheet_scenes").insert(new_scene).execute()

        return {
            "success": True,
            "call_sheet_id": new_call_sheet_id,
            "message": f"Call sheet cloned successfully"
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error cloning call sheet: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# CREW PRESETS
# =====================================================

class CrewPresetMemberInput(BaseModel):
    """A single crew member in a preset"""
    name: str
    role: Optional[str] = None
    department: Optional[str] = None
    default_call_time: Optional[str] = None
    phone: Optional[str] = None
    email: Optional[str] = None
    is_cast: bool = False
    cast_number: Optional[str] = None
    character_name: Optional[str] = None


class CrewPresetInput(BaseModel):
    """Request body for creating/updating a crew preset"""
    name: str
    description: Optional[str] = None
    template_type: Optional[str] = None  # Optionally associate with a template type
    crew_members: List[CrewPresetMemberInput]


@router.get("/projects/{project_id}/crew-presets")
async def get_crew_presets(
    project_id: str,
    authorization: str = Header(None)
):
    """Get all crew presets for a project (including user's personal presets)"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        # Get project presets and user's personal presets
        result = client.table("backlot_crew_presets").select("*").or_(
            f"project_id.eq.{project_id},user_id.eq.{user['id']}"
        ).order("use_count", desc=True).execute()

        return result.data or []

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting crew presets: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/crew-presets")
async def create_crew_preset(
    project_id: str,
    preset: CrewPresetInput,
    is_personal: bool = False,
    authorization: str = Header(None)
):
    """Create a new crew preset for a project or as a personal preset"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"])

        new_preset = {
            "name": preset.name,
            "description": preset.description,
            "template_type": preset.template_type,
            "crew_members": [m.dict() for m in preset.crew_members],
            "use_count": 0,
        }

        # If personal preset, only set user_id; otherwise set project_id
        if is_personal:
            new_preset["user_id"] = user["id"]
        else:
            new_preset["project_id"] = project_id

        result = client.table("backlot_crew_presets").insert(new_preset).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create preset")

        return result.data[0]

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating crew preset: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/crew-presets/{preset_id}")
async def update_crew_preset(
    preset_id: str,
    preset: CrewPresetInput,
    authorization: str = Header(None)
):
    """Update an existing crew preset"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get the preset and verify access
        existing = client.table("backlot_crew_presets").select("*").eq("id", preset_id).execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Preset not found")

        preset_data = existing.data[0]

        # Verify user has access (owns the preset or has project access)
        if preset_data.get("user_id"):
            if str(preset_data["user_id"]) != str(user["id"]):
                raise HTTPException(status_code=403, detail="Not authorized to modify this preset")
        elif preset_data.get("project_id"):
            await verify_project_access(client, preset_data["project_id"], user["id"])

        update_data = {
            "name": preset.name,
            "description": preset.description,
            "template_type": preset.template_type,
            "crew_members": [m.dict() for m in preset.crew_members],
        }

        result = client.table("backlot_crew_presets").update(update_data).eq("id", preset_id).execute()

        return result.data[0] if result.data else None

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating crew preset: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/crew-presets/{preset_id}")
async def delete_crew_preset(
    preset_id: str,
    authorization: str = Header(None)
):
    """Delete a crew preset"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get the preset and verify access
        existing = client.table("backlot_crew_presets").select("*").eq("id", preset_id).execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Preset not found")

        preset_data = existing.data[0]

        # Verify user has access
        if preset_data.get("user_id"):
            if str(preset_data["user_id"]) != str(user["id"]):
                raise HTTPException(status_code=403, detail="Not authorized to delete this preset")
        elif preset_data.get("project_id"):
            await verify_project_access(client, preset_data["project_id"], user["id"])

        client.table("backlot_crew_presets").delete().eq("id", preset_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting crew preset: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/call-sheets/{call_sheet_id}/apply-preset/{preset_id}")
async def apply_crew_preset_to_call_sheet(
    call_sheet_id: str,
    preset_id: str,
    clear_existing: bool = False,
    authorization: str = Header(None)
):
    """Apply a crew preset to a call sheet, adding all crew members from the preset"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify call sheet access
        sheet_result = client.table("backlot_call_sheets").select("project_id").eq("id", call_sheet_id).execute()
        if not sheet_result.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        await verify_project_access(client, sheet_result.data[0]["project_id"], user["id"])

        # Get the preset
        preset_result = client.table("backlot_crew_presets").select("*").eq("id", preset_id).execute()
        if not preset_result.data:
            raise HTTPException(status_code=404, detail="Preset not found")

        preset = preset_result.data[0]
        crew_members = preset.get("crew_members", [])

        # If clear_existing, remove all current people
        if clear_existing:
            client.table("backlot_call_sheet_people").delete().eq("call_sheet_id", call_sheet_id).execute()

        # Get current max sort_order
        existing_people = client.table("backlot_call_sheet_people").select("sort_order").eq(
            "call_sheet_id", call_sheet_id
        ).order("sort_order", desc=True).limit(1).execute()

        max_sort = 0
        if existing_people.data:
            max_sort = existing_people.data[0].get("sort_order", 0)

        # Add each crew member from the preset
        added_count = 0
        for i, member in enumerate(crew_members):
            new_person = {
                "call_sheet_id": call_sheet_id,
                "name": member.get("name"),
                "role": member.get("role"),
                "department": member.get("department"),
                "call_time": member.get("default_call_time", "06:00"),
                "phone": member.get("phone"),
                "email": member.get("email"),
                "is_cast": member.get("is_cast", False),
                "cast_number": member.get("cast_number"),
                "character_name": member.get("character_name"),
                "sort_order": max_sort + i + 1,
            }
            client.table("backlot_call_sheet_people").insert(new_person).execute()
            added_count += 1

        # Increment use count on the preset
        client.table("backlot_crew_presets").update({
            "use_count": preset.get("use_count", 0) + 1
        }).eq("id", preset_id).execute()

        return {
            "success": True,
            "added_count": added_count,
            "message": f"Added {added_count} crew members from preset"
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error applying crew preset: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/call-sheets/{call_sheet_id}/save-as-preset")
async def save_call_sheet_people_as_preset(
    call_sheet_id: str,
    preset_name: str,
    preset_description: Optional[str] = None,
    is_personal: bool = False,
    authorization: str = Header(None)
):
    """Save the current people on a call sheet as a new crew preset"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify call sheet access
        sheet_result = client.table("backlot_call_sheets").select("project_id, template_type").eq("id", call_sheet_id).execute()
        if not sheet_result.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        project_id = sheet_result.data[0]["project_id"]
        template_type = sheet_result.data[0].get("template_type")

        await verify_project_access(client, project_id, user["id"])

        # Get all people from the call sheet
        people_result = client.table("backlot_call_sheet_people").select("*").eq(
            "call_sheet_id", call_sheet_id
        ).order("sort_order").execute()

        # Convert to preset format
        crew_members = []
        for person in people_result.data or []:
            crew_members.append({
                "name": person.get("name"),
                "role": person.get("role"),
                "department": person.get("department"),
                "default_call_time": person.get("call_time"),
                "phone": person.get("phone"),
                "email": person.get("email"),
                "is_cast": person.get("is_cast", False),
                "cast_number": person.get("cast_number"),
                "character_name": person.get("character_name"),
            })

        new_preset = {
            "name": preset_name,
            "description": preset_description,
            "template_type": template_type,
            "crew_members": crew_members,
            "use_count": 0,
        }

        if is_personal:
            new_preset["user_id"] = user["id"]
        else:
            new_preset["project_id"] = project_id

        result = client.table("backlot_crew_presets").insert(new_preset).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create preset")

        return {
            "success": True,
            "preset": result.data[0],
            "member_count": len(crew_members)
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error saving as preset: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# CALL SHEET TEMPLATES (Account-Level)
# =====================================================

@router.get("/call-sheet-templates")
async def get_call_sheet_templates(
    authorization: str = Header(None)
):
    """Get all call sheet templates for the current user"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        result = client.table("backlot_call_sheet_templates").select("*").eq(
            "user_id", user["id"]
        ).order("use_count", desc=True).execute()

        return {"templates": result.data or []}

    except Exception as e:
        print(f"Error fetching call sheet templates: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/call-sheet-templates")
async def create_call_sheet_template(
    template: dict = Body(...),
    authorization: str = Header(None)
):
    """Create a new call sheet template"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        template_data = {
            "user_id": user["id"],
            "name": template.get("name"),
            "description": template.get("description"),
            "template_type": template.get("template_type"),
            "call_sheet_data": json.dumps(template.get("call_sheet_data", {})) if isinstance(template.get("call_sheet_data"), dict) else template.get("call_sheet_data", "{}"),
            "use_count": 0,
        }

        result = client.table("backlot_call_sheet_templates").insert(template_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create template")

        return {"template": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating call sheet template: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/call-sheet-templates/{template_id}")
async def update_call_sheet_template(
    template_id: str,
    template: dict = Body(...),
    authorization: str = Header(None)
):
    """Update a call sheet template"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify ownership
        existing = client.table("backlot_call_sheet_templates").select("user_id").eq("id", template_id).execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Template not found")
        if existing.data[0]["user_id"] != user["id"]:
            raise HTTPException(status_code=403, detail="Not authorized to update this template")

        update_data = {}
        for field in ["name", "description", "template_type"]:
            if field in template:
                update_data[field] = template[field]

        if "call_sheet_data" in template:
            update_data["call_sheet_data"] = json.dumps(template["call_sheet_data"]) if isinstance(template["call_sheet_data"], dict) else template["call_sheet_data"]

        result = client.table("backlot_call_sheet_templates").update(update_data).eq("id", template_id).execute()

        return {"template": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating call sheet template: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/call-sheet-templates/{template_id}")
async def delete_call_sheet_template(
    template_id: str,
    authorization: str = Header(None)
):
    """Delete a call sheet template"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify ownership
        existing = client.table("backlot_call_sheet_templates").select("user_id").eq("id", template_id).execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Template not found")
        if existing.data[0]["user_id"] != user["id"]:
            raise HTTPException(status_code=403, detail="Not authorized to delete this template")

        client.table("backlot_call_sheet_templates").delete().eq("id", template_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting call sheet template: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/call-sheets/{call_sheet_id}/save-as-template")
async def save_call_sheet_as_template(
    call_sheet_id: str,
    template_name: str = Query(...),
    template_description: str = Query(None),
    authorization: str = Header(None)
):
    """Save an existing call sheet as a reusable template"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get the call sheet with all data
        sheet_result = client.table("backlot_call_sheets").select("*").eq("id", call_sheet_id).execute()
        if not sheet_result.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        call_sheet = sheet_result.data[0]
        await verify_project_access(client, call_sheet["project_id"], user["id"])

        # Get related data
        people_result = client.table("backlot_call_sheet_people").select("*").eq("call_sheet_id", call_sheet_id).order("sort_order").execute()
        scenes_result = client.table("backlot_call_sheet_scenes").select("*").eq("call_sheet_id", call_sheet_id).order("sort_order").execute()
        locations_result = client.table("backlot_call_sheet_locations").select("*").eq("call_sheet_id", call_sheet_id).order("sort_order").execute()

        # Build template data (strip IDs and project-specific fields)
        call_sheet_data = {
            # Basic info
            "title": call_sheet.get("title"),
            "template_type": call_sheet.get("template_type"),
            "production_title": call_sheet.get("production_title"),
            "production_company": call_sheet.get("production_company"),
            "header_logo_url": call_sheet.get("header_logo_url"),
            "shoot_day_number": call_sheet.get("shoot_day_number"),
            "total_shoot_days": call_sheet.get("total_shoot_days"),

            # Timing
            "crew_call_time": call_sheet.get("crew_call_time"),
            "general_call_time": call_sheet.get("general_call_time"),
            "first_shot_time": call_sheet.get("first_shot_time"),
            "breakfast_time": call_sheet.get("breakfast_time"),
            "lunch_time": call_sheet.get("lunch_time"),
            "dinner_time": call_sheet.get("dinner_time"),
            "estimated_wrap_time": call_sheet.get("estimated_wrap_time"),
            "sunrise_time": call_sheet.get("sunrise_time"),
            "sunset_time": call_sheet.get("sunset_time"),

            # Contacts
            "production_office_phone": call_sheet.get("production_office_phone"),
            "production_email": call_sheet.get("production_email"),
            "upm_name": call_sheet.get("upm_name"),
            "upm_phone": call_sheet.get("upm_phone"),
            "first_ad_name": call_sheet.get("first_ad_name"),
            "first_ad_phone": call_sheet.get("first_ad_phone"),
            "director_name": call_sheet.get("director_name"),
            "director_phone": call_sheet.get("director_phone"),
            "producer_name": call_sheet.get("producer_name"),
            "producer_phone": call_sheet.get("producer_phone"),
            "production_contact": call_sheet.get("production_contact"),
            "production_phone": call_sheet.get("production_phone"),

            # Department notes
            "camera_notes": call_sheet.get("camera_notes"),
            "sound_notes": call_sheet.get("sound_notes"),
            "grip_electric_notes": call_sheet.get("grip_electric_notes"),
            "art_notes": call_sheet.get("art_notes"),
            "wardrobe_notes": call_sheet.get("wardrobe_notes"),
            "makeup_hair_notes": call_sheet.get("makeup_hair_notes"),
            "stunts_notes": call_sheet.get("stunts_notes"),
            "vfx_notes": call_sheet.get("vfx_notes"),
            "transport_notes": call_sheet.get("transport_notes"),
            "catering_notes": call_sheet.get("catering_notes"),

            # Schedule
            "schedule_blocks": call_sheet.get("schedule_blocks", []),

            # Custom contacts
            "custom_contacts": call_sheet.get("custom_contacts", []),

            # Weather/Safety/Notes
            "weather_forecast": call_sheet.get("weather_forecast"),
            "weather_info": call_sheet.get("weather_info"),
            "nearest_hospital": call_sheet.get("nearest_hospital"),
            "hospital_address": call_sheet.get("hospital_address"),
            "hospital_name": call_sheet.get("hospital_name"),
            "hospital_phone": call_sheet.get("hospital_phone"),
            "set_medic": call_sheet.get("set_medic"),
            "fire_safety_officer": call_sheet.get("fire_safety_officer"),
            "safety_notes": call_sheet.get("safety_notes"),
            "general_notes": call_sheet.get("general_notes"),
            "advance_schedule": call_sheet.get("advance_schedule"),
            "special_instructions": call_sheet.get("special_instructions"),

            # Template-specific fields
            "hipaa_officer": call_sheet.get("hipaa_officer"),
            "privacy_notes": call_sheet.get("privacy_notes"),
            "release_status": call_sheet.get("release_status"),
            "restricted_areas": call_sheet.get("restricted_areas"),
            "dress_code": call_sheet.get("dress_code"),
            "client_name": call_sheet.get("client_name"),
            "client_phone": call_sheet.get("client_phone"),
            "facility_contact": call_sheet.get("facility_contact"),
            "facility_phone": call_sheet.get("facility_phone"),
            "deadline_time": call_sheet.get("deadline_time"),
            "story_angle": call_sheet.get("story_angle"),
            "reporter_name": call_sheet.get("reporter_name"),
            "reporter_phone": call_sheet.get("reporter_phone"),
            "subject_notes": call_sheet.get("subject_notes"),
            "load_in_time": call_sheet.get("load_in_time"),
            "rehearsal_time": call_sheet.get("rehearsal_time"),
            "doors_time": call_sheet.get("doors_time"),
            "intermission_time": call_sheet.get("intermission_time"),
            "strike_time": call_sheet.get("strike_time"),
            "truck_location": call_sheet.get("truck_location"),
            "video_village": call_sheet.get("video_village"),
            "comm_channel": call_sheet.get("comm_channel"),
            "td_name": call_sheet.get("td_name"),
            "td_phone": call_sheet.get("td_phone"),
            "stage_manager_name": call_sheet.get("stage_manager_name"),
            "stage_manager_phone": call_sheet.get("stage_manager_phone"),
            "camera_plot": call_sheet.get("camera_plot"),
            "show_rundown": call_sheet.get("show_rundown"),
            "rain_plan": call_sheet.get("rain_plan"),
            "client_notes": call_sheet.get("client_notes"),
            "broadcast_notes": call_sheet.get("broadcast_notes"),
            "playback_notes": call_sheet.get("playback_notes"),

            # Nested data (stripped of IDs)
            "locations": [
                {
                    "location_number": loc.get("location_number"),
                    "name": loc.get("name"),
                    "address": loc.get("address"),
                    "parking_instructions": loc.get("parking_instructions"),
                    "basecamp_location": loc.get("basecamp_location"),
                    "call_time": loc.get("call_time"),
                    "notes": loc.get("notes"),
                    "sort_order": loc.get("sort_order"),
                }
                for loc in (locations_result.data or [])
            ],
            "scenes": [
                {
                    "scene_number": scene.get("scene_number"),
                    "segment_label": scene.get("segment_label"),
                    "page_count": scene.get("page_count"),
                    "set_name": scene.get("set_name"),
                    "int_ext": scene.get("int_ext"),
                    "time_of_day": scene.get("time_of_day"),
                    "description": scene.get("description"),
                    "cast_ids": scene.get("cast_ids"),
                    "notes": scene.get("notes"),
                    "sort_order": scene.get("sort_order"),
                }
                for scene in (scenes_result.data or [])
            ],
            "people": [
                {
                    "name": person.get("name"),
                    "role": person.get("role"),
                    "department": person.get("department"),
                    "call_time": person.get("call_time"),
                    "phone": person.get("phone"),
                    "email": person.get("email"),
                    "notes": person.get("notes"),
                    "makeup_time": person.get("makeup_time"),
                    "pickup_time": person.get("pickup_time"),
                    "on_set_time": person.get("on_set_time"),
                    "wardrobe_notes": person.get("wardrobe_notes"),
                    "is_cast": person.get("is_cast", False),
                    "cast_number": person.get("cast_number"),
                    "character_name": person.get("character_name"),
                    "sort_order": person.get("sort_order"),
                }
                for person in (people_result.data or [])
            ],
        }

        # Remove None values to keep it clean
        call_sheet_data = {k: v for k, v in call_sheet_data.items() if v is not None}

        # Create the template
        template_data = {
            "user_id": user["id"],
            "name": template_name,
            "description": template_description,
            "template_type": call_sheet.get("template_type"),
            "call_sheet_data": json.dumps(call_sheet_data),
            "use_count": 0,
        }

        result = client.table("backlot_call_sheet_templates").insert(template_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create template")

        return {
            "success": True,
            "template": result.data[0],
            "stats": {
                "locations": len(call_sheet_data.get("locations", [])),
                "scenes": len(call_sheet_data.get("scenes", [])),
                "people": len(call_sheet_data.get("people", [])),
            }
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error saving call sheet as template: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/call-sheets/{call_sheet_id}/full")
async def get_call_sheet_full(
    call_sheet_id: str,
    authorization: str = Header(None)
):
    """Get a call sheet with all related data (people, scenes, locations) for prefilling"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get the call sheet
        sheet_result = client.table("backlot_call_sheets").select("*").eq("id", call_sheet_id).execute()
        if not sheet_result.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        call_sheet = sheet_result.data[0]
        await verify_project_access(client, call_sheet["project_id"], user["id"])

        # Get related data
        people_result = client.table("backlot_call_sheet_people").select("*").eq("call_sheet_id", call_sheet_id).order("sort_order").execute()
        scenes_result = client.table("backlot_call_sheet_scenes").select("*").eq("call_sheet_id", call_sheet_id).order("sort_order").execute()
        locations_result = client.table("backlot_call_sheet_locations").select("*").eq("call_sheet_id", call_sheet_id).order("sort_order").execute()

        # Attach to call sheet
        call_sheet["people"] = people_result.data or []
        call_sheet["scenes"] = scenes_result.data or []
        call_sheet["locations"] = locations_result.data or []

        return {"call_sheet": call_sheet}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching full call sheet: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/call-sheet-templates/{template_id}/use")
async def increment_template_use_count(
    template_id: str,
    authorization: str = Header(None)
):
    """Increment the use count for a template (called when a user uses a template)"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify ownership
        existing = client.table("backlot_call_sheet_templates").select("user_id, use_count").eq("id", template_id).execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Template not found")
        if existing.data[0]["user_id"] != user["id"]:
            raise HTTPException(status_code=403, detail="Not authorized")

        new_count = (existing.data[0]["use_count"] or 0) + 1
        client.table("backlot_call_sheet_templates").update({
            "use_count": new_count,
            "last_used_at": datetime.utcnow().isoformat()
        }).eq("id", template_id).execute()

        return {"success": True, "use_count": new_count}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error incrementing template use count: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# CALL SHEET PEOPLE CRUD
# =====================================================

@router.get("/call-sheets/{call_sheet_id}/people")
async def get_call_sheet_people(
    call_sheet_id: str,
    authorization: str = Header(None)
):
    """Get all people for a call sheet"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        sheet_result = client.table("backlot_call_sheets").select("project_id").eq("id", call_sheet_id).execute()
        if not sheet_result.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        await verify_project_access(client, sheet_result.data[0]["project_id"], user["id"])

        result = client.table("backlot_call_sheet_people").select("*").eq(
            "call_sheet_id", call_sheet_id
        ).order("sort_order").execute()

        return {"people": result.data or []}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting call sheet people: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/call-sheets/{call_sheet_id}/people")
async def add_call_sheet_person(
    call_sheet_id: str,
    person: dict = Body(...),
    authorization: str = Header(None)
):
    """Add a person to a call sheet"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        sheet_result = client.table("backlot_call_sheets").select("project_id").eq("id", call_sheet_id).execute()
        if not sheet_result.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        await verify_project_access(client, sheet_result.data[0]["project_id"], user["id"])

        person_data = {
            "call_sheet_id": call_sheet_id,
            "member_id": person.get("member_id"),
            "name": person.get("name"),
            "role": person.get("role"),
            "department": person.get("department"),
            "call_time": person.get("call_time"),
            "phone": person.get("phone"),
            "email": person.get("email"),
            "notes": person.get("notes"),
            "makeup_time": person.get("makeup_time"),
            "wardrobe_notes": person.get("wardrobe_notes"),
            "sort_order": person.get("sort_order", 0),
        }

        result = client.table("backlot_call_sheet_people").insert(person_data).execute()

        return {"person": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error adding person: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/call-sheets/{call_sheet_id}/people/{person_id}")
async def update_call_sheet_person(
    call_sheet_id: str,
    person_id: str,
    person: dict = Body(...),
    authorization: str = Header(None)
):
    """Update a person on a call sheet"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        sheet_result = client.table("backlot_call_sheets").select("project_id").eq("id", call_sheet_id).execute()
        if not sheet_result.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        await verify_project_access(client, sheet_result.data[0]["project_id"], user["id"])

        update_data = {}
        for field in ["member_id", "name", "role", "department", "call_time",
                      "phone", "email", "notes", "makeup_time", "wardrobe_notes", "sort_order"]:
            if field in person:
                update_data[field] = person[field]

        result = client.table("backlot_call_sheet_people").update(update_data).eq("id", person_id).execute()

        return {"person": result.data[0] if result.data else None}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating person: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/call-sheets/{call_sheet_id}/people/{person_id}")
async def remove_call_sheet_person(
    call_sheet_id: str,
    person_id: str,
    authorization: str = Header(None)
):
    """Remove a person from a call sheet"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        sheet_result = client.table("backlot_call_sheets").select("project_id").eq("id", call_sheet_id).execute()
        if not sheet_result.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        await verify_project_access(client, sheet_result.data[0]["project_id"], user["id"])

        client.table("backlot_call_sheet_people").delete().eq("id", person_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error removing person: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/call-sheets/{call_sheet_id}/people/reorder")
async def reorder_call_sheet_people(
    call_sheet_id: str,
    person_ids: List[str] = Body(...),
    authorization: str = Header(None)
):
    """Reorder people on a call sheet"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        sheet_result = client.table("backlot_call_sheets").select("project_id").eq("id", call_sheet_id).execute()
        if not sheet_result.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        await verify_project_access(client, sheet_result.data[0]["project_id"], user["id"])

        for index, person_id in enumerate(person_ids):
            client.table("backlot_call_sheet_people").update(
                {"sort_order": index}
            ).eq("id", person_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error reordering people: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/call-sheets/{call_sheet_id}/people/bulk-update-times")
async def bulk_update_department_times(
    call_sheet_id: str,
    update: BulkDepartmentTimeUpdate,
    authorization: str = Header(None)
):
    """Bulk update call times for all people in a department"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify call sheet exists and user has access
        sheet_result = client.table("backlot_call_sheets").select("project_id").eq("id", call_sheet_id).execute()
        if not sheet_result.data:
            raise HTTPException(status_code=404, detail="Call sheet not found")

        await verify_project_access(client, sheet_result.data[0]["project_id"], user["id"])

        # Build the query for finding people in this department
        query = client.table("backlot_call_sheet_people").select("id, call_time, makeup_time, pickup_time, on_set_time").eq(
            "call_sheet_id", call_sheet_id
        ).eq("department", update.department)

        people_result = query.execute()
        if not people_result.data:
            return {"success": True, "updated_count": 0, "message": "No people found in department"}

        updated_count = 0
        for person in people_result.data:
            update_data = {}

            # Only update fields that were provided
            if update.call_time is not None:
                if update.apply_to == "all" or not person.get("call_time"):
                    update_data["call_time"] = update.call_time

            if update.makeup_time is not None:
                if update.apply_to == "all" or not person.get("makeup_time"):
                    update_data["makeup_time"] = update.makeup_time

            if update.pickup_time is not None:
                if update.apply_to == "all" or not person.get("pickup_time"):
                    update_data["pickup_time"] = update.pickup_time

            if update.on_set_time is not None:
                if update.apply_to == "all" or not person.get("on_set_time"):
                    update_data["on_set_time"] = update.on_set_time

            # Only perform update if there's data to update
            if update_data:
                client.table("backlot_call_sheet_people").update(update_data).eq("id", person["id"]).execute()
                updated_count += 1

        return {
            "success": True,
            "updated_count": updated_count,
            "total_in_department": len(people_result.data)
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error bulk updating times: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/can-manage-roles")
async def can_manage_roles(
    project_id: str,
    authorization: str = Header(None)
):
    """Check if current user can manage roles"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # user["id"] is already the profile ID from get_current_user_from_token
        user_id = str(user["id"])

        # Get the profile role using profile ID
        profile_result = client.table("profiles").select("id, role, is_admin, is_superadmin").eq(
            "id", user_id
        ).limit(1).execute()

        if not profile_result.data:
            print(f"[can-manage-roles] No profile found for user: {user_id}")
            return {"can_manage": False}

        profile = profile_result.data[0]
        profile_role = profile.get("role")

        # Check admin status first
        if profile_role in ["admin", "superadmin"] or profile.get("is_admin") or profile.get("is_superadmin"):
            return {"can_manage": True}

        # Check if project owner
        project_result = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        if project_result.data:
            owner_id = str(project_result.data[0]["owner_id"])
            if owner_id == user_id:
                return {"can_manage": True}

        # Check if showrunner
        roles_result = client.table("backlot_project_roles").select("backlot_role").eq(
            "project_id", project_id
        ).eq("user_id", user_id).eq("backlot_role", "showrunner").execute()

        return {"can_manage": len(roles_result.data or []) > 0}

    except Exception as e:
        print(f"Error checking manage roles permission: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Desktop API Keys & Dailies Enhancements
# =====================================================

import secrets
import hashlib


class DesktopApiKeyCreate(BaseModel):
    """Input for creating a desktop API key"""
    name: str = "Desktop App"
    scopes: List[str] = ["dailies:write", "dailies:read"]
    expires_in_days: Optional[int] = None  # None = never expires


class DesktopApiKeyResponse(BaseModel):
    """Response for API key (key only shown on create)"""
    id: str
    project_id: str
    user_id: str
    key_prefix: str
    name: str
    scopes: List[str]
    last_used_at: Optional[str] = None
    expires_at: Optional[str] = None
    is_revoked: bool
    created_at: str


class ClipAssetLinkInput(BaseModel):
    """Input for linking a clip to an asset"""
    asset_id: str
    link_type: str = "source"  # source, reference, alternate
    notes: Optional[str] = None


class PresignedUploadRequest(BaseModel):
    """Request for a presigned upload URL"""
    project_id: str
    card_id: Optional[str] = None
    file_name: str
    content_type: str = "video/mp4"
    file_size: Optional[int] = None


class ConfirmUploadRequest(BaseModel):
    """Confirm upload completion"""
    s3_key: str
    checksum: Optional[str] = None
    proxy_checksum: Optional[str] = None
    thumbnail_url: Optional[str] = None


# =====================================================
# Presigned Upload URL Endpoints
# =====================================================

@router.post("/dailies/upload-url")
async def get_dailies_upload_url(
    request: PresignedUploadRequest,
    authorization: str = Header(None),
    api_key: str = Header(None, alias="X-API-Key")
):
    """
    Get a presigned URL for uploading a dailies proxy file to S3.
    Can authenticate via either Bearer token or X-API-Key header.
    """
    # Authenticate via API key or Bearer token
    user_id = None
    project_id = request.project_id

    if api_key:
        # Verify API key - check both desktop key tables
        key_hash = hashlib.sha256(api_key.encode()).hexdigest()
        client = get_client()

        # First try the old backlot_desktop_api_keys table
        key_result = client.table("backlot_desktop_api_keys").select("*").eq(
            "key_hash", key_hash
        ).eq("is_revoked", False).execute()

        if key_result.data:
            key = key_result.data[0]
            if str(key["project_id"]) != project_id:
                raise HTTPException(status_code=403, detail="API key not valid for this project")
            user_id = str(key["user_id"])
        else:
            # Try the new backlot_desktop_keys table (swn_dk_ keys)
            key_record = execute_single(
                """
                SELECT dk.id, dk.user_id
                FROM backlot_desktop_keys dk
                WHERE dk.key_hash = :key_hash AND dk.is_active = true
                """,
                {"key_hash": key_hash}
            )

            if not key_record:
                raise HTTPException(status_code=401, detail="Invalid or expired API key")

            user_id = str(key_record["user_id"])

            # Verify user has access to the project
            access_check = execute_single(
                """
                SELECT 1 FROM backlot_projects p
                LEFT JOIN backlot_project_members pm ON pm.project_id = p.id AND pm.user_id = :user_id
                WHERE p.id = :project_id AND (p.owner_id = :user_id OR pm.user_id = :user_id)
                """,
                {"project_id": project_id, "user_id": user_id}
            )

            if not access_check:
                raise HTTPException(status_code=403, detail="Access denied to this project")
    elif authorization:
        user = await get_current_user_from_token(authorization)
        user_id = user["id"]
    else:
        raise HTTPException(status_code=401, detail="Authentication required")

    # Check storage quota before allowing upload
    file_size = getattr(request, 'file_size', 0) or 0
    await check_storage_quota(user_id, file_size)
    _enforce_org_storage(project_id, file_size)

    try:
        import uuid
        import boto3
        from botocore.config import Config

        # Create standalone asset  single source of truth for the file
        standalone_asset_id = str(uuid.uuid4())
        s3_key = f"projects/{project_id}/assets/{standalone_asset_id}/{request.file_name}"
        bucket_name = os.environ.get("AWS_S3_BACKLOT_FILES_BUCKET", "swn-backlot-files-517220555400")

        # Create standalone asset record
        file_ext = request.file_name.rsplit('.', 1)[-1].lower() if '.' in request.file_name else ''
        is_video = request.content_type.startswith('video/') or file_ext in ('mp4', 'mov', 'avi', 'webm', 'mkv')
        asset_name = request.file_name.rsplit('.', 1)[0] if '.' in request.file_name else request.file_name
        client = get_client()
        standalone_data = {
            "id": standalone_asset_id,
            "project_id": project_id,
            "name": asset_name,
            "asset_type": "video" if is_video else "other",
            "file_name": request.file_name,
            "s3_key": s3_key,
            "mime_type": request.content_type,
            "file_size_bytes": request.file_size,
            "tags": [],
            "metadata": {},
            "created_by_user_id": user_id,
        }
        client.table("backlot_standalone_assets").insert(standalone_data).execute()

        # Generate presigned URL
        s3_client = boto3.client('s3', config=Config(signature_version='s3v4'))

        upload_url = s3_client.generate_presigned_url(
            'put_object',
            Params={
                'Bucket': bucket_name,
                'Key': s3_key,
                'ContentType': request.content_type,
            },
            ExpiresIn=900,  # 15 minutes
        )

        return {
            "upload_url": upload_url,
            "key": s3_key,
            "s3_key": s3_key,
            "standalone_asset_id": standalone_asset_id,
            "expires_in": 900,
            "bucket": bucket_name,
        }

    except Exception as e:
        print(f"Error generating presigned URL: {e}")
        raise HTTPException(status_code=500, detail=str(e))


class DailiesBrowserUploadRequest(BaseModel):
    """Request for browser-based dailies upload through standalone assets"""
    project_id: str
    filename: str
    content_type: str = "video/mp4"


class CompleteDailiesBrowserUploadRequest(BaseModel):
    """Complete a browser dailies upload  creates the clip linked to the standalone asset"""
    standalone_asset_id: str
    project_id: str
    camera_label: Optional[str] = None
    scene_number: Optional[str] = None
    take_number: Optional[int] = None


@router.post("/dailies/browser-upload-url")
async def get_dailies_browser_upload_url(
    request: DailiesBrowserUploadRequest,
    authorization: str = Header(None)
):
    """
    Get a presigned URL for browser-based dailies upload.
    The file is stored as a standalone asset so there is only one copy.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        project_id = request.project_id
        await verify_project_access(client, project_id, user["id"], require_edit=True)

        # Check storage quota
        await check_storage_quota(user["id"], 0)
        _enforce_org_storage(project_id)

        import boto3
        import uuid
        from botocore.config import Config

        standalone_asset_id = str(uuid.uuid4())

        # Store under standalone assets path  single source of truth
        s3_key = f"projects/{project_id}/assets/{standalone_asset_id}/{request.filename}"
        bucket_name = os.environ.get("AWS_S3_BACKLOT_FILES_BUCKET", "swn-backlot-files-517220555400")

        s3_client = boto3.client('s3', config=Config(signature_version='s3v4'))

        presigned_url = s3_client.generate_presigned_url(
            'put_object',
            Params={
                'Bucket': bucket_name,
                'Key': s3_key,
                'ContentType': request.content_type,
            },
            ExpiresIn=3600  # 1 hour
        )

        # Create standalone asset record
        file_ext = request.filename.rsplit('.', 1)[-1].lower() if '.' in request.filename else ''
        is_video = request.content_type.startswith('video/') or file_ext in ('mp4', 'mov', 'avi', 'webm', 'mkv')
        asset_name = request.filename.rsplit('.', 1)[0] if '.' in request.filename else request.filename

        standalone_data = {
            "id": standalone_asset_id,
            "project_id": project_id,
            "name": asset_name,
            "asset_type": "video" if is_video else "other",
            "file_name": request.filename,
            "s3_key": s3_key,
            "mime_type": request.content_type,
            "tags": [],
            "metadata": {},
            "created_by_user_id": user["id"],
        }
        client.table("backlot_standalone_assets").insert(standalone_data).execute()

        return {
            "upload_url": presigned_url,
            "s3_key": s3_key,
            "standalone_asset_id": standalone_asset_id,
            "expires_in": 3600,
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error generating dailies browser upload URL: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/dailies/complete-browser-upload")
async def complete_dailies_browser_upload(
    request: CompleteDailiesBrowserUploadRequest,
    authorization: str = Header(None)
):
    """
    Complete a browser-based dailies upload.
    Creates a dailies clip record linked to the standalone asset.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, request.project_id, user["id"], require_edit=True)

        # Get the standalone asset to copy metadata from
        asset_result = client.table("backlot_standalone_assets").select("*").eq("id", request.standalone_asset_id).execute()
        if not asset_result.data:
            raise HTTPException(status_code=404, detail="Standalone asset not found")
        asset_data = asset_result.data[0]

        # Build cloud URL
        bucket = os.environ.get("AWS_S3_BACKLOT_FILES_BUCKET", "swn-backlot-files-517220555400")
        cloud_url = f"https://{bucket}.s3.amazonaws.com/{asset_data['s3_key']}"

        # Try to get file size from S3
        file_size = None
        try:
            import boto3
            s3_client = boto3.client("s3", region_name="us-east-1")
            head = s3_client.head_object(Bucket=bucket, Key=asset_data["s3_key"])
            file_size = head.get("ContentLength")
            if file_size:
                client.table("backlot_standalone_assets").update({
                    "file_size_bytes": file_size,
                }).eq("id", request.standalone_asset_id).execute()
        except Exception as size_err:
            print(f"Could not get file size: {size_err}")

        # Create dailies clip linked to standalone asset
        clip_data = {
            "project_id": request.project_id,
            "file_name": asset_data["file_name"],
            "file_path": asset_data["s3_key"],
            "cloud_url": cloud_url,
            "proxy_url": cloud_url,
            "storage_mode": "cloud",
            "upload_status": "completed",
            "camera_label": request.camera_label or "A",
            "scene_number": request.scene_number,
            "take_number": request.take_number,
            "file_size_bytes": file_size,
            "linked_standalone_asset_id": request.standalone_asset_id,
            "created_by_user_id": user["id"],
        }
        if asset_data.get("duration_seconds"):
            clip_data["duration_seconds"] = float(asset_data["duration_seconds"])

        result = client.table("backlot_dailies_clips").insert(clip_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create clip")

        return {"clip": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error completing dailies browser upload: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/storage/quota")
async def get_user_storage_quota(authorization: str = Header(None)):
    """Get the current user's storage quota status"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]

    # Get quota info without checking file size
    quota_info = await check_storage_quota(user_id, 0)

    # Format bytes for display
    def format_bytes(bytes_val: int) -> str:
        if bytes_val is None:
            return "0 B"
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if abs(bytes_val) < 1024.0:
                return f"{bytes_val:.1f} {unit}"
            bytes_val /= 1024.0
        return f"{bytes_val:.1f} PB"

    return {
        "bytes_used": quota_info["bytes_used"],
        "bytes_used_formatted": format_bytes(quota_info["bytes_used"]),
        "quota_bytes": quota_info["quota_bytes"],
        "quota_formatted": format_bytes(quota_info["quota_bytes"]),
        "bytes_remaining": quota_info["bytes_remaining"],
        "bytes_remaining_formatted": format_bytes(quota_info["bytes_remaining"]),
        "percentage_used": quota_info["percentage_used"]
    }


@router.post("/dailies/clips/{clip_id}/confirm-upload")
async def confirm_dailies_upload(
    clip_id: str,
    request: ConfirmUploadRequest,
    authorization: str = Header(None),
    api_key: str = Header(None, alias="X-API-Key")
):
    """
    Confirm that a dailies proxy upload completed successfully.
    Updates the clip with cloud_url and checksum info.
    """
    # Authenticate via API key or Bearer token
    if api_key:
        key_hash = hashlib.sha256(api_key.encode()).hexdigest()
        client = get_client()

        # Check old table first
        key_result = client.table("backlot_desktop_api_keys").select("*").eq(
            "key_hash", key_hash
        ).eq("is_revoked", False).execute()

        if not key_result.data:
            # Try new desktop keys table
            key_record = execute_single(
                """
                SELECT dk.id, dk.user_id
                FROM backlot_desktop_keys dk
                WHERE dk.key_hash = :key_hash AND dk.is_active = true
                """,
                {"key_hash": key_hash}
            )
            if not key_record:
                raise HTTPException(status_code=401, detail="Invalid API key")
    elif authorization:
        await get_current_user_from_token(authorization)
        client = get_client()
    else:
        raise HTTPException(status_code=401, detail="Authentication required")

    try:
        # Build the full S3 URL
        cloud_url = f"https://swn-backlot-files-517220555400.s3.us-east-1.amazonaws.com/{request.s3_key}"

        update_data = {
            "proxy_url": cloud_url,
            "upload_status": "completed",
        }

        if request.checksum:
            update_data["original_checksum"] = request.checksum
        if request.proxy_checksum:
            update_data["proxy_checksum"] = request.proxy_checksum
        if request.thumbnail_url:
            update_data["thumbnail_url"] = request.thumbnail_url

        result = client.table("backlot_dailies_clips").update(update_data).eq(
            "id", clip_id
        ).execute()

        if not result.data:
            raise HTTPException(status_code=404, detail="Clip not found")

        return {
            "success": True,
            "clip_id": clip_id,
            "proxy_url": cloud_url,
            "message": "Upload confirmed"
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error confirming upload: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Clip-Asset Linking Endpoints
# =====================================================

@router.post("/dailies/clips/{clip_id}/link-asset")
async def link_clip_to_asset(
    clip_id: str,
    input: ClipAssetLinkInput,
    authorization: str = Header(None)
):
    """Link a dailies clip to an asset as source material"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get the clip to find project_id
        clip_result = client.table("backlot_dailies_clips").select(
            "id, card_id"
        ).eq("id", clip_id).execute()

        if not clip_result.data:
            raise HTTPException(status_code=404, detail="Clip not found")

        # Get card to find day, then project
        card_result = client.table("backlot_dailies_cards").select(
            "day_id"
        ).eq("id", str(clip_result.data[0]["card_id"])).execute()

        if not card_result.data:
            raise HTTPException(status_code=404, detail="Card not found")

        day_result = client.table("backlot_dailies_days").select(
            "project_id"
        ).eq("id", str(card_result.data[0]["day_id"])).execute()

        if not day_result.data:
            raise HTTPException(status_code=404, detail="Day not found")

        project_id = str(day_result.data[0]["project_id"])

        # Verify access
        await verify_project_access(client, project_id, user_id)

        # Create the link
        link_data = {
            "clip_id": clip_id,
            "asset_id": input.asset_id,
            "project_id": project_id,
            "link_type": input.link_type,
            "notes": input.notes,
            "created_by_user_id": user_id,
        }

        result = client.table("backlot_dailies_clip_asset_links").insert(link_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create link")

        link = result.data[0]
        return {
            "success": True,
            "link": {
                "id": str(link["id"]),
                "clip_id": str(link["clip_id"]),
                "asset_id": str(link["asset_id"]),
                "link_type": link["link_type"],
                "notes": link.get("notes"),
                "created_at": link["created_at"],
            }
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error linking clip to asset: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/dailies/clip-asset-links/{link_id}")
async def remove_clip_asset_link(
    link_id: str,
    authorization: str = Header(None)
):
    """Remove a link between a clip and an asset"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get the link to verify access
        link_result = client.table("backlot_dailies_clip_asset_links").select(
            "project_id"
        ).eq("id", link_id).execute()

        if not link_result.data:
            raise HTTPException(status_code=404, detail="Link not found")

        project_id = str(link_result.data[0]["project_id"])
        await verify_project_access(client, project_id, user_id)

        # Delete the link
        client.table("backlot_dailies_clip_asset_links").delete().eq("id", link_id).execute()

        return {"success": True, "message": "Link removed"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error removing clip-asset link: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/assets/{asset_id}/source-clips")
async def get_asset_source_clips(
    asset_id: str,
    authorization: str = Header(None)
):
    """Get all dailies clips linked to an asset"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get asset to verify project access
        asset_result = client.table("backlot_assets").select(
            "project_id"
        ).eq("id", asset_id).execute()

        if not asset_result.data:
            raise HTTPException(status_code=404, detail="Asset not found")

        project_id = str(asset_result.data[0]["project_id"])
        await verify_project_access(client, project_id, user_id)

        # Get all links for this asset
        links_result = client.table("backlot_dailies_clip_asset_links").select("*").eq(
            "asset_id", asset_id
        ).order("created_at", desc=True).execute()

        if not links_result.data:
            return {"clips": []}

        # Get clip details
        clip_ids = [str(link["clip_id"]) for link in links_result.data]
        clips_result = client.table("backlot_dailies_clips").select("*").in_(
            "id", clip_ids
        ).execute()

        clips_map = {str(c["id"]): c for c in (clips_result.data or [])}

        # Build response with clip details
        clips = []
        for link in links_result.data:
            clip = clips_map.get(str(link["clip_id"]))
            if clip:
                clips.append({
                    "link_id": str(link["id"]),
                    "link_type": link["link_type"],
                    "link_notes": link.get("notes"),
                    "linked_at": link["created_at"],
                    "clip": {
                        "id": str(clip["id"]),
                        "file_name": clip.get("file_name"),
                        "scene_number": clip.get("scene_number"),
                        "take_number": clip.get("take_number"),
                        "duration_seconds": clip.get("duration_seconds"),
                        "proxy_url": clip.get("proxy_url"),
                        "cloud_url": clip.get("cloud_url"),
                        "thumbnail_url": clip.get("thumbnail_url"),
                        "is_circle_take": clip.get("is_circle_take"),
                        "rating": clip.get("rating"),
                    }
                })

        return {"clips": clips, "count": len(clips)}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting asset source clips: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/dailies/clips/{clip_id}/linked-assets")
async def get_clip_linked_assets(
    clip_id: str,
    authorization: str = Header(None)
):
    """Get all assets linked to a dailies clip"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get all links for this clip
        links_result = client.table("backlot_dailies_clip_asset_links").select("*").eq(
            "clip_id", clip_id
        ).order("created_at", desc=True).execute()

        if not links_result.data:
            return {"assets": []}

        # Get asset details
        asset_ids = [str(link["asset_id"]) for link in links_result.data]
        assets_result = client.table("backlot_assets").select("*").in_(
            "id", asset_ids
        ).execute()

        assets_map = {str(a["id"]): a for a in (assets_result.data or [])}

        # Build response
        assets = []
        for link in links_result.data:
            asset = assets_map.get(str(link["asset_id"]))
            if asset:
                assets.append({
                    "link_id": str(link["id"]),
                    "link_type": link["link_type"],
                    "link_notes": link.get("notes"),
                    "linked_at": link["created_at"],
                    "asset": {
                        "id": str(asset["id"]),
                        "title": asset.get("title"),
                        "asset_type": asset.get("asset_type"),
                        "status": asset.get("status"),
                        "version_label": asset.get("version_label"),
                    }
                })

        return {"assets": assets, "count": len(assets)}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting clip linked assets: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/dailies/bulk-link-assets")
async def bulk_link_clips_to_asset(
    clip_ids: List[str],
    asset_id: str,
    link_type: str = "source",
    authorization: str = Header(None)
):
    """Link multiple clips to a single asset"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Verify asset access
        asset_result = client.table("backlot_assets").select(
            "project_id"
        ).eq("id", asset_id).execute()

        if not asset_result.data:
            raise HTTPException(status_code=404, detail="Asset not found")

        project_id = str(asset_result.data[0]["project_id"])
        await verify_project_access(client, project_id, user_id)

        # Create links for each clip
        created = 0
        skipped = 0
        for clip_id in clip_ids:
            try:
                link_data = {
                    "clip_id": clip_id,
                    "asset_id": asset_id,
                    "project_id": project_id,
                    "link_type": link_type,
                    "created_by_user_id": user_id,
                }
                client.table("backlot_dailies_clip_asset_links").insert(link_data).execute()
                created += 1
            except Exception:
                # Link already exists or clip doesn't exist
                skipped += 1

        return {
            "success": True,
            "created": created,
            "skipped": skipped,
            "message": f"Linked {created} clips to asset"
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error bulk linking clips: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =============================================================================
# PURCHASE ORDERS
# =============================================================================

class CreatePurchaseOrderRequest(BaseModel):
    description: str
    estimated_amount: float
    vendor_name: Optional[str] = None
    department: Optional[str] = None
    budget_category_id: Optional[str] = None
    notes: Optional[str] = None


class UpdatePurchaseOrderRequest(BaseModel):
    description: Optional[str] = None
    estimated_amount: Optional[float] = None
    vendor_name: Optional[str] = None
    department: Optional[str] = None
    budget_category_id: Optional[str] = None
    notes: Optional[str] = None


class RejectPurchaseOrderRequest(BaseModel):
    reason: str


class ApprovalNotesRequest(BaseModel):
    notes: Optional[str] = None  # Optional notes when approving


class DenyPurchaseOrderRequest(BaseModel):
    reason: str  # Required - reason for denial (permanent rejection)


@router.get("/projects/{project_id}/purchase-orders")
async def get_project_purchase_orders(
    project_id: str,
    status: Optional[str] = None,
    department: Optional[str] = None,
    requested_by: Optional[str] = None,
    authorization: str = Header(None)
):
    """Get all purchase orders for a project"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        await verify_project_access(client, project_id, user_id)

        query = client.table("backlot_purchase_orders").select(
            "*, requester:profiles!requested_by(display_name, avatar_url), approver:profiles!approved_by(display_name)"
        ).eq("project_id", project_id)

        if status and status != "all":
            query = query.eq("status", status)
        if department:
            query = query.eq("department", department)
        if requested_by:
            query = query.eq("requested_by", requested_by)

        result = query.order("created_at", desc=True).execute()

        # Format response
        purchase_orders = []
        for po in result.data or []:
            purchase_orders.append({
                **po,
                "requester_name": po.get("requester", {}).get("display_name") if po.get("requester") else None,
                "requester_avatar": po.get("requester", {}).get("avatar_url") if po.get("requester") else None,
                "approver_name": po.get("approver", {}).get("display_name") if po.get("approver") else None,
            })

        return purchase_orders

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting purchase orders: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/purchase-orders/my")
async def get_my_purchase_orders(
    project_id: str,
    authorization: str = Header(None)
):
    """Get current user's purchase orders for a project"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        await verify_project_access(client, project_id, user_id)

        result = client.table("backlot_purchase_orders").select(
            "*, approver:profiles!approved_by(display_name)"
        ).eq("project_id", project_id).eq(
            "requested_by", user_id
        ).order("created_at", desc=True).execute()

        # Format response
        purchase_orders = []
        for po in result.data or []:
            purchase_orders.append({
                **po,
                "approver_name": po.get("approver", {}).get("display_name") if po.get("approver") else None,
            })

        return purchase_orders

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting my purchase orders: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/purchase-orders/summary")
async def get_purchase_order_summary(
    project_id: str,
    authorization: str = Header(None)
):
    """Get purchase order summary stats for a project"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        await verify_project_access(client, project_id, user_id)

        # Get all POs for this project
        result = client.table("backlot_purchase_orders").select(
            "status, estimated_amount"
        ).eq("project_id", project_id).execute()

        # Calculate stats
        total_count = 0
        draft_count = 0
        pending_count = 0
        approved_count = 0
        rejected_count = 0
        completed_count = 0
        draft_total = 0.0
        pending_total = 0.0
        approved_total = 0.0

        for po in result.data or []:
            total_count += 1
            amount = float(po.get("estimated_amount") or 0)
            status = po.get("status")

            if status == "draft":
                draft_count += 1
                draft_total += amount
            elif status == "pending":
                pending_count += 1
                pending_total += amount
            elif status == "approved":
                approved_count += 1
                approved_total += amount
            elif status == "rejected":
                rejected_count += 1
            elif status == "completed":
                completed_count += 1
                approved_total += amount

        return {
            "total_count": total_count,
            "draft_count": draft_count,
            "pending_count": pending_count,
            "approved_count": approved_count,
            "rejected_count": rejected_count,
            "completed_count": completed_count,
            "draft_total": draft_total,
            "pending_total": pending_total,
            "approved_total": approved_total,
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting PO summary: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/purchase-orders")
async def create_purchase_order(
    project_id: str,
    request: CreatePurchaseOrderRequest,
    authorization: str = Header(None)
):
    """Create a new purchase order"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        await verify_project_access(client, project_id, user_id)

        po_data = {
            "project_id": project_id,
            "requested_by": user_id,
            "description": request.description,
            "estimated_amount": request.estimated_amount,
            "vendor_name": request.vendor_name,
            "department": request.department,
            "budget_category_id": request.budget_category_id,
            "notes": request.notes,
            "status": "draft",
        }

        result = client.table("backlot_purchase_orders").insert(po_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create purchase order")

        return result.data[0]

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating purchase order: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/purchase-orders/{po_id}")
async def get_purchase_order(
    po_id: str,
    authorization: str = Header(None)
):
    """Get a single purchase order"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        result = client.table("backlot_purchase_orders").select(
            "*, requester:profiles!requested_by(display_name, avatar_url), approver:profiles!approved_by(display_name)"
        ).eq("id", po_id).execute()

        if not result.data:
            raise HTTPException(status_code=404, detail="Purchase order not found")

        po = result.data[0]
        await verify_project_access(client, po["project_id"], user_id)

        return {
            **po,
            "requester_name": po.get("requester", {}).get("display_name") if po.get("requester") else None,
            "requester_avatar": po.get("requester", {}).get("avatar_url") if po.get("requester") else None,
            "approver_name": po.get("approver", {}).get("display_name") if po.get("approver") else None,
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting purchase order: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/purchase-orders/{po_id}")
async def update_purchase_order(
    po_id: str,
    request: UpdatePurchaseOrderRequest,
    authorization: str = Header(None)
):
    """Update a purchase order (only if pending and owned by user)"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get existing PO
        existing = client.table("backlot_purchase_orders").select(
            "project_id, requested_by, status"
        ).eq("id", po_id).execute()

        if not existing.data:
            raise HTTPException(status_code=404, detail="Purchase order not found")

        po = existing.data[0]

        # Check ownership and status
        if po["requested_by"] != user_id:
            raise HTTPException(status_code=403, detail="You can only edit your own purchase orders")
        if po["status"] not in ["pending", "rejected", "denied"]:
            raise HTTPException(status_code=400, detail="Can only edit pending, rejected, or denied purchase orders")

        # Build update data
        update_data = {"updated_at": datetime.now(timezone.utc).isoformat()}
        if request.description is not None:
            update_data["description"] = request.description
        if request.estimated_amount is not None:
            update_data["estimated_amount"] = request.estimated_amount
        if request.vendor_name is not None:
            update_data["vendor_name"] = request.vendor_name
        if request.department is not None:
            update_data["department"] = request.department
        if request.budget_category_id is not None:
            update_data["budget_category_id"] = request.budget_category_id
        if request.notes is not None:
            update_data["notes"] = request.notes

        # If editing a rejected/denied PO, reset to draft so user can resubmit
        if po["status"] in ["rejected", "denied"]:
            update_data["status"] = "draft"
            update_data["rejection_reason"] = None
            update_data["rejected_by"] = None
            update_data["rejected_at"] = None

        result = client.table("backlot_purchase_orders").update(
            update_data
        ).eq("id", po_id).execute()

        return result.data[0] if result.data else {"id": po_id, **update_data}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating purchase order: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/purchase-orders/{po_id}")
async def delete_purchase_order(
    po_id: str,
    authorization: str = Header(None)
):
    """Delete a purchase order (only if pending and owned by user)"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get existing PO
        existing = client.table("backlot_purchase_orders").select(
            "project_id, requested_by, status"
        ).eq("id", po_id).execute()

        if not existing.data:
            raise HTTPException(status_code=404, detail="Purchase order not found")

        po = existing.data[0]

        # Check ownership and status
        if po["requested_by"] != user_id:
            raise HTTPException(status_code=403, detail="You can only delete your own purchase orders")
        if po["status"] != "pending":
            raise HTTPException(status_code=400, detail="Can only delete pending purchase orders")

        client.table("backlot_purchase_orders").delete().eq("id", po_id).execute()

        return {"success": True, "message": "Purchase order deleted"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting purchase order: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/purchase-orders/{po_id}/approve")
async def approve_purchase_order(
    po_id: str,
    request: ApprovalNotesRequest = None,
    authorization: str = Header(None)
):
    """Approve a purchase order with optional notes (requires approver role)"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get existing PO
        existing = client.table("backlot_purchase_orders").select(
            "project_id, status"
        ).eq("id", po_id).execute()

        if not existing.data:
            raise HTTPException(status_code=404, detail="Purchase order not found")

        po = existing.data[0]
        project_id = po["project_id"]

        # Verify user can approve (check role)
        role_result = client.table("backlot_project_roles").select(
            "backlot_role"
        ).eq("project_id", project_id).eq("user_id", user_id).execute()

        approver_roles = ["showrunner", "producer", "line_producer", "upm"]
        user_roles = [r["backlot_role"] for r in (role_result.data or [])]
        can_approve = any(role in approver_roles for role in user_roles)

        # Also check if project owner/admin
        member_result = client.table("backlot_project_members").select(
            "role"
        ).eq("project_id", project_id).eq("user_id", user_id).execute()

        if member_result.data and member_result.data[0].get("role") == "owner":
            can_approve = True

        if not can_approve:
            raise HTTPException(status_code=403, detail="You don't have permission to approve purchase orders")

        if po["status"] != "pending":
            raise HTTPException(status_code=400, detail="Can only approve pending purchase orders")

        # Update PO
        update_data = {
            "status": "approved",
            "approved_by": user_id,
            "approved_at": datetime.now(timezone.utc).isoformat(),
            "updated_at": datetime.now(timezone.utc).isoformat(),
        }

        # Add approval notes if provided
        if request and request.notes:
            update_data["approval_notes"] = request.notes

        result = client.table("backlot_purchase_orders").update(
            update_data
        ).eq("id", po_id).execute()

        # Record to budget actuals
        if result.data:
            full_po = result.data[0]
            from app.services.budget_actuals import record_purchase_order_actual
            record_purchase_order_actual(full_po, user_id)

        return result.data[0] if result.data else {"id": po_id, **update_data}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error approving purchase order: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/purchase-orders/{po_id}/reject")
async def reject_purchase_order(
    po_id: str,
    request: RejectPurchaseOrderRequest,
    authorization: str = Header(None)
):
    """Reject a purchase order (requires approver role)"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get existing PO
        existing = client.table("backlot_purchase_orders").select(
            "project_id, status"
        ).eq("id", po_id).execute()

        if not existing.data:
            raise HTTPException(status_code=404, detail="Purchase order not found")

        po = existing.data[0]
        project_id = po["project_id"]

        # Verify user can approve/reject (check role)
        role_result = client.table("backlot_project_roles").select(
            "backlot_role"
        ).eq("project_id", project_id).eq("user_id", user_id).execute()

        approver_roles = ["showrunner", "producer", "line_producer", "upm"]
        user_roles = [r["backlot_role"] for r in (role_result.data or [])]
        can_approve = any(role in approver_roles for role in user_roles)

        # Also check if project owner/admin
        member_result = client.table("backlot_project_members").select(
            "role"
        ).eq("project_id", project_id).eq("user_id", user_id).execute()

        if member_result.data and member_result.data[0].get("role") == "owner":
            can_approve = True

        if not can_approve:
            raise HTTPException(status_code=403, detail="You don't have permission to reject purchase orders")

        if po["status"] != "pending":
            raise HTTPException(status_code=400, detail="Can only reject pending purchase orders")

        # Update PO
        update_data = {
            "status": "rejected",
            "rejection_reason": request.reason,
            "updated_at": datetime.now(timezone.utc).isoformat(),
        }

        result = client.table("backlot_purchase_orders").update(
            update_data
        ).eq("id", po_id).execute()

        return result.data[0] if result.data else {"id": po_id, **update_data}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error rejecting purchase order: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/purchase-orders/{po_id}/deny")
async def deny_purchase_order(
    po_id: str,
    request: DenyPurchaseOrderRequest,
    authorization: str = Header(None)
):
    """Permanently deny a purchase order. Cannot be resubmitted."""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get existing PO
        existing = client.table("backlot_purchase_orders").select(
            "project_id, status"
        ).eq("id", po_id).execute()

        if not existing.data:
            raise HTTPException(status_code=404, detail="Purchase order not found")

        po = existing.data[0]
        project_id = po["project_id"]

        # Verify user can deny (check role)
        role_result = client.table("backlot_project_roles").select(
            "backlot_role"
        ).eq("project_id", project_id).eq("user_id", user_id).execute()

        approver_roles = ["showrunner", "producer", "line_producer", "upm"]
        user_roles = [r["backlot_role"] for r in (role_result.data or [])]
        can_deny = any(role in approver_roles for role in user_roles)

        # Also check if project owner/admin
        member_result = client.table("backlot_project_members").select(
            "role"
        ).eq("project_id", project_id).eq("user_id", user_id).execute()

        if member_result.data and member_result.data[0].get("role") == "owner":
            can_deny = True

        if not can_deny:
            raise HTTPException(status_code=403, detail="You don't have permission to deny purchase orders")

        if po["status"] not in ["pending", "rejected"]:
            raise HTTPException(status_code=400, detail="Can only deny pending or rejected purchase orders")

        # Update PO
        update_data = {
            "status": "denied",
            "denied_by": user_id,
            "denied_at": datetime.now(timezone.utc).isoformat(),
            "denial_reason": request.reason,
            "updated_at": datetime.now(timezone.utc).isoformat(),
        }

        result = client.table("backlot_purchase_orders").update(
            update_data
        ).eq("id", po_id).execute()

        return result.data[0] if result.data else {"id": po_id, **update_data}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error denying purchase order: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/purchase-orders/{po_id}/resubmit")
async def resubmit_purchase_order(
    po_id: str,
    authorization: str = Header(None)
):
    """Resubmit a rejected or denied purchase order for approval."""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get existing PO
        existing = client.table("backlot_purchase_orders").select(
            "project_id, requested_by, status"
        ).eq("id", po_id).execute()

        if not existing.data:
            raise HTTPException(status_code=404, detail="Purchase order not found")

        po = existing.data[0]

        # Only owner can resubmit
        if po["requested_by"] != user_id:
            raise HTTPException(status_code=403, detail="Only the owner can resubmit this purchase order")

        if po["status"] not in ["rejected", "denied"]:
            raise HTTPException(status_code=400, detail="Only rejected or denied purchase orders can be resubmitted")

        # Clear rejection/denial fields and set back to pending
        update_data = {
            "status": "pending",
            "rejection_reason": None,
            "denied_by": None,
            "denied_at": None,
            "denial_reason": None,
            "updated_at": datetime.now(timezone.utc).isoformat(),
        }

        result = client.table("backlot_purchase_orders").update(
            update_data
        ).eq("id", po_id).execute()

        return result.data[0] if result.data else {"id": po_id, **update_data}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error resubmitting purchase order: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/purchase-orders/{po_id}/complete")
async def complete_purchase_order(
    po_id: str,
    authorization: str = Header(None)
):
    """Mark a purchase order as completed"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get existing PO
        existing = client.table("backlot_purchase_orders").select(
            "project_id, status"
        ).eq("id", po_id).execute()

        if not existing.data:
            raise HTTPException(status_code=404, detail="Purchase order not found")

        po = existing.data[0]
        await verify_project_access(client, po["project_id"], user_id)

        if po["status"] != "approved":
            raise HTTPException(status_code=400, detail="Can only complete approved purchase orders")

        # Update PO
        update_data = {
            "status": "completed",
            "updated_at": datetime.now(timezone.utc).isoformat(),
        }

        result = client.table("backlot_purchase_orders").update(
            update_data
        ).eq("id", po_id).execute()

        return result.data[0] if result.data else {"id": po_id, **update_data}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error completing purchase order: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/purchase-orders/{po_id}/cancel")
async def cancel_purchase_order(
    po_id: str,
    authorization: str = Header(None)
):
    """Cancel a purchase order (owner only)"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get existing PO
        existing = client.table("backlot_purchase_orders").select(
            "project_id, requested_by, status"
        ).eq("id", po_id).execute()

        if not existing.data:
            raise HTTPException(status_code=404, detail="Purchase order not found")

        po = existing.data[0]

        # Check ownership
        if po["requested_by"] != user_id:
            raise HTTPException(status_code=403, detail="You can only cancel your own purchase orders")

        if po["status"] not in ["pending", "approved"]:
            raise HTTPException(status_code=400, detail="Cannot cancel this purchase order")

        # Update PO
        update_data = {
            "status": "cancelled",
            "updated_at": datetime.now(timezone.utc).isoformat(),
        }

        result = client.table("backlot_purchase_orders").update(
            update_data
        ).eq("id", po_id).execute()

        return result.data[0] if result.data else {"id": po_id, **update_data}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error cancelling purchase order: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/purchase-orders/{po_id}/submit-for-approval")
async def submit_purchase_order_for_approval(
    po_id: str,
    authorization: str = Header(None)
):
    """Submit a draft purchase order for approval"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Get existing PO
        existing = client.table("backlot_purchase_orders").select(
            "project_id, requested_by, status"
        ).eq("id", po_id).execute()

        if not existing.data:
            raise HTTPException(status_code=404, detail="Purchase order not found")

        po = existing.data[0]

        # Verify ownership - only the requester can submit for approval
        if po["requested_by"] != user_id:
            raise HTTPException(status_code=403, detail="Only the owner can submit for approval")

        # Check status is draft
        if po["status"] != "draft":
            raise HTTPException(status_code=400, detail="Only draft purchase orders can be submitted for approval")

        # Update status to pending
        update_data = {
            "status": "pending",
            "updated_at": datetime.now(timezone.utc).isoformat(),
        }

        result = client.table("backlot_purchase_orders").update(
            update_data
        ).eq("id", po_id).execute()

        return result.data[0] if result.data else {"id": po_id, **update_data}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error submitting purchase order for approval: {e}")
        raise HTTPException(status_code=500, detail=str(e))


class BulkSubmitPORequest(BaseModel):
    entry_ids: List[str]


@router.post("/projects/{project_id}/purchase-orders/bulk-submit-for-approval")
async def bulk_submit_purchase_orders_for_approval(
    project_id: str,
    request: BulkSubmitPORequest,
    authorization: str = Header(None)
):
    """Submit multiple draft purchase orders for approval"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        await verify_project_access(client, project_id, user_id)

        submitted_count = 0
        failed_count = 0
        failed_ids = []

        for po_id in request.entry_ids:
            try:
                # Get PO
                existing = client.table("backlot_purchase_orders").select(
                    "project_id, requested_by, status"
                ).eq("id", po_id).eq("project_id", project_id).execute()

                if not existing.data:
                    failed_count += 1
                    failed_ids.append(po_id)
                    continue

                po = existing.data[0]

                # Verify ownership
                if po["requested_by"] != user_id:
                    failed_count += 1
                    failed_ids.append(po_id)
                    continue

                # Check status is draft
                if po["status"] != "draft":
                    failed_count += 1
                    failed_ids.append(po_id)
                    continue

                # Update status to pending
                update_data = {
                    "status": "pending",
                    "updated_at": datetime.now(timezone.utc).isoformat(),
                }

                client.table("backlot_purchase_orders").update(
                    update_data
                ).eq("id", po_id).execute()

                submitted_count += 1

            except Exception as e:
                print(f"Error submitting PO {po_id}: {e}")
                failed_count += 1
                failed_ids.append(po_id)

        return {
            "submitted_count": submitted_count,
            "failed_count": failed_count,
            "failed_ids": failed_ids
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error bulk submitting purchase orders: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Crew Rates Endpoints
# =====================================================

@router.get("/projects/{project_id}/crew-rates")
async def get_crew_rates(
    project_id: str,
    user_id: Optional[str] = None,
    role_id: Optional[str] = None,
    authorization: str = Header(None)
):
    """Get all crew rates for a project"""
    user = await get_current_user_from_token(authorization)
    current_user_id = user["id"]
    client = get_client()

    # Verify project access
    project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    is_owner = str(project_response.data[0]["owner_id"]) == str(current_user_id)
    if not is_owner:
        member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", current_user_id).execute()
        if not member_response.data:
            raise HTTPException(status_code=403, detail="Access denied - not a project member")

    try:
        query = client.table("backlot_crew_rates").select("*").eq("project_id", project_id).order("created_at", desc=True)

        if user_id:
            query = query.eq("user_id", user_id)
        if role_id:
            query = query.eq("role_id", role_id)

        result = query.execute()
        rates = result.data or []

        # Enrich with user and role info
        for rate in rates:
            if rate.get("user_id"):
                user_result = client.table("profiles").select("id, full_name, username, avatar_url").eq("id", rate["user_id"]).execute()
                rate["user"] = user_result.data[0] if user_result.data else None
            if rate.get("role_id"):
                role_result = client.table("backlot_project_roles").select("id, title, department, type").eq("id", rate["role_id"]).execute()
                rate["role"] = role_result.data[0] if role_result.data else None

        return {"success": True, "rates": rates, "count": len(rates)}

    except Exception as e:
        print(f"Error fetching crew rates: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/crew-rates/{rate_id}")
async def get_crew_rate(
    rate_id: str,
    authorization: str = Header(None)
):
    """Get a single crew rate"""
    user = await get_current_user_from_token(authorization)
    current_user_id = user["id"]
    client = get_client()

    try:
        result = client.table("backlot_crew_rates").select("*").eq("id", rate_id).single().execute()

        if not result.data:
            raise HTTPException(status_code=404, detail="Crew rate not found")

        rate = result.data

        # Verify project access
        project_response = client.table("backlot_projects").select("owner_id").eq("id", rate["project_id"]).execute()
        if not project_response.data:
            raise HTTPException(status_code=404, detail="Project not found")

        is_owner = str(project_response.data[0]["owner_id"]) == str(current_user_id)
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", rate["project_id"]).eq("user_id", current_user_id).execute()
            if not member_response.data:
                raise HTTPException(status_code=403, detail="Access denied")

        # Enrich with user and role info
        if rate.get("user_id"):
            user_result = client.table("profiles").select("id, full_name, username, avatar_url").eq("id", rate["user_id"]).execute()
            rate["user"] = user_result.data[0] if user_result.data else None
        if rate.get("role_id"):
            role_result = client.table("backlot_project_roles").select("id, title, department, type").eq("id", rate["role_id"]).execute()
            rate["role"] = role_result.data[0] if role_result.data else None

        return {"success": True, "rate": rate}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching crew rate: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/crew-rates")
async def create_crew_rate(
    project_id: str,
    rate_input: CrewRateInput,
    authorization: str = Header(None)
):
    """Create a new crew rate"""
    user = await get_current_user_from_token(authorization)
    current_user_id = user["id"]
    client = get_client()

    # Verify project edit access
    project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    is_owner = str(project_response.data[0]["owner_id"]) == str(current_user_id)
    if not is_owner:
        member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", current_user_id).execute()
        if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin", "editor"]:
            raise HTTPException(status_code=403, detail="You don't have permission to create crew rates")

    try:
        rate_data = {
            "project_id": project_id,
            "user_id": rate_input.user_id,
            "role_id": rate_input.role_id,
            "rate_type": rate_input.rate_type,
            "rate_amount": rate_input.rate_amount,
            "overtime_multiplier": rate_input.overtime_multiplier,
            "double_time_multiplier": rate_input.double_time_multiplier,
            "kit_rental_rate": rate_input.kit_rental_rate,
            "car_allowance": rate_input.car_allowance,
            "phone_allowance": rate_input.phone_allowance,
            "effective_start": rate_input.effective_start,
            "effective_end": rate_input.effective_end,
            "notes": rate_input.notes,
        }

        result = client.table("backlot_crew_rates").insert(rate_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create crew rate")

        rate = result.data[0]

        # Enrich with user and role info
        if rate.get("user_id"):
            user_result = client.table("profiles").select("id, full_name, username, avatar_url").eq("id", rate["user_id"]).execute()
            rate["user"] = user_result.data[0] if user_result.data else None
        if rate.get("role_id"):
            role_result = client.table("backlot_project_roles").select("id, title, department, type").eq("id", rate["role_id"]).execute()
            rate["role"] = role_result.data[0] if role_result.data else None

        return {"success": True, "rate": rate, "message": "Crew rate created successfully"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating crew rate: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/crew-rates/{rate_id}")
async def update_crew_rate(
    rate_id: str,
    rate_input: CrewRateInput,
    authorization: str = Header(None)
):
    """Update a crew rate"""
    user = await get_current_user_from_token(authorization)
    current_user_id = user["id"]
    client = get_client()

    try:
        # Get existing rate
        existing = client.table("backlot_crew_rates").select("project_id").eq("id", rate_id).execute()

        if not existing.data:
            raise HTTPException(status_code=404, detail="Crew rate not found")

        project_id = existing.data[0]["project_id"]

        # Verify project edit access
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        if not project_response.data:
            raise HTTPException(status_code=404, detail="Project not found")

        is_owner = str(project_response.data[0]["owner_id"]) == str(current_user_id)
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", current_user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin", "editor"]:
                raise HTTPException(status_code=403, detail="You don't have permission to update crew rates")

        update_data = {
            "user_id": rate_input.user_id,
            "role_id": rate_input.role_id,
            "rate_type": rate_input.rate_type,
            "rate_amount": rate_input.rate_amount,
            "overtime_multiplier": rate_input.overtime_multiplier,
            "double_time_multiplier": rate_input.double_time_multiplier,
            "kit_rental_rate": rate_input.kit_rental_rate,
            "car_allowance": rate_input.car_allowance,
            "phone_allowance": rate_input.phone_allowance,
            "effective_start": rate_input.effective_start,
            "effective_end": rate_input.effective_end,
            "notes": rate_input.notes,
            "updated_at": datetime.now(timezone.utc).isoformat(),
        }

        result = client.table("backlot_crew_rates").update(update_data).eq("id", rate_id).execute()

        rate = result.data[0] if result.data else {"id": rate_id, **update_data}

        # Enrich with user and role info
        if rate.get("user_id"):
            user_result = client.table("profiles").select("id, full_name, username, avatar_url").eq("id", rate["user_id"]).execute()
            rate["user"] = user_result.data[0] if user_result.data else None
        if rate.get("role_id"):
            role_result = client.table("backlot_project_roles").select("id, title, department, type").eq("id", rate["role_id"]).execute()
            rate["role"] = role_result.data[0] if role_result.data else None

        return {"success": True, "rate": rate, "message": "Crew rate updated successfully"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating crew rate: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/crew-rates/{rate_id}")
async def delete_crew_rate(
    rate_id: str,
    authorization: str = Header(None)
):
    """Delete a crew rate"""
    user = await get_current_user_from_token(authorization)
    current_user_id = user["id"]
    client = get_client()

    try:
        # Get existing rate
        existing = client.table("backlot_crew_rates").select("project_id").eq("id", rate_id).execute()

        if not existing.data:
            raise HTTPException(status_code=404, detail="Crew rate not found")

        project_id = existing.data[0]["project_id"]

        # Verify project edit access
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        if not project_response.data:
            raise HTTPException(status_code=404, detail="Project not found")

        is_owner = str(project_response.data[0]["owner_id"]) == str(current_user_id)
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", current_user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin", "editor"]:
                raise HTTPException(status_code=403, detail="You don't have permission to delete crew rates")

        client.table("backlot_crew_rates").delete().eq("id", rate_id).execute()

        return {"success": True, "message": "Crew rate deleted successfully"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting crew rate: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/crew-rates/by-user/{target_user_id}")
async def get_crew_rates_by_user(
    project_id: str,
    target_user_id: str,
    effective_date: Optional[str] = None,
    authorization: str = Header(None)
):
    """Get crew rates for a specific user on a project"""
    user = await get_current_user_from_token(authorization)
    current_user_id = user["id"]
    client = get_client()

    # Verify project access
    project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    is_owner = str(project_response.data[0]["owner_id"]) == str(current_user_id)
    if not is_owner:
        member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", current_user_id).execute()
        if not member_response.data:
            raise HTTPException(status_code=403, detail="Access denied")

    try:
        query = client.table("backlot_crew_rates").select("*").eq("project_id", project_id).eq("user_id", target_user_id).order("effective_start", desc=True)

        result = query.execute()
        rates = result.data or []

        # Filter by effective date if provided
        if effective_date and rates:
            filtered_rates = []
            for rate in rates:
                start = rate.get("effective_start")
                end = rate.get("effective_end")
                # If no dates, rate is always effective
                if not start and not end:
                    filtered_rates.append(rate)
                elif start and not end and effective_date >= start:
                    filtered_rates.append(rate)
                elif not start and end and effective_date <= end:
                    filtered_rates.append(rate)
                elif start and end and start <= effective_date <= end:
                    filtered_rates.append(rate)
            rates = filtered_rates

        # Enrich with role info
        for rate in rates:
            if rate.get("role_id"):
                role_result = client.table("backlot_project_roles").select("id, title, department, type").eq("id", rate["role_id"]).execute()
                rate["role"] = role_result.data[0] if role_result.data else None

        return {"success": True, "rates": rates, "count": len(rates)}

    except Exception as e:
        print(f"Error fetching crew rates by user: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/crew-rates/by-role/{target_role_id}")
async def get_crew_rates_by_role(
    project_id: str,
    target_role_id: str,
    effective_date: Optional[str] = None,
    authorization: str = Header(None)
):
    """Get crew rates for a specific role on a project"""
    user = await get_current_user_from_token(authorization)
    current_user_id = user["id"]
    client = get_client()

    # Verify project access
    project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
    if not project_response.data:
        raise HTTPException(status_code=404, detail="Project not found")

    is_owner = str(project_response.data[0]["owner_id"]) == str(current_user_id)
    if not is_owner:
        member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", current_user_id).execute()
        if not member_response.data:
            raise HTTPException(status_code=403, detail="Access denied")

    try:
        query = client.table("backlot_crew_rates").select("*").eq("project_id", project_id).eq("role_id", target_role_id).order("effective_start", desc=True)

        result = query.execute()
        rates = result.data or []

        # Filter by effective date if provided
        if effective_date and rates:
            filtered_rates = []
            for rate in rates:
                start = rate.get("effective_start")
                end = rate.get("effective_end")
                if not start and not end:
                    filtered_rates.append(rate)
                elif start and not end and effective_date >= start:
                    filtered_rates.append(rate)
                elif not start and end and effective_date <= end:
                    filtered_rates.append(rate)
                elif start and end and start <= effective_date <= end:
                    filtered_rates.append(rate)
            rates = filtered_rates

        # Enrich with user info
        for rate in rates:
            if rate.get("user_id"):
                user_result = client.table("profiles").select("id, full_name, username, avatar_url").eq("id", rate["user_id"]).execute()
                rate["user"] = user_result.data[0] if user_result.data else None

        return {"success": True, "rates": rates, "count": len(rates)}

    except Exception as e:
        print(f"Error fetching crew rates by role: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Credit Preferences Endpoints
# =====================================================

@router.get("/users/{user_id}/credit-preferences")
async def get_user_credit_preferences(
    user_id: str,
    project_id: Optional[str] = None,
    authorization: str = Header(None)
):
    """Get credit preferences for a user"""
    user = await get_current_user_from_token(authorization)
    current_user_id = user["id"]
    client = get_client()

    try:
        query = client.table("backlot_credit_preferences").select("*").eq("user_id", user_id)

        if project_id:
            query = query.eq("project_id", project_id)

        result = query.order("created_at", desc=True).execute()
        preferences = result.data or []

        return {"success": True, "credit_preferences": preferences, "count": len(preferences)}

    except Exception as e:
        print(f"Error fetching credit preferences: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/credit-preferences/defaults/{user_id}")
async def get_default_credit_preferences(
    user_id: str,
    authorization: str = Header(None)
):
    """Get the user's default credit preferences"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Get default preference (use_as_default=true, no project/role)
        result = client.table("backlot_credit_preferences").select("*").eq("user_id", user_id).eq("use_as_default", True).is_("project_id", "null").single().execute()

        if result.data:
            return {"success": True, "credit_preference": result.data}

        # Fall back to profile data
        profile_result = client.table("profiles").select("full_name, username").eq("id", user_id).single().execute()
        profile = profile_result.data if profile_result.data else {}

        # Return a default-like object from profile
        default = {
            "id": None,
            "user_id": user_id,
            "display_name": profile.get("full_name") or profile.get("username"),
            "role_title_preference": None,
            "department_preference": None,
            "endorsement_note": None,
            "imdb_id": None,
            "use_as_default": True,
            "is_public": True,
        }

        return {"success": True, "credit_preference": default}

    except Exception as e:
        print(f"Error fetching default credit preferences: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/credit-preferences")
async def create_credit_preference(
    preference: CreditPreferenceInput,
    authorization: str = Header(None)
):
    """Create a new credit preference"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        preference_data = {
            "user_id": user_id,
            "project_id": preference.project_id,
            "role_id": preference.role_id,
            "display_name": preference.display_name,
            "role_title_preference": preference.role_title_preference,
            "department_preference": preference.department_preference,
            "endorsement_note": preference.endorsement_note,
            "imdb_id": preference.imdb_id,
            "use_as_default": preference.use_as_default,
            "is_public": preference.is_public,
        }

        result = client.table("backlot_credit_preferences").insert(preference_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create credit preference")

        return {"success": True, "credit_preference": result.data[0], "message": "Credit preference created"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating credit preference: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/credit-preferences/{preference_id}")
async def update_credit_preference(
    preference_id: str,
    preference: CreditPreferenceInput,
    authorization: str = Header(None)
):
    """Update a credit preference"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Verify ownership
        existing = client.table("backlot_credit_preferences").select("user_id").eq("id", preference_id).single().execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Credit preference not found")
        if existing.data["user_id"] != user_id:
            raise HTTPException(status_code=403, detail="Access denied")

        update_data = {
            "display_name": preference.display_name,
            "role_title_preference": preference.role_title_preference,
            "department_preference": preference.department_preference,
            "endorsement_note": preference.endorsement_note,
            "imdb_id": preference.imdb_id,
            "use_as_default": preference.use_as_default,
            "is_public": preference.is_public,
            "updated_at": datetime.utcnow().isoformat(),
        }

        # Remove None values
        update_data = {k: v for k, v in update_data.items() if v is not None}

        result = client.table("backlot_credit_preferences").update(update_data).eq("id", preference_id).execute()

        return {"success": True, "credit_preference": result.data[0] if result.data else None, "message": "Credit preference updated"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating credit preference: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/credit-preferences/{preference_id}")
async def delete_credit_preference(
    preference_id: str,
    authorization: str = Header(None)
):
    """Delete a credit preference"""
    user = await get_current_user_from_token(authorization)
    user_id = user["id"]
    client = get_client()

    try:
        # Verify ownership
        existing = client.table("backlot_credit_preferences").select("user_id").eq("id", preference_id).single().execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Credit preference not found")
        if existing.data["user_id"] != user_id:
            raise HTTPException(status_code=403, detail="Access denied")

        client.table("backlot_credit_preferences").delete().eq("id", preference_id).execute()

        return {"success": True, "message": "Credit preference deleted"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting credit preference: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Deal Memo Endpoints
# =====================================================

@router.get("/projects/{project_id}/deal-memos")
async def get_project_deal_memos(
    project_id: str,
    status: Optional[str] = None,
    user_id: Optional[str] = None,
    authorization: str = Header(None)
):
    """Get all deal memos for a project"""
    user = await get_current_user_from_token(authorization)
    current_user_id = user["id"]
    client = get_client()

    try:
        # Verify project access
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        if not project_response.data:
            raise HTTPException(status_code=404, detail="Project not found")

        is_owner = str(project_response.data[0]["owner_id"]) == str(current_user_id)
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", current_user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin", "editor"]:
                raise HTTPException(status_code=403, detail="Access denied")

        query = client.table("backlot_deal_memos").select("*").eq("project_id", project_id).order("created_at", desc=True)

        if status:
            query = query.eq("status", status)
        if user_id:
            query = query.eq("user_id", user_id)

        result = query.execute()
        deal_memos = result.data or []

        # Enrich with user and role info
        for memo in deal_memos:
            if memo.get("user_id"):
                user_result = client.table("profiles").select("id, full_name, username, avatar_url").eq("id", memo["user_id"]).execute()
                memo["user"] = user_result.data[0] if user_result.data else None
            if memo.get("role_id"):
                role_result = client.table("backlot_project_roles").select("id, title, department, type").eq("id", memo["role_id"]).execute()
                memo["role"] = role_result.data[0] if role_result.data else None

        return {"success": True, "deal_memos": deal_memos, "count": len(deal_memos)}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching deal memos: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/deal-memos/{deal_memo_id}")
async def get_deal_memo(
    deal_memo_id: str,
    authorization: str = Header(None)
):
    """Get a single deal memo"""
    user = await get_current_user_from_token(authorization)
    current_user_id = user["id"]
    client = get_client()

    try:
        result = client.table("backlot_deal_memos").select("*").eq("id", deal_memo_id).single().execute()
        if not result.data:
            raise HTTPException(status_code=404, detail="Deal memo not found")

        memo = result.data
        project_id = memo["project_id"]

        # Verify access (project admin or the person the memo is for)
        is_recipient = memo["user_id"] == current_user_id

        if not is_recipient:
            project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
            is_owner = str(project_response.data[0]["owner_id"]) == str(current_user_id) if project_response.data else False

            if not is_owner:
                member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", current_user_id).execute()
                if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin", "editor"]:
                    raise HTTPException(status_code=403, detail="Access denied")

        # Enrich with user and role info
        if memo.get("user_id"):
            user_result = client.table("profiles").select("id, full_name, username, avatar_url").eq("id", memo["user_id"]).execute()
            memo["user"] = user_result.data[0] if user_result.data else None
        if memo.get("role_id"):
            role_result = client.table("backlot_project_roles").select("id, title, department, type").eq("id", memo["role_id"]).execute()
            memo["role"] = role_result.data[0] if role_result.data else None

        return {"success": True, "deal_memo": memo}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching deal memo: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/deal-memos")
async def create_deal_memo(
    project_id: str,
    memo: DealMemoInput,
    authorization: str = Header(None)
):
    """Create a new deal memo"""
    user = await get_current_user_from_token(authorization)
    current_user_id = user["id"]
    client = get_client()

    try:
        # Verify project admin access
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        if not project_response.data:
            raise HTTPException(status_code=404, detail="Project not found")

        is_owner = str(project_response.data[0]["owner_id"]) == str(current_user_id)
        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", current_user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin"]:
                raise HTTPException(status_code=403, detail="Access denied")

        memo_data = {
            "project_id": project_id,
            "role_id": memo.role_id,
            "user_id": memo.user_id,
            "position_title": memo.position_title,
            "rate_type": memo.rate_type,
            "rate_amount": memo.rate_amount,
            "overtime_multiplier": memo.overtime_multiplier or 1.5,
            "double_time_multiplier": memo.double_time_multiplier or 2.0,
            "kit_rental_rate": memo.kit_rental_rate,
            "car_allowance": memo.car_allowance,
            "phone_allowance": memo.phone_allowance,
            "per_diem_rate": memo.per_diem_rate,
            "start_date": memo.start_date,
            "end_date": memo.end_date,
            "additional_terms": memo.additional_terms or {},
            "notes": memo.notes,
            "status": "draft",
            "created_by": current_user_id,
        }

        result = client.table("backlot_deal_memos").insert(memo_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create deal memo")

        return {"success": True, "deal_memo": result.data[0], "message": "Deal memo created"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating deal memo: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/deal-memos/{deal_memo_id}")
async def update_deal_memo(
    deal_memo_id: str,
    memo: DealMemoInput,
    authorization: str = Header(None)
):
    """Update a deal memo (only if still in draft status)"""
    user = await get_current_user_from_token(authorization)
    current_user_id = user["id"]
    client = get_client()

    try:
        # Get existing memo
        existing = client.table("backlot_deal_memos").select("project_id, status").eq("id", deal_memo_id).single().execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Deal memo not found")

        if existing.data["status"] not in ["draft", "pending_send"]:
            raise HTTPException(status_code=400, detail="Cannot edit a deal memo that has been sent")

        project_id = existing.data["project_id"]

        # Verify project admin access
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = str(project_response.data[0]["owner_id"]) == str(current_user_id) if project_response.data else False

        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", current_user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin"]:
                raise HTTPException(status_code=403, detail="Access denied")

        update_data = {
            "role_id": memo.role_id,
            "user_id": memo.user_id,
            "position_title": memo.position_title,
            "rate_type": memo.rate_type,
            "rate_amount": memo.rate_amount,
            "overtime_multiplier": memo.overtime_multiplier or 1.5,
            "double_time_multiplier": memo.double_time_multiplier or 2.0,
            "kit_rental_rate": memo.kit_rental_rate,
            "car_allowance": memo.car_allowance,
            "phone_allowance": memo.phone_allowance,
            "per_diem_rate": memo.per_diem_rate,
            "start_date": memo.start_date,
            "end_date": memo.end_date,
            "additional_terms": memo.additional_terms or {},
            "notes": memo.notes,
            "updated_at": datetime.utcnow().isoformat(),
        }

        result = client.table("backlot_deal_memos").update(update_data).eq("id", deal_memo_id).execute()

        return {"success": True, "deal_memo": result.data[0] if result.data else None, "message": "Deal memo updated"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating deal memo: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/deal-memos/{deal_memo_id}")
async def delete_deal_memo(
    deal_memo_id: str,
    authorization: str = Header(None)
):
    """Delete a deal memo (only if in draft status)"""
    user = await get_current_user_from_token(authorization)
    current_user_id = user["id"]
    client = get_client()

    try:
        # Get existing memo
        existing = client.table("backlot_deal_memos").select("project_id, status").eq("id", deal_memo_id).single().execute()
        if not existing.data:
            raise HTTPException(status_code=404, detail="Deal memo not found")

        if existing.data["status"] != "draft":
            raise HTTPException(status_code=400, detail="Cannot delete a deal memo that has been sent")

        project_id = existing.data["project_id"]

        # Verify project admin access
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = str(project_response.data[0]["owner_id"]) == str(current_user_id) if project_response.data else False

        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", current_user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin"]:
                raise HTTPException(status_code=403, detail="Access denied")

        client.table("backlot_deal_memos").delete().eq("id", deal_memo_id).execute()

        return {"success": True, "message": "Deal memo deleted"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting deal memo: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/deal-memos/{deal_memo_id}/create-rate")
async def create_rate_from_deal_memo(
    deal_memo_id: str,
    authorization: str = Header(None)
):
    """Create a crew rate from a signed deal memo"""
    user = await get_current_user_from_token(authorization)
    current_user_id = user["id"]
    client = get_client()

    try:
        # Get deal memo
        memo_result = client.table("backlot_deal_memos").select("*").eq("id", deal_memo_id).single().execute()
        if not memo_result.data:
            raise HTTPException(status_code=404, detail="Deal memo not found")

        memo = memo_result.data
        project_id = memo["project_id"]

        # Verify project admin access
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = str(project_response.data[0]["owner_id"]) == str(current_user_id) if project_response.data else False

        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", current_user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin"]:
                raise HTTPException(status_code=403, detail="Access denied")

        # Create crew rate from deal memo data
        rate_data = {
            "project_id": project_id,
            "user_id": memo["user_id"],
            "role_id": memo["role_id"],
            "rate_type": memo["rate_type"],
            "rate_amount": memo["rate_amount"],
            "overtime_multiplier": memo["overtime_multiplier"],
            "double_time_multiplier": memo["double_time_multiplier"],
            "kit_rental_rate": memo["kit_rental_rate"],
            "car_allowance": memo["car_allowance"],
            "phone_allowance": memo["phone_allowance"],
            "effective_start": memo["start_date"],
            "effective_end": memo["end_date"],
            "notes": f"Created from deal memo: {memo['position_title']}",
            "deal_memo_id": deal_memo_id,
            "source": "deal_memo",
        }

        rate_result = client.table("backlot_crew_rates").insert(rate_data).execute()

        if not rate_result.data:
            raise HTTPException(status_code=500, detail="Failed to create crew rate")

        return {"success": True, "rate": rate_result.data[0], "message": "Crew rate created from deal memo"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating rate from deal memo: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/deal-memos/{deal_memo_id}/void")
async def void_deal_memo(
    deal_memo_id: str,
    authorization: str = Header(None)
):
    """Void a deal memo (cancel signature request)"""
    user = await get_current_user_from_token(authorization)
    current_user_id = user["id"]
    client = get_client()

    try:
        # Get deal memo
        memo_result = client.table("backlot_deal_memos").select("*").eq("id", deal_memo_id).single().execute()
        if not memo_result.data:
            raise HTTPException(status_code=404, detail="Deal memo not found")

        memo = memo_result.data
        project_id = memo["project_id"]

        # Can only void sent or viewed memos
        if memo["status"] not in ["sent", "viewed"]:
            raise HTTPException(status_code=400, detail=f"Cannot void deal memo with status '{memo['status']}'")

        # Verify project admin access
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = str(project_response.data[0]["owner_id"]) == str(current_user_id) if project_response.data else False

        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", current_user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin"]:
                raise HTTPException(status_code=403, detail="Access denied")

        # Update status to voided
        update_result = client.table("backlot_deal_memos").update({
            "status": "voided",
            "docusign_status": "voided",
            "updated_at": datetime.utcnow().isoformat(),
        }).eq("id", deal_memo_id).execute()

        # Notify the recipient
        if memo.get("user_id"):
            client.table("notifications").insert({
                "user_id": memo["user_id"],
                "type": "deal_memo_voided",
                "title": "Deal Memo Voided",
                "body": f"The deal memo for {memo['position_title']} has been voided.",
                "data": {"deal_memo_id": deal_memo_id, "project_id": project_id},
            }).execute()

        return {"success": True, "message": "Deal memo voided"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error voiding deal memo: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/deal-memos/{deal_memo_id}/resend")
async def resend_deal_memo(
    deal_memo_id: str,
    authorization: str = Header(None)
):
    """Resend a declined or expired deal memo (creates new draft for editing)"""
    user = await get_current_user_from_token(authorization)
    current_user_id = user["id"]
    client = get_client()

    try:
        # Get original deal memo
        memo_result = client.table("backlot_deal_memos").select("*").eq("id", deal_memo_id).single().execute()
        if not memo_result.data:
            raise HTTPException(status_code=404, detail="Deal memo not found")

        memo = memo_result.data
        project_id = memo["project_id"]

        # Can only resend declined or expired memos
        if memo["status"] not in ["declined", "expired"]:
            raise HTTPException(status_code=400, detail=f"Cannot resend deal memo with status '{memo['status']}'")

        # Verify project admin access
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = str(project_response.data[0]["owner_id"]) == str(current_user_id) if project_response.data else False

        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", current_user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin"]:
                raise HTTPException(status_code=403, detail="Access denied")

        # Create a new deal memo as draft (copy of the original)
        new_memo_data = {
            "project_id": project_id,
            "role_id": memo.get("role_id"),
            "user_id": memo["user_id"],
            "position_title": memo["position_title"],
            "rate_type": memo["rate_type"],
            "rate_amount": memo["rate_amount"],
            "overtime_multiplier": memo.get("overtime_multiplier", 1.5),
            "double_time_multiplier": memo.get("double_time_multiplier", 2.0),
            "kit_rental_rate": memo.get("kit_rental_rate"),
            "car_allowance": memo.get("car_allowance"),
            "phone_allowance": memo.get("phone_allowance"),
            "per_diem_rate": memo.get("per_diem_rate"),
            "start_date": memo.get("start_date"),
            "end_date": memo.get("end_date"),
            "additional_terms": memo.get("additional_terms", {}),
            "notes": memo.get("notes"),
            "status": "draft",
            "docusign_status": "draft",
            "created_by": current_user_id,
        }

        new_result = client.table("backlot_deal_memos").insert(new_memo_data).execute()

        if not new_result.data:
            raise HTTPException(status_code=500, detail="Failed to create new deal memo")

        return {
            "success": True,
            "deal_memo": new_result.data[0],
            "message": "New deal memo created as draft. You can edit and send it."
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error resending deal memo: {e}")
        raise HTTPException(status_code=500, detail=str(e))


class DealMemoSendInput(BaseModel):
    """Input for sending deal memo with in-app signing"""
    signer_email: Optional[str] = None
    signer_name: Optional[str] = None
    message: Optional[str] = None


@router.post("/deal-memos/{deal_memo_id}/generate-pdf")
async def generate_deal_memo_pdf_endpoint(
    deal_memo_id: str,
    authorization: str = Header(None)
):
    """Generate PDF from deal memo data, store in S3"""
    user = await get_current_user_from_token(authorization)
    current_user_id = user["id"]
    client = get_client()

    try:
        # Get deal memo
        memo_result = client.table("backlot_deal_memos").select("*").eq("id", deal_memo_id).single().execute()
        if not memo_result.data:
            raise HTTPException(status_code=404, detail="Deal memo not found")

        memo = memo_result.data
        project_id = memo["project_id"]

        # Verify project admin access
        project_response = client.table("backlot_projects").select("*").eq("id", project_id).execute()
        if not project_response.data:
            raise HTTPException(status_code=404, detail="Project not found")
        project = project_response.data[0]
        is_owner = str(project.get("owner_id")) == str(current_user_id)

        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", current_user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin"]:
                raise HTTPException(status_code=403, detail="Access denied")

        # Get user profile for the crew member
        user_profile = {}
        if memo.get("user_id"):
            profile_result = client.table("profiles").select("id, full_name, username, avatar_url, email").eq("id", memo["user_id"]).execute()
            if profile_result.data:
                user_profile = profile_result.data[0]

        # Generate PDF
        pdf_bytes = await generate_deal_memo_pdf(memo, project, user_profile)

        # Upload to S3
        s3_key = f"deal-memos/{project_id}/{deal_memo_id}/deal_memo_{deal_memo_id}.pdf"
        import boto3
        s3_client = boto3.client("s3")
        s3_client.put_object(
            Bucket=settings.AWS_S3_BACKLOT_FILES_BUCKET,
            Key=s3_key,
            Body=pdf_bytes,
            ContentType="application/pdf",
        )

        # Update deal memo with S3 key
        client.table("backlot_deal_memos").update({
            "pdf_s3_key": s3_key,
            "updated_at": datetime.utcnow().isoformat(),
        }).eq("id", deal_memo_id).execute()

        # Generate presigned URL for immediate preview
        presigned_url = s3_client.generate_presigned_url(
            "get_object",
            Params={"Bucket": settings.AWS_S3_BACKLOT_FILES_BUCKET, "Key": s3_key},
            ExpiresIn=3600,
        )

        return {
            "success": True,
            "pdf_url": presigned_url,
            "pdf_s3_key": s3_key,
            "message": "Deal memo PDF generated",
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error generating deal memo PDF: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/deal-memos/{deal_memo_id}/send")
async def send_deal_memo(
    deal_memo_id: str,
    send_input: Optional[DealMemoSendInput] = None,
    authorization: str = Header(None)
):
    """Send deal memo for in-app signature. Generates PDF if needed, creates signing token, sends notification."""
    user = await get_current_user_from_token(authorization)
    current_user_id = user["id"]
    client = get_client()

    try:
        # Get deal memo
        memo_result = client.table("backlot_deal_memos").select("*").eq("id", deal_memo_id).single().execute()
        if not memo_result.data:
            raise HTTPException(status_code=404, detail="Deal memo not found")

        memo = memo_result.data
        project_id = memo["project_id"]

        # Can only send draft memos
        if memo["status"] not in ["draft", "pending_send"]:
            raise HTTPException(status_code=400, detail=f"Cannot send deal memo with status '{memo['status']}'")

        # Verify project admin access
        project_response = client.table("backlot_projects").select("*").eq("id", project_id).execute()
        if not project_response.data:
            raise HTTPException(status_code=404, detail="Project not found")
        project = project_response.data[0]
        is_owner = str(project.get("owner_id")) == str(current_user_id)

        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", current_user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin"]:
                raise HTTPException(status_code=403, detail="Access denied")

        # Generate PDF if not already generated
        if not memo.get("pdf_s3_key"):
            user_profile = {}
            if memo.get("user_id"):
                profile_result = client.table("profiles").select("id, full_name, username, avatar_url, email").eq("id", memo["user_id"]).execute()
                if profile_result.data:
                    user_profile = profile_result.data[0]

            pdf_bytes = await generate_deal_memo_pdf(memo, project, user_profile)
            s3_key = f"deal-memos/{project_id}/{deal_memo_id}/deal_memo_{deal_memo_id}.pdf"
            import boto3
            s3_client = boto3.client("s3")
            s3_client.put_object(
                Bucket=settings.AWS_S3_BACKLOT_FILES_BUCKET,
                Key=s3_key,
                Body=pdf_bytes,
                ContentType="application/pdf",
            )
            memo["pdf_s3_key"] = s3_key

        # Generate unique signing token
        signing_token = secrets.token_urlsafe(48)

        # Update deal memo
        update_data = {
            "status": "sent",
            "docusign_status": "sent",
            "docusign_sent_at": datetime.utcnow().isoformat(),
            "sent_at": datetime.utcnow().isoformat(),
            "signature_request_token": signing_token,
            "pdf_s3_key": memo.get("pdf_s3_key"),
            "updated_at": datetime.utcnow().isoformat(),
        }
        if send_input:
            if send_input.signer_email:
                update_data["signer_email"] = send_input.signer_email
            if send_input.signer_name:
                update_data["signer_name"] = send_input.signer_name
            if send_input.message:
                update_data["email_message"] = send_input.message

        client.table("backlot_deal_memos").update(update_data).eq("id", deal_memo_id).execute()

        # Send notification to crew member
        if memo.get("user_id"):
            client.table("notifications").insert({
                "user_id": memo["user_id"],
                "type": "deal_memo_received",
                "title": "Deal Memo Received",
                "body": f"You have received a deal memo for {memo['position_title']} on {project.get('title', 'a project')}. Please review and sign.",
                "data": {
                    "deal_memo_id": deal_memo_id,
                    "project_id": project_id,
                    "signing_token": signing_token,
                },
            }).execute()

        # Send email if signer_email provided
        signer_email = (send_input.signer_email if send_input else None) or memo.get("signer_email")
        if signer_email:
            try:
                email_service = EmailService()
                signing_url = f"{settings.FRONTEND_URL}/deal-memo/sign/{signing_token}"
                subject = f"Deal Memo - {memo['position_title']} on {project.get('title', '')}"
                body_html = f"""
                <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                    <h2>Deal Memo for Signature</h2>
                    <p>You have a deal memo ready for review and signature:</p>
                    <ul>
                        <li><strong>Project:</strong> {project.get('title', '')}</li>
                        <li><strong>Position:</strong> {memo['position_title']}</li>
                    </ul>
                    {f'<p><em>{send_input.message}</em></p>' if send_input and send_input.message else ''}
                    <p><a href="{signing_url}" style="display:inline-block;padding:12px 24px;background:#FF3C3C;color:#fff;text-decoration:none;border-radius:6px;">Review & Sign</a></p>
                    <p style="color:#666;font-size:12px;">This link is unique to you. Do not share it.</p>
                </div>
                """
                await email_service.send_email(
                    to_email=signer_email,
                    subject=subject,
                    html_content=body_html,
                )
            except Exception as email_err:
                print(f"Warning: Failed to send deal memo email: {email_err}")

        return {
            "success": True,
            "signing_token": signing_token,
            "message": "Deal memo sent for signature",
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error sending deal memo: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =============================================================================
# DEAL MEMO PAPERWORK TRACKING
# =============================================================================

class DealMemoStatusUpdate(BaseModel):
    """Input for updating deal memo status"""
    status: Literal["sent", "viewed", "signed", "declined"]
    notes: Optional[str] = None
    signed_document_url: Optional[str] = None


@router.patch("/deal-memos/{deal_memo_id}/status")
async def update_deal_memo_status(
    deal_memo_id: str,
    update: DealMemoStatusUpdate,
    authorization: str = Header(None)
):
    """Update deal memo status (manual paperwork tracking)"""
    user = await get_current_user_from_token(authorization)
    current_user_id = user["id"]
    client = get_client()

    try:
        # Get deal memo
        memo_result = client.table("backlot_deal_memos").select("*").eq("id", deal_memo_id).single().execute()
        if not memo_result.data:
            raise HTTPException(status_code=404, detail="Deal memo not found")

        memo = memo_result.data
        project_id = memo["project_id"]
        old_status = memo["status"]

        # Verify project admin access
        project_response = client.table("backlot_projects").select("owner_id, title").eq("id", project_id).execute()
        project_data = project_response.data[0] if project_response.data else {}
        is_owner = str(project_data.get("owner_id")) == str(current_user_id)

        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", current_user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin"]:
                raise HTTPException(status_code=403, detail="Access denied")

        # Build update data
        update_data = {
            "status": update.status,
            "docusign_status": update.status,
            "updated_at": datetime.utcnow().isoformat(),
        }

        # Add status-specific timestamps
        if update.status == "sent" and old_status in ["draft", "pending_send"]:
            update_data["docusign_sent_at"] = datetime.utcnow().isoformat()
        elif update.status == "signed":
            update_data["docusign_signed_at"] = datetime.utcnow().isoformat()
            if update.signed_document_url:
                update_data["signed_document_url"] = update.signed_document_url
        elif update.status == "declined":
            update_data["docusign_declined_at"] = datetime.utcnow().isoformat()

        # Add notes if provided
        if update.notes:
            existing_notes = memo.get("notes") or ""
            timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M")
            new_note = f"\n[{timestamp}] Status  {update.status}: {update.notes}"
            update_data["notes"] = existing_notes + new_note

        # Update the deal memo
        client.table("backlot_deal_memos").update(update_data).eq("id", deal_memo_id).execute()

        # Send notifications based on status change
        notification_data = {
            "deal_memo_id": deal_memo_id,
            "project_id": project_id,
            "project_title": project_data.get("title", ""),
            "position_title": memo["position_title"],
        }

        if update.status == "sent" and memo.get("user_id"):
            # Notify recipient that deal memo was sent
            client.table("notifications").insert({
                "user_id": memo["user_id"],
                "type": "deal_memo_received",
                "title": "Deal Memo Received",
                "body": f"You have a deal memo for {memo['position_title']} on {project_data.get('title', 'a project')}. Please review and sign.",
                "data": notification_data,
            }).execute()

        elif update.status == "signed":
            # Notify project owner that deal memo was signed
            if project_data.get("owner_id") and str(project_data["owner_id"]) != str(current_user_id):
                client.table("notifications").insert({
                    "user_id": project_data["owner_id"],
                    "type": "deal_memo_signed",
                    "title": "Deal Memo Signed",
                    "body": f"The deal memo for {memo['position_title']} has been signed.",
                    "data": notification_data,
                }).execute()

            # Auto-create crew rate if not already created
            existing_rate = client.table("backlot_crew_rates").select("id").eq("deal_memo_id", deal_memo_id).execute()
            if not existing_rate.data:
                rate_data = {
                    "project_id": project_id,
                    "user_id": memo["user_id"],
                    "role_id": memo.get("role_id"),
                    "rate_type": memo["rate_type"],
                    "rate_amount": memo["rate_amount"],
                    "overtime_multiplier": memo.get("overtime_multiplier", 1.5),
                    "double_time_multiplier": memo.get("double_time_multiplier", 2.0),
                    "kit_rental_rate": memo.get("kit_rental_rate"),
                    "car_allowance": memo.get("car_allowance"),
                    "phone_allowance": memo.get("phone_allowance"),
                    "effective_start": memo.get("start_date"),
                    "effective_end": memo.get("end_date"),
                    "notes": f"Auto-created from signed deal memo: {memo['position_title']}",
                    "deal_memo_id": deal_memo_id,
                    "source": "deal_memo",
                }
                client.table("backlot_crew_rates").insert(rate_data).execute()

        elif update.status == "declined" and memo.get("user_id"):
            # Notify project owner that deal memo was declined
            if project_data.get("owner_id"):
                client.table("notifications").insert({
                    "user_id": project_data["owner_id"],
                    "type": "deal_memo_declined",
                    "title": "Deal Memo Declined",
                    "body": f"The deal memo for {memo['position_title']} was declined.",
                    "data": notification_data,
                }).execute()

        return {"success": True, "message": f"Deal memo status updated to {update.status}"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating deal memo status: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/deal-memos/{deal_memo_id}/upload-signed")
async def upload_signed_document(
    deal_memo_id: str,
    file_url: str = Body(..., embed=True),
    authorization: str = Header(None)
):
    """Upload a signed deal memo document"""
    user = await get_current_user_from_token(authorization)
    current_user_id = user["id"]
    client = get_client()

    try:
        # Get deal memo
        memo_result = client.table("backlot_deal_memos").select("project_id, status").eq("id", deal_memo_id).single().execute()
        if not memo_result.data:
            raise HTTPException(status_code=404, detail="Deal memo not found")

        memo = memo_result.data
        project_id = memo["project_id"]

        # Verify project admin access
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = str(project_response.data[0]["owner_id"]) == str(current_user_id) if project_response.data else False

        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", current_user_id).execute()
            if not member_response.data or member_response.data[0]["role"] not in ["owner", "admin"]:
                raise HTTPException(status_code=403, detail="Access denied")

        # Update deal memo with signed document URL
        client.table("backlot_deal_memos").update({
            "signed_document_url": file_url,
            "updated_at": datetime.utcnow().isoformat(),
        }).eq("id", deal_memo_id).execute()

        return {"success": True, "message": "Signed document uploaded"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error uploading signed document: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/deal-memos/{deal_memo_id}/history")
async def get_deal_memo_history(
    deal_memo_id: str,
    authorization: str = Header(None)
):
    """Get status history for a deal memo (from notes)"""
    user = await get_current_user_from_token(authorization)
    current_user_id = user["id"]
    client = get_client()

    try:
        # Get deal memo
        memo_result = client.table("backlot_deal_memos").select("*").eq("id", deal_memo_id).single().execute()
        if not memo_result.data:
            raise HTTPException(status_code=404, detail="Deal memo not found")

        memo = memo_result.data
        project_id = memo["project_id"]

        # Verify project access
        project_response = client.table("backlot_projects").select("owner_id").eq("id", project_id).execute()
        is_owner = str(project_response.data[0]["owner_id"]) == str(current_user_id) if project_response.data else False

        if not is_owner:
            member_response = client.table("backlot_project_members").select("role").eq("project_id", project_id).eq("user_id", current_user_id).execute()
            if not member_response.data:
                # Check if user is the recipient
                if str(memo.get("user_id")) != str(current_user_id):
                    raise HTTPException(status_code=403, detail="Access denied")

        # Build history from timestamps
        history = []

        if memo.get("created_at"):
            history.append({
                "status": "draft",
                "timestamp": memo["created_at"],
                "description": "Deal memo created",
            })

        if memo.get("docusign_sent_at"):
            history.append({
                "status": "sent",
                "timestamp": memo["docusign_sent_at"],
                "description": "Sent for signature",
            })

        if memo.get("docusign_signed_at"):
            history.append({
                "status": "signed",
                "timestamp": memo["docusign_signed_at"],
                "description": "Document signed",
            })

        if memo.get("docusign_declined_at"):
            history.append({
                "status": "declined",
                "timestamp": memo["docusign_declined_at"],
                "description": "Document declined",
            })

        # Sort by timestamp
        history.sort(key=lambda x: x["timestamp"])

        return {
            "success": True,
            "deal_memo_id": deal_memo_id,
            "current_status": memo["status"],
            "history": history,
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching deal memo history: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =============================================================================
# DEAL MEMO SIGNING PORTAL (Public - Token Based)
# =============================================================================

@router.get("/deal-memos/sign/{token}")
async def get_deal_memo_signing_data(token: str):
    """Public endpoint - Get deal memo data for signing portal. No auth required."""
    client = get_client()

    try:
        result = client.table("backlot_deal_memos").select("*").eq("signature_request_token", token).single().execute()
        if not result.data:
            raise HTTPException(status_code=404, detail="Invalid or expired signing link")

        memo = result.data

        if memo["status"] not in ["sent", "viewed"]:
            if memo["status"] == "signed":
                return {"success": True, "already_signed": True, "signed_at": memo.get("signed_at")}
            raise HTTPException(status_code=400, detail=f"This deal memo is no longer available for signing (status: {memo['status']})")

        # Get project info
        project_result = client.table("backlot_projects").select("title, project_type, settings").eq("id", memo["project_id"]).execute()
        project_title = project_result.data[0]["title"] if project_result.data else "Unknown Project"

        # Get user profile
        user_name = memo.get("signer_name", "")
        if memo.get("user_id"):
            profile_result = client.table("profiles").select("full_name, username").eq("id", memo["user_id"]).execute()
            if profile_result.data:
                user_name = profile_result.data[0].get("full_name") or profile_result.data[0].get("username") or user_name

        # Generate presigned URL for PDF
        pdf_url = None
        if memo.get("pdf_s3_key"):
            import boto3
            s3_client = boto3.client("s3")
            pdf_url = s3_client.generate_presigned_url(
                "get_object",
                Params={"Bucket": settings.AWS_S3_BACKLOT_FILES_BUCKET, "Key": memo["pdf_s3_key"]},
                ExpiresIn=3600,
            )

        # Mark as viewed if first time
        if memo["status"] == "sent":
            client.table("backlot_deal_memos").update({
                "status": "viewed",
                "docusign_status": "viewed",
                "viewed_at": datetime.utcnow().isoformat(),
                "updated_at": datetime.utcnow().isoformat(),
            }).eq("id", memo["id"]).execute()

        return {
            "success": True,
            "deal_memo": {
                "id": memo["id"],
                "position_title": memo["position_title"],
                "rate_type": memo["rate_type"],
                "rate_amount": memo["rate_amount"],
                "overtime_multiplier": memo.get("overtime_multiplier"),
                "double_time_multiplier": memo.get("double_time_multiplier"),
                "kit_rental_rate": memo.get("kit_rental_rate"),
                "car_allowance": memo.get("car_allowance"),
                "phone_allowance": memo.get("phone_allowance"),
                "per_diem_rate": memo.get("per_diem_rate"),
                "start_date": memo.get("start_date"),
                "end_date": memo.get("end_date"),
                "additional_terms": memo.get("additional_terms", {}),
                "notes": memo.get("notes"),
                "template_type": memo.get("template_type", "crew"),
                "performer_category": memo.get("performer_category"),
                "usage_rights": memo.get("usage_rights", {}),
            },
            "project_title": project_title,
            "signer_name": user_name,
            "pdf_url": pdf_url,
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching signing data: {e}")
        raise HTTPException(status_code=500, detail=str(e))


class DealMemoSignInput(BaseModel):
    """Input for signing a deal memo"""
    signature_data: str  # Base64 PNG image of signature
    signature_type: Literal["draw", "type", "saved"]
    signer_name: Optional[str] = None


@router.post("/deal-memos/sign/{token}")
async def sign_deal_memo(
    token: str,
    sign_input: DealMemoSignInput,
    request: Request,
):
    """Public endpoint - Sign a deal memo via token. No auth required."""
    client = get_client()

    try:
        result = client.table("backlot_deal_memos").select("*").eq("signature_request_token", token).single().execute()
        if not result.data:
            raise HTTPException(status_code=404, detail="Invalid or expired signing link")

        memo = result.data

        if memo["status"] not in ["sent", "viewed"]:
            raise HTTPException(status_code=400, detail=f"This deal memo cannot be signed (status: {memo['status']})")

        project_id = memo["project_id"]
        now = datetime.utcnow()

        # Get project and user profile for signed PDF generation
        project_result = client.table("backlot_projects").select("*").eq("id", project_id).execute()
        project = project_result.data[0] if project_result.data else {}

        user_profile = {}
        if memo.get("user_id"):
            profile_result = client.table("profiles").select("id, full_name, username, avatar_url, email").eq("id", memo["user_id"]).execute()
            if profile_result.data:
                user_profile = profile_result.data[0]

        signer_name = sign_input.signer_name or memo.get("signer_name") or user_profile.get("full_name") or "Signer"

        # Generate signed PDF with embedded signature
        signed_pdf_bytes = await generate_signed_deal_memo_pdf(
            memo, project, user_profile,
            signature_image_base64=sign_input.signature_data,
            signer_name=signer_name,
            signed_at=now.strftime("%B %d, %Y at %I:%M %p"),
        )

        # Upload signed PDF to S3
        signed_s3_key = f"deal-memos/{project_id}/{memo['id']}/signed_deal_memo_{memo['id']}.pdf"
        import boto3
        s3_client = boto3.client("s3")
        s3_client.put_object(
            Bucket=settings.AWS_S3_BACKLOT_FILES_BUCKET,
            Key=signed_s3_key,
            Body=signed_pdf_bytes,
            ContentType="application/pdf",
        )

        # Update deal memo
        update_data = {
            "status": "signed",
            "docusign_status": "signed",
            "docusign_signed_at": now.isoformat(),
            "signed_at": now.isoformat(),
            "signed_pdf_s3_key": signed_s3_key,
            "signature_type": sign_input.signature_type,
            "signature_data": sign_input.signature_data[:200],  # Store first 200 chars as reference
            "signing_ip": request.client.host if request.client else None,
            "signing_user_agent": request.headers.get("user-agent", "")[:500],
            "signer_name": signer_name,
            "signature_request_token": None,  # Invalidate token after use
            "updated_at": now.isoformat(),
        }
        client.table("backlot_deal_memos").update(update_data).eq("id", memo["id"]).execute()

        # Post-sign automation: auto-create crew rate
        existing_rate = client.table("backlot_crew_rates").select("id").eq("deal_memo_id", memo["id"]).execute()
        if not existing_rate.data:
            rate_data = {
                "project_id": project_id,
                "user_id": memo.get("user_id"),
                "role_id": memo.get("role_id"),
                "rate_type": memo["rate_type"],
                "rate_amount": memo["rate_amount"],
                "overtime_multiplier": memo.get("overtime_multiplier", 1.5),
                "double_time_multiplier": memo.get("double_time_multiplier", 2.0),
                "kit_rental_rate": memo.get("kit_rental_rate"),
                "car_allowance": memo.get("car_allowance"),
                "phone_allowance": memo.get("phone_allowance"),
                "effective_start": memo.get("start_date"),
                "effective_end": memo.get("end_date"),
                "notes": f"Auto-created from signed deal memo: {memo['position_title']}",
                "deal_memo_id": memo["id"],
                "source": "deal_memo",
            }
            client.table("backlot_crew_rates").insert(rate_data).execute()

        # Post-sign automation: auto-trigger onboarding if configured
        if project.get("default_onboarding_package_id") and project.get("onboarding_auto_trigger") and memo.get("user_id"):
            try:
                # Create onboarding session
                session_token = secrets.token_urlsafe(48)
                session_data = {
                    "project_id": project_id,
                    "user_id": memo["user_id"],
                    "access_token": session_token,
                    "package_id": project["default_onboarding_package_id"],
                    "deal_memo_id": memo["id"],
                    "status": "in_progress",
                }
                client.table("backlot_onboarding_sessions").insert(session_data).execute()
            except Exception as onb_err:
                print(f"Warning: Failed to auto-create onboarding session: {onb_err}")

        # Notify project owner
        if project.get("owner_id"):
            client.table("notifications").insert({
                "user_id": project["owner_id"],
                "type": "deal_memo_signed",
                "title": "Deal Memo Signed",
                "body": f"The deal memo for {memo['position_title']} has been signed by {signer_name}.",
                "data": {"deal_memo_id": memo["id"], "project_id": project_id},
            }).execute()

        return {"success": True, "message": "Deal memo signed successfully"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error signing deal memo: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/deal-memo-templates")
async def get_deal_memo_templates(
    template_type: Optional[str] = None,
    authorization: str = Header(None)
):
    """Get available deal memo templates (system + organization)"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        query = client.table("backlot_deal_memo_templates").select("*").order("is_system_template", desc=True).order("name")

        if template_type:
            query = query.eq("template_type", template_type)

        result = query.execute()

        return {"success": True, "templates": result.data or []}

    except Exception as e:
        print(f"Error fetching deal memo templates: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/deal-memos/{deal_memo_id}/encrypt-fields")
async def encrypt_deal_memo_fields(
    deal_memo_id: str,
    fields: Dict[str, Any] = Body(...),
    authorization: str = Header(None)
):
    """Store E2EE encrypted field values for a deal memo"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        # Verify access to deal memo
        memo_result = client.table("backlot_deal_memos").select("project_id, user_id").eq("id", deal_memo_id).single().execute()
        if not memo_result.data:
            raise HTTPException(status_code=404, detail="Deal memo not found")

        for field_name, field_data in fields.items():
            client.table("e2ee_encrypted_fields").upsert({
                "document_type": "deal_memo",
                "document_id": deal_memo_id,
                "field_name": field_name,
                "encrypted_value": field_data.get("encrypted_value", ""),
                "nonce": field_data.get("nonce", ""),
                "updated_at": datetime.utcnow().isoformat(),
            }, on_conflict="document_type,document_id,field_name").execute()

        return {"success": True, "message": f"Encrypted {len(fields)} fields"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error encrypting deal memo fields: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/deal-memos/{deal_memo_id}/encrypted-document")
async def get_encrypted_document(
    deal_memo_id: str,
    authorization: str = Header(None)
):
    """Return encrypted PDF + key envelope for requesting user"""
    user = await get_current_user_from_token(authorization)
    current_user_id = user["id"]
    client = get_client()

    try:
        # Get deal memo
        memo_result = client.table("backlot_deal_memos").select("project_id, pdf_s3_key, signed_pdf_s3_key").eq("id", deal_memo_id).single().execute()
        if not memo_result.data:
            raise HTTPException(status_code=404, detail="Deal memo not found")

        memo = memo_result.data
        s3_key = memo.get("signed_pdf_s3_key") or memo.get("pdf_s3_key")

        if not s3_key:
            raise HTTPException(status_code=404, detail="No PDF available")

        # Get key envelope for this user
        key_result = client.table("e2ee_document_keys").select("*").eq(
            "document_type", "deal_memo"
        ).eq("document_id", deal_memo_id).eq("recipient_user_id", current_user_id).execute()

        key_envelope = key_result.data[0] if key_result.data else None

        # Get encrypted fields
        fields_result = client.table("e2ee_encrypted_fields").select("*").eq(
            "document_type", "deal_memo"
        ).eq("document_id", deal_memo_id).execute()

        # Generate presigned URL
        import boto3
        s3_client = boto3.client("s3")
        pdf_url = s3_client.generate_presigned_url(
            "get_object",
            Params={"Bucket": settings.AWS_S3_BACKLOT_FILES_BUCKET, "Key": s3_key},
            ExpiresIn=3600,
        )

        return {
            "success": True,
            "pdf_url": pdf_url,
            "key_envelope": key_envelope,
            "encrypted_fields": fields_result.data or [],
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error fetching encrypted document: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =============================================================================
# SHOT TEMPLATES
# =============================================================================

class ShotTemplateCreate(BaseModel):
    """Request model for creating a shot template"""
    name: str
    description: Optional[str] = None
    project_id: Optional[str] = None  # null = global/personal template
    template_data: dict  # { frame_size, lens, movement, est_time_minutes, etc. }
    is_default: bool = False


class ShotTemplateUpdate(BaseModel):
    """Request model for updating a shot template"""
    name: Optional[str] = None
    description: Optional[str] = None
    template_data: Optional[dict] = None
    is_default: Optional[bool] = None


# Default system templates
DEFAULT_TEMPLATES = [
    {
        "name": "Standard CU",
        "description": "Close-up with 50mm lens",
        "template_data": {
            "frame_size": "CU",
            "lens": "50mm Prime",
            "movement": "static",
            "est_time_minutes": 5
        }
    },
    {
        "name": "Standard WS",
        "description": "Wide shot with 24mm lens",
        "template_data": {
            "frame_size": "WS",
            "lens": "24mm Prime",
            "movement": "static",
            "est_time_minutes": 5
        }
    },
    {
        "name": "Tracking MS",
        "description": "Medium shot with tracking movement",
        "template_data": {
            "frame_size": "MS",
            "lens": "35mm Prime",
            "movement": "tracking",
            "est_time_minutes": 10
        }
    },
    {
        "name": "OTS Dialogue",
        "description": "Over-the-shoulder for dialogue scenes",
        "template_data": {
            "frame_size": "OTS",
            "lens": "85mm Prime",
            "movement": "static",
            "est_time_minutes": 5
        }
    },
    {
        "name": "Establishing",
        "description": "Wide establishing shot",
        "template_data": {
            "frame_size": "EWS",
            "lens": "14mm Prime",
            "movement": "static",
            "est_time_minutes": 10
        }
    },
    {
        "name": "Insert Detail",
        "description": "Close insert of props/details",
        "template_data": {
            "frame_size": "INSERT",
            "lens": "100mm Macro",
            "movement": "static",
            "est_time_minutes": 3
        }
    },
    {
        "name": "POV Handheld",
        "description": "Point-of-view handheld shot",
        "template_data": {
            "frame_size": "POV",
            "lens": "35mm Prime",
            "movement": "handheld",
            "est_time_minutes": 5
        }
    },
    {
        "name": "Gimbal Walk & Talk",
        "description": "Smooth gimbal for walk & talk",
        "template_data": {
            "frame_size": "MS",
            "lens": "24mm Prime",
            "movement": "gimbal",
            "est_time_minutes": 15
        }
    }
]


@router.get("/shot-templates")
async def list_shot_templates(
    project_id: Optional[str] = None,
    authorization: str = Header(None)
):
    """Get all shot templates available to the user"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        profile_id = get_profile_id_from_cognito_id(user["id"])
        if not profile_id:
            raise HTTPException(status_code=403, detail="Profile not found")

        # Get user's personal templates (project_id is null)
        personal_query = client.table("backlot_shot_templates").select("*").eq("user_id", profile_id).is_("project_id", "null")
        personal_result = personal_query.execute()
        personal_templates = personal_result.data or []

        # Get system templates
        system_query = client.table("backlot_shot_templates").select("*").eq("is_system", True)
        system_result = system_query.execute()
        system_templates = system_result.data or []

        # Get project-specific templates if project_id provided
        project_templates = []
        if project_id:
            project_query = client.table("backlot_shot_templates").select("*").eq("project_id", project_id)
            project_result = project_query.execute()
            project_templates = project_result.data or []

        return {
            "success": True,
            "templates": {
                "personal": personal_templates,
                "project": project_templates,
                "system": system_templates,
                "defaults": DEFAULT_TEMPLATES,  # Always include built-in defaults
            }
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error listing shot templates: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/shot-templates")
async def create_shot_template(
    input_data: ShotTemplateCreate,
    authorization: str = Header(None)
):
    """Create a new shot template"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        profile_id = get_profile_id_from_cognito_id(user["id"])
        if not profile_id:
            raise HTTPException(status_code=403, detail="Profile not found")

        # If project-specific, verify user has access
        if input_data.project_id:
            has_access = await verify_shot_list_edit_access(client, input_data.project_id, user["id"])
            if not has_access:
                raise HTTPException(status_code=403, detail="Access denied to this project")

        template_data = {
            "user_id": profile_id,
            "project_id": input_data.project_id,
            "name": input_data.name,
            "description": input_data.description,
            "template_data": input_data.template_data,
            "is_default": input_data.is_default,
            "is_system": False,
        }

        result = client.table("backlot_shot_templates").insert(template_data).execute()
        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create template")

        return {
            "success": True,
            "template": result.data[0]
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating shot template: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/shot-templates/{template_id}")
async def get_shot_template(
    template_id: str,
    authorization: str = Header(None)
):
    """Get a single shot template"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        profile_id = get_profile_id_from_cognito_id(user["id"])

        result = client.table("backlot_shot_templates").select("*").eq("id", template_id).single().execute()
        if not result.data:
            raise HTTPException(status_code=404, detail="Template not found")

        template = result.data

        # Verify access - system templates are public, personal templates belong to user
        if not template.get("is_system"):
            if template.get("user_id") != profile_id:
                # Check if user has project access
                if template.get("project_id"):
                    has_access = await verify_shot_list_edit_access(client, template["project_id"], user["id"])
                    if not has_access:
                        raise HTTPException(status_code=403, detail="Access denied")
                else:
                    raise HTTPException(status_code=403, detail="Access denied")

        return {
            "success": True,
            "template": template
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting shot template: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/shot-templates/{template_id}")
async def update_shot_template(
    template_id: str,
    input_data: ShotTemplateUpdate,
    authorization: str = Header(None)
):
    """Update a shot template (only owner can update)"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        profile_id = get_profile_id_from_cognito_id(user["id"])
        if not profile_id:
            raise HTTPException(status_code=403, detail="Profile not found")

        # Get existing template
        result = client.table("backlot_shot_templates").select("*").eq("id", template_id).single().execute()
        if not result.data:
            raise HTTPException(status_code=404, detail="Template not found")

        template = result.data

        # Cannot update system templates
        if template.get("is_system"):
            raise HTTPException(status_code=403, detail="Cannot modify system templates")

        # Only owner can update
        if template.get("user_id") != profile_id:
            raise HTTPException(status_code=403, detail="Access denied")

        # Build update data
        update_data = {"updated_at": datetime.utcnow().isoformat()}
        if input_data.name is not None:
            update_data["name"] = input_data.name
        if input_data.description is not None:
            update_data["description"] = input_data.description
        if input_data.template_data is not None:
            update_data["template_data"] = input_data.template_data
        if input_data.is_default is not None:
            update_data["is_default"] = input_data.is_default

        updated = client.table("backlot_shot_templates").update(update_data).eq("id", template_id).execute()

        return {
            "success": True,
            "template": updated.data[0] if updated.data else template
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating shot template: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/shot-templates/{template_id}")
async def delete_shot_template(
    template_id: str,
    authorization: str = Header(None)
):
    """Delete a shot template (only owner can delete)"""
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        profile_id = get_profile_id_from_cognito_id(user["id"])
        if not profile_id:
            raise HTTPException(status_code=403, detail="Profile not found")

        # Get existing template
        result = client.table("backlot_shot_templates").select("*").eq("id", template_id).single().execute()
        if not result.data:
            raise HTTPException(status_code=404, detail="Template not found")

        template = result.data

        # Cannot delete system templates
        if template.get("is_system"):
            raise HTTPException(status_code=403, detail="Cannot delete system templates")

        # Only owner can delete
        if template.get("user_id") != profile_id:
            raise HTTPException(status_code=403, detail="Access denied")

        client.table("backlot_shot_templates").delete().eq("id", template_id).execute()

        return {"success": True, "message": "Template deleted"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting shot template: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Desktop API Keys
# =====================================================

class DesktopKeyCreateInput(BaseModel):
    """Input for creating a new desktop API key"""
    name: str = Field(..., min_length=1, max_length=100, description="Name for the key (e.g., 'Work Laptop')")


class DesktopKeyResponse(BaseModel):
    """Response for a desktop API key (without the actual key)"""
    id: str
    key_prefix: str
    name: str
    last_used_at: Optional[str] = None
    created_at: str
    is_active: bool


class DesktopKeyCreateResponse(BaseModel):
    """Response when creating a new key (includes full key, shown only once)"""
    id: str
    key: str  # Only returned at creation time
    key_prefix: str
    name: str
    created_at: str


class DesktopKeyVerifyResponse(BaseModel):
    """Response for key verification"""
    valid: bool
    user: Optional[Dict[str, Any]] = None
    projects: Optional[List[Dict[str, Any]]] = None


@router.get("/desktop-keys")
async def list_desktop_keys(
    authorization: str = Header(None)
) -> List[DesktopKeyResponse]:
    """List all desktop API keys for the current user"""
    user = await get_current_user_from_token(authorization)
    profile_id = user["id"]

    def format_datetime(dt) -> str:
        """Safely format datetime - handles both datetime objects and strings."""
        if dt is None:
            return None
        if hasattr(dt, 'isoformat'):
            return dt.isoformat()
        return str(dt)

    try:
        keys = execute_query(
            """
            SELECT id, key_prefix, name, last_used_at, created_at, is_active
            FROM backlot_desktop_keys
            WHERE user_id = :user_id AND is_active = true
            ORDER BY created_at DESC
            """,
            {"user_id": profile_id}
        )

        return [
            DesktopKeyResponse(
                id=str(k["id"]),
                key_prefix=k["key_prefix"],
                name=k["name"],
                last_used_at=format_datetime(k["last_used_at"]),
                created_at=format_datetime(k["created_at"]) or "",
                is_active=k["is_active"]
            )
            for k in keys
        ]

    except Exception as e:
        print(f"Error listing desktop keys: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/desktop-keys")
async def create_desktop_key(
    input_data: DesktopKeyCreateInput,
    authorization: str = Header(None)
) -> DesktopKeyCreateResponse:
    """Create a new desktop API key. The full key is only returned once at creation."""
    user = await get_current_user_from_token(authorization)
    profile_id = user["id"]

    try:
        # Generate a secure random key
        random_bytes = secrets.token_hex(16)  # 32 hex chars
        full_key = f"swn_dk_{random_bytes}"
        key_prefix = full_key[:10]  # "swn_dk_" + first 3 hex chars

        # Hash the key for storage
        key_hash = hashlib.sha256(full_key.encode()).hexdigest()

        # Insert into database
        result = execute_single(
            """
            INSERT INTO backlot_desktop_keys (user_id, key_hash, key_prefix, name)
            VALUES (:user_id, :key_hash, :key_prefix, :name)
            RETURNING id, created_at
            """,
            {
                "user_id": profile_id,
                "key_hash": key_hash,
                "key_prefix": key_prefix,
                "name": input_data.name
            }
        )

        # Handle created_at - may be datetime or string depending on driver
        created_at = result["created_at"]
        if created_at and hasattr(created_at, 'isoformat'):
            created_at = created_at.isoformat()
        elif created_at is None:
            created_at = ""

        return DesktopKeyCreateResponse(
            id=str(result["id"]),
            key=full_key,  # Only shown this once
            key_prefix=key_prefix,
            name=input_data.name,
            created_at=str(created_at)
        )

    except Exception as e:
        print(f"Error creating desktop key: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/desktop-keys/{key_id}")
async def revoke_desktop_key(
    key_id: str,
    authorization: str = Header(None)
):
    """Revoke (deactivate) a desktop API key"""
    user = await get_current_user_from_token(authorization)
    profile_id = user["id"]

    try:
        # Verify the key belongs to this user
        existing = execute_single(
            """
            SELECT id, user_id FROM backlot_desktop_keys
            WHERE id::text = :key_id AND is_active = true
            """,
            {"key_id": key_id}
        )

        if not existing:
            raise HTTPException(status_code=404, detail="Key not found")

        if str(existing["user_id"]) != str(profile_id):
            raise HTTPException(status_code=403, detail="Access denied")

        # Revoke the key
        execute_single(
            """
            UPDATE backlot_desktop_keys
            SET is_active = false, revoked_at = NOW()
            WHERE id::text = :key_id
            RETURNING id
            """,
            {"key_id": key_id}
        )

        return {"success": True, "message": "Key revoked"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error revoking desktop key: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/desktop-keys/verify")
async def verify_desktop_key(
    x_api_key: str = Header(None, alias="X-API-Key")
) -> DesktopKeyVerifyResponse:
    """
    Verify a desktop API key and return user info + projects.
    Called by the SWN Dailies Helper desktop application.
    """
    if not x_api_key or not x_api_key.startswith("swn_dk_"):
        return DesktopKeyVerifyResponse(valid=False)

    try:
        # Hash the provided key
        key_hash = hashlib.sha256(x_api_key.encode()).hexdigest()

        # Look up the key
        key_record = execute_single(
            """
            SELECT dk.id, dk.user_id, dk.name, p.email, p.display_name
            FROM backlot_desktop_keys dk
            JOIN profiles p ON p.id = dk.user_id
            WHERE dk.key_hash = :key_hash AND dk.is_active = true
            """,
            {"key_hash": key_hash}
        )

        if not key_record:
            return DesktopKeyVerifyResponse(valid=False)

        # Update last_used_at
        execute_single(
            """
            UPDATE backlot_desktop_keys
            SET last_used_at = NOW()
            WHERE id = :key_id
            RETURNING id
            """,
            {"key_id": str(key_record["id"])}
        )

        user_id = str(key_record["user_id"])

        # Get user's projects
        projects = execute_query(
            """
            SELECT DISTINCT
                p.id,
                p.title as name,
                CASE
                    WHEN p.owner_id = :user_id THEN 'owner'
                    ELSE COALESCE(pm.role, 'member')
                END as role
            FROM backlot_projects p
            LEFT JOIN backlot_project_members pm ON pm.project_id = p.id AND pm.user_id = :user_id
            WHERE p.owner_id = :user_id OR pm.user_id = :user_id
            ORDER BY p.title
            """,
            {"user_id": user_id}
        )

        return DesktopKeyVerifyResponse(
            valid=True,
            user={
                "id": user_id,
                "email": key_record["email"],
                "display_name": key_record["display_name"]
            },
            projects=[
                {"id": str(p["id"]), "name": p["name"], "role": p["role"]}
                for p in projects
            ]
        )

    except Exception as e:
        print(f"Error verifying desktop key: {e}")
        return DesktopKeyVerifyResponse(valid=False)


@router.get("/desktop-keys/projects/{project_id}/production-days")
async def get_production_days_for_desktop(
    project_id: str,
    x_api_key: str = Header(None, alias="X-API-Key")
):
    """
    Get production days for a project using desktop API key authentication.
    Called by the SWN Dailies Helper desktop application.
    """
    if not x_api_key or not x_api_key.startswith("swn_dk_"):
        raise HTTPException(status_code=401, detail="Invalid API key")

    try:
        # Hash the provided key
        key_hash = hashlib.sha256(x_api_key.encode()).hexdigest()

        # Verify the key and get user
        key_record = execute_single(
            """
            SELECT dk.id, dk.user_id
            FROM backlot_desktop_keys dk
            WHERE dk.key_hash = :key_hash AND dk.is_active = true
            """,
            {"key_hash": key_hash}
        )

        if not key_record:
            raise HTTPException(status_code=401, detail="Invalid or inactive API key")

        user_id = str(key_record["user_id"])

        # Verify user has access to the project
        access_check = execute_single(
            """
            SELECT 1 FROM backlot_projects p
            LEFT JOIN backlot_project_members pm ON pm.project_id = p.id AND pm.user_id = :user_id
            WHERE p.id = :project_id AND (p.owner_id = :user_id OR pm.user_id = :user_id)
            """,
            {"project_id": project_id, "user_id": user_id}
        )

        if not access_check:
            raise HTTPException(status_code=403, detail="Access denied to this project")

        # Get production days
        production_days = execute_query(
            """
            SELECT id, day_number, date, title, location_name, is_completed
            FROM backlot_production_days
            WHERE project_id = :project_id
            ORDER BY day_number
            """,
            {"project_id": project_id}
        )

        return {
            "production_days": [
                {
                    "id": str(day["id"]),
                    "day_number": day["day_number"],
                    "date": str(day["date"]) if day["date"] else None,
                    "title": day["title"],
                    "location_name": day["location_name"],
                    "is_completed": day["is_completed"]
                }
                for day in production_days
            ]
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting production days for desktop: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ==================== Desktop Dailies Days Endpoints ====================

async def verify_desktop_key_and_project_access(
    x_api_key: str,
    project_id: str
) -> str:
    """
    Verify desktop API key and return user_id if valid and has project access.
    Raises HTTPException if invalid.
    """
    if not x_api_key or not x_api_key.startswith("swn_dk_"):
        raise HTTPException(status_code=401, detail="Invalid API key format")

    key_hash = hashlib.sha256(x_api_key.encode()).hexdigest()

    key_record = execute_single(
        """
        SELECT dk.id, dk.user_id
        FROM backlot_desktop_keys dk
        WHERE dk.key_hash = :key_hash AND dk.is_active = true
        """,
        {"key_hash": key_hash}
    )

    if not key_record:
        raise HTTPException(status_code=401, detail="Invalid or inactive API key")

    user_id = str(key_record["user_id"])

    # Verify project access
    access_check = execute_single(
        """
        SELECT 1 FROM backlot_projects p
        LEFT JOIN backlot_project_members pm ON pm.project_id = p.id AND pm.user_id = :user_id
        WHERE p.id = :project_id AND (p.owner_id = :user_id OR pm.user_id = :user_id)
        """,
        {"project_id": project_id, "user_id": user_id}
    )

    if not access_check:
        raise HTTPException(status_code=403, detail="Access denied to this project")

    return user_id


@router.get("/desktop-keys/projects/{project_id}/dailies/days")
async def get_dailies_days_for_desktop(
    project_id: str,
    limit: int = Query(100, ge=1, le=500),
    x_api_key: str = Header(None, alias="X-API-Key")
):
    """
    Get dailies days for a project using desktop API key authentication.
    Called by the SWN Dailies Helper desktop application.
    """
    try:
        await verify_desktop_key_and_project_access(x_api_key, project_id)
        client = get_client()

        # Get days with production day info for labels
        days_result = client.table("backlot_dailies_days").select(
            "*, production_day:backlot_production_days(id, day_number, title, date)"
        ).eq(
            "project_id", project_id
        ).order("shoot_date", desc=True).limit(limit).execute()

        days = days_result.data or []

        return [
            {
                "id": str(day["id"]),
                "label": day.get("production_day", {}).get("title") or f"Day {day.get('production_day', {}).get('day_number', '')}" if day.get("production_day") else "",
                "shoot_date": str(day["shoot_date"]) if day.get("shoot_date") else None,
                "status": day.get("status"),
                "notes": day.get("notes"),
                "created_at": str(day["created_at"]) if day.get("created_at") else None,
            }
            for day in days
        ]

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting dailies days for desktop: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/desktop-keys/projects/{project_id}/dailies/days")
async def create_dailies_day_for_desktop(
    project_id: str,
    request: dict,
    x_api_key: str = Header(None, alias="X-API-Key")
):
    """
    Create a new dailies day using desktop API key authentication.
    """
    try:
        await verify_desktop_key_and_project_access(x_api_key, project_id)
        client = get_client()

        # Create day with correct schema
        day_data = {
            "project_id": project_id,
            "shoot_date": request.get("shoot_date"),
            "status": "pending",
            "notes": request.get("notes", ""),
        }

        result = client.table("backlot_dailies_days").insert(day_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create dailies day")

        day = result.data[0]
        return {
            "id": str(day["id"]),
            "label": f"Shoot {day['shoot_date']}" if day.get("shoot_date") else "",
            "shoot_date": str(day["shoot_date"]) if day.get("shoot_date") else None,
            "status": day.get("status"),
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating dailies day for desktop: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/desktop-keys/projects/{project_id}/dailies/ensure-day")
async def ensure_dailies_day_for_desktop(
    project_id: str,
    request: dict,
    x_api_key: str = Header(None, alias="X-API-Key")
):
    """
    Ensure a dailies day exists for a production day using desktop API key authentication.

    If a dailies day already exists for the given production day, returns the existing one.
    Otherwise, creates a new dailies day linked to the production day.
    Auto-populates label from production day info.

    Request body:
        production_day_id: ID of the production day to ensure dailies day for
    """
    try:
        user_id = await verify_desktop_key_and_project_access(x_api_key, project_id)
        client = get_client()

        production_day_id = request.get("production_day_id")
        if not production_day_id:
            raise HTTPException(status_code=400, detail="production_day_id is required")

        # Check if dailies day already exists for this production day
        existing_result = client.table("backlot_dailies_days").select("*").eq(
            "project_id", project_id
        ).eq("production_day_id", production_day_id).limit(1).execute()

        if existing_result.data:
            # Return existing dailies day
            day = existing_result.data[0]
            return {
                "id": str(day["id"]),
                "label": day.get("label") or f"Shoot {day.get('shoot_date', '')}",
                "shoot_date": str(day["shoot_date"]) if day.get("shoot_date") else None,
                "production_day_id": str(day["production_day_id"]) if day.get("production_day_id") else None,
                "status": day.get("status"),
                "created": False,
            }

        # Get the production day to populate label
        prod_day_result = client.table("backlot_production_days").select(
            "id, day_number, date, title"
        ).eq("id", production_day_id).eq(
            "project_id", project_id
        ).single().execute()

        if not prod_day_result.data:
            raise HTTPException(status_code=404, detail="Production day not found")

        prod_day = prod_day_result.data

        # Generate label from production day info
        if prod_day.get("title"):
            label = f"Day {prod_day['day_number']} - {prod_day['title']}"
        else:
            label = f"Day {prod_day['day_number']}"

        # Create new dailies day
        dailies_day_data = {
            "project_id": project_id,
            "production_day_id": production_day_id,
            "shoot_date": prod_day["date"],
            "label": label,
            "status": "pending",
            "created_by_user_id": user_id
        }

        day_result = client.table("backlot_dailies_days").insert(
            dailies_day_data
        ).execute()

        if not day_result.data:
            raise HTTPException(status_code=500, detail="Failed to create dailies day")

        day = day_result.data[0]
        return {
            "id": str(day["id"]),
            "label": day.get("label") or label,
            "shoot_date": str(day["shoot_date"]) if day.get("shoot_date") else None,
            "production_day_id": str(day["production_day_id"]) if day.get("production_day_id") else None,
            "status": day.get("status"),
            "created": True,
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error ensuring dailies day for desktop: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/desktop-keys/dailies/days/{day_id}/cards")
async def get_dailies_cards_for_desktop(
    day_id: str,
    limit: int = Query(100, ge=1, le=500),
    x_api_key: str = Header(None, alias="X-API-Key")
):
    """
    Get dailies cards for a day using desktop API key authentication.
    """
    if not x_api_key or not x_api_key.startswith("swn_dk_"):
        raise HTTPException(status_code=401, detail="Invalid API key format")

    try:
        key_hash = hashlib.sha256(x_api_key.encode()).hexdigest()

        key_record = execute_single(
            """
            SELECT dk.id, dk.user_id
            FROM backlot_desktop_keys dk
            WHERE dk.key_hash = :key_hash AND dk.is_active = true
            """,
            {"key_hash": key_hash}
        )

        if not key_record:
            raise HTTPException(status_code=401, detail="Invalid or inactive API key")

        client = get_client()

        # Get cards (actual schema: camera, card_number)
        cards_result = client.table("backlot_dailies_cards").select("*").eq(
            "dailies_day_id", day_id
        ).order("created_at", desc=True).limit(limit).execute()

        cards = cards_result.data or []

        return [
            {
                "id": str(card["id"]),
                "camera_label": card.get("camera", ""),
                "roll_name": card.get("card_number", ""),
                "card_number": card.get("card_number", ""),
                "camera": card.get("camera", ""),
            }
            for card in cards
        ]

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting dailies cards for desktop: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/desktop-keys/dailies/days/{day_id}/cards")
async def create_dailies_card_for_desktop(
    day_id: str,
    request: dict,
    x_api_key: str = Header(None, alias="X-API-Key")
):
    """
    Create a new dailies card using desktop API key authentication.
    """
    if not x_api_key or not x_api_key.startswith("swn_dk_"):
        raise HTTPException(status_code=401, detail="Invalid API key format")

    try:
        key_hash = hashlib.sha256(x_api_key.encode()).hexdigest()

        key_record = execute_single(
            """
            SELECT dk.id, dk.user_id
            FROM backlot_desktop_keys dk
            WHERE dk.key_hash = :key_hash AND dk.is_active = true
            """,
            {"key_hash": key_hash}
        )

        if not key_record:
            raise HTTPException(status_code=401, detail="Invalid or inactive API key")

        client = get_client()

        # Create card (actual schema: camera, card_number)
        card_data = {
            "dailies_day_id": day_id,
            "camera": request.get("camera_label", request.get("camera", "A")),
            "card_number": request.get("roll_name", request.get("card_number", "")),
            "status": "pending",
        }

        result = client.table("backlot_dailies_cards").insert(card_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create dailies card")

        card = result.data[0]
        return {
            "id": str(card["id"]),
            "camera_label": card.get("camera", ""),
            "roll_name": card.get("card_number", ""),
            "camera": card.get("camera", ""),
            "card_number": card.get("card_number", ""),
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating dailies card for desktop: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/desktop-keys/dailies/confirm-upload")
async def confirm_desktop_dailies_upload(
    request: dict,
    x_api_key: str = Header(None, alias="X-API-Key")
):
    """
    Confirm a dailies upload from the desktop helper.
    Creates a new clip record and marks it as uploaded.

    Request body:
        project_id: Project ID
        s3_key: The S3 key where the file was uploaded
        checksum: XXH64 checksum of the file
        file_size: Size in bytes
        file_name: Original filename (optional)
    """
    if not x_api_key or not x_api_key.startswith("swn_dk_"):
        raise HTTPException(status_code=401, detail="Invalid API key format")

    try:
        key_hash = hashlib.sha256(x_api_key.encode()).hexdigest()

        key_record = execute_single(
            """
            SELECT dk.id, dk.user_id
            FROM backlot_desktop_keys dk
            WHERE dk.key_hash = :key_hash AND dk.is_active = true
            """,
            {"key_hash": key_hash}
        )

        if not key_record:
            raise HTTPException(status_code=401, detail="Invalid or inactive API key")

        project_id = request.get("project_id")
        s3_key = request.get("s3_key")
        checksum = request.get("checksum")
        file_size = request.get("file_size")
        file_name = request.get("file_name", s3_key.split("/")[-1] if s3_key else "unknown")

        if not project_id or not s3_key:
            raise HTTPException(status_code=400, detail="project_id and s3_key are required")

        # Build the cloud URL
        bucket_name = os.environ.get("AWS_S3_BACKLOT_FILES_BUCKET", "swn-backlot-files-517220555400")
        cloud_url = f"https://{bucket_name}.s3.us-east-1.amazonaws.com/{s3_key}"

        client = get_client()

        # Look up standalone asset by s3_key to link it
        standalone_asset = client.table("backlot_standalone_assets").select("id").eq("s3_key", s3_key).execute()
        standalone_asset_id = standalone_asset.data[0]["id"] if standalone_asset.data else None

        # Create the clip record with upload confirmed
        clip_data = {
            "project_id": project_id,
            "file_name": file_name,
            "file_path": s3_key,
            "cloud_url": cloud_url,
            "proxy_url": cloud_url,
            "storage_mode": "cloud",
            "upload_status": "completed",
        }

        if standalone_asset_id:
            clip_data["linked_standalone_asset_id"] = standalone_asset_id

        if checksum:
            clip_data["original_checksum"] = checksum
            clip_data["proxy_checksum"] = checksum

        result = client.table("backlot_dailies_clips").insert(clip_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create clip record")

        clip = result.data[0]
        return {
            "success": True,
            "clip_id": str(clip["id"]),
            "cloud_url": cloud_url,
            "message": "Upload confirmed and clip created"
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error confirming desktop upload: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/desktop-keys/dailies/register-clips")
async def register_desktop_dailies_clips(
    request: dict,
    x_api_key: str = Header(None, alias="X-API-Key")
):
    """
    Register multiple clips that have been uploaded from the desktop helper.

    Request body:
        project_id: Project ID
        day_id: Dailies day ID (optional, for metadata only)
        cards: List of card objects with clips
    """
    if not x_api_key or not x_api_key.startswith("swn_dk_"):
        raise HTTPException(status_code=401, detail="Invalid API key format")

    try:
        key_hash = hashlib.sha256(x_api_key.encode()).hexdigest()

        key_record = execute_single(
            """
            SELECT dk.id, dk.user_id
            FROM backlot_desktop_keys dk
            WHERE dk.key_hash = :key_hash AND dk.is_active = true
            """,
            {"key_hash": key_hash}
        )

        if not key_record:
            raise HTTPException(status_code=401, detail="Invalid or inactive API key")

        project_id = request.get("project_id")
        day_id = request.get("day_id")
        cards = request.get("cards", [])

        if not project_id:
            raise HTTPException(status_code=400, detail="project_id is required")

        client = get_client()
        bucket_name = os.environ.get("AWS_S3_BACKLOT_FILES_BUCKET", "swn-backlot-files-517220555400")

        clips_created = 0
        clip_ids = []

        for card in cards:
            camera_label = card.get("camera_label", card.get("camera", "A"))
            clips = card.get("clips", [])

            for clip_data in clips:
                s3_key = clip_data.get("s3_key", clip_data.get("file_path", ""))
                file_name = clip_data.get("file_name", s3_key.split("/")[-1] if s3_key else "unknown")

                cloud_url = f"https://{bucket_name}.s3.us-east-1.amazonaws.com/{s3_key}" if s3_key else None

                insert_data = {
                    "project_id": project_id,
                    "file_name": file_name,
                    "file_path": s3_key,
                    "cloud_url": cloud_url,
                    "proxy_url": cloud_url,
                    "storage_mode": "cloud",
                    "upload_status": "completed",
                    "camera_label": camera_label,
                }

                # Copy optional fields
                for field in ["duration_seconds", "timecode_start", "frame_rate", "resolution",
                              "codec", "scene_number", "take_number", "original_checksum", "proxy_checksum"]:
                    if clip_data.get(field) is not None:
                        insert_data[field] = clip_data[field]

                if clip_data.get("checksum"):
                    insert_data["original_checksum"] = clip_data["checksum"]
                    insert_data["proxy_checksum"] = clip_data["checksum"]

                result = client.table("backlot_dailies_clips").insert(insert_data).execute()
                if result.data:
                    clips_created += 1
                    clip_ids.append(str(result.data[0]["id"]))

        return {
            "success": True,
            "clips_created": clips_created,
            "clip_ids": clip_ids,
            "message": f"Registered {clips_created} clips"
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error registering desktop clips: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ============================================================================
# UNIFIED ASSETS (for Assets Tab)
# ============================================================================

@router.get("/projects/{project_id}/assets/unified")
async def list_unified_assets(
    project_id: str,
    source: str = Query(None, description="Filter by source: dailies, review, standalone"),
    asset_type: str = Query(None, description="Filter by asset type: video, audio, image, etc."),
    search: str = Query(None, description="Search by name"),
    limit: int = Query(100, ge=1, le=500),
    offset: int = Query(0, ge=0),
    authorization: str = Header(None)
):
    """
    List unified assets from all sources (Dailies, Review, Standalone).
    Uses the backlot_unified_assets view.
    """
    try:
        # Verify authentication and project access
        await require_project_member(project_id, authorization)

        # Build query with filters
        params: dict = {"project_id": project_id}
        where_clauses = ["project_id = :project_id"]

        if source:
            where_clauses.append("source = :source")
            params["source"] = source

        if asset_type:
            where_clauses.append("asset_type = :asset_type")
            params["asset_type"] = asset_type

        if search:
            where_clauses.append("name ILIKE :search")
            params["search"] = f"%{search}%"

        where_sql = " AND ".join(where_clauses)

        # Get total count
        count_result = execute_single(
            f"""
            SELECT COUNT(*) as total
            FROM backlot_unified_assets
            WHERE {where_sql}
            """,
            params
        )
        total = count_result["total"] if count_result else 0

        # Get assets
        assets = execute_query(
            f"""
            SELECT id, project_id, source, name, asset_type, thumbnail_url,
                   duration_seconds, file_size_bytes, created_at
            FROM backlot_unified_assets
            WHERE {where_sql}
            ORDER BY created_at DESC
            LIMIT :limit OFFSET :offset
            """,
            {**params, "limit": limit, "offset": offset}
        )

        return {
            "assets": assets,
            "total": total,
            "limit": limit,
            "offset": offset
        }

    except Exception as e:
        print(f"Error listing unified assets: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/assets/summary")
async def get_assets_summary(
    project_id: str,
    authorization: str = Header(None)
):
    """
    Get summary counts for all asset types in a project.
    """
    try:
        summary = execute_query(
            """
            SELECT source, asset_type, COUNT(*) as count
            FROM backlot_unified_assets
            WHERE project_id = :project_id
            GROUP BY source, asset_type
            ORDER BY source, asset_type
            """,
            {"project_id": project_id}
        )

        # Also get total storage used
        storage = execute_single(
            """
            SELECT COALESCE(SUM(file_size_bytes), 0) as total_bytes
            FROM backlot_unified_assets
            WHERE project_id = :project_id
            """,
            {"project_id": project_id}
        )

        return {
            "summary": summary,
            "total_storage_bytes": storage["total_bytes"] if storage else 0
        }

    except Exception as e:
        print(f"Error getting assets summary: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ============================================================================
# STANDALONE ASSETS CRUD
# ============================================================================

class StandaloneAssetInput(BaseModel):
    name: str
    description: Optional[str] = None
    asset_type: str  # audio, 3d_model, image, document, graphics, music, sfx, video, video_link, other
    file_name: Optional[str] = None
    s3_key: Optional[str] = None
    file_size_bytes: Optional[int] = None
    mime_type: Optional[str] = None
    duration_seconds: Optional[float] = None  # For audio
    dimensions: Optional[str] = None  # For images (WxH)
    tags: Optional[List[str]] = None
    metadata: Optional[dict] = None
    folder_id: Optional[str] = None
    source_url: Optional[str] = None  # URL for link-based assets (YouTube, Vimeo, etc.)
    video_provider: Optional[str] = None  # 'youtube', 'vimeo', etc.
    external_video_id: Optional[str] = None  # Provider-specific video ID


@router.post("/projects/{project_id}/assets/standalone")
async def create_standalone_asset(
    project_id: str,
    asset_input: StandaloneAssetInput,
    authorization: str = Header(None)
):
    """
    Create a new standalone asset (files, audio, 3D, images, or URL-based video links)
    """
    user = await get_current_user_from_token(authorization)
    try:
        # Validate: must have either s3_key or source_url
        if not asset_input.s3_key and not asset_input.source_url:
            raise HTTPException(status_code=400, detail="Either s3_key or source_url must be provided")

        client = get_client()

        insert_data = {
            "project_id": project_id,
            "name": asset_input.name,
            "description": asset_input.description,
            "asset_type": asset_input.asset_type,
            "file_size_bytes": asset_input.file_size_bytes,
            "mime_type": asset_input.mime_type,
            "duration_seconds": asset_input.duration_seconds,
            "dimensions": asset_input.dimensions,
            "tags": asset_input.tags or [],
            "metadata": asset_input.metadata or {},
            "folder_id": asset_input.folder_id,
            "created_by_user_id": user["id"],
        }

        # Include file fields only when provided (nullable for link assets)
        if asset_input.file_name is not None:
            insert_data["file_name"] = asset_input.file_name
        if asset_input.s3_key is not None:
            insert_data["s3_key"] = asset_input.s3_key

        # Include link asset fields when provided
        if asset_input.source_url is not None:
            insert_data["source_url"] = asset_input.source_url
        if asset_input.video_provider is not None:
            insert_data["video_provider"] = asset_input.video_provider
        if asset_input.external_video_id is not None:
            insert_data["external_video_id"] = asset_input.external_video_id

        result = client.table("backlot_standalone_assets").insert(insert_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create asset")

        return {"asset": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating standalone asset: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/assets/standalone")
async def list_standalone_assets(
    project_id: str,
    folder_id: str = Query(None),
    asset_type: str = Query(None),
    tags: str = Query(None, description="Comma-separated tags"),
    authorization: str = Header(None)
):
    """
    List standalone assets for a project.
    """
    try:
        client = get_client()

        query = client.table("backlot_standalone_assets") \
            .select("*") \
            .eq("project_id", project_id) \
            .order("created_at", desc=True)

        if folder_id:
            query = query.eq("folder_id", folder_id)
        elif folder_id == "":
            query = query.is_("folder_id", "null")

        if asset_type:
            query = query.eq("asset_type", asset_type)

        if tags:
            tag_list = [t.strip() for t in tags.split(",")]
            query = query.contains("tags", tag_list)

        result = query.execute()

        return {"assets": result.data}

    except Exception as e:
        print(f"Error listing standalone assets: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/assets/standalone/{asset_id}")
async def get_standalone_asset(
    asset_id: str,
    authorization: str = Header(None)
):
    """
    Get a standalone asset by ID.
    """
    try:
        client = get_client()

        result = client.table("backlot_standalone_assets") \
            .select("*") \
            .eq("id", asset_id) \
            .single() \
            .execute()

        if not result.data:
            raise HTTPException(status_code=404, detail="Asset not found")

        return {"asset": result.data}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting standalone asset: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/assets/standalone/{asset_id}")
async def update_standalone_asset(
    asset_id: str,
    update_data: dict,
    authorization: str = Header(None)
):
    """
    Update a standalone asset.
    """
    try:
        client = get_client()

        allowed_fields = ["name", "description", "tags", "metadata", "folder_id"]
        filtered_data = {k: v for k, v in update_data.items() if k in allowed_fields}

        if not filtered_data:
            raise HTTPException(status_code=400, detail="No valid fields to update")

        result = client.table("backlot_standalone_assets") \
            .update(filtered_data) \
            .eq("id", asset_id) \
            .execute()

        if not result.data:
            raise HTTPException(status_code=404, detail="Asset not found")

        return {"asset": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating standalone asset: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/assets/standalone/{asset_id}")
async def delete_standalone_asset(
    asset_id: str,
    authorization: str = Header(None)
):
    """
    Delete a standalone asset.
    """
    try:
        client = get_client()

        # Get asset to find S3 key for cleanup
        asset = client.table("backlot_standalone_assets") \
            .select("s3_key") \
            .eq("id", asset_id) \
            .single() \
            .execute()

        if not asset.data:
            raise HTTPException(status_code=404, detail="Asset not found")

        # Delete from database
        client.table("backlot_standalone_assets") \
            .delete() \
            .eq("id", asset_id) \
            .execute()

        # Note: S3 cleanup could be done here or via a background job

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting standalone asset: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/assets/standalone/{asset_id}/upload-url")
async def get_standalone_asset_upload_url(
    asset_id: str,
    request: dict,
    authorization: str = Header(None)
):
    """
    Get a presigned URL to upload a standalone asset file.
    """
    try:
        filename = request.get("filename")
        content_type = request.get("content_type", "application/octet-stream")

        if not filename:
            raise HTTPException(status_code=400, detail="filename is required")

        # Generate S3 key
        project_id = request.get("project_id")

        # Org-level storage enforcement
        if project_id:
            _enforce_org_storage(project_id)

        s3_key = f"projects/{project_id}/assets/{asset_id}/{filename}"

        # Generate presigned URL
        s3_client = boto3.client("s3", region_name="us-east-1")
        bucket = os.environ.get("AWS_S3_BACKLOT_FILES_BUCKET", "swn-backlot-files-517220555400")

        presigned_url = s3_client.generate_presigned_url(
            "put_object",
            Params={
                "Bucket": bucket,
                "Key": s3_key,
                "ContentType": content_type,
            },
            ExpiresIn=3600  # 1 hour
        )

        return {
            "upload_url": presigned_url,
            "s3_key": s3_key,
            "expires_in": 3600
        }

    except Exception as e:
        print(f"Error generating upload URL: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ============================================================================
# GENERAL ASSET UPLOAD (BROWSER)
# ============================================================================

class AssetUploadRequest(BaseModel):
    """Request for browser-based asset upload of any file type"""
    filename: str
    content_type: str
    folder_id: Optional[str] = None


def _detect_asset_type(content_type: str, filename: str) -> str:
    """Detect asset type from content type and file extension."""
    ext = filename.rsplit('.', 1)[-1].lower() if '.' in filename else ''

    if content_type.startswith('video/') or ext in ('mp4', 'mov', 'avi', 'webm', 'mkv', 'mxf', 'r3d'):
        return 'video'
    if content_type.startswith('audio/') or ext in ('mp3', 'wav', 'aac', 'flac', 'ogg', 'm4a'):
        return 'audio'
    if content_type.startswith('image/') or ext in ('jpg', 'jpeg', 'png', 'gif', 'webp', 'tiff', 'tif', 'exr', 'dpx'):
        return 'image'
    if content_type == 'application/pdf' or content_type.startswith('text/') or ext in ('doc', 'docx', 'txt', 'rtf', 'pages', 'pdf'):
        return 'document'
    if ext in ('fbx', 'obj', 'gltf', 'glb', 'blend', 'usd', 'usdc', 'usdz', 'c4d', 'ma', 'mb'):
        return '3d_model'
    if ext in ('psd', 'ai', 'svg', 'eps', 'sketch', 'fig', 'xd'):
        return 'graphics'
    return 'other'


@router.post("/projects/{project_id}/assets/upload-url")
async def get_asset_upload_url(
    project_id: str,
    request: AssetUploadRequest,
    authorization: str = Header(None)
):
    """
    Get a presigned URL for browser-based asset upload of any file type.
    Creates a standalone asset record and returns a presigned PUT URL.
    """
    user = await get_current_user_from_token(authorization)
    client = get_client()

    try:
        await verify_project_access(client, project_id, user["id"], require_edit=True)
        await check_storage_quota(user["id"], 0)
        _enforce_org_storage(project_id)

        import boto3, uuid
        from botocore.config import Config

        asset_id = str(uuid.uuid4())
        s3_key = f"projects/{project_id}/assets/{asset_id}/{request.filename}"
        bucket_name = os.environ.get("AWS_S3_BACKLOT_FILES_BUCKET", "swn-backlot-files-517220555400")

        asset_type = _detect_asset_type(request.content_type, request.filename)
        asset_name = request.filename.rsplit('.', 1)[0] if '.' in request.filename else request.filename

        asset_data = {
            "id": asset_id,
            "project_id": project_id,
            "name": asset_name,
            "asset_type": asset_type,
            "file_name": request.filename,
            "s3_key": s3_key,
            "mime_type": request.content_type,
            "tags": [],
            "metadata": {},
            "created_by_user_id": user["id"],
        }

        if request.folder_id:
            asset_data["folder_id"] = request.folder_id

        client.table("backlot_standalone_assets").insert(asset_data).execute()

        s3_client = boto3.client('s3', region_name='us-east-1', config=Config(signature_version='s3v4'))
        upload_url = s3_client.generate_presigned_url(
            'put_object',
            Params={'Bucket': bucket_name, 'Key': s3_key, 'ContentType': request.content_type},
            ExpiresIn=3600,
        )

        return {
            "upload_url": upload_url,
            "s3_key": s3_key,
            "asset_id": asset_id,
            "expires_in": 3600,
        }
    except HTTPException:
        raise
    except Exception as e:
        print(f"Error generating asset upload URL: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ============================================================================
# ASSET FOLDERS CRUD
# ============================================================================

class AssetFolderInput(BaseModel):
    name: str
    folder_type: Optional[str] = None  # audio, 3d, graphics, documents, mixed
    parent_folder_id: Optional[str] = None


@router.get("/projects/{project_id}/assets/folders")
async def list_asset_folders(
    project_id: str,
    authorization: str = Header(None)
):
    """
    List asset folders for a project.
    """
    try:
        client = get_client()

        result = client.table("backlot_asset_folders") \
            .select("*") \
            .eq("project_id", project_id) \
            .order("sort_order") \
            .order("name") \
            .execute()

        # Build folder tree
        folders = result.data
        folder_map = {f["id"]: {**f, "children": []} for f in folders}

        root_folders = []
        for folder in folders:
            if folder["parent_folder_id"] and folder["parent_folder_id"] in folder_map:
                folder_map[folder["parent_folder_id"]]["children"].append(folder_map[folder["id"]])
            else:
                root_folders.append(folder_map[folder["id"]])

        return {"folders": root_folders}

    except Exception as e:
        print(f"Error listing asset folders: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/assets/folders")
async def create_asset_folder(
    project_id: str,
    folder_input: AssetFolderInput,
    authorization: str = Header(None)
):
    """
    Create a new asset folder.
    """
    try:
        client = get_client()

        insert_data = {
            "project_id": project_id,
            "name": folder_input.name,
            "folder_type": folder_input.folder_type,
            "parent_folder_id": folder_input.parent_folder_id,
            "created_by_user_id": user["id"],
        }

        result = client.table("backlot_asset_folders").insert(insert_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create folder")

        return {"folder": result.data[0]}

    except Exception as e:
        print(f"Error creating asset folder: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/assets/folders/{folder_id}")
async def update_asset_folder(
    folder_id: str,
    update_data: dict,
    authorization: str = Header(None)
):
    """
    Update an asset folder.
    """
    try:
        client = get_client()

        allowed_fields = ["name", "folder_type", "parent_folder_id", "sort_order"]
        filtered_data = {k: v for k, v in update_data.items() if k in allowed_fields}

        if not filtered_data:
            raise HTTPException(status_code=400, detail="No valid fields to update")

        result = client.table("backlot_asset_folders") \
            .update(filtered_data) \
            .eq("id", folder_id) \
            .execute()

        if not result.data:
            raise HTTPException(status_code=404, detail="Folder not found")

        return {"folder": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating asset folder: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/assets/folders/{folder_id}")
async def delete_asset_folder(
    folder_id: str,
    authorization: str = Header(None)
):
    """
    Delete an asset folder. Assets inside will have their folder_id set to null.
    """
    try:
        client = get_client()

        # Get folder to check it exists
        folder = client.table("backlot_asset_folders") \
            .select("id, parent_folder_id") \
            .eq("id", folder_id) \
            .single() \
            .execute()

        if not folder.data:
            raise HTTPException(status_code=404, detail="Folder not found")

        # Move child folders to parent
        client.table("backlot_asset_folders") \
            .update({"parent_folder_id": folder.data["parent_folder_id"]}) \
            .eq("parent_folder_id", folder_id) \
            .execute()

        # Move assets to parent folder
        client.table("backlot_standalone_assets") \
            .update({"folder_id": folder.data["parent_folder_id"]}) \
            .eq("folder_id", folder_id) \
            .execute()

        # Delete folder
        client.table("backlot_asset_folders") \
            .delete() \
            .eq("id", folder_id) \
            .execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting asset folder: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ============================================================================
# Desktop API Key Endpoints - Review Tab
# ============================================================================

@router.get("/desktop-keys/projects/{project_id}/review/folders")
async def get_review_folders_for_desktop(
    project_id: str,
    x_api_key: str = Header(None, alias="X-API-Key")
):
    """Get review folders for a project using desktop API key authentication."""
    try:
        await verify_desktop_key_and_project_access(x_api_key, project_id)
        client = get_client()

        result = client.table("backlot_review_folders").select("*").eq(
            "project_id", project_id
        ).order("sort_order").order("name").execute()

        return {"folders": result.data or []}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting review folders for desktop: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/desktop-keys/projects/{project_id}/review/folders")
async def create_review_folder_for_desktop(
    project_id: str,
    request: dict,
    x_api_key: str = Header(None, alias="X-API-Key")
):
    """Create review folder using desktop API key authentication."""
    try:
        user_id = await verify_desktop_key_and_project_access(x_api_key, project_id)
        client = get_client()

        folder_id = str(uuid.uuid4())
        name = request.get("name", "New Folder")
        description = request.get("description")
        color = request.get("color")
        parent_folder_id = request.get("parent_folder_id")

        # Validate parent folder if specified
        if parent_folder_id:
            parent_resp = client.table("backlot_review_folders").select("id").eq(
                "id", parent_folder_id
            ).eq("project_id", project_id).execute()
            if not parent_resp.data:
                raise HTTPException(status_code=404, detail="Parent folder not found")

        # Get max sort_order for this level
        sort_query = client.table("backlot_review_folders").select("sort_order").eq(
            "project_id", project_id
        )
        if parent_folder_id:
            sort_query = sort_query.eq("parent_folder_id", parent_folder_id)
        else:
            sort_query = sort_query.is_("parent_folder_id", "null")
        sort_resp = sort_query.order("sort_order", desc=True).limit(1).execute()
        max_sort = (sort_resp.data[0]["sort_order"] if sort_resp.data else 0) + 1

        folder_data = {
            "id": folder_id,
            "project_id": project_id,
            "name": name,
            "description": description,
            "color": color,
            "parent_folder_id": parent_folder_id,
            "sort_order": max_sort,
            "created_by_user_id": user_id
        }

        result = client.table("backlot_review_folders").insert(folder_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create folder")

        return {"folder": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating review folder for desktop: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/desktop-keys/projects/{project_id}/review/assets")
async def get_review_assets_for_desktop(
    project_id: str,
    folder_id: Optional[str] = Query(None),
    x_api_key: str = Header(None, alias="X-API-Key")
):
    """Get review assets for a project using desktop API key authentication."""
    try:
        await verify_desktop_key_and_project_access(x_api_key, project_id)
        client = get_client()

        query = client.table("backlot_review_assets").select(
            "*, active_version:backlot_review_versions!active_version_id(*)"
        ).eq("project_id", project_id)

        if folder_id:
            query = query.eq("folder_id", folder_id)

        result = query.order("created_at", desc=True).execute()

        return {"assets": result.data or []}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting review assets for desktop: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/desktop-keys/projects/{project_id}/review/assets")
async def create_review_asset_for_desktop(
    project_id: str,
    request: dict,
    x_api_key: str = Header(None, alias="X-API-Key")
):
    """Create a review asset using desktop API key authentication."""
    try:
        user_id = await verify_desktop_key_and_project_access(x_api_key, project_id)
        client = get_client()

        asset_data = {
            "project_id": project_id,
            "name": request.get("name", "Untitled"),
            "description": request.get("description", ""),
            "status": "draft",
            "uploaded_by": user_id,
        }

        if request.get("folder_id"):
            asset_data["folder_id"] = request["folder_id"]

        result = client.table("backlot_review_assets").insert(asset_data).execute()

        if result.data:
            return {"asset": result.data[0]}
        raise HTTPException(status_code=500, detail="Failed to create asset")

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating review asset for desktop: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/desktop-keys/review/assets/{asset_id}/versions/upload-url")
async def get_review_upload_url_for_desktop(
    asset_id: str,
    request: dict,
    x_api_key: str = Header(None, alias="X-API-Key")
):
    """Get presigned upload URL for a review version using desktop API key."""
    try:
        # Verify key and get user
        key_result = await verify_desktop_key(x_api_key)
        user_id = key_result["user_id"]
        client = get_client()

        # Verify asset exists and user has access
        asset = client.table("backlot_review_assets").select(
            "*, project:backlot_projects(id)"
        ).eq("id", asset_id).single().execute()

        if not asset.data:
            raise HTTPException(status_code=404, detail="Asset not found")

        project_id = asset.data["project_id"]

        # Verify project access
        await verify_desktop_key_and_project_access(x_api_key, project_id)

        # Org-level storage enforcement
        _enforce_org_storage(project_id)

        # Create version record
        filename = request.get("filename", "upload")
        content_type = request.get("content_type", "video/mp4")
        storage_mode = request.get("storage_mode", "s3")

        version_data = {
            "asset_id": asset_id,
            "version_number": 1,  # Will be updated
            "file_url": "",
            "storage_mode": storage_mode,
            "original_filename": filename,
            "transcode_status": "pending",
            "uploaded_by": user_id,
        }

        # Get next version number
        versions = client.table("backlot_review_versions").select("version_number").eq(
            "asset_id", asset_id
        ).order("version_number", desc=True).limit(1).execute()

        if versions.data:
            version_data["version_number"] = versions.data[0]["version_number"] + 1

        # Create standalone asset  single source of truth for the file
        import uuid
        version_id = str(uuid.uuid4())
        standalone_asset_id = str(uuid.uuid4())
        s3_key = f"projects/{project_id}/assets/{standalone_asset_id}/{filename}"

        # Create standalone asset record
        file_ext = filename.rsplit('.', 1)[-1].lower() if '.' in filename else ''
        is_video = content_type.startswith('video/') or file_ext in ('mp4', 'mov', 'avi', 'webm', 'mkv')
        asset_name = filename.rsplit('.', 1)[0] if '.' in filename else filename
        standalone_data = {
            "id": standalone_asset_id,
            "project_id": project_id,
            "name": asset_name,
            "asset_type": "video" if is_video else "other",
            "file_name": filename,
            "s3_key": s3_key,
            "mime_type": content_type,
            "tags": [],
            "metadata": {},
            "created_by_user_id": user_id,
        }
        client.table("backlot_standalone_assets").insert(standalone_data).execute()

        version_data["id"] = version_id
        version_data["s3_key"] = s3_key
        version_data["linked_standalone_asset_id"] = standalone_asset_id

        # Create version record
        result = client.table("backlot_review_versions").insert(version_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create version")

        # Set active_version_id on asset if not already set, and link standalone asset
        asset_record = client.table("backlot_review_assets").select("active_version_id").eq("id", asset_id).single().execute()
        update_asset = {"linked_standalone_asset_id": standalone_asset_id}
        if asset_record.data and not asset_record.data.get("active_version_id"):
            update_asset["active_version_id"] = version_id
        client.table("backlot_review_assets").update(update_asset).eq("id", asset_id).execute()

        # Generate presigned URL  use files bucket
        import boto3
        s3_client = boto3.client("s3", region_name="us-east-1")
        bucket = os.environ.get("AWS_S3_BACKLOT_FILES_BUCKET", "swn-backlot-files-517220555400")

        upload_url = s3_client.generate_presigned_url(
            "put_object",
            Params={
                "Bucket": bucket,
                "Key": s3_key,
                "ContentType": content_type,
            },
            ExpiresIn=3600,
        )

        return {
            "upload_url": upload_url,
            "version_id": version_id,
            "s3_key": s3_key,
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting review upload URL for desktop: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/desktop-keys/review/versions/{version_id}/complete-upload")
async def complete_review_upload_for_desktop(
    version_id: str,
    request: dict,
    x_api_key: str = Header(None, alias="X-API-Key")
):
    """Complete a review version upload and trigger transcoding."""
    try:
        # Verify key
        await verify_desktop_key(x_api_key)
        client = get_client()

        # Get version and verify access
        version = client.table("backlot_review_versions").select("*").eq("id", version_id).single().execute()

        if not version.data:
            raise HTTPException(status_code=404, detail="Version not found")

        # Get asset to find project_id
        asset = client.table("backlot_review_assets").select("project_id").eq("id", version.data["asset_id"]).single().execute()
        if not asset.data:
            raise HTTPException(status_code=404, detail="Asset not found")

        project_id = asset.data["project_id"]
        await verify_desktop_key_and_project_access(x_api_key, project_id)

        # Update version with file info
        update_data = {
            "file_size_bytes": request.get("file_size_bytes"),
            "transcode_status": "pending",
        }

        if request.get("checksum"):
            update_data["checksum"] = request["checksum"]

        client.table("backlot_review_versions").update(update_data).eq(
            "id", version_id
        ).execute()

        # Set as active version
        client.table("backlot_review_assets").update({
            "active_version_id": version_id
        }).eq("id", version.data["asset_id"]).execute()

        # TODO: Trigger transcoding Lambda

        return {"success": True, "version_id": version_id}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error completing review upload for desktop: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ============================================================================
# Desktop API Key Endpoints - Assets Tab
# ============================================================================

@router.get("/desktop-keys/projects/{project_id}/assets/folders")
async def get_asset_folders_for_desktop(
    project_id: str,
    x_api_key: str = Header(None, alias="X-API-Key")
):
    """Get asset folders for a project using desktop API key authentication."""
    try:
        await verify_desktop_key_and_project_access(x_api_key, project_id)
        client = get_client()

        result = client.table("backlot_asset_folders").select("*").eq(
            "project_id", project_id
        ).order("sort_order").order("name").execute()

        return {"folders": result.data or []}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting asset folders for desktop: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/desktop-keys/projects/{project_id}/assets/folders")
async def create_asset_folder_for_desktop(
    project_id: str,
    folder_input: AssetFolderInput,
    x_api_key: str = Header(None, alias="X-API-Key")
):
    """Create asset folder using desktop API key authentication."""
    try:
        user_id = await verify_desktop_key_and_project_access(x_api_key, project_id)
        client = get_client()

        insert_data = {
            "project_id": project_id,
            "name": folder_input.name,
            "folder_type": folder_input.folder_type,
            "parent_folder_id": folder_input.parent_folder_id,
            "created_by_user_id": user_id,
        }

        result = client.table("backlot_asset_folders").insert(insert_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create folder")

        return {"folder": result.data[0]}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating asset folder for desktop: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/desktop-keys/projects/{project_id}/assets")
async def get_assets_for_desktop(
    project_id: str,
    folder_id: Optional[str] = Query(None),
    asset_type: Optional[str] = Query(None),
    x_api_key: str = Header(None, alias="X-API-Key")
):
    """Get standalone assets for a project using desktop API key authentication."""
    try:
        await verify_desktop_key_and_project_access(x_api_key, project_id)
        client = get_client()

        query = client.table("backlot_standalone_assets").select("*").eq(
            "project_id", project_id
        )

        if folder_id:
            query = query.eq("folder_id", folder_id)
        if asset_type:
            query = query.eq("asset_type", asset_type)

        result = query.order("created_at", desc=True).execute()

        return {"assets": result.data or []}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting assets for desktop: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/desktop-keys/projects/{project_id}/assets/upload-url")
async def get_asset_upload_url_for_desktop(
    project_id: str,
    request: dict,
    x_api_key: str = Header(None, alias="X-API-Key")
):
    """Get presigned upload URL for a standalone asset."""
    try:
        user_id = await verify_desktop_key_and_project_access(x_api_key, project_id)
        client = get_client()

        # Org-level storage enforcement
        _enforce_org_storage(project_id)

        filename = request.get("filename", "upload")
        content_type = request.get("content_type", "application/octet-stream")
        asset_type = request.get("asset_type", "other")
        name = request.get("name", filename)
        folder_id = request.get("folder_id")

        # Create asset record
        import uuid
        asset_id = str(uuid.uuid4())
        s3_key = f"projects/{project_id}/assets/{asset_id}/{filename}"

        asset_data = {
            "id": asset_id,
            "project_id": project_id,
            "name": name,
            "asset_type": asset_type,
            "file_name": filename,
            "s3_key": s3_key,
            "mime_type": content_type,
            "created_by_user_id": user_id,
        }

        if folder_id:
            asset_data["folder_id"] = folder_id

        result = client.table("backlot_standalone_assets").insert(asset_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create asset")

        # Generate presigned URL  files bucket
        import boto3
        s3_client = boto3.client("s3", region_name="us-east-1")
        bucket = os.environ.get("AWS_S3_BACKLOT_FILES_BUCKET", "swn-backlot-files-517220555400")

        upload_url = s3_client.generate_presigned_url(
            "put_object",
            Params={
                "Bucket": bucket,
                "Key": s3_key,
                "ContentType": content_type,
            },
            ExpiresIn=3600,
        )

        return {
            "upload_url": upload_url,
            "asset_id": asset_id,
            "s3_key": s3_key,
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting asset upload URL for desktop: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/desktop-keys/assets/{asset_id}/complete-upload")
async def complete_asset_upload_for_desktop(
    asset_id: str,
    request: dict,
    x_api_key: str = Header(None, alias="X-API-Key")
):
    """Complete a standalone asset upload."""
    try:
        await verify_desktop_key(x_api_key)
        client = get_client()

        # Get asset and verify access
        asset = client.table("backlot_standalone_assets").select("*").eq(
            "id", asset_id
        ).single().execute()

        if not asset.data:
            raise HTTPException(status_code=404, detail="Asset not found")

        await verify_desktop_key_and_project_access(x_api_key, asset.data["project_id"])

        # Update asset with file info
        update_data = {
            "file_size_bytes": request.get("file_size_bytes"),
        }

        if request.get("checksum"):
            update_data["checksum"] = request["checksum"]
        if request.get("duration_seconds"):
            update_data["duration_seconds"] = request["duration_seconds"]
        if request.get("dimensions"):
            update_data["dimensions"] = request["dimensions"]

        client.table("backlot_standalone_assets").update(update_data).eq(
            "id", asset_id
        ).execute()

        return {"success": True, "asset_id": asset_id}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error completing asset upload for desktop: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/desktop-keys/assets/{asset_id}/link-to-dailies")
async def link_asset_to_dailies(
    asset_id: str,
    request: dict,
    x_api_key: str = Header(None, alias="X-API-Key")
):
    """
    Link a standalone asset to the Dailies system.
    Creates a dailies clip entry that references the asset's S3 URL.
    """
    try:
        await verify_desktop_key(x_api_key)
        client = get_client()

        # Get asset details
        asset = client.table("backlot_standalone_assets").select("*").eq(
            "id", asset_id
        ).single().execute()

        if not asset.data:
            raise HTTPException(status_code=404, detail="Asset not found")

        asset_data = asset.data
        project_id = asset_data["project_id"]
        await verify_desktop_key_and_project_access(x_api_key, project_id)

        # Build S3 URL from key  files bucket
        bucket = os.environ.get("AWS_S3_BACKLOT_FILES_BUCKET", "swn-backlot-files-517220555400")
        s3_url = f"https://{bucket}.s3.amazonaws.com/{asset_data['s3_key']}"

        # Create dailies clip entry in backlot_dailies_clips
        clip_data = {
            "project_id": project_id,
            "file_name": asset_data["file_name"],
            "cloud_url": s3_url,
            "storage_mode": "cloud",
            "upload_status": "completed",
            "camera_label": request.get("camera", "A"),
            "file_size_bytes": asset_data.get("file_size_bytes"),
            "linked_standalone_asset_id": asset_id,
        }

        if asset_data.get("duration_seconds"):
            clip_data["duration_seconds"] = float(asset_data["duration_seconds"])

        result = client.table("backlot_dailies_clips").insert(clip_data).execute()

        if not result.data:
            raise HTTPException(status_code=500, detail="Failed to create dailies link")

        return {
            "success": True,
            "dailies_clip_id": result.data[0]["id"],
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error linking asset to dailies: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/desktop-keys/assets/{asset_id}/link-to-review")
async def link_asset_to_review(
    asset_id: str,
    request: dict,
    x_api_key: str = Header(None, alias="X-API-Key")
):
    """
    Link a standalone asset to the Review system.
    Creates a review asset and version that references the asset's S3 URL.
    """
    try:
        await verify_desktop_key(x_api_key)
        client = get_client()

        # Get asset details
        asset = client.table("backlot_standalone_assets").select("*").eq(
            "id", asset_id
        ).single().execute()

        if not asset.data:
            raise HTTPException(status_code=404, detail="Asset not found")

        asset_data = asset.data
        project_id = asset_data["project_id"]
        await verify_desktop_key_and_project_access(x_api_key, project_id)

        # Get folder_id if specified
        folder_id = request.get("folder_id")

        # Build S3 URL from key  files bucket
        bucket = os.environ.get("AWS_S3_BACKLOT_FILES_BUCKET", "swn-backlot-files-517220555400")
        s3_url = f"https://{bucket}.s3.amazonaws.com/{asset_data['s3_key']}"

        # Create review asset
        review_asset_data = {
            "project_id": project_id,
            "folder_id": folder_id,
            "name": asset_data["name"],
            "status": "draft",
            "linked_standalone_asset_id": asset_id,
        }

        asset_result = client.table("backlot_review_assets").insert(review_asset_data).execute()

        if not asset_result.data:
            raise HTTPException(status_code=500, detail="Failed to create review asset")

        review_asset_id = asset_result.data[0]["id"]

        # Create review version
        version_data = {
            "asset_id": review_asset_id,
            "version_number": 1,
            "file_url": "",
            "storage_mode": "s3",
            "s3_key": asset_data["s3_key"],
            "cloud_url": s3_url,
            "original_filename": asset_data["file_name"],
            "file_size_bytes": asset_data.get("file_size_bytes"),
            "transcode_status": "completed",  # Already in usable format
            "linked_standalone_asset_id": asset_id,
        }

        version_result = client.table("backlot_review_versions").insert(version_data).execute()

        if not version_result.data:
            raise HTTPException(status_code=500, detail="Failed to create review version")

        return {
            "success": True,
            "review_asset_id": review_asset_id,
            "review_version_id": version_result.data[0]["id"],
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error linking asset to review: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Document Packages & Crew Onboarding
# =====================================================

class DocumentPackageItemInput(BaseModel):
    """Input for a document package item"""
    clearance_type: str
    template_id: Optional[str] = None
    is_required: bool = True
    sort_order: int = 0
    custom_title: Optional[str] = None
    custom_description: Optional[str] = None


class DocumentPackageInput(BaseModel):
    """Input for creating/updating a document package"""
    name: str
    description: Optional[str] = None
    target_type: str = "all"  # cast, crew, all
    items: Optional[List[DocumentPackageItemInput]] = None


class SendPackageInput(BaseModel):
    """Input for sending a package to recipients"""
    package_id: str
    recipient_user_ids: List[str]
    due_date: Optional[str] = None
    notes: Optional[str] = None


@router.get("/projects/{project_id}/document-packages")
async def get_document_packages(
    project_id: str,
    authorization: str = Header(None)
):
    """Get all document packages for a project"""
    try:
        user = await get_user_from_token(authorization)
        client = get_client()

        # Get packages for this project (including org-wide packages with null project_id)
        result = client.table("backlot_document_packages").select(
            "*, backlot_document_package_items(*)"
        ).or_(
            f"project_id.eq.{project_id},project_id.is.null"
        ).eq("is_active", True).order("created_at", desc=True).execute()

        return {"packages": result.data or []}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting document packages: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/document-packages")
async def create_document_package(
    project_id: str,
    input: DocumentPackageInput,
    authorization: str = Header(None)
):
    """Create a new document package"""
    try:
        user = await get_user_from_token(authorization)
        client = get_client()

        # Create the package
        package_data = {
            "project_id": project_id,
            "owner_user_id": user["id"],
            "name": input.name,
            "description": input.description,
            "target_type": input.target_type,
            "is_active": True,
        }

        result = client.table("backlot_document_packages").insert(
            package_data
        ).execute()

        package = result.data[0]

        # Create package items if provided
        if input.items:
            items_data = []
            for idx, item in enumerate(input.items):
                items_data.append({
                    "package_id": package["id"],
                    "clearance_type": item.clearance_type,
                    "template_id": item.template_id,
                    "is_required": item.is_required,
                    "sort_order": item.sort_order if item.sort_order else idx,
                    "custom_title": item.custom_title,
                    "custom_description": item.custom_description,
                })

            client.table("backlot_document_package_items").insert(
                items_data
            ).execute()

            # Fetch updated package with items
            result = client.table("backlot_document_packages").select(
                "*, backlot_document_package_items(*)"
            ).eq("id", package["id"]).single().execute()
            package = result.data

        return {"package": package}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating document package: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/document-packages/{package_id}")
async def get_document_package(
    package_id: str,
    authorization: str = Header(None)
):
    """Get a single document package with items"""
    try:
        user = await get_user_from_token(authorization)
        client = get_client()

        result = client.table("backlot_document_packages").select(
            "*, backlot_document_package_items(*)"
        ).eq("id", package_id).single().execute()

        if not result.data:
            raise HTTPException(status_code=404, detail="Package not found")

        return {"package": result.data}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting document package: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/document-packages/{package_id}")
async def update_document_package(
    package_id: str,
    input: DocumentPackageInput,
    authorization: str = Header(None)
):
    """Update a document package"""
    try:
        user = await get_user_from_token(authorization)
        client = get_client()

        # Update package
        update_data = {
            "name": input.name,
            "description": input.description,
            "target_type": input.target_type,
            "updated_at": datetime.now(timezone.utc).isoformat(),
        }

        client.table("backlot_document_packages").update(
            update_data
        ).eq("id", package_id).execute()

        # Replace items if provided
        if input.items is not None:
            # Delete existing items
            client.table("backlot_document_package_items").delete().eq(
                "package_id", package_id
            ).execute()

            # Insert new items
            if input.items:
                items_data = []
                for idx, item in enumerate(input.items):
                    items_data.append({
                        "package_id": package_id,
                        "clearance_type": item.clearance_type,
                        "template_id": item.template_id,
                        "is_required": item.is_required,
                        "sort_order": item.sort_order if item.sort_order else idx,
                        "custom_title": item.custom_title,
                        "custom_description": item.custom_description,
                    })

                client.table("backlot_document_package_items").insert(
                    items_data
                ).execute()

        # Fetch updated package
        result = client.table("backlot_document_packages").select(
            "*, backlot_document_package_items(*)"
        ).eq("id", package_id).single().execute()

        return {"package": result.data}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating document package: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/document-packages/{package_id}")
async def delete_document_package(
    package_id: str,
    authorization: str = Header(None)
):
    """Delete a document package (soft delete)"""
    try:
        user = await get_user_from_token(authorization)
        client = get_client()

        # Soft delete by setting is_active to false
        client.table("backlot_document_packages").update({
            "is_active": False,
            "updated_at": datetime.now(timezone.utc).isoformat(),
        }).eq("id", package_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting document package: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/send-package")
async def send_document_package(
    project_id: str,
    input: SendPackageInput,
    authorization: str = Header(None)
):
    """Send a document package to one or more recipients"""
    try:
        user = await get_user_from_token(authorization)
        client = get_client()

        # Get the package with items
        package_result = client.table("backlot_document_packages").select(
            "*, backlot_document_package_items(*)"
        ).eq("id", input.package_id).single().execute()

        if not package_result.data:
            raise HTTPException(status_code=404, detail="Package not found")

        package = package_result.data
        items = package.get("backlot_document_package_items", [])

        if not items:
            raise HTTPException(status_code=400, detail="Package has no documents")

        assignments_created = 0
        clearances_created = 0

        # Create an assignment for each recipient
        for recipient_id in input.recipient_user_ids:
            # Create package assignment
            assignment_data = {
                "package_id": input.package_id,
                "project_id": project_id,
                "assigned_to_user_id": recipient_id,
                "assigned_by_user_id": user["id"],
                "due_date": input.due_date,
                "notes": input.notes,
                "status": "pending",
            }

            assignment_result = client.table("backlot_document_package_assignments").insert(
                assignment_data
            ).execute()

            assignment = assignment_result.data[0]
            assignments_created += 1

            # Get recipient info for clearance creation
            recipient = client.table("profiles").select(
                "id, full_name, email"
            ).eq("id", recipient_id).single().execute()

            recipient_name = recipient.data.get("full_name", "Unknown") if recipient.data else "Unknown"
            recipient_email = recipient.data.get("email") if recipient.data else None

            # Create a clearance for each item in the package
            for item in items:
                # Create the clearance item
                clearance_data = {
                    "project_id": project_id,
                    "type": item["clearance_type"],
                    "title": item.get("custom_title") or f"{item['clearance_type'].replace('_', ' ').title()} - {recipient_name}",
                    "status": "requested",
                    "priority": "medium",
                    "related_person_id": recipient_id,
                    "related_person_name": recipient_name,
                    "created_by": user["id"],
                    "template_id": item.get("template_id"),
                    "batch_sign_allowed": True,
                }

                clearance_result = client.table("backlot_clearance_items").insert(
                    clearance_data
                ).execute()

                clearance = clearance_result.data[0]
                clearances_created += 1

                # Create the assignment item linking to the clearance
                assignment_item_data = {
                    "assignment_id": assignment["id"],
                    "package_item_id": item["id"],
                    "clearance_id": clearance["id"],
                    "status": "not_started",
                    "is_required": item.get("is_required", True),
                }

                client.table("backlot_document_package_assignment_items").insert(
                    assignment_item_data
                ).execute()

                # Update clearance with the assignment item ID
                client.table("backlot_clearance_items").update({
                    "package_assignment_item_id": assignment_item_data.get("id")
                }).eq("id", clearance["id"]).execute()

                # Create a recipient record for the clearance
                if recipient_email:
                    access_token = secrets.token_urlsafe(32)
                    recipient_data = {
                        "clearance_id": clearance["id"],
                        "user_id": recipient_id,
                        "email": recipient_email,
                        "name": recipient_name,
                        "status": "pending",
                        "access_token": access_token,
                    }

                    client.table("backlot_clearance_recipients").insert(
                        recipient_data
                    ).execute()

        # Increment package use count
        client.table("backlot_document_packages").update({
            "use_count": package.get("use_count", 0) + len(input.recipient_user_ids),
            "updated_at": datetime.now(timezone.utc).isoformat(),
        }).eq("id", input.package_id).execute()

        return {
            "success": True,
            "assignments_created": assignments_created,
            "clearances_created": clearances_created,
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error sending document package: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/package-assignments")
async def get_package_assignments(
    project_id: str,
    user_id: Optional[str] = None,
    authorization: str = Header(None)
):
    """Get package assignments for a project, optionally filtered by user"""
    try:
        user = await get_user_from_token(authorization)
        client = get_client()

        query = client.table("backlot_document_package_assignments").select(
            "*, backlot_document_packages(name, description), backlot_document_package_assignment_items(*, backlot_clearance_items(id, title, status, type))"
        ).eq("project_id", project_id)

        if user_id:
            query = query.eq("assigned_to_user_id", user_id)

        result = query.order("created_at", desc=True).execute()

        return {"assignments": result.data or []}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting package assignments: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch("/projects/{project_id}/package-assignments/{assignment_id}")
async def update_package_assignment(
    project_id: str,
    assignment_id: str,
    input: dict,
    authorization: str = Header(None)
):
    """Update a package assignment (e.g., cancel it)"""
    try:
        user = await get_user_from_token(authorization)
        client = get_client()

        update_data = {"updated_at": datetime.now(timezone.utc).isoformat()}

        if "status" in input:
            update_data["status"] = input["status"]
            if input["status"] == "cancelled":
                update_data["completed_at"] = None
            elif input["status"] == "completed":
                update_data["completed_at"] = datetime.now(timezone.utc).isoformat()

        client.table("backlot_document_package_assignments").update(
            update_data
        ).eq("id", assignment_id).eq("project_id", project_id).execute()

        return {"success": True}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating package assignment: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Signing Portal & Pending Documents
# =====================================================

@router.get("/users/me/pending-documents")
async def get_my_pending_documents(
    authorization: str = Header(None)
):
    """Get all pending documents for the current user across all projects"""
    try:
        user = await get_user_from_token(authorization)
        client = get_client()

        # Get clearance recipients where this user is the recipient and status is pending
        result = client.table("backlot_clearance_recipients").select(
            "*, backlot_clearance_items(id, title, type, status, file_url, project_id, batch_sign_allowed, backlot_projects(id, title))"
        ).eq("user_id", user["id"]).in_(
            "status", ["pending", "viewed"]
        ).execute()

        documents = []
        for recipient in result.data or []:
            clearance = recipient.get("backlot_clearance_items")
            if not clearance:
                continue

            project = clearance.get("backlot_projects", {})

            documents.append({
                "clearance_id": clearance["id"],
                "clearance_title": clearance.get("title", "Untitled"),
                "clearance_type": clearance.get("type", "other"),
                "project_id": clearance.get("project_id"),
                "project_title": project.get("title", "Unknown Project") if project else "Unknown Project",
                "recipient_id": recipient["id"],
                "requires_signature": True,
                "batch_sign_allowed": clearance.get("batch_sign_allowed", True),
                "file_url": clearance.get("file_url"),
                "access_token": recipient.get("access_token"),
                "due_date": recipient.get("due_date"),
            })

        return {"documents": documents}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting pending documents: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/users/me/clearances/history")
async def get_my_clearance_history(
    authorization: str = Header(None)
):
    """Get signed document history for the current user"""
    try:
        user = await get_user_from_token(authorization)
        client = get_client()

        # Get clearance recipients where this user signed
        result = client.table("backlot_clearance_recipients").select(
            "*, backlot_clearance_items(id, title, type, status, file_url, project_id, signed_at, backlot_projects(id, title))"
        ).eq("user_id", user["id"]).eq("status", "signed").order(
            "signed_at", desc=True
        ).execute()

        documents = []
        for recipient in result.data or []:
            clearance = recipient.get("backlot_clearance_items")
            if not clearance:
                continue

            project = clearance.get("backlot_projects", {})

            documents.append({
                "clearance_id": clearance["id"],
                "clearance_title": clearance.get("title", "Untitled"),
                "clearance_type": clearance.get("type", "other"),
                "project_id": clearance.get("project_id"),
                "project_title": project.get("title", "Unknown Project") if project else "Unknown Project",
                "signed_at": recipient.get("signed_at"),
                "signed_by_name": recipient.get("signed_by_name"),
                "file_url": clearance.get("file_url"),
            })

        return {"documents": documents}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting clearance history: {e}")
        raise HTTPException(status_code=500, detail=str(e))


class BatchSignInput(BaseModel):
    """Input for batch signing multiple documents"""
    clearance_ids: List[str]
    recipient_ids: List[str]
    signature_data: str
    signed_by_name: str


@router.post("/clearances/batch-sign")
async def batch_sign_clearances(
    input: BatchSignInput,
    request: Request,
    authorization: str = Header(None)
):
    """Sign multiple documents at once with a single signature"""
    try:
        user = await get_user_from_token(authorization)
        client = get_client()

        if len(input.clearance_ids) != len(input.recipient_ids):
            raise HTTPException(
                status_code=400,
                detail="clearance_ids and recipient_ids must have the same length"
            )

        # Get client IP for audit
        client_ip = request.client.host if request.client else None

        documents_signed = 0
        now = datetime.now(timezone.utc).isoformat()

        # Create batch sign session for audit trail
        session_data = {
            "user_id": user["id"],
            "signature_data": input.signature_data,
            "signature_ip": client_ip,
            "recipient_ids": input.recipient_ids,
            "clearance_ids": input.clearance_ids,
            "documents_signed": 0,
        }

        session_result = client.table("backlot_batch_sign_sessions").insert(
            session_data
        ).execute()

        session_id = session_result.data[0]["id"]

        # Sign each document
        for clearance_id, recipient_id in zip(input.clearance_ids, input.recipient_ids):
            # Verify the recipient belongs to this user
            recipient_check = client.table("backlot_clearance_recipients").select(
                "id, user_id, clearance_id"
            ).eq("id", recipient_id).single().execute()

            if not recipient_check.data:
                continue

            if recipient_check.data.get("user_id") != user["id"]:
                continue

            # Update the recipient record
            client.table("backlot_clearance_recipients").update({
                "status": "signed",
                "signed_at": now,
                "signed_by_name": input.signed_by_name,
                "signature_data": input.signature_data,
                "signature_ip": client_ip,
            }).eq("id", recipient_id).execute()

            # Update the clearance item status
            client.table("backlot_clearance_items").update({
                "status": "signed",
                "signed_at": now,
                "updated_at": now,
            }).eq("id", clearance_id).execute()

            documents_signed += 1

        # Update session with count
        client.table("backlot_batch_sign_sessions").update({
            "documents_signed": documents_signed,
        }).eq("id", session_id).execute()

        return {
            "success": True,
            "documents_signed": documents_signed,
            "session_id": session_id,
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error batch signing clearances: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Clearance Approval Workflow
# =====================================================

class ConfigureApprovalInput(BaseModel):
    """Input for configuring approval requirements"""
    requires_approval: bool = True
    approver_user_id: Optional[str] = None
    approver_role: Optional[str] = None


class ApprovalActionInput(BaseModel):
    """Input for approval actions"""
    notes: Optional[str] = None


@router.get("/clearances/{clearance_id}/approval")
async def get_clearance_approval(
    clearance_id: str,
    authorization: str = Header(None)
):
    """Get approval status for a clearance"""
    try:
        user = await get_user_from_token(authorization)
        client = get_client()

        result = client.table("backlot_clearance_approvals").select(
            "*, profiles!approver_user_id(id, full_name), approved_by_profile:profiles!approved_by_user_id(id, full_name)"
        ).eq("clearance_id", clearance_id).single().execute()

        if not result.data:
            raise HTTPException(status_code=404, detail="No approval configured")

        approval = result.data
        # Add approver name from profile
        approver = approval.pop("profiles", None)
        approved_by = approval.pop("approved_by_profile", None)

        if approver:
            approval["approver_name"] = approver.get("full_name")
        if approved_by:
            approval["approved_by_name"] = approved_by.get("full_name")

        return {"approval": approval}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting clearance approval: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/clearances/{clearance_id}/approval/configure")
async def configure_clearance_approval(
    clearance_id: str,
    input: ConfigureApprovalInput,
    authorization: str = Header(None)
):
    """Configure approval requirements for a clearance"""
    try:
        user = await get_user_from_token(authorization)
        client = get_client()

        # Check if approval record exists
        existing = client.table("backlot_clearance_approvals").select(
            "id"
        ).eq("clearance_id", clearance_id).execute()

        approval_data = {
            "clearance_id": clearance_id,
            "requires_approval": input.requires_approval,
            "approver_user_id": input.approver_user_id,
            "approver_role": input.approver_role,
            "approval_status": "pending_approval" if input.requires_approval else "not_required",
            "updated_at": datetime.now(timezone.utc).isoformat(),
        }

        if existing.data:
            # Update existing
            result = client.table("backlot_clearance_approvals").update(
                approval_data
            ).eq("clearance_id", clearance_id).execute()
        else:
            # Create new
            result = client.table("backlot_clearance_approvals").insert(
                approval_data
            ).execute()

        return {"approval": result.data[0] if result.data else approval_data}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error configuring clearance approval: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/clearances/{clearance_id}/approval/approve")
async def approve_clearance(
    clearance_id: str,
    input: ApprovalActionInput,
    authorization: str = Header(None)
):
    """Approve a signed clearance"""
    try:
        user = await get_user_from_token(authorization)
        client = get_client()

        now = datetime.now(timezone.utc).isoformat()

        # Update approval record
        client.table("backlot_clearance_approvals").update({
            "approval_status": "approved",
            "approved_at": now,
            "approved_by_user_id": user["id"],
            "locked_at": now,
            "updated_at": now,
        }).eq("clearance_id", clearance_id).execute()

        # Update clearance item
        client.table("backlot_clearance_items").update({
            "status": "approved",
            "approved_at": now,
            "approved_by": user["id"],
            "updated_at": now,
        }).eq("id", clearance_id).execute()

        return {"success": True, "status": "approved"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error approving clearance: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/clearances/{clearance_id}/approval/request-changes")
async def request_clearance_changes(
    clearance_id: str,
    input: ApprovalActionInput,
    authorization: str = Header(None)
):
    """Request changes on a signed clearance"""
    try:
        user = await get_user_from_token(authorization)
        client = get_client()

        now = datetime.now(timezone.utc).isoformat()

        # Update approval record
        client.table("backlot_clearance_approvals").update({
            "approval_status": "changes_requested",
            "change_request_notes": input.notes,
            "change_requested_at": now,
            "change_requested_by_user_id": user["id"],
            "updated_at": now,
        }).eq("clearance_id", clearance_id).execute()

        # Reset clearance status to allow re-signing
        client.table("backlot_clearance_items").update({
            "status": "requested",
            "signed_at": None,
            "updated_at": now,
        }).eq("id", clearance_id).execute()

        # Reset recipient status
        client.table("backlot_clearance_recipients").update({
            "status": "pending",
            "signed_at": None,
            "signature_data": None,
        }).eq("clearance_id", clearance_id).execute()

        return {"success": True, "status": "changes_requested"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error requesting changes: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/clearances/{clearance_id}/approval/reject")
async def reject_clearance(
    clearance_id: str,
    input: ApprovalActionInput,
    authorization: str = Header(None)
):
    """Reject a signed clearance"""
    try:
        user = await get_user_from_token(authorization)
        client = get_client()

        now = datetime.now(timezone.utc).isoformat()

        # Update approval record
        client.table("backlot_clearance_approvals").update({
            "approval_status": "rejected",
            "change_request_notes": input.notes,
            "updated_at": now,
        }).eq("clearance_id", clearance_id).execute()

        # Update clearance item
        client.table("backlot_clearance_items").update({
            "status": "rejected",
            "updated_at": now,
        }).eq("id", clearance_id).execute()

        return {"success": True, "status": "rejected"}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error rejecting clearance: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/approvals/pending")
async def get_pending_approvals(
    project_id: str,
    authorization: str = Header(None)
):
    """Get all pending approvals for a project"""
    try:
        user = await get_user_from_token(authorization)
        client = get_client()

        # Get all clearances with pending approval
        result = client.table("backlot_clearance_approvals").select(
            "*, backlot_clearance_items!inner(id, title, type, project_id, signed_at, related_person_name)"
        ).eq("approval_status", "pending_approval").execute()

        approvals = []
        for item in result.data or []:
            clearance = item.get("backlot_clearance_items")
            if not clearance or clearance.get("project_id") != project_id:
                continue

            approvals.append({
                "clearance_id": clearance["id"],
                "clearance_title": clearance.get("title", "Untitled"),
                "clearance_type": clearance.get("type", "other"),
                "signer_name": clearance.get("related_person_name", "Unknown"),
                "signed_at": clearance.get("signed_at"),
                "approval": {
                    "id": item["id"],
                    "requires_approval": item["requires_approval"],
                    "approval_status": item["approval_status"],
                    "approver_user_id": item.get("approver_user_id"),
                },
            })

        return {"approvals": approvals}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting pending approvals: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/users/me/approvals/pending")
async def get_my_pending_approvals(
    authorization: str = Header(None)
):
    """Get all pending approvals assigned to the current user"""
    try:
        user = await get_user_from_token(authorization)
        client = get_client()

        # Get approvals where this user is the approver
        result = client.table("backlot_clearance_approvals").select(
            "*, backlot_clearance_items!inner(id, title, type, project_id, signed_at, related_person_name, backlot_projects(id, title))"
        ).eq("approver_user_id", user["id"]).eq(
            "approval_status", "pending_approval"
        ).execute()

        approvals = []
        for item in result.data or []:
            clearance = item.get("backlot_clearance_items")
            if not clearance:
                continue

            project = clearance.get("backlot_projects", {})

            approvals.append({
                "clearance_id": clearance["id"],
                "clearance_title": clearance.get("title", "Untitled"),
                "clearance_type": clearance.get("type", "other"),
                "project_id": clearance.get("project_id"),
                "project_title": project.get("title", "Unknown Project") if project else "Unknown Project",
                "signer_name": clearance.get("related_person_name", "Unknown"),
                "signed_at": clearance.get("signed_at"),
                "approval": {
                    "id": item["id"],
                    "requires_approval": item["requires_approval"],
                    "approval_status": item["approval_status"],
                },
            })

        return {"approvals": approvals}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting my pending approvals: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =====================================================
# Crew Document Summary & Checklists
# =====================================================

@router.get("/projects/{project_id}/crew-document-summary")
async def get_crew_document_summary(
    project_id: str,
    authorization: str = Header(None)
):
    """Get document completion summary for all crew in a project"""
    try:
        if not authorization:
            raise HTTPException(status_code=401, detail="Authorization required")
        user = await get_user_from_token(authorization)
        client = get_client()

        # Use the crew_document_summary view if available, otherwise compute
        # First, get all booked people for this project
        booked_result = client.table("backlot_project_roles").select(
            "user_id, title, type, department"
        ).eq("project_id", project_id).eq("status", "booked").execute()

        # Filter out entries without user_id (client doesn't support .not_.is_)
        booked_data = [r for r in (booked_result.data or []) if r.get("user_id")]

        if not booked_data:
            return {"crew": []}

        # Get profile names for all user_ids (separate query since nested joins aren't supported)
        user_ids = list(set(r["user_id"] for r in booked_data))
        profiles_by_id = {}
        if user_ids:
            profiles_result = client.table("profiles").select("id, full_name").in_("id", user_ids).execute()
            profiles_by_id = {p["id"]: p for p in (profiles_result.data or [])}

        # Get clearance stats for each person
        crew_summaries = []

        for role in booked_data:
            user_id = role.get("user_id")

            if not user_id:
                continue

            # Get profile from our lookup
            profile = profiles_by_id.get(user_id, {})

            # Get clearances for this person in this project
            clearances_result = client.table("backlot_clearance_items").select(
                "id, status, type"
            ).eq("project_id", project_id).eq("related_person_id", user_id).execute()

            clearances = clearances_result.data or []

            total = len(clearances)
            signed = len([c for c in clearances if c["status"] in ("signed", "approved")])
            pending = len([c for c in clearances if c["status"] in ("requested", "pending")])
            missing = total - signed - pending

            completion_percentage = (signed / total * 100) if total > 0 else 0

            crew_summaries.append({
                "person_id": user_id,
                "person_name": profile.get("full_name", "Unknown"),
                "role_title": role.get("title"),
                "role_type": role.get("type"),
                "department": role.get("department"),
                "documents": {
                    "required": total,
                    "signed": signed,
                    "pending": pending,
                    "missing": missing,
                },
                "completion_percentage": round(completion_percentage),
            })

        return {"crew": crew_summaries}

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting crew document summary: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/person-checklist/{person_id}")
async def get_person_document_checklist(
    project_id: str,
    person_id: str,
    authorization: str = Header(None)
):
    """Get detailed document checklist for a specific person"""
    try:
        user = await get_user_from_token(authorization)
        client = get_client()

        # Get person info
        person_result = client.table("profiles").select(
            "id, full_name, email"
        ).eq("id", person_id).single().execute()

        person_name = person_result.data.get("full_name", "Unknown") if person_result.data else "Unknown"

        # Get all clearances for this person
        clearances_result = client.table("backlot_clearance_items").select(
            "id, title, type, status, due_date, signed_at, file_url"
        ).eq("project_id", project_id).eq("related_person_id", person_id).order(
            "created_at"
        ).execute()

        documents = []
        for clearance in clearances_result.data or []:
            documents.append({
                "clearance_id": clearance["id"],
                "title": clearance.get("title", "Untitled"),
                "type": clearance.get("type", "other"),
                "status": clearance.get("status", "not_started"),
                "due_date": clearance.get("due_date"),
                "signed_at": clearance.get("signed_at"),
                "has_file": bool(clearance.get("file_url")),
            })

        # Calculate summary
        total = len(documents)
        signed = len([d for d in documents if d["status"] in ("signed", "approved")])
        pending = len([d for d in documents if d["status"] in ("requested", "pending")])
        missing = total - signed - pending
        completion_percentage = (signed / total * 100) if total > 0 else 0

        return {
            "checklist": {
                "person_id": person_id,
                "person_name": person_name,
                "documents": documents,
                "summary": {
                    "total": total,
                    "signed": signed,
                    "pending": pending,
                    "missing": missing,
                    "completion_percentage": round(completion_percentage),
                },
            }
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting person document checklist: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# =============================================================================
# DASHBOARD WIDGET AGGREGATION ENDPOINTS
# These provide cross-project summaries for the dashboard widgets
# =============================================================================

@router.get("/my-schedule-summary")
async def get_my_schedule_summary(
    authorization: str = Header(None)
):
    """
    Get schedule summary across all user's projects for dashboard widget.
    Returns upcoming shoot days, today's shoot, and conflicts.
    """
    from app.api.users import get_profile_id_from_cognito_id
    import logging
    logger = logging.getLogger(__name__)
    try:
        user = await get_user_from_token(authorization)
        logger.info(f"[ScheduleSummary] user from token: {user}")
        if not user:
            logger.warning("[ScheduleSummary] No user from token, returning empty")
            return {
                "upcoming_shoot_days": [],
                "today_shoot": None,
                "conflicts": [],
                "next_7_days_count": 0
            }
        cognito_id = user.get("user_id")  # Note: get_user_from_token returns 'user_id' not 'id'
        logger.info(f"[ScheduleSummary] cognito_id: {cognito_id}")
        if not cognito_id:
            logger.warning("[ScheduleSummary] No cognito_id, returning empty")
            return {
                "upcoming_shoot_days": [],
                "today_shoot": None,
                "conflicts": [],
                "next_7_days_count": 0
            }
        # Convert Cognito ID to profile ID
        user_id = get_profile_id_from_cognito_id(cognito_id)
        logger.info(f"[ScheduleSummary] profile user_id: {user_id}")
        if not user_id:
            logger.warning(f"[ScheduleSummary] No profile found for cognito_id {cognito_id}, returning empty")
            return {
                "upcoming_shoot_days": [],
                "today_shoot": None,
                "conflicts": [],
                "next_7_days_count": 0
            }
        client = get_client()
        today = datetime.now().date()
        next_week = today + timedelta(days=7)

        # Get user's projects (owner or team member)
        projects_result = client.table("backlot_projects").select(
            "id, title, slug, status"
        ).eq("owner_id", user_id).in_("status", ["pre_production", "production"]).execute()

        project_ids = [p["id"] for p in (projects_result.data or [])]
        logger.info(f"[ScheduleSummary] owned project_ids for user {user_id}: {project_ids}")

        # Also check team membership even if no owned projects
        team_result = client.table("backlot_project_members").select(
            "project_id"
        ).eq("user_id", user_id).execute()  # No status column - membership record = active member

        team_project_ids = [t["project_id"] for t in (team_result.data or [])]
        all_project_ids = list(set(project_ids + team_project_ids))
        logger.info(f"[ScheduleSummary] all_project_ids (owned + team): {all_project_ids}")

        if not all_project_ids:
            logger.warning(f"[ScheduleSummary] No projects found for user {user_id}, returning empty")
            return {
                "upcoming_shoot_days": [],
                "today_shoot": None,
                "conflicts": [],
                "next_7_days_count": 0
            }

        # Get project details for team projects too
        if team_project_ids:
            team_projects = client.table("backlot_projects").select(
                "id, title, slug"
            ).in_("id", team_project_ids).execute()
            projects_result.data = (projects_result.data or []) + (team_projects.data or [])

        # Get upcoming production days
        days_result = client.table("backlot_production_days").select(
            "id, project_id, date, day_number, title, general_call_time, is_completed, location_name"
        ).in_("project_id", all_project_ids).gte(
            "date", str(today)
        ).lte(
            "date", str(next_week)
        ).order("date").execute()

        production_days = days_result.data or []

        # Get project info map
        project_map = {p["id"]: {"title": p["title"], "slug": p.get("slug", p["id"])} for p in (projects_result.data or [])}

        # Get scene counts for each production day
        day_ids = [d["id"] for d in production_days]
        scene_counts = {}
        if day_ids:
            scenes_result = client.table("backlot_scenes").select(
                "scheduled_day_id"
            ).in_("scheduled_day_id", day_ids).execute()
            for scene in (scenes_result.data or []):
                day_id = scene["scheduled_day_id"]
                scene_counts[day_id] = scene_counts.get(day_id, 0) + 1

        upcoming = []
        today_shoot = None

        for day in production_days:
            shoot_date = day.get("date", "")[:10] if day.get("date") else ""
            project_info = project_map.get(day["project_id"], {"title": "Unknown Project", "slug": day["project_id"]})
            day_info = {
                "id": day["id"],
                "project_id": day["project_id"],
                "project_name": project_info["title"],
                "project_slug": project_info["slug"],
                "date": shoot_date,
                "day_number": day.get("day_number"),
                "title": day.get("title"),
                "general_call_time": day.get("general_call_time"),
                "location": day.get("location_name"),
                "scene_count": scene_counts.get(day["id"], 0)
            }

            if shoot_date == str(today):
                today_shoot = day_info
            else:
                upcoming.append(day_info)

        return {
            "upcoming_shoot_days": upcoming[:5],
            "today_shoot": today_shoot,
            "conflicts": [],  # TODO: Add conflict detection
            "next_7_days_count": len(production_days)
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting schedule summary: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/my-dailies-summary")
async def get_my_dailies_summary(
    authorization: str = Header(None)
):
    """
    Get dailies/footage summary across all user's projects for dashboard widget.
    Returns recent uploads, processing status, and storage usage.
    """
    from app.api.users import get_profile_id_from_cognito_id
    try:
        user = await get_user_from_token(authorization)
        if not user:
            return {
                "recent_uploads": [],
                "total_clips_this_week": 0,
                "processing_count": 0,
                "storage_used_gb": 0,
                "storage_limit_gb": 100,
                "circle_takes_count": 0
            }
        cognito_id = user.get("user_id")  # get_user_from_token returns 'user_id' not 'id'
        if not cognito_id:
            return {
                "recent_uploads": [],
                "total_clips_this_week": 0,
                "processing_count": 0,
                "storage_used_gb": 0,
                "storage_limit_gb": 100,
                "circle_takes_count": 0
            }
        # Convert Cognito ID to profile ID
        user_id = get_profile_id_from_cognito_id(cognito_id)
        if not user_id:
            return {
                "recent_uploads": [],
                "total_clips_this_week": 0,
                "processing_count": 0,
                "storage_used_gb": 0,
                "storage_limit_gb": 100,
                "circle_takes_count": 0
            }
        client = get_client()
        one_week_ago = (datetime.now() - timedelta(days=7)).isoformat()

        # Get user's projects (include slug for links)
        projects_result = client.table("backlot_projects").select(
            "id, title, slug"
        ).eq("owner_id", user_id).execute()

        project_ids = [p["id"] for p in (projects_result.data or [])]
        project_map = {p["id"]: {"title": p["title"], "slug": p.get("slug", p["id"])} for p in (projects_result.data or [])}

        if not project_ids:
            return {
                "recent_uploads": [],
                "total_clips_this_week": 0,
                "processing_count": 0,
                "storage_used_gb": 0,
                "storage_limit_gb": 100,
                "circle_takes_count": 0
            }

        # Get recent dailies clips
        clips_result = client.table("backlot_dailies_clips").select(
            "id, project_id, file_name, thumbnail_url, duration_seconds, scene_id, scene_number, created_at"
        ).in_("project_id", project_ids).gte(
            "created_at", one_week_ago
        ).order("created_at", desc=True).limit(6).execute()

        recent_uploads = []
        for clip in (clips_result.data or []):
            project_info = project_map.get(clip["project_id"], {"title": "Unknown", "slug": clip["project_id"]})
            recent_uploads.append({
                "id": clip["id"],
                "project_id": clip["project_id"],
                "project_slug": project_info["slug"],
                "project_name": project_info["title"],
                "clip_name": clip.get("file_name", "Untitled Clip"),  # Map file_name to clip_name for frontend
                "thumbnail_url": clip.get("thumbnail_url"),
                "duration_seconds": clip.get("duration_seconds"),
                "scene_id": clip.get("scene_id"),
                "scene_number": clip.get("scene_number"),
                "created_at": clip.get("created_at")
            })

        # Get circle takes count
        circle_result = client.table("backlot_dailies_clips").select(
            "id", count="exact"
        ).in_("project_id", project_ids).eq("is_circle_take", True).gte(
            "created_at", one_week_ago
        ).execute()

        return {
            "recent_uploads": recent_uploads,
            "processing_count": 0,  # TODO: Query video_assets for processing status
            "storage_used_gb": 0,  # TODO: Calculate actual storage
            "storage_limit_gb": 100,
            "circle_takes_count": circle_result.count or 0
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting dailies summary: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/my-casting-summary")
async def get_my_casting_summary(
    authorization: str = Header(None)
):
    """
    Get casting summary across all user's projects for dashboard widget.
    Returns open roles, pending applications, and upcoming auditions.
    """
    from app.api.users import get_profile_id_from_cognito_id
    try:
        user = await get_user_from_token(authorization)
        if not user:
            return {
                "open_roles_count": 0,
                "pending_applications": 0,
                "recent_applications": [],
                "auditions_scheduled": [],
                "roles_by_project": []
            }
        cognito_id = user.get("user_id")  # get_user_from_token returns 'user_id' not 'id'
        if not cognito_id:
            return {
                "open_roles_count": 0,
                "pending_applications": 0,
                "recent_applications": [],
                "auditions_scheduled": [],
                "roles_by_project": []
            }
        # Convert Cognito ID to profile ID
        user_id = get_profile_id_from_cognito_id(cognito_id)
        if not user_id:
            return {
                "open_roles_count": 0,
                "pending_applications": 0,
                "recent_applications": [],
                "auditions_scheduled": [],
                "roles_by_project": []
            }
        client = get_client()

        # Get user's projects (include slug for links)
        projects_result = client.table("backlot_projects").select(
            "id, title, slug"
        ).eq("owner_id", user_id).execute()

        project_ids = [p["id"] for p in (projects_result.data or [])]
        project_map = {p["id"]: {"title": p["title"], "slug": p.get("slug", p["id"])} for p in (projects_result.data or [])}

        if not project_ids:
            return {
                "open_roles_count": 0,
                "pending_applications": 0,
                "recent_applications": [],
                "auditions_scheduled": [],
                "roles_by_project": []
            }

        # Get open roles count
        roles_result = client.table("backlot_project_roles").select(
            "id, project_id, title, type, status"
        ).in_("project_id", project_ids).eq("status", "open").execute()

        open_roles = roles_result.data or []

        # Count roles by project
        roles_by_project = {}
        for role in open_roles:
            pid = role["project_id"]
            if pid not in roles_by_project:
                project_info = project_map.get(pid, {"title": "Unknown", "slug": pid})
                roles_by_project[pid] = {"project_id": pid, "project_slug": project_info["slug"], "project_title": project_info["title"], "open_roles": 0}
            roles_by_project[pid]["open_roles"] += 1

        # Get pending applications - first get role IDs, then applications
        role_ids = [r["id"] for r in open_roles]
        recent_applications = []

        if role_ids:
            apps_result = client.table("backlot_project_role_applications").select(
                "id, role_id, user_id, status, applied_at"
            ).in_("role_id", role_ids).eq(
                "status", "pending"
            ).order("applied_at", desc=True).limit(10).execute()

            # Build role lookup map
            role_map = {r["id"]: r for r in open_roles}

            for app in (apps_result.data or []):
                role_data = role_map.get(app["role_id"], {})
                project_id = role_data.get("project_id")
                project_info = project_map.get(project_id, {"title": "Unknown", "slug": project_id})
                # Get applicant info
                applicant_result = client.table("profiles").select("full_name, avatar_url").eq("id", app["user_id"]).single().execute()
                applicant_name = applicant_result.data.get("full_name", "Unknown") if applicant_result.data else "Unknown"
                applicant_avatar = applicant_result.data.get("avatar_url") if applicant_result.data else None

                recent_applications.append({
                    "id": app["id"],
                    "role_id": app["role_id"],
                    "role_name": role_data.get("title", "Unknown Role"),
                    "project_id": project_id,
                    "project_slug": project_info["slug"],
                    "project_name": project_info["title"],
                    "applicant_name": applicant_name,
                    "applicant_avatar": applicant_avatar,
                    "status": app.get("status"),
                    "applied_at": app.get("applied_at")
                })

        return {
            "open_roles_count": len(open_roles),
            "pending_applications": len(recent_applications),
            "recent_applications": recent_applications[:5],
            "auditions_scheduled": []  # TODO: Add audition tracking
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting casting summary: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/my-budget-summary")
async def get_my_budget_summary(
    authorization: str = Header(None)
):
    """
    Get budget summary across all user's projects for dashboard widget.
    Returns total budget, spend, pending approvals, and alerts.
    """
    from app.api.users import get_profile_id_from_cognito_id
    try:
        user = await get_user_from_token(authorization)
        if not user:
            return {
                "total_budget": 0,
                "total_spent": 0,
                "total_remaining": 0,
                "percent_spent": 0,
                "pending_invoices": 0,
                "pending_invoices_amount": 0,
                "pending_expenses": 0,
                "pending_expenses_amount": 0,
                "overdue_invoices": 0,
                "alerts": [],
                "by_project": []
            }
        cognito_id = user.get("user_id")  # get_user_from_token returns 'user_id' not 'id'
        if not cognito_id:
            return {
                "total_budget": 0,
                "total_spent": 0,
                "total_remaining": 0,
                "percent_spent": 0,
                "pending_invoices": 0,
                "pending_invoices_amount": 0,
                "pending_expenses": 0,
                "pending_expenses_amount": 0,
                "overdue_invoices": 0,
                "alerts": [],
                "by_project": []
            }
        # Convert Cognito ID to profile ID
        user_id = get_profile_id_from_cognito_id(cognito_id)
        if not user_id:
            return {
                "total_budget": 0,
                "total_spent": 0,
                "total_remaining": 0,
                "percent_spent": 0,
                "pending_invoices": 0,
                "pending_invoices_amount": 0,
                "pending_expenses": 0,
                "pending_expenses_amount": 0,
                "overdue_invoices": 0,
                "alerts": [],
                "by_project": []
            }
        client = get_client()

        # Get user's projects
        projects_result = client.table("backlot_projects").select(
            "id, title"
        ).eq("owner_id", user_id).execute()

        project_ids = [p["id"] for p in (projects_result.data or [])]
        project_map = {p["id"]: p for p in (projects_result.data or [])}

        if not project_ids:
            return {
                "total_budget": 0,
                "total_spent": 0,
                "pending_invoices": 0,
                "pending_expenses": 0,
                "alerts": []
            }

        # Get budgets for total budget amounts
        budgets_result = client.table("backlot_budgets").select(
            "estimated_total, actual_total"
        ).in_("project_id", project_ids).eq("status", "active").execute()

        total_budget = sum(float(b.get("estimated_total") or 0) for b in (budgets_result.data or []))
        total_spent = sum(float(b.get("actual_total") or 0) for b in (budgets_result.data or []))

        # Get pending budget actuals (expenses)
        pending_expenses_result = client.table("backlot_budget_actuals").select(
            "amount", count="exact"
        ).in_("project_id", project_ids).execute()

        pending_expenses_count = pending_expenses_result.count or 0

        # Get pending invoices
        pending_invoices_result = client.table("backlot_invoices").select(
            "total_amount, status, due_date", count="exact"
        ).in_("project_id", project_ids).in_("status", ["pending", "pending_approval", "sent", "draft"]).execute()

        # Count overdue invoices
        today = datetime.now().date()
        overdue_count = 0
        for inv in (pending_invoices_result.data or []):
            due_date = inv.get("due_date")
            if due_date and str(due_date) < str(today):
                overdue_count += 1

        # Build alerts
        alerts = []
        percent_spent = (total_spent / total_budget * 100) if total_budget > 0 else 0

        if percent_spent > 100:
            alerts.append({
                "project_id": None,
                "project_name": "All Projects",
                "type": "over_budget",
                "message": f"Total spending exceeds budget by ${total_spent - total_budget:,.0f}",
                "severity": "error"
            })
        elif percent_spent > 90:
            alerts.append({
                "project_id": None,
                "project_name": "All Projects",
                "type": "over_budget",
                "message": f"Budget is {percent_spent:.0f}% spent",
                "severity": "warning"
            })

        if overdue_count > 0:
            alerts.append({
                "project_id": None,
                "project_name": "All Projects",
                "type": "invoice_overdue",
                "message": f"{overdue_count} invoice(s) overdue",
                "severity": "error"
            })

        if pending_expenses_count > 0:
            alerts.append({
                "project_id": None,
                "project_name": "All Projects",
                "type": "expense_pending",
                "message": f"{pending_expenses_count} expense(s) tracked",
                "severity": "warning"
            })

        return {
            "total_budget": total_budget,
            "total_spent": total_spent,
            "pending_invoices": pending_invoices_result.count or 0,
            "pending_expenses": pending_expenses_count,
            "alerts": alerts
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting budget summary: {e}")
        raise HTTPException(status_code=500, detail=str(e))

